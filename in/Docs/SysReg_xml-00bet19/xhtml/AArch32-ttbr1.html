<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>TTBR1</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">TTBR1, Translation Table Base Register 1</h1><p>The TTBR1 characteristics are:</p><h2>Purpose</h2>
          <p>Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the higher VA range in the PL1&amp;0 translation regime, and other information for this translation regime.</p>
        <p>This 
        register
       is part of the Virtual memory control registers functional group.</p><h2>Usage constraints</h2><p>If EL3 is implemented and is using AArch32, there are separate Secure and Non-secure instances of this register:</p><table class="register_access"><tr><th></th><th>EL0 (NS)</th><th>EL0 (S)</th><th>EL1 (NS)</th><th>EL2 (NS)</th><th>EL3 (SCR.NS=1)</th><th>EL3 (SCR.NS=0)</th></tr><tr><td>TTBR1(S)</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>RW</td></tr><tr><td>TTBR1(NS)</td><td>-</td><td>-</td><td>RW</td><td>RW</td><td>RW</td><td>-</td></tr></table><p>If EL3 is not implemented or EL3 is implemented and is using AArch64, there is a single instance of this register:</p><table class="register_access"><tr><th></th><th>EL0</th><th>EL1</th><th>EL2 (NS)</th></tr><tr><td>TTBR1</td><td>-</td><td>RW</td><td>RW</td></tr></table><h2>Traps and Enables</h2><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>Â®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules:</p>
          <p>If <a href="AArch32-hcr.html">HCR</a>.TVM==1, Non-secure write accesses to this register from EL1 are trapped to Hyp mode.</p>
        
          <p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TVM==1, Non-secure write accesses to this register from EL1 are trapped to EL2.</p>
        
          <p>If <a href="AArch32-hcr.html">HCR</a>.TRVM==1, Non-secure read accesses to this register from EL1 are trapped to Hyp mode.</p>
        
          <p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TRVM==1, Non-secure read accesses to this register from EL1 are trapped to EL2.</p>
        
          <p>If <a href="AArch32-hstr.html">HSTR</a>.T2==1, Non-secure accesses to this register from EL1 are trapped to Hyp mode.</p>
        
          <p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T2==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p>
        <h2>Configuration</h2><p>AArch32 System register TTBR1
                is architecturally mapped to
              AArch64 System register <a href="AArch64-ttbr1_el1.html">TTBR1_EL1</a>.
          </p>
          <p><a href="AArch32-ttbcr.html">TTBCR</a>.EAE determines which TTBR1 format is used:</p>
        
          <dl>
            <dt>EAE==0</dt><dd>32-bit format is used. TTBR1[63:32] are ignored.</dd>
            <dt>EAE==1</dt><dd>64-bit format is used.</dd>
          </dl>
        
          <p>Used in conjunction with the <a href="AArch32-ttbcr.html">TTBCR</a>. When the 64-bit TTBR1 format is used, cacheability and shareability information is held in the <a href="AArch32-ttbcr.html">TTBCR</a>, not in TTBR1.</p>
        <p>
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>TTBR1 is a 64-bit register that can also be accessed as a 32-bit value. If it is accessed as a 32-bit register, accesses read and write bits [31:0] and do not modify bits [63:32].</p>
        <h2>Field descriptions</h2><p>The TTBR1 bit assignments are:</p><h3>When TTBCR.EAE==0:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#TTBCR.EAE0_TTB1">TTB1</a></td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_IRGN[0]">IRGN[0]</a></td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_NOS">NOS</a></td><td class="lr" colspan="2"><a href="#TTBCR.EAE0_RGN">RGN</a></td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_IMP">IMP</a></td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_S">S</a></td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_IRGN[1]">IRGN[1]</a></td></tr></tbody></table><h4 id="TTBCR.EAE0_TTB1">TTB1, bits [31:7]
                  </h4>
              <p>Translation table base address, bits[31:14]. Register bits [13:7] are <span class="arm-defined-word">RES0</span>, with the additional requirement that if these bits are not all zero, this is a misaligned translation table base address, with effects that are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and must be one of the following:</p>
            
              <ul>
                <li>
                  Register bits [13:7] are treated as if all the bits are zero. The value read back from these bits is either the value written or zero.
                </li>
                <li>
                  The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
                </li>
              </ul>
            <h4 id="TTBCR.EAE0_IRGN[0]">IRGN[0], bit [6]
              </h4>
              <p>See the IRGN[1] description.</p>
            <h4 id="TTBCR.EAE0_NOS">NOS, bit [5]
              </h4>
              <p>Not Outer Shareable. When the value of TTBR1.S is 1, indicates whether the memory associated with a translation table walk is Inner Shareable or Outer Shareable:</p>
            <table class="valuetable"><tr><th>NOS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Memory is Outer Shareable.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Memory is Inner Shareable.</p>
                </td></tr></table>
              <p>This bit is ignored when the value of TTBR1.S is 0.</p>
            <h4 id="TTBCR.EAE0_RGN">RGN, bits [4:3]
                  </h4>
              <p>Region bits. Indicates the Outer cacheability attributes for the memory associated with the translation table walks:</p>
            <table class="valuetable"><tr><th>RGN</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>Normal memory, Outer Non-cacheable.</p>
                </td></tr><tr><td class="bitfield">01</td><td>
                  <p>Normal memory, Outer Write-Back Write-Allocate Cacheable.</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>Normal memory, Outer Write-Through Cacheable.</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>Normal memory, Outer Write-Back no Write-Allocate Cacheable.</p>
                </td></tr></table><h4 id="TTBCR.EAE0_IMP">IMP, bit [2]
              </h4>
              <p>The effect of this bit is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>. If the translation table implementation does not include any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> features this bit is UNK/SBZP.</p>
            <h4 id="TTBCR.EAE0_S">S, bit [1]
              </h4>
              <p>Shareable. Indicates whether the memory associated with the translation table walks is Non-shareable:</p>
            <table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Memory is Non-shareable.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Memory is shareable. The TTBR1.NOS field indicates whether the memory is Inner Shareable or Outer Shareable.</p>
                </td></tr></table><h4 id="TTBCR.EAE0_IRGN[1]">IRGN[1], bit [0]
              </h4>
              <p>Inner region bits. IRGN[1:0] indicate the Inner Cacheability attributes for the memory associated with the translation table walks. The possible values of IRGN[1:0] are:</p>
            <table class="valuetable"><tr><th>IRGN</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>Normal memory, Inner Non-cacheable.</p>
                </td></tr><tr><td class="bitfield">01</td><td>
                  <p>Normal memory, Inner Write-Back Write-Allocate Cacheable.</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>Normal memory, Inner Write-Through Cacheable.</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>Normal memory, Inner Write-Back no Write-Allocate Cacheable.</p>
                </td></tr></table>
              <div class="note"><span class="note-header">Note</span>
                <p>The encoding of the IRGN bits is counter-intuitive, with register bit[6] being IRGN[0] and register bit[0] being IRGN[1]. This encoding is chosen to give a consistent encoding of memory region types and to ensure that software written for ARMv7 without the Multiprocessing Extensions can run unmodified on an implementation that includes the functionality introduced by the ARMv7 Multiprocessing Extensions.</p>
              </div>
            <h3>When TTBCR.EAE==1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="8"><a href="#TTBCR.EAE1_ASID">ASID</a></td><td class="lr" colspan="16"><a href="#TTBCR.EAE1_BADDR">BADDR</a></td></tr><tr class="firstrow"><td class="lr" colspan="31"><a href="#TTBCR.EAE1_BADDR">BADDR</a></td><td class="lr">0</td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><h4 id="TTBCR.EAE1_0">
                Bits [63:56]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE1_ASID">ASID, bits [55:48]
                  </h4>
              <p>An ASID for the translation table base address. The <a href="AArch32-ttbcr.html">TTBCR</a>.A1 field selects either TTBR0.ASID or TTBR1.ASID.</p>
            <h4 id="TTBCR.EAE1_BADDR">BADDR, bits [47:1]
                  </h4>
              <p>Translation table base address, bits[47:x], Bits [x-1:0] are <span class="arm-defined-word">RES0</span>, with the additional requirement that if bits[x-1:3] are not all zero, this is a misaligned translation table base address, with effects that are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and must be one of the following:</p>
            
              <ul>
                <li>
                  Register bits [x-1:3] are treated as if all the bits are zero. The value read back from these bits is either the value written or zero.
                </li>
                <li>
                  The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
                </li>
              </ul>
            
              <p>x is determined from the value of <a href="AArch32-ttbcr.html">TTBCR</a>.T1SZ as follows:</p>
            
              <ul>
                <li>
                  If <a href="AArch32-ttbcr.html">TTBCR</a>.T1SZ is 0 or 1, x = 5 - <a href="AArch32-ttbcr.html">TTBCR</a>.T1SZ.
                </li>
                <li>
                  If <a href="AArch32-ttbcr.html">TTBCR</a>.T1SZ is greater than 1, x = 14 - <a href="AArch32-ttbcr.html">TTBCR</a>.T1SZ.
                </li>
              </ul>
            
              <p>If bits[47:40] of the translation table base address are not zero, an Address size fault is generated.</p>
            <h4 id="TTBCR.EAE1_0">
                Bit [0]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h2>Accessing the TTBR1</h2><p>To access the TTBR1 when accessing as a 32-bit register:</p><p class="asm-code">MRC p15,0,&lt;Rt&gt;,c2,c0,1 ; Read TTBR1[31:0] into Rt</p><p class="asm-code">MCR p15,0,&lt;Rt&gt;,c2,c0,1 ; Write Rt to TTBR1[31:0]. TTBR1[63:32] are unchanged</p><p>Register access is encoded as follows:</p><table class="info"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>1111</td><td>000</td><td>0010</td><td>0000</td><td>001</td></tr></table><p>To access the TTBR1 when accessing as a 64-bit register:</p><p class="asm-code">MRRC p15,1,&lt;Rt&gt;,&lt;Rt2&gt;,c2 ; Read TTBR1[31:0] into Rt and TTBR1[63:32] into Rt2</p><p class="asm-code">MCRR p15,1,&lt;Rt&gt;,&lt;Rt2&gt;,c2 ; Write Rt to TTBR1[31:0] and Rt2 to TTBR1[63:32]</p><p>Register access is encoded as follows:</p><table class="info"><tr><th>coproc</th><th>opc1</th><th>CRm</th></tr><tr><td>1111</td><td>0001</td><td>0010</td></tr></table><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 15:40</p><p class="copyconf">Copyright Â© 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
