<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>EDSCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">EDSCR, External Debug Status and Control Register</h1><p>The EDSCR characteristics are:</p><h2>Purpose</h2>
          <p>Main control register for the debug implementation.</p>
        <p>This 
        register
       is part of the Debug registers functional group.</p><h2>Usage constraints</h2><p>This register is accessible as follows:</p><table class="register_access"><tr><th>Off</th><th>DLK</th><th>OSLK</th><th>SLK</th><th>Default</th></tr><tr><td>Error</td><td>Error</td><td>Error</td><td>RO</td><td>RW</td></tr></table><h2>Configuration</h2><p>EDSCR is in the Core power domain.
      Some or all RW fields of this register have defined reset values. These apply only on a Cold reset. The register is not affected by a Warm reset and is not affected by an External debug reset.</p><h2>Attributes</h2>
          <p>EDSCR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The EDSCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">0</td><td class="lr" colspan="1"><a href="#RXfull">RXfull</a></td><td class="lr" colspan="1"><a href="#TXfull">TXfull</a></td><td class="lr" colspan="1"><a href="#ITO">ITO</a></td><td class="lr" colspan="1"><a href="#RXO">RXO</a></td><td class="lr" colspan="1"><a href="#TXU">TXU</a></td><td class="lr" colspan="1"><a href="#PipeAdv">PipeAdv</a></td><td class="lr" colspan="1"><a href="#ITE">ITE</a></td><td class="lr" colspan="2"><a href="#INTdis">INTdis</a></td><td class="lr" colspan="1"><a href="#TDA">TDA</a></td><td class="lr" colspan="1"><a href="#MA">MA</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#NS">NS</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#SDD">SDD</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#HDE">HDE</a></td><td class="lr" colspan="4"><a href="#RW">RW</a></td><td class="lr" colspan="2"><a href="#EL">EL</a></td><td class="lr" colspan="1"><a href="#A">A</a></td><td class="lr" colspan="1"><a href="#ERR">ERR</a></td><td class="lr" colspan="6"><a href="#STATUS">STATUS</a></td></tr></tbody></table><h4 id="0">
                Bit [31]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="RXfull">RXfull, bit [30]
              </h4>
              <p>DTRRX full. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TXfull">TXfull, bit [29]
              </h4>
              <p>DTRTX full. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="ITO">ITO, bit [28]
              </h4>
              <p>ITR overrun. This bit is RO.</p>
            
              <p>If the PE is in Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>. ITO is set to 0 on entry to Debug state.</p>
            <h4 id="RXO">RXO, bit [27]
              </h4>
              <p>DTRRX overrun. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TXU">TXU, bit [26]
              </h4>
              <p>DTRTX underrun. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="PipeAdv">PipeAdv, bit [25]
              </h4>
              <p>Pipeline advance. This bit is RO. Set to 1 every time the PE pipeline retires one or more instructions. Cleared to 0 by a write to <a href="ext-edrcr.html">EDRCR</a>.CSPA.</p>
            
              <p>The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</p>
            <h4 id="ITE">ITE, bit [24]
              </h4>
              <p>ITR empty. This bit is RO.</p>
            
              <p>If the PE is in Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>. It is always valid in Debug state.</p>
            <h4 id="INTdis">INTdis, bits [23:22]
                  </h4>
              <p>Interrupt disable. Disables taking interrupts (including virtual interrupts and System Error interrupts) in Non-Debug state.</p>
            
              <p>If ExternalInvasiveDebugEnabled() = FALSE, the value of this field is ignored.</p>
            
              <p>If ExternalInvasiveDebugEnabled() = TRUE, the possible values of this field are:</p>
            <table class="valuetable"><tr><th>INTdis</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>Do not disable interrupts.</p>
                </td></tr><tr><td class="bitfield">01</td><td>
                  <p>Disable interrupts taken to Non-secure EL1.</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>Disable interrupts taken only to Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable interrupts taken to Secure EL1.</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>Disable interrupts taken only to Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable all other interrupts.</p>
                </td></tr></table>
              <p>The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.</p>
            
              <p>If EL3 and EL2 are not implemented, the values <span class="binarynumber">0b01</span> and <span class="binarynumber">0b10</span> are reserved. If programmed with a reserved value the PE behaves as if INTdis has been programmed with a defined value, other than for a direct read of EDSCR, and the value returned by a read of EDSCR.INTdis is <span class="arm-defined-word">UNKNOWN</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TDA">TDA, bit [21]
              </h4>
              <p>Traps accesses to the following Debug System registers:</p>
            
              <ul>
                <li>
                  AArch64: <a href="ext-dbgbcrn_el1.html">DBGBCR&lt;n&gt;_EL1</a>, <a href="ext-dbgbvrn_el1.html">DBGBVR&lt;n&gt;_EL1</a>, <a href="ext-dbgwcrn_el1.html">DBGWCR&lt;n&gt;_EL1</a>, <a href="ext-dbgwvrn_el1.html">DBGWVR&lt;n&gt;_EL1</a>.
                </li>
                <li>
                  AArch32: <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>, <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n&gt;</a>, <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n&gt;</a>, <a href="AArch32-dbgwcrn.html">DBGWCR&lt;n&gt;</a>, <a href="AArch32-dbgwvrn.html">DBGWVR&lt;n&gt;</a>.
                </li>
              </ul>
            
              <p>The possible values of this field are:</p>
            <table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Accesses to Debug System registers do not generate a Software Access debug event.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Accesses to Debug System registers generate a Software Access debug event, if OSLSR.OSLK is 0 and if halting is allowed.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="MA">MA, bit [20]
              </h4>
              <p>Memory access mode. Controls use of memory-access mode for accessing ITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.</p>
            
              <p>Possible values of this field are:</p>
            <table class="valuetable"><tr><th>MA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Normal access mode.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Memory access mode.</p>
                </td></tr></table><h4 id="0">
                Bit [19]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="NS">NS, bit [18]
              </h4>
              <p>Non-secure status. Read-only. When in Debug state, gives the current Security state:</p>
            <table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Secure state, IsSecure() == TRUE.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure state, IsSecure() == FALSE.</p>
                </td></tr></table>
              <p>In Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p>
            <h4 id="0">
                Bit [17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="SDD">SDD, bit [16]
              </h4>
              <p>Secure debug disabled. This bit is RO.</p>
            
              <p>On entry to Debug state:</p>
            
              <ul>
                <li>
                  If entering in Secure state, SDD is set to 0.
                </li>
                <li>
                  If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().
                </li>
              </ul>
            
              <p>In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.</p>
            
              <p>In Non-debug state:</p>
            
              <ul>
                <li>
                  SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization event is required to guarantee their effect.
                </li>
                <li>
                  This bit is unaffected by the Security state of the PE.
                </li>
              </ul>
            
              <p>If EL3 is not implemented and the implementation is Non-secure, this bit is <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bit [15]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HDE">HDE, bit [14]
              </h4>
              <p>Halting debug enable. The possible values of this field are:</p>
            <table class="valuetable"><tr><th>HDE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Halting disabled for Breakpoint, Watchpoint and Halt Instruction debug events.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Halting enabled for Breakpoint, Watchpoint and Halt Instruction debug events.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="RW">RW, bits [13:10]
                  </h4>
              <p>Exception level Execution state status. Read-only. In Debug state, each bit gives the current Execution state of each EL:</p>
            
              <table class="valuetable">
                
                  <thead>
                    <tr>
                      <th>RW</th>
                      <th>Meaning</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <span class="binarynumber">1111</span>
                      </td>
                      <td>All Exception levels are using AArch64.</td>
                    </tr>
                    <tr>
                      <td>
                        <span class="binarynumber">1110</span>
                      </td>
                      <td>EL0 is using AArch32. All other Exception levels are using AArch64.</td>
                    </tr>
                    <tr>
                      <td>
                        <span class="binarynumber">110x</span>
                      </td>
                      <td>EL0 and EL1 are using AArch32. All other Exception levels are using AArch64. Never seen if EL2 is not implemented in the current Security state.</td>
                    </tr>
                    <tr>
                      <td>
                        <span class="binarynumber">10xx</span>
                      </td>
                      <td>EL0, EL1, and, if implemented in the current Security state, EL2 are using AArch32. All other Exception levels are using AArch64.</td>
                    </tr>
                    <tr>
                      <td>
                        <span class="binarynumber">0xxx</span>
                      </td>
                      <td>All Exception levels are using AArch32.</td>
                    </tr>
                  </tbody>
                
              </table>
            
              <p>However:</p>
            
              <ul>
                <li>
                  The value of <span class="binarynumber">1110</span> is only permitted at EL0.
                </li>
                <li>
                  The values <span class="binarynumber">110x</span> are not permitted if either:<ul><li>EL2 is not implemented.</li><li>EL3 is implemented and SCR_EL3.NS/SCR.NS == 0.</li></ul>
                </li>
                <li>
                  The values <span class="binarynumber">10xx</span> are not permitted if EL3 is not implemented.
                </li>
              </ul>
            
              <p>In Non-debug state, this field is RAO.</p>
            <h4 id="EL">EL, bits [9:8]
                  </h4>
              <p>Exception level. Read-only. In Debug state, this gives the current EL of the PE.</p>
            
              <p>In Non-debug state, this field is RAZ.</p>
            <h4 id="A">A, bit [7]
              </h4>
              <p>System Error interrupt pending. Read-only. In Debug state, indicates whether a SError interrupt is pending:</p>
            
              <ul>
                <li>
                  If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.
                </li>
                <li>
                  Otherwise, a physical SError interrupt.
                </li>
              </ul>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>No SError interrupt pending.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>SError interrupt pending.</p>
                </td></tr></table>
              <p>A debugger can read EDSCR to check whether an SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.</p>
            
              <p><span class="arm-defined-word">UNKNOWN</span> in Non-debug state.</p>
            <h4 id="ERR">ERR, bit [6]
              </h4>
              <p>Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="STATUS">STATUS, bits [5:0]
                  </h4>
              <p>Debug status flags. This field is RO.</p>
            
              <p>The possible values of this field are:</p>
            <table class="valuetable"><tr><th>STATUS</th><th>Meaning</th></tr><tr><td class="bitfield">000010</td><td>
                  <p>PE is in Non-debug state.</p>
                </td></tr><tr><td class="bitfield">000001</td><td>
                  <p>PE is restarting, exiting Debug state.</p>
                </td></tr><tr><td class="bitfield">000111</td><td>
                  <p>Breakpoint.</p>
                </td></tr><tr><td class="bitfield">010011</td><td>
                  <p>External debug request.</p>
                </td></tr><tr><td class="bitfield">011011</td><td>
                  <p>Halting step, normal.</p>
                </td></tr><tr><td class="bitfield">011111</td><td>
                  <p>Halting step, exclusive.</p>
                </td></tr><tr><td class="bitfield">100011</td><td>
                  <p>OS Unlock Catch.</p>
                </td></tr><tr><td class="bitfield">100111</td><td>
                  <p>Reset Catch.</p>
                </td></tr><tr><td class="bitfield">101011</td><td>
                  <p>Watchpoint.</p>
                </td></tr><tr><td class="bitfield">101111</td><td>
                  <p>HLT instruction.</p>
                </td></tr><tr><td class="bitfield">110011</td><td>
                  <p>Software access to debug register.</p>
                </td></tr><tr><td class="bitfield">110111</td><td>
                  <p>Exception Catch.</p>
                </td></tr><tr><td class="bitfield">111011</td><td>
                  <p>Halting step, no syndrome.</p>
                </td></tr></table>
              <p>All other values of STATUS are reserved.</p>
            <h2>Accessing the EDSCR</h2><p>EDSCR can be accessed through the external debug interface:</p><table class="info"><tr><th>Component</th><th>Offset</th></tr><tr><td>Debug</td><td>
          <span class="hexnumber">0x088</span>
        </td></tr></table><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 15:40</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
