<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SCTLR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">SCTLR_EL2, System Control Register (EL2)</h1><p>The SCTLR_EL2 characteristics are:</p><h2>Purpose</h2>
          <p>Provides top level control of the system, including its memory system, at EL2.</p>
        <p>This 
        register
       is part of:</p><ul><li>The Virtualization registers functional group.</li><li>The Other system control registers functional group.</li></ul><h2>Usage constraints</h2><p>This register is accessible as follows:</p><table class="register_access"><tr><th>EL0</th><th>EL1 (NS)</th><th>EL1 (S)</th><th>EL2 (NS)</th><th>EL3 (SCR.NS=1)</th><th>EL3 (SCR.NS=0)</th></tr><tr><td>-</td><td>-</td><td>-</td><td>RW</td><td>RW</td><td>RW</td></tr></table><h2>Traps and Enables</h2><p>There are no traps or enables affecting this register.</p><h2>Configuration</h2><p>AArch64 System register SCTLR_EL2
                is architecturally mapped to
              AArch32 System register <a href="AArch32-hsctlr.html">HSCTLR</a>.
          </p>
          <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>
        <p>
                Some or all RW fields of this register have defined reset values. 
                
        These apply
      
                only if the PE resets into EL2 using AArch64. 
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>SCTLR_EL2 is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The SCTLR_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#EE">EE</a></td><td class="lr">0</td><td class="l">1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#WXN">WXN</a></td><td class="lr">1</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#I">I</a></td><td class="lr">1</td><td class="l">0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="1"><a href="#SA">SA</a></td><td class="lr" colspan="1"><a href="#C">C</a></td><td class="lr" colspan="1"><a href="#A">A</a></td><td class="lr" colspan="1"><a href="#M">M</a></td></tr></tbody></table><h4 id="0">
                Bits [31:30]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bits [29:28]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [27:26]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="EE">EE, bit [25]
              </h4>
              <p>Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime.</p>
            
              <p>The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime are little-endian.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime are big-endian.</p>
                </td></tr></table>
              <p>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>The EE bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="0">
                Bit [24]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bits [23:22]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [21:20]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="WXN">WXN, bit [19]
              </h4>
              <p>Write permission implies XN (Execute-never). For the EL2 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on memory access permissions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any region that is writable in the EL2 translation regime is forced to XN for accesses from software executing at EL2.</p>
                </td></tr></table>
              <p>The WXN bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="1">
                Bit [18]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bit [17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bit [16]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [15:13]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="I">I, bit [12]
              </h4>
              <p>Instruction access Cacheability control, for accesses at EL2:</p>
            <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All instruction access to Normal memory from EL2 are Non-cacheable for all levels of instruction and unified cache.</p>
                
                  <p>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control has no effect on the Cacheability of instruction access to Normal memory from EL2.</p>
                
                  <p>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p>
                </td></tr></table>
              <p>This bit has no effect on the EL1&amp;0 or EL3 translation regimes.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="1">
                Bit [11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [10:6]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bits [5:4]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="SA">SA, bit [3]
              </h4>
              <p>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL2 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the ARMv8 ARM, section D1 (The AArch64 System Level Programmers' Model)</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="C">C, bit [2]
              </h4>
              <p>Cacheability control, for data accesses.</p>
            <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All data access to Normal memory from EL2, and all Normal memory accesses to the EL2 translation tables, are Non-cacheable for all levels of data and unified cache.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control has no effect on the Cacheability of:</p>
                
                  <ul>
                    <li>
                      Data access to Normal memory from EL2.
                    </li>
                    <li>
                      Normal memory accesses to the EL2 translation tables.
                    </li>
                  </ul>
                </td></tr></table>
              <p>This bit has no effect on the EL1&amp;0 or EL3 translation regimes.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="A">A, bit [1]
              </h4>
              <p>Alignment check enable. This is the enable bit for Alignment fault checking at EL2:</p>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Alignment fault checking disabled when executing at EL2.</p>
                
                  <p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Alignment fault checking enabled when executing at EL2.</p>
                
                  <p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p>
                </td></tr></table>
              <p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="M">M, bit [0]
              </h4>
              <p>MMU enable for EL2 stage 1 address translation. Possible values of this bit are:</p>
            <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL2 stage 1 address translation disabled.</p>
                
                  <p>See the SCTLR_EL2.I field for the behavior of instruction accesses to Normal memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2 stage 1 address translation enabled.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h2>Accessing the SCTLR_EL2</h2><p>To access the SCTLR_EL2:</p><p class="asm-code">MRS &lt;Xt&gt;, SCTLR_EL2 ; Read SCTLR_EL2 into Xt</p><p class="asm-code">MSR SCTLR_EL2, &lt;Xt&gt; ; Write Xt to SCTLR_EL2</p><p>Register access is encoded as follows:</p><table class="info"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>11</td><td>100</td><td>0001</td><td>0000</td><td>000</td></tr></table><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 15:40</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
