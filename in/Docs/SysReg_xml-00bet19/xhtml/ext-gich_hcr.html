<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>GICH_HCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">GICH_HCR, Hypervisor Control Register</h1><p>The GICH_HCR characteristics are:</p><h2>Purpose</h2>
          <p>Controls the virtual CPU interface.</p>
        <p>This 
        register
       is part of the GIC virtualised guest interface control registers functional group.</p><h2>Usage constraints</h2><p>This register is accessible as follows:</p><table class="register_access"><tr><th>Security disabled</th><th>Secure</th><th>Non-secure</th></tr><tr><td>RW</td><td>RW</td><td>RW</td></tr></table>
          <p>This register is used only when System register access is not enabled. When System register access is enabled:</p>
        
          <ul>
            <li>
              For AArch32 implementations, <a href="AArch32-ich_hcr.html">ICH_HCR</a> provides equivalent functionality.
            </li>
            <li>
              For AArch64 implementations, <a href="AArch64-ich_hcr_el2.html">ICH_HCR_EL2</a> provides equivalent functionality.
            </li>
          </ul>
        
          <p>GICH_HCR.En must be set to 1 for any virtual or maintenance interrupt to be asserted.</p>
        <h2>Configuration</h2><p>RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.</p>
          <p>This register is available when the GIC implementation supports interrupt virtualization.</p>
        <h2>Attributes</h2>
          <p>GICH_HCR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The GICH_HCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="5"><a href="#EOICount">EOICount</a></td><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#VGrp1DIE">VGrp1DIE</a></td><td class="lr" colspan="1"><a href="#VGrp1EIE">VGrp1EIE</a></td><td class="lr" colspan="1"><a href="#VGrp0DIE">VGrp0DIE</a></td><td class="lr" colspan="1"><a href="#VGrp0EIE">VGrp0EIE</a></td><td class="lr" colspan="1"><a href="#NPIE">NPIE</a></td><td class="lr" colspan="1"><a href="#LRENPIE">LRENPIE</a></td><td class="lr" colspan="1"><a href="#UIE">UIE</a></td><td class="lr" colspan="1"><a href="#En">En</a></td></tr></tbody></table><h4 id="EOICount">EOICount, bits [31:27]
                  </h4>
              <p>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in <a href="ext-gich_aprn.html">GICH_APR&lt;n&gt;</a> do not cause an increment. If an EOI occurs when the value of this field is 31, then the field wraps to 0.</p>
            
              <p>The maintenance interrupt is asserted whenever this field is nonzero and GICH_HCR.LRENPIE == 1.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0">
                Bits [26:8]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="VGrp1DIE">VGrp1DIE, bit [7]
              </h4>
              <p>VM Group 1 Disabled Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled:</p>
            <table class="valuetable"><tr><th>VGrp1DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp1 == 0.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="VGrp1EIE">VGrp1EIE, bit [6]
              </h4>
              <p>VM Group 1 Enabled Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled:</p>
            <table class="valuetable"><tr><th>VGrp1EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp1 == 1.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="VGrp0DIE">VGrp0DIE, bit [5]
              </h4>
              <p>VM Group 0 Disabled Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled:</p>
            <table class="valuetable"><tr><th>VGrp0DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp0 == 0.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="VGrp0EIE">VGrp0EIE, bit [4]
              </h4>
              <p>VM Group 0 Enabled Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled:</p>
            <table class="valuetable"><tr><th>VGrp0EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp0 == 1.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="NPIE">NPIE, bit [3]
              </h4>
              <p>No Pending Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers:</p>
            <table class="valuetable"><tr><th>NPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Maintenance interrupt signaled while the List registers contain no interrupts in the pending state.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="LRENPIE">LRENPIE, bit [2]
              </h4>
              <p>List Register Entry Not Present Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register for an EOI request:</p>
            <table class="valuetable"><tr><th>LRENPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Maintenance interrupt signaled while GICH_HCR.EOICount is not 0.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="UIE">UIE, bit [1]
              </h4>
              <p>Underflow Interrupt Enable.</p>
            
              <p>Enables the signaling of a maintenance interrupt when the List registers are either empty or hold only one valid entry.</p>
            <table class="valuetable"><tr><th>UIE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Maintenance interrupt disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>A maintenance interrupt is signaled if zero or one of the List register entries are marked as a valid interrupt.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="En">En, bit [0]
              </h4>
              <p>Enable.</p>
            
              <p>Global enable bit for the virtual CPU interface.</p>
            <table class="valuetable"><tr><th>En</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Virtual CPU interface operation is disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Virtual CPU interface operation is enabled.</p>
                </td></tr></table>
              <p>When this field is 0:</p>
            
              <ul>
                <li>
                  The virtual CPU interface does not signal any maintenance interrupts.
                </li>
                <li>
                  The virtual CPU interface does not signal any virtual interrupts.
                </li>
                <li>
                  A read of <a href="ext-gicv_iar.html">GICV_IAR</a> or <a href="ext-gicv_aiar.html">GICV_AIAR</a> returns a spurious interrupt ID.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><div class="text_after_fields">
            <p>The VGrp1DIE, VGrp1EIE, VGrp0DIE, and VGrp0EIE fields permit the hypervisor to track the virtual CPU interfaces that are enabled. The hypervisor can then route interrupts that have multiple targets correctly and efficiently, without having to read the virtual CPU interface status.</p>
            <p>See <span class="xref">Maintenance interrupts</span> and <a href="ext-gich_misr.html">GICH_MISR</a> for more information.</p>
          </div><h2>Accessing the GICH_HCR</h2><p>GICH_HCR can be accessed through its memory-mapped interface:</p><table class="info"><tr><th>Component</th><th>Offset</th></tr><tr><td>GIC Virtual interface control</td><td>
          <span class="hexnumber">0x0000</span>
        </td></tr></table><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 15:40</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
