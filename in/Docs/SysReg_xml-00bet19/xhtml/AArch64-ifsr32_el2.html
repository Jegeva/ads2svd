<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>IFSR32_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">IFSR32_EL2, Instruction Fault Status Register (EL2)</h1><p>The IFSR32_EL2 characteristics are:</p><h2>Purpose</h2>
          <p>Allows access to the AArch32 <a href="AArch32-ifsr.html">IFSR</a> register from AArch64 state only. Its value has no effect on execution in AArch64 state.</p>
        <p>This 
        register
       is part of the Exception and fault handling registers functional group.</p><h2>Usage constraints</h2><p>This register is accessible as follows:</p><table class="register_access"><tr><th>EL0</th><th>EL1 (NS)</th><th>EL1 (S)</th><th>EL2 (NS)</th><th>EL3 (SCR.NS=1)</th><th>EL3 (SCR.NS=0)</th></tr><tr><td>-</td><td>-</td><td>-</td><td>RW</td><td>RW</td><td>RW</td></tr></table><h2>Traps and Enables</h2><p>There are no traps or enables affecting this register.</p><h2>Configuration</h2><p>AArch64 System register IFSR32_EL2
                is architecturally mapped to
              AArch32 System register <a href="AArch32-ifsr.html">IFSR</a>.
          </p>
          <p>If EL1 is AArch64 only, this register is <span class="arm-defined-word">UNDEFINED</span>.</p>
        
          <p>If EL2 is not implemented but EL3 is implemented, and EL1 is capable of using AArch32, then this register is not <span class="arm-defined-word">RES0</span>.</p>
        <p>
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>IFSR32_EL2 is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The IFSR32_EL2 bit assignments are:</p><h3>When TTBCR.EAE==0:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_FnV">FnV</a></td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_ExT">ExT</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_FS[4]">FS[4]</a></td><td class="lr" colspan="1"><a href="#TTBCR.EAE0_LPAE">LPAE</a></td><td class="l">0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="4"><a href="#TTBCR.EAE0_FS[3:0]">FS[3:0]</a></td></tr></tbody></table><h4 id="TTBCR.EAE0_0">
                Bits [31:17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE0_FnV">FnV, bit [16]
              </h4>
              <p>FAR not Valid, for a Synchronous external abort other than a Synchronous external abort on a translation table walk.</p>
            <table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-ifar.html">IFAR</a> is valid.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-ifar.html">IFAR</a> is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p>
                </td></tr></table>
              <p>This field is only valid for a Synchronous external abort other than a Synchronous external abort on a translation table walk. It is <span class="arm-defined-word">RES0</span> for all other Prefetch Abort exceptions.</p>
            <h4 id="TTBCR.EAE0_0">
                Bits [15:13]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE0_ExT">ExT, bit [12]
              </h4>
              <p>External abort type. This bit can be used to provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of external aborts.</p>
            
              <p>In an implementation that does not provide any classification of external aborts, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>For aborts other than external aborts this bit always returns 0.</p>
            <h4 id="TTBCR.EAE0_0">
                Bit [11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE0_FS[4]">FS[4], bit [10]
              </h4>
              <p>See FS[3:0], bits [3:0] for description of the FS field.</p>
            <h4 id="TTBCR.EAE0_LPAE">LPAE, bit [9]
              </h4>
              <p>On taking a Data Abort exception, this bit is set as follows:</p>
            <table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Using the Short-descriptor translation table formats.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Using the Long-descriptor translation table formats.</p>
                </td></tr></table>
              <p>Hardware does not interpret this bit to determine the behavior of the memory system, and therefore software can set this bit to 0 or 1 without affecting operation.</p>
            <h4 id="TTBCR.EAE0_0">
                Bits [8:4]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE0_FS[3:0]">FS[3:0], bits [3:0]
                  </h4>
              <p>Fault status bits. Interpreted with bit [10]. Possible values of FS[4:0] are:</p>
            <table class="valuetable"><tr><th>FS</th><th>Meaning</th></tr><tr><td class="bitfield">00001</td><td>
                  <p>PC alignment fault</p>
                </td></tr><tr><td class="bitfield">00010</td><td>
                  <p>Debug exception</p>
                </td></tr><tr><td class="bitfield">00011</td><td>
                  <p>Access flag fault, level 1</p>
                </td></tr><tr><td class="bitfield">00101</td><td>
                  <p>Translation fault, level 1</p>
                </td></tr><tr><td class="bitfield">00110</td><td>
                  <p>Access flag fault, level 2</p>
                </td></tr><tr><td class="bitfield">00111</td><td>
                  <p>Translation fault, level 2</p>
                </td></tr><tr><td class="bitfield">01000</td><td>
                  <p>Synchronous external abort, not on translation table walk</p>
                </td></tr><tr><td class="bitfield">01001</td><td>
                  <p>Domain fault, level 1</p>
                </td></tr><tr><td class="bitfield">01011</td><td>
                  <p>Domain fault, level 2</p>
                </td></tr><tr><td class="bitfield">01100</td><td>
                  <p>Synchronous external abort, on translation table walk, level 1</p>
                </td></tr><tr><td class="bitfield">01101</td><td>
                  <p>Permission fault, level 1</p>
                </td></tr><tr><td class="bitfield">01110</td><td>
                  <p>Synchronous external abort, on translation table walk, level 2</p>
                </td></tr><tr><td class="bitfield">01111</td><td>
                  <p>Permission fault, level 2</p>
                </td></tr><tr><td class="bitfield">10000</td><td>
                  <p>TLB conflict abort</p>
                </td></tr><tr><td class="bitfield">10100</td><td>
                  <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Lockdown fault)</p>
                </td></tr><tr><td class="bitfield">11001</td><td>
                  <p>Synchronous parity or ECC error on memory access, not on translation table walk</p>
                </td></tr><tr><td class="bitfield">11100</td><td>
                  <p>Synchronous parity or ECC error on translation table walk, level 1</p>
                </td></tr><tr><td class="bitfield">11110</td><td>
                  <p>Synchronous parity or ECC error on translation table walk, level 2</p>
                </td></tr></table>
              <p>All other values are reserved.</p>
            
              <p>When the RAS Extension is implemented, <span class="binarynumber">11001</span>, <span class="binarynumber">11100</span>, and <span class="binarynumber">11110</span>, are reserved.</p>
            <h3>When TTBCR.EAE==1:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TTBCR.EAE1_FnV">FnV</a></td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TTBCR.EAE1_ExT">ExT</a></td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TTBCR.EAE1_LPAE">LPAE</a></td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="6"><a href="#TTBCR.EAE1_STATUS">STATUS</a></td></tr></tbody></table><h4 id="TTBCR.EAE1_0">
                Bits [31:17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE1_FnV">FnV, bit [16]
              </h4>
              <p>FAR not Valid, for a Synchronous external abort other than a Synchronous external abort on a translation table walk.</p>
            <table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-ifar.html">IFAR</a> is valid.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-ifar.html">IFAR</a> is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p>
                </td></tr></table>
              <p>This field is only valid for a Synchronous external abort other than a Synchronous external abort on a translation table walk. It is <span class="arm-defined-word">RES0</span> for all other Prefetch Abort exceptions.</p>
            <h4 id="TTBCR.EAE1_0">
                Bits [15:13]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE1_ExT">ExT, bit [12]
              </h4>
              <p>External abort type. This bit can be used to provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of external aborts.</p>
            
              <p>In an implementation that does not provide any classification of external aborts, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>For aborts other than external aborts this bit always returns 0.</p>
            <h4 id="TTBCR.EAE1_0">
                Bits [11:10]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE1_LPAE">LPAE, bit [9]
              </h4>
              <p>On taking a Data Abort exception, this bit is set as follows:</p>
            <table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Using the Short-descriptor translation table formats.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Using the Long-descriptor translation table formats.</p>
                </td></tr></table>
              <p>Hardware does not interpret this bit to determine the behavior of the memory system, and therefore software can set this bit to 0 or 1 without affecting operation.</p>
            <h4 id="TTBCR.EAE1_0">
                Bits [8:6]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TTBCR.EAE1_STATUS">STATUS, bits [5:0]
                  </h4>
              <p>Fault status bits. All encodings not shown below are reserved:</p>
            <table class="valuetable"><tr><th>STATUS</th><th>Meaning</th></tr><tr><td class="bitfield">000000</td><td>
                  <p>Address size fault in <a href="AArch32-ttbr0.html">TTBR0</a> or <a href="AArch32-ttbr1.html">TTBR1</a></p>
                </td></tr><tr><td class="bitfield">000001</td><td>
                  <p>Address size fault, level 1</p>
                </td></tr><tr><td class="bitfield">000010</td><td>
                  <p>Address size fault, level 2</p>
                </td></tr><tr><td class="bitfield">000011</td><td>
                  <p>Address size fault, level 3</p>
                </td></tr><tr><td class="bitfield">000101</td><td>
                  <p>Translation fault, level 1</p>
                </td></tr><tr><td class="bitfield">000110</td><td>
                  <p>Translation fault, level 2</p>
                </td></tr><tr><td class="bitfield">000111</td><td>
                  <p>Translation fault, level 3</p>
                </td></tr><tr><td class="bitfield">001001</td><td>
                  <p>Access flag fault, level 1</p>
                </td></tr><tr><td class="bitfield">001010</td><td>
                  <p>Access flag fault, level 2</p>
                </td></tr><tr><td class="bitfield">001011</td><td>
                  <p>Access flag fault, level 3</p>
                </td></tr><tr><td class="bitfield">001101</td><td>
                  <p>Permission fault, level 1</p>
                </td></tr><tr><td class="bitfield">001110</td><td>
                  <p>Permission fault, level 2</p>
                </td></tr><tr><td class="bitfield">001111</td><td>
                  <p>Permission fault, level 3</p>
                </td></tr><tr><td class="bitfield">010000</td><td>
                  <p>Synchronous external abort, not on translation table walk</p>
                </td></tr><tr><td class="bitfield">010101</td><td>
                  <p>Synchronous external abort, on translation table walk, level 1</p>
                </td></tr><tr><td class="bitfield">010110</td><td>
                  <p>Synchronous external abort, on translation table walk, level 2</p>
                </td></tr><tr><td class="bitfield">010111</td><td>
                  <p>Synchronous external abort, on translation table walk, level 3</p>
                </td></tr><tr><td class="bitfield">011000</td><td>
                  <p>Synchronous parity or ECC error on memory access, not on translation table walk</p>
                </td></tr><tr><td class="bitfield">011101</td><td>
                  <p>Synchronous parity or ECC error on memory access on translation table walk, level 1</p>
                </td></tr><tr><td class="bitfield">011110</td><td>
                  <p>Synchronous parity or ECC error on memory access on translation table walk, level 2</p>
                </td></tr><tr><td class="bitfield">011111</td><td>
                  <p>Synchronous parity or ECC error on memory access on translation table walk, level 3</p>
                </td></tr><tr><td class="bitfield">100001</td><td>
                  <p>PC alignment fault</p>
                </td></tr><tr><td class="bitfield">100010</td><td>
                  <p>Debug exception</p>
                </td></tr><tr><td class="bitfield">110000</td><td>
                  <p>TLB conflict abort</p>
                </td></tr></table>
              <p>All other values are reserved.</p>
            
              <p>When the RAS Extension is implemented, <span class="binarynumber">011000</span>, <span class="binarynumber">011101</span>, <span class="binarynumber">011110</span>, and <span class="binarynumber">011111</span>, are reserved.</p>
            
              <p>The lookup level associated with a fault is:</p>
            
              <ul>
                <li>
                  For a fault generated on a translation table walk, the lookup level of the walk being performed.
                </li>
                <li>
                  For a Translation fault, the lookup level of the translation table that gave the fault. If a fault occurs because a stage of address translation is disabled, or because the input address is outside the range specified by the appropriate base address register or registers, the fault is reported as a fault at level 1.
                </li>
                <li>
                  For an Access flag fault, the lookup level of the translation table that gave the fault.
                </li>
                <li>
                  For a Permission fault, including a Permission fault caused by hierarchical permissions, the lookup level of the final level of translation table accessed for the translation. That is, the lookup level of the translation table that returned a Block or Page descriptor.
                </li>
              </ul>
            <h2>Accessing the IFSR32_EL2</h2><p>To access the IFSR32_EL2:</p><p class="asm-code">MRS &lt;Xt&gt;, IFSR32_EL2 ; Read IFSR32_EL2 into Xt</p><p class="asm-code">MSR IFSR32_EL2, &lt;Xt&gt; ; Write Xt to IFSR32_EL2</p><p>Register access is encoded as follows:</p><table class="info"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>11</td><td>100</td><td>0101</td><td>0000</td><td>001</td></tr></table><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 15:40</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
