<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>DC ZVA</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">DC ZVA, Data Cache Zero by VA</h1><p>The DC ZVA characteristics are:</p><h2>Purpose</h2>
          <p>Zero data cache by address. Zeroes a naturally aligned block of N bytes, where the size of N is identified in <a href="AArch64-dczid_el0.html">DCZID_EL0</a>.</p>
        <p>This 
        System instruction
       is part of the Cache maintenance instructions functional group.</p><h2>Usage constraints</h2><p>This instruction can be executed at the following exception levels:</p><table class="register_access"><tr><th>EL0</th><th>EL1 (NS)</th><th>EL1 (S)</th><th>EL2 (NS)</th><th>EL3 (SCR.NS=1)</th><th>EL3 (SCR.NS=0)</th></tr><tr><td>Config-WO</td><td>WO</td><td>WO</td><td>WO</td><td>WO</td><td>WO</td></tr></table>
          <p>When the value of <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.DZE is 0 this instruction is <span class="arm-defined-word">UNDEFINED</span> at EL0.</p>
        
          <p>When this instruction is executed, it can generate memory faults or watchpoints which are prioritized in the same way as other memory-related faults or watchpoints. If a synchronous data abort fault or a watchpoint is generated, the CM bit in the <a href="AArch64-esr_elx.html">ESR_ELx</a>.ISS field is not set.</p>
        
          <p>If the memory region being zeroed is any type of Device memory, this instruction can give an alignment fault which is prioritized in the same way as other alignment faults that are determined by the memory type.</p>
        
          <p>This instruction applies to Normal memory regardless of cacheability attributes.</p>
        
          <p>This instruction behaves as a set of Stores to each byte within the block being accessed, and so it:</p>
        
          <ul>
            <li>
              Will cause a Permission Fault if the translation system does not permit writes to the locations.
            </li>
            <li>
              Requires the same considerations for ordering and the management of coherency as any other store instructions.
            </li>
          </ul>
        <h2>Traps and Enables</h2><p>For a description of the prioritization of any generated exceptions, see section D1.13.2 (Synchronous exception prioritization) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i>. Subject to the prioritization rules:</p>
          <p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TDZ==1, Non-secure execution of this instruction at EL0 and EL1 is trapped to EL2.</p>
        
          <p>If <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.DZE==0, execution of this instruction at EL0 is trapped to EL1.</p>
        <h2>Configuration</h2><p>There are no configuration notes.</p><h2>Attributes</h2>
          <p>DC ZVA is a 64-bit System instruction.</p>
        <h2>Field descriptions</h2><p>The DC ZVA input value bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#Virtualaddresstouse">Virtual address to use</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#Virtualaddresstouse">Virtual address to use</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><h4 id="Virtualaddresstouse">
                Bits [63:0]
              </h4>
              <p>Virtual address to use. There is no alignment restriction on the address within the block of N bytes that is used.</p>
            <h2>Executing the DC ZVA instruction</h2><p>The DC ZVA instruction is executed as:</p><p class="asm-code">DC ZVA, &lt;Xt&gt;</p><p>The instruction is encoded in the System instruction encoding space as follows:</p><table class="info"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>01</td><td>011</td><td>0111</td><td>0100</td><td>001</td></tr></table>
          <p>When this instruction is executed, it can generate memory faults or watchpoints which are prioritized in the same way as other memory-related faults or watchpoints. If a synchronous data abort fault or a watchpoint is generated, the CM bit in the <a href="AArch64-esr_elx.html">ESR_ELx</a>.ISS field is not set.</p>
          <p>If the memory region being zeroed is any type of Device memory, this instruction can give an alignment fault which is prioritized in the same way as other alignment faults that are determined by the memory type.</p>
          <p>This instruction applies to Normal memory regardless of cacheability attributes.</p>
          <p>This instruction behaves as a set of Stores to each byte within the block being accessed, and so it:</p>
          <ul>
            <li>
              Generates a Permission Fault if the translation system does not permit writes to the locations.
            </li>
            <li>
              Requires the same considerations for ordering and the management of coherency as any other store instructions.
            </li>
          </ul>
        <br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 15:40</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
