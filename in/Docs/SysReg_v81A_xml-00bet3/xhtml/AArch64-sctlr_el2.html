<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SCTLR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">SCTLR_EL2, System Control Register (EL2)</h1><p>The SCTLR_EL2 characteristics are:</p><h2>Purpose</h2>
          <p>Provides top level control of the system, including its memory system, at EL2.</p>
        
          <p>When <span class="xref">ARMv8.1-VHE</span> is implemented, and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, these controls apply also to execution at Non-secure EL0.</p>
        <p>This 
        register
       is part of:</p><ul><li>The Virtualization registers functional group.</li><li>The Other system control registers functional group.</li></ul><h2>Configuration</h2><p>AArch64 System register SCTLR_EL2
                is architecturally mapped to
              AArch32 System register <a href="AArch32-hsctlr.html">HSCTLR</a>.
          </p>
          <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>
        <p>
                Some or all RW fields of this register have defined reset values. 
                
        These apply
      
                only if the PE resets into EL2 using AArch64. 
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>SCTLR_EL2 is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The SCTLR_EL2 bit assignments are:</p><h3>When HCR_EL2.{E2H, TGE} != {1, 1}:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_EE">EE</a></td><td class="lr">0</td><td class="l">1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_WXN">WXN</a></td><td class="lr">1</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_I">I</a></td><td class="lr">1</td><td class="l">0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_SA">SA</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_C">C</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_A">A</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}!{1,1}_M">M</a></td></tr></tbody></table><div class="text_before_fields">
            <p>This format applies in all ARMv8.0 implementations, and from ARMv8.1 in Secure state.</p>
          </div><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bits [31:30]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_1">
                Bits [29:28]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bits [27:26]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_EE">EE, bit [25]
              </h4>
              <p>Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime.</p>
            
              <p>The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime are little-endian.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime are big-endian.</p>
                </td></tr></table>
              <p>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>The EE bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bit [24]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_1">
                Bits [23:22]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bits [21:20]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_WXN">WXN, bit [19]
              </h4>
              <p>Write permission implies XN (Execute-never). For the EL2 or EL2&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on memory access permissions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any region that is writable in the EL2 or EL2&amp;0 translation regime is forced to XN for accesses from software executing at EL2.</p>
                </td></tr></table>
              <p>The WXN bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_1">
                Bit [18]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bit [17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_1">
                Bit [16]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bits [15:13]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_I">I, bit [12]
              </h4>
              <p>Instruction access Cacheability control, for accesses at EL2:</p>
            <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All instruction access to Normal memory from EL2 are Non-cacheable for all levels of instruction and unified cache.</p>
                
                  <p>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2 or EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control has no effect on the Cacheability of instruction access to Normal memory from EL2.</p>
                
                  <p>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2 or EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p>
                </td></tr></table>
              <p>This bit has no effect on the EL1&amp;0 or EL3 translation regimes.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_1">
                Bit [11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_0">
                Bits [10:6]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_1">
                Bits [5:4]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}!{1,1}_SA">SA, bit [3]
              </h4>
              <p>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL2 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the ARMv8 ARM, section D1 (The AArch64 System Level Programmers' Model)</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_C">C, bit [2]
              </h4>
              <p>Cacheability control, for data accesses.</p>
            <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All data access to Normal memory from EL2, and all Normal memory accesses to the EL2 translation tables, are Non-cacheable for all levels of data and unified cache.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control has no effect on the Cacheability of:</p>
                
                  <ul>
                    <li>
                      Data access to Normal memory from EL2.
                    </li>
                    <li>
                      Normal memory accesses to the EL2 translation tables.
                    </li>
                  </ul>
                </td></tr></table>
              <p>This bit has no effect on the EL1&amp;0 or EL3 translation regimes.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_A">A, bit [1]
              </h4>
              <p>Alignment check enable. This is the enable bit for Alignment fault checking at EL2:</p>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Alignment fault checking disabled when executing at EL2.</p>
                
                  <p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Alignment fault checking enabled when executing at EL2.</p>
                
                  <p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p>
                </td></tr></table>
              <p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}!{1,1}_M">M, bit [0]
              </h4>
              <p>MMU enable for EL2 stage 1 address translation. Possible values of this bit are:</p>
            <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL2 stage 1 address translation disabled.</p>
                
                  <p>See the SCTLR_EL2.I field for the behavior of instruction accesses to Normal memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2 stage 1 address translation enabled.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h3>When HCR_EL2.{E2H, TGE} == {1, 1}:</h3><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td class="lr">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_UCI">UCI</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_EE">EE</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_E0E">E0E</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_SPAN">SPAN</a></td><td class="lr">1</td><td class="lr">0</td><td class="lr">1</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_WXN">WXN</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_nTWE">nTWE</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_nTWI">nTWI</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_UCT">UCT</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_DZE">DZE</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_I">I</a></td><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_SED">SED</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_ITD">ITD</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_CP15BEN">CP15BEN</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_SA0">SA0</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_SA">SA</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_C">C</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_A">A</a></td><td class="lr" colspan="1"><a href="#HCR_EL2.{E2H,TGE}{1,1}_M">M</a></td></tr></tbody></table><div class="text_before_fields">
            <p>This format applies only from ARMv8.1 and only in Non-secure state when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} == {1, 1}.</p>
          </div><h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bits [31:30]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_1">
                Bits [29:28]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bit [27]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_UCI">UCI, bit [26]
              </h4>
              <p>Traps EL0 execution of cache maintenance instructions to EL2, from AArch64 state only.</p>
            <table class="valuetable"><tr><th>UCI</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Any attempt to execute a <a href="AArch64-dc-cvau.html">DC CVAU</a>, <a href="AArch64-dc-civac.html">DC CIVAC</a>, <a href="AArch64-dc-cvac.html">DC CVAC</a>, or <a href="AArch64-ic-ivau.html">IC IVAU</a> instruction at EL0 using AArch64 is trapped to EL2.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_EE">EE, bit [25]
              </h4>
              <p>Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL2&amp;0 translation regime.</p>
            
              <p>The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL2&amp;0 translation regime are little-endian.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or El2&amp;0 translation regime, and stage 2 translation table walks in the EL2&amp;0 translation regime are big-endian.</p>
                </td></tr></table>
              <p>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>The EE bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_E0E">E0E, bit [24]
              </h4>
              <p>Endianness of data accesses at EL0. </p>
            
              <p>The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>E0E</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Explicit data accesses at EL0 are little-endian.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Explicit data accesses at EL0 are big-endian.</p>
                </td></tr></table>
              <p>If an implementation only supports Little-endian accesses at EL0 then this bit is <span class="arm-defined-word">RES0</span>. This option is not permitted when SCTLR_EL1.EE is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>If an implementation only supports Big-endian accesses at EL0 then this bit is <span class="arm-defined-word">RES1</span>. This option is not permitted when SCTLR_EL1.EE is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>This bit has no effect on the endianness of LDTR, LDTRH, LDTRSH, LDTRSW, STTR, and STTRH instructions executed at EL1.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_SPAN">SPAN, bit [23]
              </h4>
              <p>Set Privileged Access Never, on taking an exception to EL2.</p>
            <table class="valuetable"><tr><th>SPAN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>PSTATE.PAN is set to 1 on taking an exception to EL2.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The value of PSTATE.PAN is left unchanged on taking an exception to EL2.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_1">
                Bit [22]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bit [21]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_1">
                Bit [20]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_WXN">WXN, bit [19]
              </h4>
              <p>Write permission implies XN (Execute-never). For the EL2 or EL2&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on memory access permissions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any region that is writable in the EL2 or EL2&amp;0 translation regime is forced to XN for accesses from software executing at EL2.</p>
                </td></tr></table>
              <p>The WXN bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_nTWE">nTWE, bit [18]
              </h4>
              <p>Traps EL0 execution of WFE instructions to EL2, from both Execution states.</p>
            <table class="valuetable"><tr><th>nTWE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Any attempt to execute a WFE instruction at EL0 is trapped to EL2, if the instruction would otherwise have caused the PE to enter a low-power state.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table>
              <p>In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bit [17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_nTWI">nTWI, bit [16]
              </h4>
              <p>Traps EL0 execution of WFI instructions to EL2, from both Execution states.</p>
            <table class="valuetable"><tr><th>nTWI</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Any attempt to execute a WFI instruction at EL0 is trapped EL2, if the instruction would otherwise have caused the PE to enter a low-power state.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table>
              <p>In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_UCT">UCT, bit [15]
              </h4>
              <p>Traps EL0 accesses to the <a href="AArch64-ctr_el0.html">CTR_EL0</a> to EL2, from AArch64 state only.</p>
            <table class="valuetable"><tr><th>UCT</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Accesses to the <a href="AArch64-ctr_el0.html">CTR_EL0</a> from EL0 using AArch64 are trapped to EL2.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_DZE">DZE, bit [14]
              </h4>
              <p>Traps EL0 execution of <a href="AArch64-dc-zva.html">DC ZVA</a> instructions to EL2, from AArch64 state only.</p>
            <table class="valuetable"><tr><th>DZE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Any attempt to execute a <a href="AArch64-dc-zva.html">DC ZVA</a> instruction at EL0 using AArch64 is trapped to EL2. Reading <a href="AArch64-dczid_el0.html">DCZID_EL0</a>.DZP from EL0 returns 1, indicating that <a href="AArch64-dc-zva.html">DC ZVA</a> instructions are not supported.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bit [13]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_I">I, bit [12]
              </h4>
              <p>Instruction access Cacheability control, for accesses at EL2 and EL0:</p>
            <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All instruction access to Normal memory from EL2 and EL0 are Non-cacheable for all levels of instruction and unified cache.</p>
                
                  <p>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control has no effect on the Cacheability of instruction access to Normal memory from EL2 and EL0.</p>
                
                  <p>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p>
                </td></tr></table>
              <p>This bit has no effect on the EL3 translation regimes.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_1">
                Bit [11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bits [10:9]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_SED">SED, bit [8]
              </h4>
              <p>SETEND instruction disable. Disables SETEND instructions at EL0 using AArch32.</p>
            <table class="valuetable"><tr><th>SED</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>SETEND instruction execution is enabled at EL0 using AArch32.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>SETEND instructions are <span class="arm-defined-word">UNDEFINED</span> at EL0 using AArch32.</p>
                </td></tr></table>
              <p>If the implementation does not support mixed-endian operation at any Exception level, this bit is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>If EL0 cannot use AArch32, this bit is <span class="arm-defined-word">RES1</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_ITD">ITD, bit [7]
              </h4>
              <p>IT Disable. Disables some uses of IT instructions at EL0 using AArch32.</p>
            <table class="valuetable"><tr><th>ITD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All IT instruction functionality is enabled at EL0 using AArch32.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any attempt at EL0 using AArch32 to execute any of the following is <span class="arm-defined-word">UNDEFINED</span>:</p>
                
                  <ul>
                    <li>
                      All encodings of the IT instruction with hw1[3:0]!=1000.
                    </li>
                    <li>
                      All encodings of the subsequent instruction with the following values for hw1:<dl><dt><span class="binarynumber">11xxxxxxxxxxxxxx</span></dt><dd>All 32-bit instructions, and the 16-bit instructions B, UDF, SVC, LDM, and STM.</dd><dt><span class="binarynumber">1011xxxxxxxxxxxx</span></dt><dd>All instructions in <span class="xref">'Miscellaneous 16-bit instructions' in the ARMv8 ARM, section F3.2.5</span>.</dd><dt><span class="binarynumber">10100xxxxxxxxxxx</span></dt><dd>ADD Rd, PC, #imm </dd><dt><span class="binarynumber">01001xxxxxxxxxxx</span></dt><dd>LDR Rd, [PC, #imm]</dd><dt><span class="binarynumber">0100x1xxx1111xxx</span></dt><dd>ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.</dd><dt><span class="binarynumber">010001xx1xxxx111</span></dt><dd>ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. This pattern also covers <span class="arm-defined-word">UNPREDICTABLE</span> cases with BLX Rn.</dd></dl>
                    </li>
                  </ul>
                
                  <p>These instructions are always <span class="arm-defined-word">UNDEFINED</span>, regardless of whether they would pass or fail the condition code check that applies to them as a result of being in an IT block.</p>
                
                  <p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the IT instruction is treated as:</p>
                
                  <ul>
                    <li>
                      A 16-bit instruction, that can only be followed by another 16-bit instruction.
                    </li>
                    <li>
                      The first half of a 32-bit instruction.
                    </li>
                  </ul>
                
                  <p>This means that, for the situations that are <span class="arm-defined-word">UNDEFINED</span>, either the second 16-bit instruction or the 32-bit instruction is <span class="arm-defined-word">UNDEFINED</span>.</p>
                
                  <p>An implementation might vary dynamically as to whether IT is treated as a 16-bit instruction or the first half of a 32-bit instruction.</p>
                </td></tr></table>
              <p>If an instruction in an active IT block that would be disabled by this field sets this field to 1 then behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>. For more information see <span class="xref">'Changes to an ITD control by an instruction in an IT block' in the ARMv8 ARM, section E1.2.4</span></p>
            
              <p>If EL0 cannot use AArch32, this bit is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>ITD is optional, but if it is implemented in the <a href="AArch32-sctlr.html">SCTLR</a> then it must also be implemented in the SCTLR_EL1. If it is not implemented then this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_0">
                Bit [6]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HCR_EL2.{E2H,TGE}{1,1}_CP15BEN">CP15BEN, bit [5]
              </h4>
              <p>System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==<span class="binarynumber">1111</span>) encoding space from EL0:</p>
            <table class="valuetable"><tr><th>CP15BEN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL0 using AArch32: EL0 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is <span class="arm-defined-word">UNDEFINED</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL0 using AArch32: EL0 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is enabled.</p>
                </td></tr></table>
              <p>If EL0 cannot use AArch32, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>CP15BEN is optional, but if it is implemented in the <a href="AArch32-sctlr.html">SCTLR</a> then it must also be implemented in the SCTLR_EL1. If it is not implemented then this bit is RAO/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_SA0">SA0, bit [4]
              </h4>
              <p>SP Alignment check enable for EL0. When set to 1, if a load or store instruction executed at EL0 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the ARMv8 ARM, section D1 (The AArch64 System Level Programmers' Model)</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_SA">SA, bit [3]
              </h4>
              <p>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL2 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <span class="xref">'SP alignment checking' in the ARMv8 ARM, section D1 (The AArch64 System Level Programmers' Model)</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_C">C, bit [2]
              </h4>
              <p>Cacheability control, for data accesses.</p>
            <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All data access to Normal memory from EL2 and EL0, and all Normal memory accesses to the EL2&amp;0 translation tables, are Non-cacheable for all levels of data and unified cache.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control has no effect on the Cacheability of:</p>
                
                  <ul>
                    <li>
                      Data access to Normal memory from EL2 and EL0.
                    </li>
                    <li>
                      Normal memory accesses to the EL2&amp;0 translation tables.
                    </li>
                  </ul>
                </td></tr></table>
              <p>This bit has no effect on the EL3 translation regimes.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_A">A, bit [1]
              </h4>
              <p>Alignment check enable. This is the enable bit for Alignment fault checking at EL2 and EL0:</p>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Alignment fault checking disabled when executing at EL2 and EL0.</p>
                
                  <p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Alignment fault checking enabled when executing at EL2 and EL0.</p>
                
                  <p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p>
                </td></tr></table>
              <p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="HCR_EL2.{E2H,TGE}{1,1}_M">M, bit [0]
              </h4>
              <p>MMU enable for EL2&amp;0 stage 1 address translation. Possible values of this bit are:</p>
            <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL2&amp;0 stage 1 address translation disabled.</p>
                
                  <p>See the SCTLR_EL2.I field for the behavior of instruction accesses to Normal memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2&amp;1 stage 1 address translation enabled.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><div class="access_mechanisms"><h2>Accessing the SCTLR_EL2</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRS with the following syntax:</p><p class="asm-code">MRS  &lt;Xt&gt;, &lt;systemreg&gt;</p></div><div class="access_instruction"><p>This register can be written using MSR (register) with the following syntax:</p><p class="asm-code">MSR  &lt;systemreg&gt;, &lt;Xt&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;systemreg&gt;
      </th><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>SCTLR_EL2</td><td>11</td><td>100</td><td>0001</td><td>0000</td><td>000</td></tr><tr><td>SCTLR_EL1</td><td>11</td><td>000</td><td>0001</td><td>0000</td><td>000</td></tr></table></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th rowspan="2">
        &lt;systemreg&gt;
      </th><th class="accessibility_control" colspan="3">
            Control
          </th><th colspan="4">
          Accessibility
        </th></tr><tr><th class="accessibility_control">E2H</th><th class="accessibility_control">TGE</th><th class="accessibility_control">NS</th><th>EL0</th><th>EL1</th><th>EL2</th><th>EL3</th></tr><tr><td>SCTLR_EL2</td><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td></tr><tr><td>SCTLR_EL2</td><td class="accessibility_control">0</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        -
      </td><td>RW</td><td>RW</td></tr><tr><td>SCTLR_EL2</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>RW</td></tr><tr><td>SCTLR_EL2</td><td class="accessibility_control">1</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        -
      </td><td>RW</td><td>RW</td></tr><tr><td>SCTLR_EL2</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>RW</td></tr><tr><td>SCTLR_EL1</td><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td><td>
        n/a
      </td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td></tr><tr><td>SCTLR_EL1</td><td class="accessibility_control">0</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td></tr><tr><td>SCTLR_EL1</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td></tr><tr><td>SCTLR_EL1</td><td class="accessibility_control">1</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td><td>RW</td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td></tr><tr><td>SCTLR_EL1</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td><a href="AArch64-sctlr_el1.html">
                              SCTLR_EL1
                              </a></td></tr></table>
            <p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, without explicit synchronization, access from EL2 using the mnemonic SCTLR_EL2 or SCTLR_EL1 are not guaranteed to be ordered with respect to accesses using the other mnemonic.</p>
          </div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 16:41</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
