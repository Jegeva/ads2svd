<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ICC_MCTLR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">ICC_MCTLR, Interrupt Controller Monitor Control Register</h1><p>The ICC_MCTLR characteristics are:</p><h2>Purpose</h2>
          <p>Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.</p>
        <p>This 
        register
       is part of:</p><ul><li>The GIC system registers functional group.</li><li>The Security registers functional group.</li><li>The GIC control registers functional group.</li></ul><h2>Configuration</h2>
        <p>This register is only accessible in Secure state.</p>
      <p>AArch32 System register ICC_MCTLR 
            can be mapped to 
            AArch64 System register <a href="AArch64-icc_ctlr_el3.html">ICC_CTLR_EL3</a>, but this is not architecturally mandated.
          </p><h2>Attributes</h2>
          <p>ICC_MCTLR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The ICC_MCTLR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#nDS">nDS</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#A3V">A3V</a></td><td class="lr" colspan="1"><a href="#SEIS">SEIS</a></td><td class="lr" colspan="3"><a href="#IDbits">IDbits</a></td><td class="lr" colspan="3"><a href="#PRIbits">PRIbits</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#PMHE">PMHE</a></td><td class="lr" colspan="1"><a href="#RM">RM</a></td><td class="lr" colspan="1"><a href="#EOImode_EL1NS">EOImode_EL1NS</a></td><td class="lr" colspan="1"><a href="#EOImode_EL1S">EOImode_EL1S</a></td><td class="lr" colspan="1"><a href="#EOImode_EL3">EOImode_EL3</a></td><td class="lr" colspan="1"><a href="#CBPR_EL1NS">CBPR_EL1NS</a></td><td class="lr" colspan="1"><a href="#CBPR_EL1S">CBPR_EL1S</a></td></tr></tbody></table><h4 id="0">
                Bits [31:18]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="nDS">nDS, bit [17]
              </h4>
              <p>Disable Security not supported. Read-only and writes are ignored. Possible values are:</p>
            <table class="valuetable"><tr><th>nDS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The CPU interface logic supports disabling of security.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The CPU interface logic does not support disabling of security, and requires that security is not disabled.</p>
                </td></tr></table><h4 id="0">
                Bit [16]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="A3V">A3V, bit [15]
              </h4>
              <p>Affinity 3 Valid. Read-only and writes are ignored. Possible values are:</p>
            <table class="valuetable"><tr><th>A3V</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The CPU interface logic does not support non-zero values of the Aff3 field in SGI generation System registers.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The CPU interface logic supports non-zero values of the Aff3 field in SGI generation System registers.</p>
                </td></tr></table>
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.AV3 is an alias of ICC_MCTLR.A3V</p>
            <h4 id="SEIS">SEIS, bit [14]
              </h4>
              <p>SEI Support. Read-only and writes are ignored. Indicates whether the CPU interface supports generation of SEIs:</p>
            <table class="valuetable"><tr><th>SEIS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The CPU interface logic does not support generation of SEIs.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The CPU interface logic supports generation of SEIs.</p>
                </td></tr></table>
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.SEIS is an alias of ICC_MCTLR.SEIS</p>
            <h4 id="IDbits">IDbits, bits [13:11]
                  </h4>
              <p>Identifier bits. Read-only and writes are ignored. The number of physical interrupt identifier bits supported:</p>
            <table class="valuetable"><tr><th>IDbits</th><th>Meaning</th></tr><tr><td class="bitfield">000</td><td>
                  <p>16 bits.</p>
                </td></tr><tr><td class="bitfield">001</td><td>
                  <p>24 bits.</p>
                </td></tr></table>
              <p>All other values are reserved.</p>
            
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.IDbits is an alias of ICC_MCTLR.IDbits</p>
            <h4 id="PRIbits">PRIbits, bits [10:8]
                  </h4>
              <p>Priority bits. Read-only and writes are ignored. The number of priority bits implemented, minus one.</p>
            
              <p>An implementation that supports two Security states must implement at least 32 levels of physical priority (5 priority bits).</p>
            
              <p>An implementation that supports only a single Security state must implement at least 16 levels of physical priority (4 priority bits).</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>This field always returns the number of priority bits implemented, regardless of the value of <span class="xref">SCR</span>.NS or the value of <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS.</p>
              </div>
            
              <p>The division between group priority and subpriority is defined in the binary point registers <a href="AArch32-icc_bpr0.html">ICC_BPR0</a> and <a href="AArch32-icc_bpr1.html">ICC_BPR1</a>.</p>
            
              <p>This field determines the minimum value of ICC_BPR0.</p>
            <h4 id="0">
                Bit [7]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="PMHE">PMHE, bit [6]
              </h4>
              <p>Priority Mask Hint Enable.</p>
            <table class="valuetable"><tr><th>PMHE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Disables use of the priority mask register as a hint for interrupt distribution.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Enables use of the priority mask register as a hint for interrupt distribution.</p>
                </td></tr></table>
              <p>Software must write <a href="AArch32-icc_pmr.html">ICC_PMR</a> to <span class="hexnumber">0xFF</span> before clearing this field to 0.</p>
            
              <p>An implementation might choose to make this field RAO/WI.</p>
            
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>.PMHE is an alias of ICC_MCTLR.PMHE.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">0</span>.</p><h4 id="RM">RM, bit [5]
              </h4>
              <p>SBZ.</p>
            
              <p>The equivalent bit in AArch64 is the Routing Modifier bit. This feature is not supported when EL3 is using AArch32.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="EOImode_EL1NS">EOImode_EL1NS, bit [4]
              </h4>
              <p>EOI mode for interrupts handled at Non-secure EL1 and EL2. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>
            <table class="valuetable"><tr><th>EOImode_EL1NS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
                </td></tr></table>
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(NS).EOImode is an alias of ICC_MCTLR.EOImode_EL1NS.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="EOImode_EL1S">EOImode_EL1S, bit [3]
              </h4>
              <p>EOI mode for interrupts handled at Secure EL1. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>
            <table class="valuetable"><tr><th>EOImode_EL1S</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
                </td></tr></table>
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(S).EOImode is an alias of ICC_MCTLR.EOImode_EL1S.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="EOImode_EL3">EOImode_EL3, bit [2]
              </h4>
              <p>EOI mode for interrupts handled at EL3. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>
            <table class="valuetable"><tr><th>EOImode_EL3</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="CBPR_EL1NS">CBPR_EL1NS, bit [1]
              </h4>
              <p>Common Binary Point Register, EL1 Non-secure. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 Non-secure interrupts at EL1 and EL2:</p>
            <table class="valuetable"><tr><th>CBPR_EL1NS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts only.</p>
                
                  <p><a href="AArch32-icc_bpr1.html">ICC_BPR1</a> determines the preemption group for Non-secure Group 1 interrupts.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts and Non-secure Group 1 interrupts. Non-secure accesses to <a href="ext-gicc_bpr.html">GICC_BPR</a> and <a href="AArch32-icc_bpr1.html">ICC_BPR1</a> access the state of <a href="AArch32-icc_bpr0.html">ICC_BPR0</a>.</p>
                </td></tr></table>
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(NS).CBPR is an alias of ICC_MCTLR.CBPR_EL1NS.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="CBPR_EL1S">CBPR_EL1S, bit [0]
              </h4>
              <p>Common Binary Point Register, EL1 Secure. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 Secure interrupts in Secure non-Monitor modes:</p>
            <table class="valuetable"><tr><th>CBPR_EL1S</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts only.</p>
                
                  <p><a href="AArch32-icc_bpr1.html">ICC_BPR1</a> determines the preemption group for Secure Group 1 interrupts.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts and Secure Group 1 interrupts. Secure EL1 accesses, or EL3 accesses when not in Monitor mode, to <a href="AArch32-icc_bpr1.html">ICC_BPR1</a> access the state of <a href="AArch32-icc_bpr0.html">ICC_BPR0</a>.</p>
                </td></tr></table>
              <p>If EL3 is present, <a href="AArch32-icc_ctlr.html">ICC_CTLR</a>(S).CBPR is an alias of ICC_MCTLR.CBPR_EL1S.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><div class="access_mechanisms"><h2>Accessing the ICC_MCTLR</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRC with the following syntax:</p><p class="asm-code">MRC  &lt;syntax&gt;</p></div><div class="access_instruction"><p>This register can be written using MCR with the following syntax:</p><p class="asm-code">MCR  &lt;syntax&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;syntax&gt;
      </th><th>opc1</th><th>opc2</th><th>CRn</th><th>coproc</th><th>CRm</th></tr><tr><td>p15, 6, 
                &lt;Rt&gt;, c12, c12, 4</td><td>110</td><td>100</td><td>1100</td><td>1111</td><td>1100</td></tr></table><ul></ul></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th class="accessibility_control" colspan="2">
            Control
          </th><th colspan="4">
          Accessibility
        </th></tr><tr><th class="accessibility_control">TGE</th><th class="accessibility_control">NS</th><th>EL0</th><th>EL1</th><th>EL2</th><th>EL3</th></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td></tr><tr><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        -
      </td><td>
        -
      </td><td>RW</td></tr><tr><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>
        -
      </td><td>RW</td></tr></table><p><p>This table applies to all instructions that can access this register.</p></p>
            <p>This register is only accessible when executing in Monitor mode.</p>
          <h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when 
            accessing this register.
          </p></div><p>
            In both Security states, and not dependent on other configuration bits:
          </p><ul><li><p>If <a href="AArch32-icc_msre.html">ICC_MSRE</a>.SRE==0, accesses to this register from EL3 are <span class="arm-defined-word">UNDEFINED</span>.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; .E2H==0
        :
      </p><ul><li><p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T12==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; .E2H==1 &amp;&amp; HCR_EL2.TGE==0
        :
      </p><ul><li><p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T12==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch32
        and
        SCR_EL3.NS==1
        :
      </p><ul><li><p>If <a href="AArch32-hstr.html">HSTR</a>.T12==1, Non-secure accesses to this register from EL1 are trapped to Hyp mode.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 16:41</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
