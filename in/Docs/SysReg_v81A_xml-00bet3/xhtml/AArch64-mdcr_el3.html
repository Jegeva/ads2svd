<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>MDCR_EL3</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">MDCR_EL3, Monitor Debug Configuration Register (EL3)</h1><p>The MDCR_EL3 characteristics are:</p><h2>Purpose</h2>
          <p>Provides EL3 configuration options for self-hosted debug and the Performance Monitors Extension.</p>
        <p>This 
        register
       is part of:</p><ul><li>The Debug registers functional group.</li><li>The Security registers functional group.</li></ul><h2>Configuration</h2><p>AArch64 System register MDCR_EL3 
            can be mapped to 
            AArch32 System register <a href="AArch32-sdcr-s.html">SDCR</a>, but this is not architecturally mandated.
          </p><p>This register is in the Warm reset domain.
                Some or all RW fields of this register have defined reset values. 
                
        On a Warm or Cold reset these apply
      
                only if the PE resets into an Exception level that is using AArch64. 
                Otherwise,
                
                  on a Warm or Cold reset
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>MDCR_EL3 is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The MDCR_EL3 bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#EPMAD">EPMAD</a></td><td class="lr" colspan="1"><a href="#EDAD">EDAD</a></td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#SPME">SPME</a></td><td class="lr" colspan="1"><a href="#SDD">SDD</a></td><td class="lr" colspan="2"><a href="#SPD32">SPD32</a></td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TDOSA">TDOSA</a></td><td class="lr" colspan="1"><a href="#TDA">TDA</a></td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#TPM">TPM</a></td><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td></tr></tbody></table><h4 id="0">
                Bits [31:22]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="EPMAD">EPMAD, bit [21]
              </h4>
              <p>External debug interface Performance Monitors registers disable. This disables access to these registers by an external debugger:</p>
            <table class="valuetable"><tr><th>EPMAD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Access to Performance Monitors registers from external debugger is permitted.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Access to Performance Monitors registers from external debugger is disabled, unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
                </td></tr></table>
              <p>If the Performance Monitors Extension is not implemented or does not support external debug interface accesses this bit is <span class="arm-defined-word">RES0</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">0</span>.</p><h4 id="EDAD">EDAD, bit [20]
              </h4>
              <p>External debug interface breakpoint and watchpoint register access disable. This disables access to these registers by an external debugger:</p>
            <table class="valuetable"><tr><th>EDAD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Access to breakpoint and watchpoint registers from external debugger is permitted.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Access to breakpoint and watchpoint registers from external debugger is disabled, unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="0">
                Bits [19:18]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="SPME">SPME, bit [17]
              </h4>
              <p>Secure Performance Monitors enable. This allows event counting in Secure state:</p>
            <table class="valuetable"><tr><th>SPME</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Event counting prohibited in Secure state, unless ExternalSecureNoninvasiveDebugEnabled() is TRUE, meaning this control is overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Event counting allowed in Secure state.</p>
                </td></tr></table>
              <p>If the Performance Monitors Extension is not implemented, this field is <span class="arm-defined-word">RES0</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="SDD">SDD, bit [16]
              </h4>
              <p>AArch64 Secure self-hosted invasive debug disable. Disables Software debug exceptions in Secure state, other than Breakpoint Instruction exceptions.</p>
            <table class="valuetable"><tr><th>SDD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Debug exceptions from Secure EL0 are enabled, and debug exceptions from Secure EL1 are enabled if the value of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.KDE is 1 and the value of PSTATE.D is 0.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Debug exceptions, other than Breakpoint Instruction exceptions, are disabled from all Exception levels in Secure state.</p>
                </td></tr></table>
              <p>The SDD bit is ignored unless both of the following are true:</p>
            
              <ul>
                <li>
                  The PE is in Secure state.
                </li>
                <li>
                  Secure EL1 is using AArch64.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="SPD32">SPD32, bits [15:14]
                  </h4>
              <p>AArch32 Secure self-hosted privileged invasive debug control. Enables or disables debug exceptions from Secure EL1 using AArch32, other than Breakpoint Instruction exceptions. Valid values for this field are:</p>
            <table class="valuetable"><tr><th>SPD32</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>Legacy mode. Debug exceptions from Secure EL1 are enabled by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>Secure privileged debug disabled. Debug exceptions from Secure EL1 are disabled.</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>Secure privileged debug enabled. Debug exceptions from Secure EL1 are enabled.</p>
                </td></tr></table>
              <p>Other values are reserved, and have the <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behavior that they must have the same behavior as <span class="binarynumber">0b00</span>. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</p>
            
              <p>This field has no effect on Breakpoint Instruction exceptions. These are always enabled.</p>
            
              <p>This field is:</p>
            
              <ul>
                <li>
                  Ignored if either the PE is in Non-secure state or Secure EL1 is using AArch64.
                </li>
                <li>
                  <span class="arm-defined-word">RES0</span> if the implementation does not support EL1 using AArch32.
                </li>
              </ul>
            
              <p>If Secure EL1 is using AArch32 then:</p>
            
              <ul>
                <li>
                  If debug exceptions from Secure EL1 are enabled, then debug exceptions from Secure EL0 are also enabled.
                </li>
                <li>
                  Otherwise, debug exceptions from Secure EL0 are enabled only if the value of <a href="AArch64-sder32_el3.html">SDER32_EL3</a>.SUIDEN is 1.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0">
                Bits [13:11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TDOSA">TDOSA, bit [10]
              </h4>
              <p>Trap debug OS-related register access. Traps EL2 and EL1 System register accesses to the powerdown debug registers to EL3:</p>
            <table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2 and EL1 System register accesses to the powerdown debug registers are trapped to EL3, unless it is trapped by <a href="AArch32-hdcr.html">HDCR</a>.TDOSA or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA.</p>
                </td></tr></table>
              <p>The registers for which accesses are trapped are as follows:</p>
            
              <p>AArch64: <a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a>, <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>.</p>
            
              <p>AArch32: <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, <a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgosdlr.html">DBGOSDLR</a>, <a href="AArch32-dbgprcr.html">DBGPRCR</a>.</p>
            
              <p>AArch64 and AArch32: Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="TDA">TDA, bit [9]
              </h4>
              <p>Trap Debug Access. Traps EL2, EL1, and EL0 System register accesses to those debug System registers that cannot be trapped using the MDCR_EL3.TDOSA field. When MDCR_EL3.TDA is:</p>
            <table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL0, EL1, and EL2 accesses to the debug registers, other than the registers that can be trapped by MDCR_EL3.TDOSA, are trapped to EL3, from both Security states and both Execution states, unless it is trapped by <a href="AArch32-dbgdscrext.html">DBGDSCRext</a>.UDCCdis, <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, <a href="AArch32-hdcr.html">HDCR</a>.TDA or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA.</p>
                </td></tr></table>
              <p>Traps of AArch32 accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> are ignored in Debug state.</p>
            
              <p>Traps of AArch64 accesses to <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a> are ignored in Debug state.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0">
                Bits [8:7]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TPM">TPM, bit [6]
              </h4>
              <p>Trap Performance Monitors accesses. Traps EL2, EL1, and EL0 accesses to all Performance Monitors registers to EL3, from both Security states and both Execution states.</p>
            <table class="valuetable"><tr><th>TPM</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2, EL1, and EL0 System register accesses to all Performance Monitors registers are trapped to EL3, unless it is trapped by <a href="AArch32-hdcr.html">HDCR</a>.TPM or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TPM.</p>
                </td></tr></table>
              <p>If the Performance Monitors Extension is not implemented, this field is <span class="arm-defined-word">RES0</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0">
                Bits [5:0]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <div class="access_mechanisms"><h2>Accessing the MDCR_EL3</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRS with the following syntax:</p><p class="asm-code">MRS  &lt;Xt&gt;, &lt;systemreg&gt;</p></div><div class="access_instruction"><p>This register can be written using MSR (register) with the following syntax:</p><p class="asm-code">MSR  &lt;systemreg&gt;, &lt;Xt&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;systemreg&gt;
      </th><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>MDCR_EL3</td><td>11</td><td>110</td><td>0001</td><td>0011</td><td>001</td></tr></table></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th class="accessibility_control" colspan="3">
            Control
          </th><th colspan="4">
          Accessibility
        </th></tr><tr><th class="accessibility_control">E2H</th><th class="accessibility_control">TGE</th><th class="accessibility_control">NS</th><th>EL0</th><th>EL1</th><th>EL2</th><th>EL3</th></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        -
      </td><td>
        -
      </td><td>RW</td></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>
        -
      </td><td>RW</td></tr></table><p><p>This table applies to all instructions that can access this register.</p></p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 16:41</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
