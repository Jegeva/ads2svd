<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SCTLR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">SCTLR, System Control Register</h1><p>The SCTLR characteristics are:</p><h2>Purpose</h2>
          <p>Provides the top level control of the system, including its memory system.</p>
        <p>This 
        register
       is part of the Other system control registers functional group.</p><h2>Configuration</h2><p>AArch32 System register SCTLR
                is architecturally mapped to
              AArch64 System register <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.
          </p>
          <p>When EL3 is using AArch32, write access to SCTLR(S) is disabled when the CP15SDISABLE signal is asserted HIGH.</p>
        
          <p>Some bits in the register are read-only. These bits relate to non-configurable features of an implementation, and are provided for compatibility with previous versions of the architecture.</p>
        <p>
                Some or all RW fields of this register have defined reset values. 
                
        These apply
      
                only if the PE resets into an Exception level that is using AArch32. 
                If the PE resets into EL3 using AArch32 they apply only to the Secure instance of the register. 
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>SCTLR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The SCTLR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">0</td><td class="lr" colspan="1"><a href="#TE">TE</a></td><td class="lr" colspan="1"><a href="#AFE">AFE</a></td><td class="lr" colspan="1"><a href="#TRE">TRE</a></td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#EE">EE</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#SPAN">SPAN</a></td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="1"><a href="#UWXN">UWXN</a></td><td class="lr" colspan="1"><a href="#WXN">WXN</a></td><td class="lr" colspan="1"><a href="#nTWE">nTWE</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#nTWI">nTWI</a></td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#V">V</a></td><td class="lr" colspan="1"><a href="#I">I</a></td><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#SED">SED</a></td><td class="lr" colspan="1"><a href="#ITD">ITD</a></td><td class="lr" colspan="1"><a href="#UNK">UNK</a></td><td class="lr" colspan="1"><a href="#CP15BEN">CP15BEN</a></td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="1"><a href="#C">C</a></td><td class="lr" colspan="1"><a href="#A">A</a></td><td class="lr" colspan="1"><a href="#M">M</a></td></tr></tbody></table><h4 id="0">
                Bit [31]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TE">TE, bit [30]
              </h4>
              <p>T32 Exception Enable. This bit controls whether exceptions to an Exception Level that is executing at PL1 are taken to A32 or T32 state:</p>
            <table class="valuetable"><tr><th>TE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Exceptions, including reset, taken to A32 state.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Exceptions, including reset, taken to T32 state.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice between:</p><ul><li><span class="binarynumber">0</span>.</li><li>A value determined by an input configuration signal.</li></ul><h4 id="AFE">AFE, bit [29]
              </h4>
              <p>Access Flag Enable. When using the Short-descriptor translation table format for the PL1&amp;0 translation regime, this bit enables use of the AP[0] bit in the translation descriptors as the Access flag, and restricts access permissions in the translation descriptors to the simplified model. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>AFE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>In the translation table descriptors, AP[0] is an access permissions bit. The full range of access permissions is supported. No Access flag is implemented.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>In the translation table descriptors, AP[0] is the Access flag. Only the simplified model for access permissions is supported.</p>
                </td></tr></table>
              <p>When using the Long-descriptor translation table format, the VMSA behaves as if this bit is set to 1, regardless of the value of this bit.</p>
            
              <p>The AFE bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TRE">TRE, bit [28]
              </h4>
              <p>TEX remap enable. This bit enables remapping of the TEX[2:1] bits in the PL1&amp;0 translation regime for use as two translation table bits that can be managed by the operating system. Enabling this remapping also changes the scheme used to describe the memory region attributes in the VMSA. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>TRE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>TEX remap disabled. TEX[2:0] are used, with the C and B bits, to describe the memory region attributes.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>TEX remap enabled. TEX[2:1] are reassigned for use as bits managed by the operating system. The TEX[0], C, and B bits are used to describe the memory region attributes, with the MMU remap registers.</p>
                </td></tr></table>
              <p>When the value of <a href="AArch32-ttbcr.html">TTBCR</a>.EAE is 1, this bit is <span class="arm-defined-word">RES1</span>.</p>
            
              <p>The TRE bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="0">
                Bits [27:26]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="EE">EE, bit [25]
              </h4>
              <p>The value of the PSTATE.E bit on branch to an exception vector or coming out of reset, and the endianness of stage 1 translation table walks in the PL1&amp;0 translation regime.</p>
            
              <p>The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Little-endian. PSTATE.E is cleared to 0 on taking an exception or coming out of reset. Stage 1 translation table walks in the PL1&amp;0 translation regime are little-endian.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Big-endian. PSTATE.E is cleared to 0 on taking an exception or coming out of reset. Stage 1 translation table walks in the PL1&amp;0 translation regime are big-endian.</p>
                </td></tr></table>
              <p>If an implementation does not provide Big-endian support for data accesses at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>If an implementation does not provide Little-endian support for data accesses at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice between:</p><ul><li><span class="binarynumber">0</span>.</li><li>A value determined by an input configuration signal.</li></ul><h4 id="0">
                Bit [24]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="SPAN">SPAN, bit [23]
              <font style="font-size:smaller;"><br />
            In 
            ARMv8.1:</font></h4>
              <p>Set Privileged Access Never, on taking an exception to EL1 from either Secure or Non-secure state, or to EL3 from Secure state when EL3 is using AArch32.</p>
            <table class="valuetable"><tr><th>SPAN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-cpsr.html">CPSR</a>.PAN is set to 1 in the following situations:</p>
                
                  <ul>
                    <li>
                      In Non-secure state, on taking an exception to EL1.
                    </li>
                    <li>
                      In Secure state, when EL3 is using AArch64, on taking an exception to EL1.
                    </li>
                    <li>
                      In Secure state, when EL3 is using AArch32, on taking an exception to EL3.
                    </li>
                  </ul>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The value of <a href="AArch32-cpsr.html">CPSR</a>.PAN is left unchanged on taking an exception.</p>
                </td></tr></table><h4 id="1"><font style="font-size:smaller;"><br />
            In 
            ARMv8.0:</font></h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="1">
                Bit [22]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bit [21]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="UWXN">UWXN, bit [20]
              </h4>
              <p>Unprivileged write permission implies PL1 XN (Execute-never). This bit can force all memory regions that are writable at PL0 to be treated as XN for accesses from software executing at PL1. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>UWXN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on memory access permissions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any region that is writable at PL0 forced to XN for accesses from software executing at PL1.</p>
                </td></tr></table>
              <p>The UWXN bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="WXN">WXN, bit [19]
              </h4>
              <p>Write permission implies XN (Execute-never). For the PL1&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on memory access permissions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any region that is writable in the PL1&amp;0 translation regime is forced to XN for accesses from software executing at PL1 or PL0.</p>
                </td></tr></table>
              <p>The WXN bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="nTWE">nTWE, bit [18]
              </h4>
              <p>Traps EL0 execution of WFE instructions to Undefined mode.</p>
            <table class="valuetable"><tr><th>nTWE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Any attempt to execute a WFE instruction at EL0 is trapped to Undefined mode, if the instruction would otherwise have caused the PE to enter a low-power state.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table>
              <p>The attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">1</span>.</p><h4 id="0">
                Bit [17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="nTWI">nTWI, bit [16]
              </h4>
              <p>Traps EL0 execution of WFI instructions to Undefined mode.</p>
            <table class="valuetable"><tr><th>nTWI</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Any attempt to execute a WFI instruction at EL0 is trapped to Undefined mode, if the instruction would otherwise have caused the PE to enter a low-power state.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr></table>
              <p>The attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">1</span>.</p><h4 id="0">
                Bits [15:14]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="V">V, bit [13]
              </h4>
              <p>Vectors bit. This bit selects the base address of the exception vectors for exceptions taken to a PE mode other than Monitor mode or Hyp mode:</p>
            <table class="valuetable"><tr><th>V</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Normal exception vectors. Base address is held in <a href="AArch32-vbar.html">VBAR</a>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>High exception vectors (Hivecs), base address <span class="hexnumber">0xFFFF0000</span>. This base address cannot be remapped.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice between:</p><ul><li><span class="binarynumber">0</span>.</li><li>A value determined by an input configuration signal.</li></ul><h4 id="I">I, bit [12]
              </h4>
              <p>Instruction access Cacheability control, for accesses at EL1 and EL0:</p>
            <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All instruction access to Normal memory from PL1 and PL0 are Non-cacheable for all levels of instruction and unified cache.</p>
                
                  <p>If the value of SCTLR.M is 0, instruction accesses from stage 1 of the PL1&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>All instruction access to Normal memory from PL1 and PL0 can be cached at all levels of instruction and unified cache.</p>
                
                  <p>If the value of SCTLR.M is 0, instruction accesses from stage 1 of the PL1&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p>
                </td></tr></table>
              <p>Instruction accesses to Normal memory from Non-secure EL1 and Non-secure EL0 are Cacheable regardless of the value of the SCTLR.I bit if either:</p>
            
              <ul>
                <li>
                  EL2 is using AArch32 and the value of <a href="AArch32-hcr.html">HCR</a>.DC is 1.
                </li>
                <li>
                  EL2 is using AArch64 and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.DC is 1.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="1">
                Bit [11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [10:9]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="SED">SED, bit [8]
              </h4>
              <p>SETEND instruction disable. Disables SETEND instructions at PL0 and PL1.</p>
            <table class="valuetable"><tr><th>SED</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>SETEND instruction execution is enabled at PL0 and PL1.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>SETEND instructions are <span class="arm-defined-word">UNDEFINED</span> at PL0 and PL1.</p>
                </td></tr></table>
              <p>If the implementation does not support mixed-endian operation at any Exception level, this bit is <span class="arm-defined-word">RES1</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">0</span>.</p><h4 id="ITD">ITD, bit [7]
              </h4>
              <p>IT Disable. Disables some uses of IT instructions at PL1 and PL0.</p>
            <table class="valuetable"><tr><th>ITD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All IT instruction functionality is enabled at PL1 and PL0.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any attempt at PL1 or PL0 to execute any of the following is <span class="arm-defined-word">UNDEFINED</span>:</p>
                
                  <ul>
                    <li>
                      All encodings of the IT instruction with hw1[3:0]!=1000.
                    </li>
                    <li>
                      All encodings of the subsequent instruction with the following values for hw1:<dl><dt><span class="binarynumber">11xxxxxxxxxxxxxx</span></dt><dd>All 32-bit instructions, and the 16-bit instructions B, UDF, SVC, LDM, and STM.</dd><dt><span class="binarynumber">1011xxxxxxxxxxxx</span></dt><dd>All instructions in <span class="xref">'Miscellaneous 16-bit instructions' in the ARMv8 ARM, section F3.2.5</span>.</dd><dt><span class="binarynumber">10100xxxxxxxxxxx</span></dt><dd>ADD Rd, PC, #imm </dd><dt><span class="binarynumber">01001xxxxxxxxxxx</span></dt><dd>LDR Rd, [PC, #imm]</dd><dt><span class="binarynumber">0100x1xxx1111xxx</span></dt><dd>ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.</dd><dt><span class="binarynumber">010001xx1xxxx111</span></dt><dd>ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. This pattern also covers <span class="arm-defined-word">UNPREDICTABLE</span> cases with BLX Rn.</dd></dl>
                    </li>
                  </ul>
                
                  <p>These instructions are always <span class="arm-defined-word">UNDEFINED</span>, regardless of whether they would pass or fail the condition code check that applies to them as a result of being in an IT block.</p>
                
                  <p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the IT instruction is treated as:</p>
                
                  <ul>
                    <li>
                      A 16-bit instruction, that can only be followed by another 16-bit instruction.
                    </li>
                    <li>
                      The first half of a 32-bit instruction.
                    </li>
                  </ul>
                
                  <p>This means that, for the situations that are <span class="arm-defined-word">UNDEFINED</span>, either the second 16-bit instruction or the 32-bit instruction is <span class="arm-defined-word">UNDEFINED</span>.</p>
                
                  <p>An implementation might vary dynamically as to whether IT is treated as a 16-bit instruction or the first half of a 32-bit instruction.</p>
                </td></tr></table>
              <p>If an instruction in an active IT block that would be disabled by this field sets this field to 1 then behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>. For more information see <span class="xref">'Changes to an ITD control by an instruction in an IT block' in the ARMv8 ARM, section E1.2.4</span>.</p>
            
              <p>ITD is optional, but if it is implemented in the SCTLR then it must also be implemented in the <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>. If it is not implemented then this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">0</span>.</p><h4 id="UNK">UNK, bit [6]
              </h4>
              <p>Writes to this bit are IGNORED. Reads of this bit return an <span class="arm-defined-word">UNKNOWN</span> value.</p>
            <h4 id="CP15BEN">CP15BEN, bit [5]
              </h4>
              <p>System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==<span class="binarynumber">1111</span>) encoding space from PL1 and PL0:</p>
            <table class="valuetable"><tr><th>CP15BEN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>PL0 and PL1 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is <span class="arm-defined-word">UNDEFINED</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>PL0 and PL1 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is enabled.</p>
                </td></tr></table>
              <p>CP15BEN is optional, but if it is implemented in the SCTLR then it must also be implemented in the <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>. If it is not implemented then this bit is RAO/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">1</span>.</p><h4 id="1">
                Bits [4:3]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="C">C, bit [2]
              </h4>
              <p>Cacheability control, for data accesses at EL1 and EL0:</p>
            <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All data access to Normal memory from PL1 and PL0, and all accesses to the PL1&amp;0 stage 1 translation tables, are Non-cacheable for all levels of data and unified cache.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>All data access to Normal memory from PL1 and PL0, and all accesses to the PL1&amp;0 stage 1 translation tables, can be cached at all levels of data and unified cache.</p>
                </td></tr></table>
              <p>The PE ignores SCLTR.C for Non-secure state and data accesses to Normal memory from EL1 and EL0 are Cacheable if either:</p>
            
              <ul>
                <li>
                  EL2 is using AArch32 and the value of <a href="AArch32-hcr.html">HCR</a>.DC is 1.
                </li>
                <li>
                  EL2 is using AArch64 and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.DC is 1.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="A">A, bit [1]
              </h4>
              <p>Alignment check enable. This is the enable bit for Alignment fault checking at PL1 and PL0:</p>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Alignment fault checking disabled when executing at PL1 or PL0.</p>
                
                  <p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Alignment fault checking enabled when executing at PL1 or PL0.</p>
                
                  <p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p>
                </td></tr></table>
              <p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="M">M, bit [0]
              </h4>
              <p>MMU enable for EL1 and EL0 stage 1 address translation. Possible values of this bit are:</p>
            <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL1 and EL0 stage 1 address translation disabled.</p>
                
                  <p>See the SCTLR.I field for the behavior of instruction accesses to Normal memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL1 and EL0 stage 1 address translation enabled.</p>
                </td></tr></table>
              <p>In the Non-secure state the PE behaves as if the value of the SCTLR.M field is 0 for all purposes other than returning the value of a direct read of the field if either:</p>
            
              <ul>
                <li>
                  EL2 is using AArch32 and the value of <a href="AArch32-hcr.html">HCR</a>.{DC, TGE} is not {0, 0}.
                </li>
                <li>
                  EL2 is using AArch64 and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{DC, TGE} is not {0, 0}.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><div class="access_mechanisms"><h2>Accessing the SCTLR</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRC with the following syntax:</p><p class="asm-code">MRC  &lt;syntax&gt;</p></div><div class="access_instruction"><p>This register can be written using MCR with the following syntax:</p><p class="asm-code">MCR  &lt;syntax&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;syntax&gt;
      </th><th>opc1</th><th>opc2</th><th>CRn</th><th>coproc</th><th>CRm</th></tr><tr><td>p15, 0, 
                &lt;Rt&gt;, c1, c0, 0</td><td>000</td><td>000</td><td>0001</td><td>1111</td><td>0000</td></tr></table><ul></ul></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th rowspan="2">Configuration</th><th class="accessibility_control" colspan="3">
            Control
          </th><th colspan="4">
          Accessibility
        </th><th rowspan="2">Instance</th></tr><tr><th class="accessibility_control">E2H</th><th class="accessibility_control">TGE</th><th class="accessibility_control">NS</th><th>EL0</th><th>EL1</th><th>EL2</th><th>EL3</th></tr><tr><td>
            EL3 not implemented
          </td><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>RW</td><td>
        n/a
      </td><td>
        n/a
      </td><td>SCTLR</td></tr><tr><td>
            EL3 not implemented
          </td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>RW</td><td>RW</td><td>
        n/a
      </td><td>SCTLR</td></tr><tr><td>
            EL3 not implemented
          </td><td class="accessibility_control">x</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>
        n/a
      </td><td>SCTLR</td></tr><tr><td>
            EL3 using AArch64</td><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>RW</td><td>
        n/a
      </td><td>
        n/a
      </td><td>SCTLR</td></tr><tr><td>
            EL3 using AArch64</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>RW</td><td>RW</td><td>
        n/a
      </td><td>SCTLR</td></tr><tr><td>
            EL3 using AArch64</td><td class="accessibility_control">x</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>
        n/a
      </td><td>SCTLR</td></tr><tr><td>
            EL3 using AArch32</td><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>
        n/a
      </td><td>
        n/a
      </td><td>RW</td><td>SCTLR_s</td></tr><tr><td>
            EL3 using AArch32</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>RW</td><td>RW</td><td>RW</td><td>SCTLR_ns</td></tr><tr><td>
            EL3 using AArch32</td><td class="accessibility_control">x</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>RW</td><td>SCTLR_ns</td></tr></table><p><p>This table applies to all instructions that can access this register.</p></p>
            <p>When EL3 is using AArch32, write access to SCTLR_s is <span class="arm-defined-word">UNDEFINED</span> when the CP15SDISABLE signal is asserted HIGH.</p>
          <h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when 
            accessing this register.
          </p></div><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; HCR_EL2.E2H==0
        :
      </p><ul><li><p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TVM==1, Non-secure write accesses to this register from EL1 are trapped to EL2.</p></li><li><p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TRVM==1, Non-secure read accesses to this register from EL1 are trapped to EL2.</p></li><li><p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T1==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; HCR_EL2.E2H==1 &amp;&amp; HCR_EL2.TGE==0
        :
      </p><ul><li><p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TVM==1, Non-secure write accesses to this register from EL1 are trapped to EL2.</p></li><li><p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TRVM==1, Non-secure read accesses to this register from EL1 are trapped to EL2.</p></li><li><p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T1==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch32
        and
        SCR_EL3.NS==1
        :
      </p><ul><li><p>If <a href="AArch32-hcr.html">HCR</a>.TVM==1, Non-secure write accesses to this register from EL1 are trapped to Hyp mode.</p></li><li><p>If <a href="AArch32-hcr.html">HCR</a>.TRVM==1, Non-secure read accesses to this register from EL1 are trapped to Hyp mode.</p></li><li><p>If <a href="AArch32-hstr.html">HSTR</a>.T1==1, Non-secure accesses to this register from EL1 are trapped to Hyp mode.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 16:41</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
