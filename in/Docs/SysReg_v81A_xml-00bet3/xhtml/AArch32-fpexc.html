<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>FPEXC</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">FPEXC, Floating-Point Exception Control register</h1><p>The FPEXC characteristics are:</p><h2>Purpose</h2>
          <p>Provides a global enable for the implemented Advanced SIMD and floating-point functionality, and reports floating-point status information.</p>
        <p>This 
        register
       is part of the Floating-point registers functional group.</p><h2>Configuration</h2>
        <p>There is one instance of this register that is used in both Secure and Non-secure states.</p>
      <p>AArch32 System register FPEXC
                is architecturally mapped to
              AArch64 System register <a href="AArch64-fpexc32_el2.html">FPEXC32_EL2</a>.
          </p>
          <p>Implemented only if the implementation includes the Advanced SIMD and floating-point functionality.</p>
        <p>
                Some or all RW fields of this register have defined reset values. 
                
        These apply
      
                  only if the PE resets into an Exception level that is using AArch32.
                
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>FPEXC is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The FPEXC bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#EX">EX</a></td><td class="lr" colspan="1"><a href="#EN">EN</a></td><td class="lr" colspan="1"><a href="#DEX">DEX</a></td><td class="lr" colspan="1"><a href="#FP2V">FP2V</a></td><td class="lr" colspan="1"><a href="#VV">VV</a></td><td class="lr" colspan="1"><a href="#TFV">TFV</a></td><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="3"><a href="#VECITR">VECITR</a></td><td class="lr" colspan="1"><a href="#IDF">IDF</a></td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#IXF">IXF</a></td><td class="lr" colspan="1"><a href="#UFF">UFF</a></td><td class="lr" colspan="1"><a href="#OFF">OFF</a></td><td class="lr" colspan="1"><a href="#DZF">DZF</a></td><td class="lr" colspan="1"><a href="#IOF">IOF</a></td></tr></tbody></table><h4 id="EX">EX, bit [31]
              </h4>
              <p>Exception bit. In ARMv8, this bit is RAZ/WI.</p>
            <h4 id="EN">EN, bit [30]
              </h4>
              <p>Enables access to the Advanced SIMD and floating-point functionality from all Exception levels, except that setting this field to 0 does not disable the following:</p>
            
              <ul>
                <li>
                  VMSR accesses to the <a href="AArch32-fpexc.html">FPEXC</a> or <a href="AArch32-fpsid.html">FPSID</a>.
                </li>
                <li>
                  VMRS accesses from the <a href="AArch32-fpexc.html">FPEXC</a>, <a href="AArch32-fpsid.html">FPSID</a>, <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a>, or <a href="AArch32-mvfr2.html">MVFR2</a>.
                </li>
              </ul>
            <table class="valuetable"><tr><th>EN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Accesses to the <a href="AArch32-fpscr.html">FPSCR</a>, and any of the SIMD and floating-point registers Q0-Q15, including their views as D0-D31 registers or S0-S31 registers, are <span class="arm-defined-word">UNDEFINED</span> at all Exception levels.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>This control permits access to the Advanced SIMD and floating-point functionality at all Exception levels.</p>
                </td></tr></table>
              <p>Execution of floating-point and Advanced SIMD instructions in AArch32 state can be disabled or trapped by the following controls:</p>
            
              <ul>
                <li>
                  <a href="AArch32-cpacr.html">CPACR</a>.cp10, or, if executing at EL0, <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN.
                </li>
                <li>
                  FPEXC.EN.
                </li>
                <li>
                  If executing in Non-secure state:<ul><li><a href="AArch32-hcptr.html">HCPTR</a>.TCP10, or if EL2 is using AArch64, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP.</li><li><a href="AArch32-nsacr.html">NSACR</a>.cp10, or if EL3 is using AArch64, <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TFP.</li></ul>
                </li>
                <li>
                  For Advanced SIMD instructions only:<ul><li>CPACR.ASEDIS.</li><li>If executing in Non-secure state, <a href="AArch32-hcptr.html">HCPTR</a>.TASE and <a href="AArch32-nsacr.html">NSACR</a>.NSTRCDIS.</li></ul>
                </li>
              </ul>
            
              <p>See the descriptions of the controls for more information.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>When executing at EL0 using AArch32:</p>
                <ul>
                  <li>
                    If EL1 is using AArch64 then behavior is as if the value of FPEXC.EN is 1.
                  </li>
                  <li>
                    In Non-secure state, if EL2 is using AArch64 and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{RW, TGE} is {1, 1} then behavior is as if the value of FPEXC.EN is 1.
                  </li>
                  <li>
                    In Non-secure state, if EL2 is using AArch64 and the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{RW, TGE} is {0, 1} then it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the behavior is:<ul><li> As if the value of FPEXC.EN is 1.</li><li>Determined by the value of FPEXC.EN, as described in this field description. However, ARM deprecates using the value of FPEXC.EN to determine behavior.</li></ul>
                  </li>
                </ul>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="DEX">DEX, bit [29]
              </h4>
              <p>Defined synchronous exception on floating-point execution.</p>
            
              <p>This field identifies whether a synchronous exception generated by the attempted execution of an instruction was generated by an unallocated encoding. The instruction must be in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr() returning TRUE. This field also indicates whether the FPEXC.TFV field is valid.</p>
            
              <p>The meaning of this bit is:</p>
            <table class="valuetable"><tr><th>DEX</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The exception was generated by the attempted execution of an unallocated instruction in the encoding space that is identified by the pseudocode function ExecutingCP10or11Instr(). If FPEXC.TFV is RW then it is invalid and <span class="arm-defined-word">UNKNOWN</span>. If FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} are RW then they are invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The exception was generated during the execution of an unallocated encoding. FPEXC.TFV is valid and indicates the cause of the exception.</p>
                </td></tr></table>
              <p>On an exception that sets this bit to 1 the exception-handling routine must clear this bit to 0.</p>
            
              <p>On an implementation that both does not support trapping of floating-point exceptions and implements the <a href="AArch32-fpscr.html">FPSCR</a>.{Stride, Len} fields as RAZ, this bit is <span class="arm-defined-word">RES0</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="FP2V">FP2V, bit [28]
              </h4>
              <p>FPINST2 instruction valid bit. In ARMv8, this bit is <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="VV">VV, bit [27]
              </h4>
              <p>VECITR valid bit. In ARMv8, this bit is <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TFV">TFV, bit [26]
              </h4>
              <p>Trapped Fault Valid bit. Valid only when the value of FPEXC.DEX is 1. When valid, it indicates the cause of the exception and therefore whether the FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} bits are valid.</p>
            <table class="valuetable"><tr><th>TFV</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The exception was caused by the execution of a floating-point VABS, VADD, VDIV, VFMA, VFMS, VFNMA, VFNMS, VMLA, VMLS, VMOV, VMUL, VNEG, VNMLA, VNMLS, VNMUL, VSQRT, or VSUB instruction when one or both of <a href="AArch32-fpscr.html">FPSCR</a>.{Stride, Len} was non-zero. If the FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} bits are RW then they are invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} indicate the presence of trapped floating-point exceptions that had occurred at the time of the exception. Bits are set for all trapped exceptions that had occurred at the time of the exception.</p>
                </td></tr></table>
              <p>This bit returns a status value and ignores writes.</p>
            
              <p>When the value of FPEXC.DEX is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            
              <p>On an implementation that supports the trapping of floating-point exceptions and implements <a href="AArch32-fpscr.html">FPSCR</a>.{Stride, Len} as RAZ, this bit is RAO/WI.</p>
            <h4 id="0">
                Bits [25:11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="VECITR">VECITR, bits [10:8]
                  </h4>
              <p>Vector iteration count. In ARMv8, this field is <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="IDF">IDF, bit [7]
              </h4>
              <p>Input Denormal trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Input Denormal exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.IDE was 1:</p>
            <table class="valuetable"><tr><th>IDF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Input denormal exception has not occurred.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Input denormal exception has occurred.</p>
                </td></tr></table>
              <p>Input Denormal exceptions can occur only when <a href="AArch32-fpscr.html">FPSCR</a>.FZ is 1.</p>
            
              <p>This bit must be cleared to 0 by the exception-handling routine.</p>
            
              <p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0">
                Bits [6:5]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="IXF">IXF, bit [4]
              </h4>
              <p>Inexact trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Inexact exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.IXE was 1:</p>
            <table class="valuetable"><tr><th>IXF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Inexact exception has not occurred.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Inexact exception has occurred.</p>
                </td></tr></table>
              <p>This bit must be cleared to 0 by the exception-handling routine.</p>
            
              <p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="UFF">UFF, bit [3]
              </h4>
              <p>Underflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Underflow exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.UFE was 1:</p>
            <table class="valuetable"><tr><th>UFF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Underflow exception has not occurred.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Underflow exception has occurred.</p>
                </td></tr></table>
              <p>Underflow trapped exceptions can occur only when <a href="AArch32-fpscr.html">FPSCR</a>.FZ is 0.</p>
            
              <p>This bit must be cleared to 0 by the exception-handling routine.</p>
            
              <p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="OFF">OFF, bit [2]
              </h4>
              <p>Overflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Overflow exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.OFE was 1:</p>
            <table class="valuetable"><tr><th>OFF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Overflow exception has not occurred.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Overflow exception has occurred.</p>
                </td></tr></table>
              <p>This bit must be cleared to 0 by the exception-handling routine.</p>
            
              <p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="DZF">DZF, bit [1]
              </h4>
              <p>Divide by Zero trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether a Divide by Zero exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.DZE was 1:</p>
            <table class="valuetable"><tr><th>DZF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Divide by Zero exception has not occurred.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Divide by Zero exception has occurred.</p>
                </td></tr></table>
              <p>This bit must be cleared to 0 by the exception-handling routine.</p>
            
              <p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="IOF">IOF, bit [0]
              </h4>
              <p>Invalid Operation trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Invalid Operation exception occurred while <a href="AArch32-fpscr.html">FPSCR</a>.IOE was 1:</p>
            <table class="valuetable"><tr><th>IOF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Invalid Operation exception has not occurred.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Invalid Operation exception has occurred.</p>
                </td></tr></table>
              <p>This bit must be cleared to 0 by the exception-handling routine.</p>
            
              <p>When the value of FPEXC.TFV is 0 and this bit is RW, this bit is invalid and <span class="arm-defined-word">UNKNOWN</span>.</p>
            
              <p>On an implementation that does not support the trapping of floating-point exceptions this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><div class="access_mechanisms"><h2>Accessing the FPEXC</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using VMRS with the following syntax:</p><p class="asm-code">VMRS  &lt;Rt&gt;, &lt;spec_reg&gt;</p></div><div class="access_instruction"><p>This register can be written using VMSR with the following syntax:</p><p class="asm-code">VMSR  &lt;spec_reg&gt;, &lt;Rt&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;spec_reg&gt;
      </th><th>reg</th></tr><tr><td>FPEXC</td><td>1000</td></tr></table></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th class="accessibility_control" colspan="3">
            Control
          </th><th colspan="4">
          Accessibility
        </th></tr><tr><th class="accessibility_control">E2H</th><th class="accessibility_control">TGE</th><th class="accessibility_control">NS</th><th>EL0</th><th>EL1</th><th>EL2</th><th>EL3</th></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>RW</td><td>
        n/a
      </td><td>RW</td></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>RW</td><td>RW</td><td>RW</td></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>RW</td></tr></table><p><p>This table applies to all instructions that can access this register.</p></p><h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when 
            accessing this register.
          </p></div><p>
        When
        HCR_EL2.E2H==0
        :
      </p><ul><li><p>If <a href="AArch32-cpacr.html">CPACR</a>.cp10==00, accesses to this register from PL1 are <span class="arm-defined-word">UNDEFINED</span>.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; HCR_EL2.E2H==0
        :
      </p><ul><li><p>If <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; HCR_EL2.E2H==1 &amp;&amp; HCR_EL2.TGE==0
        :
      </p><ul><li><p>If <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.FPEN==00, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li><li><p>If <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.FPEN==10, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch32
        and
        SCR_EL3.NS==1
        :
      </p><ul><li><p>If <a href="AArch32-hcptr.html">HCPTR</a>.TCP10==1, Non-secure accesses to this register from EL1 are trapped to Hyp mode.</p></li><li><p>If <a href="AArch32-hcptr.html">HCPTR</a>.TCP10==1, Non-secure accesses to this register from EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p></li></ul><p>
        When
        EL3 is implemented and is using AArch32
        and
        SCR_EL3.NS==1
        :
      </p><ul><li><p>If <a href="AArch32-nsacr.html">NSACR</a>.cp10==0, Non-secure accesses to this register from EL1 and EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p></li></ul><p>
        When
        EL3 is implemented and is using AArch64
        :
      </p><ul><li><p>If <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TFP==1, accesses to this register from EL1 and EL2 are trapped to EL3.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 16:41</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
