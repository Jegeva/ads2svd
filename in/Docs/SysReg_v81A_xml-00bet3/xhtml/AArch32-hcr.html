<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>HCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">HCR, Hyp Configuration Register</h1><p>The HCR characteristics are:</p><h2>Purpose</h2>
          <p>Provides configuration controls for virtualization, including defining whether various Non-secure operations are trapped to Hyp mode.</p>
        <p>This 
        register
       is part of the Virtualization registers functional group.</p><h2>Configuration</h2><p>AArch32 System register HCR
                is architecturally mapped to
              AArch64 System register <a href="AArch64-hcr_el2.html">HCR_EL2[31:0]
        </a>.
          </p>
          <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>
        <p>
                Some or all RW fields of this register have defined reset values. 
                
        These apply
      
                only if the PE resets into EL2
                
                  with EL2 using AArch32,
                
                or into
                
                    EL3 with EL3 using AArch32.
                  
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>HCR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The HCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">0</td><td class="lr" colspan="1"><a href="#TRVM">TRVM</a></td><td class="lr" colspan="1"><a href="#HCD">HCD</a></td><td class="lr">0</td><td class="lr" colspan="1"><a href="#TGE">TGE</a></td><td class="lr" colspan="1"><a href="#TVM">TVM</a></td><td class="lr" colspan="1"><a href="#TTLB">TTLB</a></td><td class="lr" colspan="1"><a href="#TPU">TPU</a></td><td class="lr" colspan="1"><a href="#TPC">TPC</a></td><td class="lr" colspan="1"><a href="#TSW">TSW</a></td><td class="lr" colspan="1"><a href="#TAC">TAC</a></td><td class="lr" colspan="1"><a href="#TIDCP">TIDCP</a></td><td class="lr" colspan="1"><a href="#TSC">TSC</a></td><td class="lr" colspan="1"><a href="#TID3">TID3</a></td><td class="lr" colspan="1"><a href="#TID2">TID2</a></td><td class="lr" colspan="1"><a href="#TID1">TID1</a></td><td class="lr" colspan="1"><a href="#TID0">TID0</a></td><td class="lr" colspan="1"><a href="#TWE">TWE</a></td><td class="lr" colspan="1"><a href="#TWI">TWI</a></td><td class="lr" colspan="1"><a href="#DC">DC</a></td><td class="lr" colspan="2"><a href="#BSU">BSU</a></td><td class="lr" colspan="1"><a href="#FB">FB</a></td><td class="lr" colspan="1"><a href="#VA">VA</a></td><td class="lr" colspan="1"><a href="#VI">VI</a></td><td class="lr" colspan="1"><a href="#VF">VF</a></td><td class="lr" colspan="1"><a href="#AMO">AMO</a></td><td class="lr" colspan="1"><a href="#IMO">IMO</a></td><td class="lr" colspan="1"><a href="#FMO">FMO</a></td><td class="lr" colspan="1"><a href="#PTW">PTW</a></td><td class="lr" colspan="1"><a href="#SWIO">SWIO</a></td><td class="lr" colspan="1"><a href="#VM">VM</a></td></tr></tbody></table><h4 id="0">
                Bit [31]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TRVM">TRVM, bit [30]
              </h4>
              <p>Trap Reads of Virtual Memory controls. Traps Non-secure EL1 reads of the virtual memory control registers to Hyp mode. The registers for which read accesses are trapped are as follows:</p>
            
              <p><a href="AArch32-sctlr.html">SCTLR</a>, <a href="AArch32-ttbr0.html">TTBR0</a>, <a href="AArch32-ttbr1.html">TTBR1</a>, <a href="AArch32-ttbcr.html">TTBCR</a>, <a href="AArch32-dacr.html">DACR</a>, <a href="AArch32-dfsr.html">DFSR</a>, <a href="AArch32-ifsr.html">IFSR</a>, <a href="AArch32-dfar.html">DFAR</a>, <a href="AArch32-ifar.html">IFAR</a>, <a href="AArch32-adfsr.html">ADFSR</a>, <a href="AArch32-aifsr.html">AIFSR</a>, <a href="AArch32-prrr.html">PRRR</a>, <a href="AArch32-nmrr.html">NMRR</a>, <a href="AArch32-mair0.html">MAIR0</a>, <a href="AArch32-mair1.html">MAIR1</a>, <a href="AArch32-amair0.html">AMAIR0</a>, <a href="AArch32-amair1.html">AMAIR1</a>, <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p>
            <table class="valuetable"><tr><th>TRVM</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1 read accesses to the specified Virtual Memory controls are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="HCD">HCD, bit [29]
              </h4>
              <p>HVC instruction disable. Disables Non-secure state execution of HVC instructions.</p>
            <table class="valuetable"><tr><th>HCD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>HVC instruction execution is enabled at EL2 and Non-secure EL1.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>HVC instructions are <span class="arm-defined-word">UNDEFINED</span> at EL2 and Non-secure EL1. The Undefined Instruction exception is taken to the Exception level at which the HVC instruction is executed.</p>
                </td></tr></table>
              <div class="note"><span class="note-header">Note</span>
                <p>HVC instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p>
              </div>
            
              <p>This bit is only implemented if EL3 is not implemented. Otherwise, it is <span class="arm-defined-word">RES0</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">0</span>.</p><h4 id="0">
                Bit [28]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TGE">TGE, bit [27]
              </h4>
              <p>Trap General Exceptions, from Non-secure EL0.</p>
            <table class="valuetable"><tr><th>TGE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on execution at EL0.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>When the value of <a href="AArch32-scr-s.html">SCR</a>.NS is 0, this control has no effect on execution at EL0.</p>
                
                  <p>When the value of <a href="AArch32-scr-s.html">SCR</a>.NS is 1, then:</p>
                
                  <ul>
                    <li>
                      All exceptions that would be routed to EL1 are routed to EL2.
                    </li>
                    <li>
                      The <a href="AArch32-sctlr.html">SCTLR</a>.M bit is treated as being 0 for all purposes other than returning the result of a direct read of <a href="AArch32-sctlr.html">SCTLR</a>.
                    </li>
                    <li>
                      The HCR.{FMO, IMO, AMO} bits are treated as being 1 for all purposes other than returning the result of a direct read of HCR.
                    </li>
                    <li>
                      All virtual interrupts are disabled.
                    </li>
                    <li>
                      Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> mechanisms for signaling virtual interrupts are disabled.
                    </li>
                    <li>
                      An exception return to EL1 is treated as an illegal exception return.
                    </li>
                    <li>
                      Monitor mode execution of an MSR or CPS instruction that changes <a href="AArch32-cpsr.html">CPSR</a>.M to a Non-secure EL1 mode is an illegal change to PSTATE.M. For more information see <span class="xref">'Illegal changes to PSTATE.M' in the ARMv8 ARM, section G1 (The AArch32 System Level Programmers' Model)</span>.
                    </li>
                  </ul>
                </td></tr></table>
              <p>Also, when HCR.TGE is 1:</p>
            
              <ul>
                <li>
                  If EL3 is using AArch32, an attempt to change from a Secure PL1 mode to a Non-secure EL1 mode by changing <a href="AArch32-scr-s.html">SCR</a>.NS from 0 to 1 results in <a href="AArch32-scr-s.html">SCR</a>.NS remaining as 0.
                </li>
                <li>
                  The <a href="AArch32-hdcr.html">HDCR</a>.{TDRA, TDOSA, TDA, TDE} bits are ignored and treated as being 1 other than for the purpose of a direct read of <a href="AArch32-hdcr.html">HDCR</a>.
                </li>
              </ul>
            
              <p>In the following cases the field resets to 0:</p>
            
              <ul>
                <li>
                  The PE resets into EL3 with EL3 using AArch32.
                </li>
                <li>
                  The PE resets into EL2 with EL2 using AArch32.
                </li>
              </ul>
            
              <p>Otherwise, the field reset value is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TVM">TVM, bit [26]
              </h4>
              <p>Trap Virtual Memory controls. Traps Non-secure EL1 writes to the virtual memory control registers to Hyp mode. The registers for which write accesses are trapped are as follows:</p>
            
              <p><a href="AArch32-sctlr.html">SCTLR</a>, <a href="AArch32-ttbr0.html">TTBR0</a>, <a href="AArch32-ttbr1.html">TTBR1</a>, <a href="AArch32-ttbcr.html">TTBCR</a>, <a href="AArch32-dacr.html">DACR</a>, <a href="AArch32-dfsr.html">DFSR</a>, <a href="AArch32-ifsr.html">IFSR</a>, <a href="AArch32-dfar.html">DFAR</a>, <a href="AArch32-ifar.html">IFAR</a>, <a href="AArch32-adfsr.html">ADFSR</a>, <a href="AArch32-aifsr.html">AIFSR</a>, <a href="AArch32-prrr.html">PRRR</a>, <a href="AArch32-nmrr.html">NMRR</a>, <a href="AArch32-mair0.html">MAIR0</a>, <a href="AArch32-mair1.html">MAIR1</a>, <a href="AArch32-amair0.html">AMAIR0</a>, <a href="AArch32-amair1.html">AMAIR1</a>, <a href="AArch32-contextidr.html">CONTEXTIDR</a>.</p>
            <table class="valuetable"><tr><th>TVM</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1 write accesses to EL1 virtual memory control registers are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TTLB">TTLB, bit [25]
              </h4>
              <p>Trap TLB maintenance instructions. Traps Non-secure EL1 execution of a TLBI instruction to Hyp mode. This applies to the following instructions:</p>
            
              <p><a href="AArch32-tlbiallis.html">TLBIALLIS</a>, <a href="AArch32-tlbimvais.html">TLBIMVAIS</a>, <a href="AArch32-tlbiasidis.html">TLBIASIDIS</a>, <a href="AArch32-tlbimvaais.html">TLBIMVAAIS</a>, <a href="AArch32-tlbimvalis.html">TLBIMVALIS</a>, <a href="AArch32-tlbimvaalis.html">TLBIMVAALIS</a>, <a href="AArch32-itlbiall.html">ITLBIALL</a>, <a href="AArch32-itlbimva.html">ITLBIMVA</a>, <a href="AArch32-itlbiasid.html">ITLBIASID</a>, <a href="AArch32-dtlbiall.html">DTLBIALL</a>, <a href="AArch32-dtlbimva.html">DTLBIMVA</a>, <a href="AArch32-dtlbiasid.html">DTLBIASID</a>, <a href="AArch32-tlbiall.html">TLBIALL</a>, <a href="AArch32-tlbimva.html">TLBIMVA</a>, <a href="AArch32-tlbiasid.html">TLBIASID</a>, <a href="AArch32-tlbimvaa.html">TLBIMVAA</a>, <a href="AArch32-tlbimval.html">TLBIMVAL</a>, <a href="AArch32-tlbimvaal.html">TLBIMVAAL</a></p>
            <table class="valuetable"><tr><th>TTLB</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1 accesses to TLB maintenance instructions are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TPU">TPU, bit [24]
              </h4>
              <p>Trap cache maintenance instructions that operate to the Point of Unification. Traps Non-secure EL1 execution of those cache maintenance instructions to Hyp mode. This applies to the following instructions:</p>
            
              <p><a href="AArch32-icimvau.html">ICIMVAU</a>, <a href="AArch32-iciallu.html">ICIALLU</a>, <a href="AArch32-icialluis.html">ICIALLUIS</a>, <a href="AArch32-dccmvau.html">DCCMVAU</a>.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>An Undefined Instruction exception generated at EL0 is higher priority than this trap to EL2, and these instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p>
              </div>
            <table class="valuetable"><tr><th>TPU</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1 execution of the specified instructions is trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TPC">TPC, bit [23]
              </h4>
              <p>Trap data or unified cache maintenance instructions that operate to the Point of Coherency. Traps Non-secure EL1 execution of those cache maintenance instructions to Hyp mode. This applies to the following instructions:</p>
            
              <p><a href="AArch32-dcimvac.html">DCIMVAC</a>, <a href="AArch32-dccimvac.html">DCCIMVAC</a>, <a href="AArch32-dccmvac.html">DCCMVAC</a>.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>An Undefined Instruction exception generated at EL0 is higher priority than this trap to EL2, and these instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p>
              </div>
            <table class="valuetable"><tr><th>TPC</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure execution of the specified instructions is trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TSW">TSW, bit [22]
              </h4>
              <p>Trap data or unified cache maintenance instructions that operate by Set/Way. Traps Non-secure EL1 execution of those cache maintenance instructions by set/way to Hyp mode. This applies to the following instructions:</p>
            
              <p><a href="AArch32-dcisw.html">DCISW</a>, <a href="AArch32-dccsw.html">DCCSW</a>, <a href="AArch32-dccisw.html">DCCISW</a>.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>An Undefined Instruction exception generated at EL0 is higher priority than this trap to EL2, and these instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0.</p>
              </div>
            <table class="valuetable"><tr><th>TSW</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure execution of the specified instructions is trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TAC">TAC, bit [21]
              </h4>
              <p>Trap Auxiliary Control Registers. Traps Non-secure EL1 accesses to the Auxiliary Control Registers to Hyp mode, from both Execution states. This applies to the following register accesses:</p>
            
              <p><a href="AArch32-actlr.html">ACTLR</a> and, if implemented, <a href="AArch32-actlr2.html">ACTLR2</a>.</p>
            <table class="valuetable"><tr><th>TAC</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1 accesses to the specified registers are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TIDCP">TIDCP, bit [20]
              </h4>
              <p>Trap <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality. Traps Non-secure EL1 accesses to the encodings for <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> System Registers to Hyp mode.</p>
            
              <p>MCR and MRC instructions accessing the following encodings:</p>
            
              <ul>
                <li>
                  All coproc==p15, CRn==c9, Opcode1 = {0-7}, CRm == {c0-c2, c5-c8}, opcode2 == {0-7}.
                </li>
                <li>
                  All coproc==p15, CRn==c10, Opcode1 =={0-7}, CRm == {c0, c1, c4, c8}, opcode2 == {0-7}.
                </li>
                <li>
                  All coproc==p15, CRn==c11, Opcode1=={0-7}, CRm == {c0-c8, c15}, opcode2 == {0-7}.
                </li>
              </ul>
            
              <p>When HCR.TIDCP is set to 1, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether any of this functionality accessed from Non-secure EL0 is trapped to Hyp mode. If it is not, it is <span class="arm-defined-word">UNDEFINED</span>, and the PE takes an Undefined Instruction exception to Non-secure Undefined mode.</p>
            <table class="valuetable"><tr><th>TIDCP</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1 accesses to the specified System register encodings for <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TSC">TSC, bit [19]
              </h4>
              <p>Trap SMC instructions. Traps Non-secure EL1 execution of SMC instructions to Hyp mode.</p>
            <table class="valuetable"><tr><th>TSC</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any attempt to execute an SMC instruction at Non-secure EL1 is trapped to Hyp mode, regardless of the value of <a href="AArch32-scr-s.html">SCR</a>.SCD.</p>
                </td></tr></table>
              <p>The ARMv8-A architecture permits, but does not require, this trap to apply to conditional SMC instructions that fail their condition code check, in the same way as with traps on other conditional instructions.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <ul>
                  <li>
                    This trap is only implemented if the implementation includes EL3.
                  </li>
                  <li>
                    SMC instructions are always <span class="arm-defined-word">UNDEFINED</span> at PL0.
                  </li>
                  <li>
                    This bit traps execution of the SMC instruction. It is not a routing control for the SMC exception. Hyp Trap exceptions and SMC exceptions have different preferred return addresses.
                  </li>
                </ul>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TID3">TID3, bit [18]
              </h4>
              <p>Trap ID group 3. Traps Non-secure EL1 reads of the following registers to Hyp mode:</p>
            
              <p><a href="AArch32-id_pfr0.html">ID_PFR0</a>, <a href="AArch32-id_pfr1.html">ID_PFR1</a>, <a href="AArch32-id_dfr0.html">ID_DFR0</a>, <a href="AArch32-id_afr0.html">ID_AFR0</a>, <a href="AArch32-id_mmfr0.html">ID_MMFR0</a>, <a href="AArch32-id_mmfr1.html">ID_MMFR1</a>, <a href="AArch32-id_mmfr2.html">ID_MMFR2</a>, <a href="AArch32-id_mmfr3.html">ID_MMFR3</a>, <a href="AArch32-id_isar0.html">ID_ISAR0</a>, <a href="AArch32-id_isar1.html">ID_ISAR1</a>, <a href="AArch32-id_isar2.html">ID_ISAR2</a>, <a href="AArch32-id_isar3.html">ID_ISAR3</a>, <a href="AArch32-id_isar4.html">ID_ISAR4</a>, <a href="AArch32-id_isar5.html">ID_ISAR5</a>, <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a>, <a href="AArch32-mvfr2.html">MVFR2</a>, and <a href="AArch32-id_mmfr4.html">ID_MMFR4</a>, except that if <a href="AArch32-id_mmfr4.html">ID_MMFR4</a> is implemented as RAZ/WI then it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch32-id_mmfr4.html">ID_MMFR4</a> are trapped.</p>
            
              <p> Also an MRC access to any of the following encodings:</p>
            
              <ul>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == {c3-c7}, opc2 == {0,1}.
                </li>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == c3, opc2 == 2.
                </li>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == c5, opc2 == {4,5}.
                </li>
              </ul>
            
              <p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit traps MRC accesses to the following encodings:</p>
            
              <ul>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == c2, opc2 == 7.
                </li>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == c3, opc2 == {3-7}.
                </li>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == {c4, c6, c7}, opc2 == {2-7}.
                </li>
                <li>
                  coproc==p15, opc1 == 0, CRn == c0, CRm == c5, opc2 == {2, 3, 6, 7}.
                </li>
              </ul>
            <table class="valuetable"><tr><th>TID3</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The specified Non-secure EL1 read accesses to ID group 3 registers are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TID2">TID2, bit [17]
              </h4>
              <p>Trap ID group 2. Traps the following register accesses to Hyp mode:</p>
            
              <ul>
                <li>
                  Non-secure EL1 and EL0 reads of the <a href="AArch32-ctr.html">CTR</a>, <a href="AArch32-ccsidr.html">CCSIDR</a>, <a href="AArch32-clidr.html">CLIDR</a>, and <a href="AArch32-csselr.html">CSSELR</a>.
                </li>
                <li>
                  Non-secure EL1 and EL0 writes to the <a href="AArch32-csselr.html">CSSELR</a>.
                </li>
              </ul>
            <table class="valuetable"><tr><th>TID2</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The specified Non-secure EL1 and EL0 accesses to ID group 2 registers are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TID1">TID1, bit [16]
              </h4>
              <p>Trap ID group 1. Traps Non-secure EL1 reads of the following registers to Hyp mode:</p>
            
              <p><a href="AArch32-tcmtr.html">TCMTR</a>, <a href="AArch32-tlbtr.html">TLBTR</a>, <a href="AArch32-revidr.html">REVIDR</a>, <a href="AArch32-aidr.html">AIDR</a>.</p>
            <table class="valuetable"><tr><th>TID1</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The specified Non-secure EL1 read accesses to ID group 1 registers are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TID0">TID0, bit [15]
              </h4>
              <p>Trap ID group 0. Traps the following register accesses to Hyp mode:</p>
            
              <ul>
                <li>
                  Non-secure EL1 reads of the <a href="AArch32-jidr.html">JIDR</a> and <a href="AArch32-fpsid.html">FPSID</a>.
                </li>
                <li>
                  If the <a href="AArch32-jidr.html">JIDR</a> is RAZ from Non-secure EL0, Non-secure EL0 reads of the <a href="AArch32-jidr.html">JIDR</a>.
                </li>
              </ul>
            
              <div class="note"><span class="note-header">Note</span>
                <ul>
                  <li>
                    It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the <a href="AArch32-jidr.html">JIDR</a> is RAZ or <span class="arm-defined-word">UNDEFINED</span> at EL0. If it is <span class="arm-defined-word">UNDEFINED</span> at EL0 then the Undefined Instruction exception takes precedence over this trap.
                  </li>
                  <li>
                    The <a href="AArch32-fpsid.html">FPSID</a> is not accessible at EL0.
                  </li>
                  <li>
                    Writes to the <a href="AArch32-fpsid.html">FPSID</a> are ignored, and not trapped by this control.
                  </li>
                </ul>
              </div>
            <table class="valuetable"><tr><th>TID0</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The specified Non-secure EL1 read accesses to ID group 0 registers are trapped to Hyp mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TWE">TWE, bit [14]
              </h4>
              <p>Traps Non-secure EL0 and EL1 execution of WFE instructions to Hyp mode:</p>
            <table class="valuetable"><tr><th>TWE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any attempt to execute a WFE instruction at Non-secure EL0 or EL1 is trapped to Hyp mode, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWE.</p>
                </td></tr></table>
              <p>The attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>Since a WFE can complete at any time, even without a Wakeup event, the traps on WFE are not guaranteed to be taken, even if the WFE is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TWI">TWI, bit [13]
              </h4>
              <p>Traps Non-secure EL0 and EL1 execution of WFI instructions to Hyp mode.</p>
            <table class="valuetable"><tr><th>TWI</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control does not cause any instructions to be trapped.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any attempt to execute a WFI instruction at Non-secure EL0 or EL1 is trapped to Hyp mode, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWI.</p>
                </td></tr></table>
              <p>The attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>Since a WFI can complete at any time, even without a Wakeup event, the traps on WFI are not guaranteed to be taken, even if the WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p>
              </div>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="DC">DC, bit [12]
              </h4>
              <p>Default Cacheability.</p>
            <table class="valuetable"><tr><th>DC</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on the Non-secure EL1&amp;0 translation regime.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>In Non-secure state:</p>
                
                  <ul>
                    <li>
                      The <a href="AArch32-sctlr.html">SCTLR</a>.M field behaves as 0 for all purposes other than a direct read of the value of the field.
                    </li>
                    <li>
                      The HCR.VM field behaves as 1 for all purposes other than a direct read of the value of the field.
                    </li>
                    <li>
                      The memory type produced by the first stage of the EL1&amp;0 translation regime is Normal Non-Shareable, Inner Write-Back Read-Allocate Write-Allocate, Outer Write-Back Read-Allocate Write-Allocate.
                    </li>
                  </ul>
                </td></tr></table>
              <p>This field has no effect on the EL2 and EL3 translation regimes.</p>
            
              <p>This field is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="BSU">BSU, bits [11:10]
                  </h4>
              <p>Barrier Shareability upgrade. This field determines the minimum shareability domain that is applied to any barrier instruction executed from Non-secure EL1 or Non-secure EL0:</p>
            <table class="valuetable"><tr><th>BSU</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>No effect</p>
                </td></tr><tr><td class="bitfield">01</td><td>
                  <p>Inner Shareable</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>Outer Shareable</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>Full system</p>
                </td></tr></table>
              <p>This value is combined with the specified level of the barrier held in its instruction, using the same principles as combining the shareability attributes from two stages of address translation.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="FB">FB, bit [9]
              </h4>
              <p>Force broadcast. Causes the following instructions to be broadcast within the Inner Shareable domain when executed from Non-secure EL1:</p>
            
              <p><a href="AArch32-bpiall.html">BPIALL</a>, <a href="AArch32-tlbiall.html">TLBIALL</a>, <a href="AArch32-tlbimva.html">TLBIMVA</a>, <a href="AArch32-tlbiasid.html">TLBIASID</a>, <a href="AArch32-dtlbiall.html">DTLBIALL</a>, <a href="AArch32-dtlbimva.html">DTLBIMVA</a>, <a href="AArch32-dtlbiasid.html">DTLBIASID</a>, <a href="AArch32-itlbiall.html">ITLBIALL</a>, <a href="AArch32-itlbimva.html">ITLBIMVA</a>, <a href="AArch32-itlbiasid.html">ITLBIASID</a>, <a href="AArch32-tlbimvaa.html">TLBIMVAA</a>, <a href="AArch32-iciallu.html">ICIALLU</a>, <a href="AArch32-tlbimval.html">TLBIMVAL</a>, <a href="AArch32-tlbimvaal.html">TLBIMVAAL</a>.</p>
            <table class="valuetable"><tr><th>FB</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This field has no effect on the operation of the specified instructions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>When one of the specified instruction is executed at Non-secure EL1, the instruction is broadcast within the Inner Shareable shareability domain.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="VA">VA, bit [8]
              </h4>
              <p>Virtual SError interrupt exception. </p>
            <table class="valuetable"><tr><th>VA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This mechanism is not making a virtual SError interrupt pending.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>A virtual SError interrupt is pending because of this mechanism.</p>
                </td></tr></table>
              <p>The virtual SError interrupt is enabled only when the value of HCR.{TGE, AMO} is {0, 1}.</p>
            
              <p>The Guest OS cannot distinguish the virtual exception from the corresponding physical exception.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="VI">VI, bit [7]
              </h4>
              <p>Virtual IRQ exception. </p>
            <table class="valuetable"><tr><th>VI</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This mechanism is not making a virtual IRQ pending.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>A virtual IRQ is pending because of this mechanism.</p>
                </td></tr></table>
              <p>The virtual IRQ is enabled only when the value of HCR.{TGE, IMO} is {0, 1}.</p>
            
              <p>The Guest OS cannot distinguish the virtual exception from the corresponding physical exception.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="VF">VF, bit [6]
              </h4>
              <p>Virtual FIQ exception.</p>
            <table class="valuetable"><tr><th>VF</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This mechanism is not making a virtual FIQ pending.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>A virtual FIQ is pending because of this mechanism.</p>
                </td></tr></table>
              <p>The virtual FIQ is enabled only when the value of HCR.{TGE, FMO} is {0, 1}.</p>
            
              <p>The Guest OS cannot distinguish the virtual exception from the corresponding physical exception.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="AMO">AMO, bit [5]
              </h4>
              <p>SError interrupt Mask Override. When this bit is set to 1, it overrides the effect of <a href="AArch32-cpsr.html">CPSR</a>.A, and enables virtual exception signaling by the VA bit.</p>
            
              <p>If the value of HCR.TGE is 0, then Virtual SError Interrupts are enabled in Non-secure state.</p>
            
              <p>If the value of HCR.TGE is 1, then in Non-secure state the HCR.AMO bit behaves as 1 for all purposes other than a direct read of the value of the bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="IMO">IMO, bit [4]
              </h4>
              <p>IRQ Mask Override. When this bit is set to 1, it overrides the effect of <a href="AArch32-cpsr.html">CPSR</a>.I, and enables virtual exception signaling by the VI bit.</p>
            
              <p>If the value of HCR.TGE is 0, then Virtual IRQ interrupts are enabled in the Non-secure state.</p>
            
              <p>If the value of HCR.TGE is 1, then in Non-secure state the HCR.IMO bit behaves as 1 for all purposes other than a direct read of the value of the bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="FMO">FMO, bit [3]
              </h4>
              <p>FIQ Mask Override. When this bit is set to 1, it overrides the effect of <a href="AArch32-cpsr.html">CPSR</a>.F, and enables virtual exception signaling by the VF bit.</p>
            
              <p>If the value of HCR.TGE is 0, then Virtual FIQ interrupts are enabled in the Non-secure state.</p>
            
              <p>If the value of HCR.TGE is 1, then in Non-secure state the HCR.FMO bit behaves as 1 for all purposes other than a direct read of the value of the bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="PTW">PTW, bit [2]
              </h4>
              <p>Protected Table Walk. In the Non-secure PL1&amp;0 translation regime, a translation table access made as part of a stage 1 translation table walk is subject to a stage 2 translation. The combining of the memory type attributes from the two stages of translation means the access might be made to a type of Device memory. If this occurs then the value of this bit determines the behavior:</p>
            <table class="valuetable"><tr><th>PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The translation table walk occurs as if it is to Normal Non-cacheable memory. This means it can be made speculatively.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The memory access generates a stage 2 Permission fault.</p>
                </td></tr></table>
              <p>This field is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="SWIO">SWIO, bit [1]
              </h4>
              <p>Set/Way Invalidation Override. Causes Non-secure EL1 execution of the data cache invalidate by set/way instructions to perform a data cache clean and invalidate by set/way.</p>
            <table class="valuetable"><tr><th>SWIO</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on the operation of data cache invalidate by set/way instructions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Data cache invalidate by set/way instructions perform a data cache clean and invalidate by set/way.</p>
                </td></tr></table>
              <p>When this bit is set to 1, <a href="AArch32-dcisw.html">DCISW</a> performs the same invalidation as a <a href="AArch32-dccisw.html">DCCISW</a> instruction.</p>
            
              <p>As a result of changes to the behavior of <a href="AArch32-dcisw.html">DCISW</a>, this bit is redundant in ARMv8. This bit can be implemented as <span class="arm-defined-word">RES1</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to <span class="binarynumber">0</span>.</p><h4 id="VM">VM, bit [0]
              </h4>
              <p>Virtualization enable. Enables stage 2 address translation for the Non-secure EL1&amp;0 translation regime. Possible values of this bit are:</p>
            <table class="valuetable"><tr><th>VM</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Non-secure EL1&amp;0 stage 2 address translation disabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Non-secure EL1&amp;0 stage 2 address translation enabled.</p>
                </td></tr></table>
              <p>If the HCR.DC bit is set to 1, then the behavior of the PE when executing in a Non-secure mode other than Hyp mode is consistent with HCR.VM being 1, regardless of the actual value of HCR.VM, other than the value returned by an explicit read of HCR.VM.</p>
            
              <p>When the value of this bit is 1, data cache invalidate instructions executed at Non-secure EL1 perform a data cache clean and invalidate. For the invalidate by set/way instruction this behavior applies regardless of the value of the HCR.SWIO bit.</p>
            
              <p>This bit is permitted to be cached in a TLB.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><div class="access_mechanisms"><h2>Accessing the HCR</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRC with the following syntax:</p><p class="asm-code">MRC  &lt;syntax&gt;</p></div><div class="access_instruction"><p>This register can be written using MCR with the following syntax:</p><p class="asm-code">MCR  &lt;syntax&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;syntax&gt;
      </th><th>opc1</th><th>opc2</th><th>CRn</th><th>coproc</th><th>CRm</th></tr><tr><td>p15, 4, 
                &lt;Rt&gt;, c1, c1, 0</td><td>100</td><td>000</td><td>0001</td><td>1111</td><td>0001</td></tr></table><ul></ul></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th class="accessibility_control" colspan="3">
            Control
          </th><th colspan="4">
          Accessibility
        </th></tr><tr><th class="accessibility_control">E2H</th><th class="accessibility_control">TGE</th><th class="accessibility_control">NS</th><th>EL0</th><th>EL1</th><th>EL2</th><th>EL3</th></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td>
        -
      </td><td>
        -
      </td><td>
        n/a
      </td><td>
        -
      </td></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        -
      </td><td>RW</td><td>RW</td></tr><tr><td class="accessibility_control">x</td><td class="accessibility_control">1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td><td>RW</td></tr></table><p><p>This table applies to all instructions that can access this register.</p></p><h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when 
            accessing this register.
          </p></div><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; HCR_EL2.E2H==0
        :
      </p><ul><li><p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T1==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch64
        and
        SCR_EL3.NS==1 &amp;&amp; HCR_EL2.E2H==1 &amp;&amp; HCR_EL2.TGE==0
        :
      </p><ul><li><p>If <a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T1==1, Non-secure accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented and is using AArch32
        and
        SCR_EL3.NS==1
        :
      </p><ul><li><p>If <a href="AArch32-hstr.html">HSTR</a>.T1==1, Non-secure accesses to this register from EL1 are trapped to Hyp mode.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">24/03/2017 16:41</p><p class="copyconf">Copyright © 2010-2017 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
