<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>EDSCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">EDSCR, External Debug Status and Control Register</h1><p>The EDSCR characteristics are:</p><h2>Purpose</h2>
          <p>Main control register for the debug implementation.</p>
        <p>This 
        register
       is part of the Debug registers functional group.</p><h2>Usage constraints</h2><p>This register is accessible as follows:</p><table class="register_access"><tr><th>Off</th><th>DLK</th><th>OSLK</th><th>SLK</th><th>Default</th></tr><tr><td>Error</td><td>Error</td><td>Error</td><td>RO</td><td>RW</td></tr></table><h2>Configuration</h2><p>EDSCR is in the Core power domain.
      Some or all RW fields of this register have defined reset values. These apply only on a Cold reset. The register is not affected by a Warm reset and is not affected by an External debug reset.</p><h2>Attributes</h2>
          <p>EDSCR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The EDSCR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="r">0</td><td class="lr" colspan="1"><a href="#RXfull">RXfull</a></td><td class="lr" colspan="1"><a href="#TXfull">TXfull</a></td><td class="lr" colspan="1"><a href="#ITO">ITO</a></td><td class="lr" colspan="1"><a href="#RXO">RXO</a></td><td class="lr" colspan="1"><a href="#TXU">TXU</a></td><td class="lr" colspan="1"><a href="#PipeAdv">PipeAdv</a></td><td class="lr" colspan="1"><a href="#ITE">ITE</a></td><td class="lr" colspan="2"><a href="#INTdis">INTdis</a></td><td class="lr" colspan="1"><a href="#TDA">TDA</a></td><td class="lr" colspan="1"><a href="#MA">MA</a></td><td class="r">0</td><td class="r">1</td><td class="r">0</td><td class="r">1</td><td class="lr" colspan="1"><a href="#HDD">HDD</a></td><td class="lr" colspan="1"><a href="#HDE">HDE</a></td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="2"><a href="#EL">EL</a></td><td class="lr" colspan="1"><a href="#A">A</a></td><td class="lr" colspan="1"><a href="#ERR">ERR</a></td><td class="lr" colspan="6"><a href="#STATUS">STATUS</a></td></tr></tbody></table><h4 id="0">
                Bit [31]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="RXfull">RXfull, bit [30]
              </h4>
              <p>DTRRX full. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TXfull">TXfull, bit [29]
              </h4>
              <p>DTRTX full. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="ITO">ITO, bit [28]
              </h4>
              <p>ITR overrun. This bit is RO.</p>
            
              <p>If the PE is in Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>. ITO is set to 0 on entry to Debug state.</p>
            <h4 id="RXO">RXO, bit [27]
              </h4>
              <p>DTRRX overrun. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TXU">TXU, bit [26]
              </h4>
              <p>DTRTX underrun. This bit is RO.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="PipeAdv">PipeAdv, bit [25]
              </h4>
              <p>Pipeline advance. This bit is RO. Set to 1 every time the PE pipeline retires one or more instructions. Cleared to 0 by a write to <a href="ext-edrcr.html">EDRCR</a>.CSPA.</p>
            
              <p>The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.</p>
            <h4 id="ITE">ITE, bit [24]
              </h4>
              <p>ITR empty. This bit is RO.</p>
            
              <p>If the PE is in Non-debug state, this bit is <span class="arm-defined-word">UNKNOWN</span>. It is always valid in Debug state.</p>
            <h4 id="INTdis">INTdis, bits [23:22]
                  </h4>
              <p>Interrupt disable. Disables taking interrupts (including virtual interrupts, asynchronous Data Abort exceptions, and SError interrupts) in Non-Debug state.</p>
            
              <p>If ExternalInvasiveDebugEnabled() = FALSE, the value of this field is ignored.</p>
            
              <p>If ExternalInvasiveDebugEnabled() = TRUE, the possible values of this field are:</p>
            <table class="valuetable"><tr><th>INTdis</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>Do not disable interrupts.</p>
                </td></tr><tr><td class="bitfield">01</td><td>
                  <p>Disable interrupts taken to EL1.</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>Reserved.</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>Disable interrupts taken to EL1. If ExternalHypInvasiveDebugEnabled() == TRUE, also disable all other interrupts.</p>
                </td></tr></table>
              <p>The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.</p>
            
              <p>If EL2 is not implemented, the value <span class="binarynumber">0b01</span> is reserved. If programmed with a reserved value the PE behaves as if INTdis has been programmed with a defined value, other than for a direct read of EDSCR, and the value returned by a read of EDSCR.INTdis is <span class="arm-defined-word">UNKNOWN</span>.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="TDA">TDA, bit [21]
              </h4>
              <p>Traps accesses to <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>, <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n&gt;</a>, <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n&gt;</a>, <a href="AArch32-dbgwcrn.html">DBGWCR&lt;n&gt;</a>, and <a href="AArch32-dbgwvrn.html">DBGWVR&lt;n&gt;</a>.</p>
            
              <p>The possible values of this field are:</p>
            <table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Accesses to the registers listed above do not generate a Software Access debug event.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Accesses to the registers listed above generate a Software Access debug event, if OSLSR.OSLK is 0 and if halting is allowed.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="MA">MA, bit [20]
              </h4>
              <p>Memory access mode. Controls use of memory-access mode for accessing ITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.</p>
            
              <p>Possible values of this field are:</p>
            <table class="valuetable"><tr><th>MA</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Normal access mode.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Memory access mode.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="0">
                Bit [19]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bit [18]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bit [17]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bit [16]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="HDD">HDD, bit [15]
              </h4>
              <p>Hyp debug disabled. This bit is RO. On entry to Debug state:</p>
            
              <ul>
                <li>
                  If entering Debug state in Hyp mode, this bit is set to 0.
                </li>
                <li>
                  Otherwise, this bit is set to the inverse of ExternalHypInvasiveDebugEnabled().
                </li>
              </ul>
            
              <p>In Debug state, the value of the HDD bit does not change, even if ExternalHypInvasiveDebugEnabled() changes.</p>
            
              <p>In Non-debug state, HDD returns the inverse of ExternalHypInvasiveDebugEnabled(). If the authentication signals that control ExternalHypInvasiveDebugEnabled() change, a context synchronization operation is required to guarantee their effect.</p>
            
              <p>If EL2 is not implemented, this bit is <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="HDE">HDE, bit [14]
              </h4>
              <p>Halting debug enable. The possible values of this field are:</p>
            <table class="valuetable"><tr><th>HDE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Halting disabled for Breakpoint, Watchpoint and Halt Instruction debug events.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Halting enabled for Breakpoint, Watchpoint and Halt Instruction debug events.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="0">
                Bits [13:10]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="EL">EL, bits [9:8]
                  </h4>
              <p>Exception level. Read-only. In Debug state, this gives the current EL of the PE.</p>
            
              <p>In Non-debug state, this field is RAZ.</p>
            <h4 id="A">A, bit [7]
              </h4>
              <p>Asynchronous Data Abort or Serror interrupt pending. Read-only. In Debug state, indicates whether an asynchronous Data Abort or SError interrupt is pending:</p>
            
              <ul>
                <li>
                  If <a href="AArch32-hcr.html">HCR</a>.{AMO, TGE} = {1, 0} and in EL0 or EL1, a virtual asynchronous Data Abort or SError interrupt.
                </li>
                <li>
                  Otherwise, a physical asynchronous Data Abort or SError interrupt.
                </li>
              </ul>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>No asynchronous Data Abort or SError interrupt pending.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Asynchronous Data Abort or SError interrupt pending.</p>
                </td></tr></table>
              <p>A debugger can read EDSCR to check whether an asynchronous Data Abort or SError interrupt is pending without having to execute further instructions. A pending asynchronous Data Abort or SError might indicate data from target memory is corrupted.</p>
            
              <p><span class="arm-defined-word">UNKNOWN</span> in Non-debug state.</p>
            <h4 id="ERR">ERR, bit [6]
              </h4>
              <p>Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="STATUS">STATUS, bits [5:0]
                  </h4>
              <p>Debug status flags. This field is RO.</p>
            
              <p>The possible values of this field are:</p>
            <table class="valuetable"><tr><th>STATUS</th><th>Meaning</th></tr><tr><td class="bitfield">000010</td><td>
                  <p>PE is in Non-debug state.</p>
                </td></tr><tr><td class="bitfield">000001</td><td>
                  <p>PE is restarting, exiting Debug state.</p>
                </td></tr><tr><td class="bitfield">000111</td><td>
                  <p>Breakpoint.</p>
                </td></tr><tr><td class="bitfield">010011</td><td>
                  <p>External debug request.</p>
                </td></tr><tr><td class="bitfield">011011</td><td>
                  <p>Halting step, normal.</p>
                </td></tr><tr><td class="bitfield">011111</td><td>
                  <p>Halting step, exclusive.</p>
                </td></tr><tr><td class="bitfield">100011</td><td>
                  <p>OS Unlock Catch.</p>
                </td></tr><tr><td class="bitfield">100111</td><td>
                  <p>Reset Catch.</p>
                </td></tr><tr><td class="bitfield">101011</td><td>
                  <p>Watchpoint.</p>
                </td></tr><tr><td class="bitfield">101111</td><td>
                  <p>HLT instruction.</p>
                </td></tr><tr><td class="bitfield">110011</td><td>
                  <p>Software access to debug register.</p>
                </td></tr><tr><td class="bitfield">110111</td><td>
                  <p>Exception Catch.</p>
                </td></tr><tr><td class="bitfield">111011</td><td>
                  <p>Halting step, no syndrome.</p>
                </td></tr></table>
              <p>All other values of STATUS are reserved.</p>
            <h2>Accessing the EDSCR</h2><p>EDSCR can be accessed through the external debug interface:</p><table class="info"><tr><th>Component</th><th>Offset</th></tr><tr><td>Debug</td><td>
          <span class="hexnumber">0x088</span>
        </td></tr></table><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">10/08/2016 10:36</p><p class="copyconf">Copyright © 2010-2016 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
