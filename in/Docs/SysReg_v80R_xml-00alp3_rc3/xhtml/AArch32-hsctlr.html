<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>HSCTLR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">HSCTLR, Hyp System Control Register</h1><p>The HSCTLR characteristics are:</p><h2>Purpose</h2>
          <p>Provides top level control of the system operation in Hyp mode.</p>
        <p>This 
        register
       is part of:</p><ul><li>The Virtualization registers functional group.</li><li>The Other system control registers functional group.</li></ul><h2>Configuration</h2><p>
                Some or all RW fields of this register have defined reset values. 
                
        These apply
      
                only if the PE resets into
                
                    EL2.
                  
                Otherwise,
                
                RW fields in this register reset to architecturally <span class="arm-defined-word">UNKNOWN</span> values.
              </p><h2>Attributes</h2>
          <p>HSCTLR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The HSCTLR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="r">0</td><td class="lr" colspan="1"><a href="#TE">TE</a></td><td class="l">1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#EE">EE</a></td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="1"><a href="#FI">FI</a></td><td class="r">0</td><td class="lr" colspan="1"><a href="#WXN">WXN</a></td><td class="r">1</td><td class="lr" colspan="1"><a href="#BR">BR</a></td><td class="r">1</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#I">I</a></td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#SED">SED</a></td><td class="lr" colspan="1"><a href="#ITD">ITD</a></td><td class="r">0</td><td class="lr" colspan="1"><a href="#CP15BEN">CP15BEN</a></td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="1"><a href="#C">C</a></td><td class="lr" colspan="1"><a href="#A">A</a></td><td class="lr" colspan="1"><a href="#M">M</a></td></tr></tbody></table><h4 id="0">
                Bit [31]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="TE">TE, bit [30]
              </h4>
              <p>T32 Exception Enable. This bit controls whether exceptions to EL2 are taken to A32 or T32 state:</p>
            <table class="valuetable"><tr><th>TE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Exceptions, including reset, taken to A32 state.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Exceptions, including reset, taken to T32 state.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="1">
                Bits [29:28]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [27:26]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="EE">EE, bit [25]
              </h4>
              <p>The value of the PSTATE.E bit on entry to Hyp mode.</p>
            
              <p>The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Little-endian. PSTATE.E is cleared to 0 on entry to Hyp mode.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Big-endian. PSTATE.E is set to 1 on entry to Hyp mode.</p>
                </td></tr></table>
              <p>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES0</span>.</p>
            
              <p>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <span class="arm-defined-word">RES1</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><h4 id="0">
                Bit [24]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="1">
                Bits [23:22]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="FI">FI, bit [21]
              </h4>
              <p>Fast Interrupts enable. Permitted values of this bit are:</p>
            <table class="valuetable"><tr><th>FI</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All performance features enabled.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Low interrupt latency configuration. Some performance features disabled.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="0">
                Bit [20]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="WXN">WXN, bit [19]
              </h4>
              <p>Write permission implies XN (Execute-never). For the EL2 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</p>
            <table class="valuetable"><tr><th>WXN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>This control has no effect on memory access permissions.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any region that is writable in the EL2 translation regime is forced to XN for accesses from software executing at EL2.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="1">
                Bit [18]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="BR">BR, bit [17]
              </h4>
              <p>Background Region enable for EL2.</p>
            <table class="valuetable"><tr><th>BR</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL2-controlled MPU background region disabled. Any EL2 transaction that does not match an EL2-controlled MPU region results in a fault.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2-controlled MPU background region enabled. For EL2 transactions that do not match an EL2-controlled MPU region, the EL2 background region attributes are used.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="1">
                Bit [16]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [15:13]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="I">I, bit [12]
              </h4>
              <p>Instruction access Cacheability control, for accesses at EL2:</p>
            <table class="valuetable"><tr><th>I</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All instruction access to Normal memory from EL2 are Non-cacheable for all levels of instruction and unified cache.</p>
                
                  <p>If the value of HSCTLR.M is 0, instruction accesses from stage 1 of the EL2 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>All instruction access to Normal memory from EL2 can be cached at all levels of instruction and unified cache.</p>
                
                  <p>If the value of HSCTLR.M is 0, instruction accesses from stage 1 of the EL2 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</p>
                </td></tr></table>
              <p>This bit has no effect on the EL1&amp;0 translation regime.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="1">
                Bit [11]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="0">
                Bits [10:9]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="SED">SED, bit [8]
              </h4>
              <p>SETEND instruction disable. Disables SETEND instructions at EL2.</p>
            <table class="valuetable"><tr><th>SED</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>SETEND instruction execution is enabled at EL2.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>SETEND instructions are <span class="arm-defined-word">UNDEFINED</span> at EL2.</p>
                </td></tr></table>
              <p>If the implementation does not support mixed-endian operation at EL2, this bit is <span class="arm-defined-word">RES1</span>.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="ITD">ITD, bit [7]
              </h4>
              <p>IT Disable. Disables some uses of IT instructions at EL2.</p>
            <table class="valuetable"><tr><th>ITD</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All IT instruction functionality is enabled at EL2.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Any attempt at EL2 to execute any of the following is <span class="arm-defined-word">UNDEFINED</span>:</p>
                
                  <ul>
                    <li>
                      All encodings of the IT instruction with hw1[3:0]!=1000.
                    </li>
                    <li>
                      All encodings of the subsequent instruction with the following values for hw1:<dl><dt><span class="binarynumber">11xxxxxxxxxxxxxx</span></dt><dd>All 32-bit instructions, and the 16-bit instructions B, UDF, SVC, LDM, and STM.</dd><dt><span class="binarynumber">1011xxxxxxxxxxxx</span></dt><dd>All instructions in <span class="xref">'Miscellaneous 16-bit instructions' in the ARMv8 ARM, section F3.2.5</span>.</dd><dt><span class="binarynumber">10100xxxxxxxxxxx</span></dt><dd>ADD Rd, PC, #imm </dd><dt><span class="binarynumber">01001xxxxxxxxxxx</span></dt><dd>LDR Rd, [PC, #imm]</dd><dt><span class="binarynumber">0100x1xxx1111xxx</span></dt><dd>ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.</dd><dt><span class="binarynumber">010001xx1xxxx111</span></dt><dd>ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. This pattern also covers <span class="arm-defined-word">UNPREDICTABLE</span> cases with BLX Rn.</dd></dl>
                    </li>
                  </ul>
                
                  <p>These instructions are always <span class="arm-defined-word">UNDEFINED</span>, regardless of whether they would pass or fail the condition code check that applies to them as a result of being in an IT block.</p>
                
                  <p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the IT instruction is treated as:</p>
                
                  <ul>
                    <li>
                      A 16-bit instruction, that can only be followed by another 16-bit instruction.
                    </li>
                    <li>
                      The first half of a 32-bit instruction.
                    </li>
                  </ul>
                
                  <p>This means that, for the situations that are <span class="arm-defined-word">UNDEFINED</span>, either the second 16-bit instruction or the 32-bit instruction is <span class="arm-defined-word">UNDEFINED</span>.</p>
                
                  <p>An implementation might vary dynamically as to whether IT is treated as a 16-bit instruction or the first half of a 32-bit instruction.</p>
                </td></tr></table>
              <p>ITD is optional, but if it is implemented in the <a href="AArch32-sctlr.html">SCTLR</a> then it must also be implemented in the HSCTLR. If it is not implemented then this bit is RAZ/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="0">
                Bit [6]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="CP15BEN">CP15BEN, bit [5]
              </h4>
              <p>System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==<span class="binarynumber">1111</span>) encoding space from EL2:</p>
            <table class="valuetable"><tr><th>CP15BEN</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL2 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is <span class="arm-defined-word">UNDEFINED</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2 execution of the <a href="AArch32-cp15dmb.html">CP15DMB</a>, <a href="AArch32-cp15dsb.html">CP15DSB</a>, and <a href="AArch32-cp15isb.html">CP15ISB</a> instructions is enabled.</p>
                </td></tr></table>
              <p>CP15BEN is optional, but if it is implemented in the <a href="AArch32-sctlr.html">SCTLR</a> then it must also be implemented in the HSCTLR. If it is not implemented then this bit is RAO/WI.</p>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="1">
                Bits [4:3]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
            <h4 id="C">C, bit [2]
              </h4>
              <p>Cacheability control, for data accesses at EL2:</p>
            <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>All data accesses to Normal memory from EL2 are Non-cacheable for all levels of data and unified cache.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>All data accesses to Normal memory from EL2 can be cached at all levels of data and unified cache.</p>
                </td></tr></table>
              <p>This bit has no effect on the EL1&amp;0 translation regime.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><h4 id="A">A, bit [1]
              </h4>
              <p>Alignment check enable. This is the enable bit for Alignment fault checking at EL2:</p>
            <table class="valuetable"><tr><th>A</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Alignment fault checking disabled when executing at EL2.</p>
                
                  <p>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element or data elements being accessed.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Alignment fault checking enabled when executing at EL2.</p>
                
                  <p>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element or data elements being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</p>
                </td></tr></table>
              <p>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="M">M, bit [0]
              </h4>
              <p>MPU enable for the EL2-controlled MPU. Possible values of this bit are:</p>
            <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>EL2-controlled MPU disabled.</p>
                
                  <p>See the HSCTLR.I field for the behavior of instruction accesses to Normal memory.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>EL2-controlled MPU enabled.</p>
                </td></tr></table><p>When this register has an architecturally-defined reset value, this field resets to <span class="binarynumber">0</span>.</p><div class="access_mechanisms"><h2>Accessing the HSCTLR</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRC with the following syntax:</p><p class="asm-code">MRC  
    &lt;syntax&gt;</p></div><div class="access_instruction"><p>This register can be written using MCR with the following syntax:</p><p class="asm-code">MCR  
    &lt;syntax&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;syntax&gt;
      </th><th>opc1</th><th>opc2</th><th>CRn</th><th>coproc</th><th>CRm</th></tr><tr><td>p15, 4, 
                &lt;Rt&gt;, c1, c0, 0</td><td>100</td><td>000</td><td>0001</td><td>1111</td><td>0000</td></tr></table><ul></ul></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th rowspan="2">
        &lt;syntax&gt;
      </th><th class="accessibility_control" colspan="1">
          Control
        </th><th colspan="3">
        Accessibility
      </th></tr><tr><th class="accessibility_control">TGE</th><th>EL0</th><th>EL1</th><th>EL2</th></tr><tr><td>p15, 4, 
                &lt;Rt&gt;, c1, c0, 0</td><td class="accessibility_control">0</td><td>
        -
      </td><td>
        -
      </td><td>RW</td></tr><tr><td>p15, 4, 
                &lt;Rt&gt;, c1, c0, 0</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RW</td></tr></table><h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when accessing this register.</p></div><p>
        When
        EL2 is implemented
        :
      </p><ul><li><p>If <a href="AArch32-hstr.html">HSTR</a>.T1==1, accesses to this register from EL1 are trapped to Hyp mode.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">10/08/2016 10:36</p><p class="copyconf">Copyright © 2010-2016 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
