<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ICC_CTLR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">ICC_CTLR, Interrupt Controller Control Register</h1><p>The ICC_CTLR characteristics are:</p><h2>Purpose</h2>
          <p>Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.</p>
        <p>This 
        register
       is part of:</p><ul><li>The GIC system registers functional group.</li><li>The GIC control registers functional group.</li></ul><h2>Configuration</h2><p>There are no configuration notes.</p><h2>Attributes</h2>
          <p>ICC_CTLR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The ICC_CTLR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#A3V">A3V</a></td><td class="lr" colspan="1"><a href="#SEIS">SEIS</a></td><td class="lr" colspan="3"><a href="#IDbits">IDbits</a></td><td class="lr" colspan="3"><a href="#PRIbits">PRIbits</a></td><td class="r">0</td><td class="lr" colspan="1"><a href="#PMHE">PMHE</a></td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr" colspan="1"><a href="#EOImode">EOImode</a></td><td class="lr" colspan="1"><a href="#CBPR">CBPR</a></td></tr></tbody></table><h4 id="0">
                Bits [31:16]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="A3V">A3V, bit [15]
              </h4>
              <p>Affinity 3 Valid. Read-only and writes are ignored. Possible values are:</p>
            <table class="valuetable"><tr><th>A3V</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The CPU interface logic only supports zero values of Affinity 3 in SGI generation System registers.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The CPU interface logic supports non-zero values of Affinity 3 in SGI generation System registers.</p>
                </td></tr></table>
              <p>If EL3 is implemented and using AArch32, this bit is an alias of ICC_MCTLR.A3V.</p>
            
              <p>If EL3 is implemented and using AArch64, this bit is an alias of ICC_CTLR_EL3.A3V.</p>
            <h4 id="SEIS">SEIS, bit [14]
              </h4>
              <p>SEI Support. Read-only and writes are ignored. Indicates whether the CPU interface supports local generation of SEIs:</p>
            <table class="valuetable"><tr><th>SEIS</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>The CPU interface logic does not support local generation of SEIs.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>The CPU interface logic supports local generation of SEIs.</p>
                </td></tr></table>
              <p>If EL3 is implemented and using AArch32, this bit is an alias of ICC_MCTLR.SEIS.</p>
            
              <p>If EL3 is implemented and using AArch64, this bit is an alias of ICC_CTLR_EL3.SEIS.</p>
            <h4 id="IDbits">IDbits, bits [13:11]
                  </h4>
              <p>Identifier bits. Read-only and writes are ignored. The number of physical interrupt identifier bits supported:</p>
            <table class="valuetable"><tr><th>IDbits</th><th>Meaning</th></tr><tr><td class="bitfield">000</td><td>
                  <p>16 bits.</p>
                </td></tr><tr><td class="bitfield">001</td><td>
                  <p>24 bits.</p>
                </td></tr></table>
              <p>All other values are reserved.</p>
            
              <p>If EL3 is implemented and using AArch32, this field is an alias of ICC_MCTLR.IDbits.</p>
            
              <p>If EL3 is implemented and using AArch64, this field is an alias of ICC_CTLR_EL3.IDbits.</p>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="PRIbits">PRIbits, bits [10:8]
                  </h4>
              <p>Priority bits. Read-only and writes are ignored. The number of priority bits implemented, minus one.</p>
            
              <p>An implementation that supports two Security states must implement at least 32 levels of physical priority (5 priority bits).</p>
            
              <p>An implementation that supports only a single Security state must implement at least 16 levels of physical priority (4 priority bits).</p>
            
              <div class="note"><span class="note-header">Note</span>
                <p>This field always returns the number of priority bits implemented, regardless of the Security state of the access or the value of <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS.</p>
              </div>
            
              <p>The division between group priority and subpriority is defined in the binary point registers <a href="AArch32-icc_bpr0.html">ICC_BPR0</a> and <a href="AArch32-icc_bpr1.html">ICC_BPR1</a>.</p>
            
              <p>If EL3 is implemented and using AArch32, physical accesses return the value from ICC_MCTLR.PRIbits.</p>
            
              <p>If EL3 is implemented and using AArch64, physical accesses return the value from ICC_CTLR_EL3.PRIbits.</p>
            
              <p>If EL3 is not implemented, physical accesses return the value from this field.</p>
            <h4 id="0">
                Bit [7]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="PMHE">PMHE, bit [6]
              </h4>
              <p>Priority Mask Hint Enable. Controls whether the priority mask register is used as a hint for interrupt distribution:</p>
            <table class="valuetable"><tr><th>PMHE</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p>Disables use of <a href="AArch32-icc_pmr.html">ICC_PMR</a> as a hint for interrupt distribution.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p>Enables use of <a href="AArch32-icc_pmr.html">ICC_PMR</a> as a hint for interrupt distribution.</p>
                </td></tr></table>
              <p>If EL3 is implemented:</p>
            
              <ul>
                <li>
                  If EL3 is using AArch32, this bit is an alias of ICC_MCTLR.PMHE.
                </li>
                <li>
                  If EL3 is using AArch64, this bit is an alias of ICC_CTLR_EL3.PMHE.
                </li>
                <li>
                  If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 0, this bit is read-only.
                </li>
                <li>
                  If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 1, this bit is read/write.
                </li>
              </ul>
            
              <p>If EL3 is not implemented, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is read-only or read-write:</p>
            
              <ul>
                <li>
                  If this bit is read-only, an implementation can choose to make this field RAZ/WI or RAO/WI.
                </li>
                <li>
                  If this bit is read/write, it resets to zero.
                </li>
              </ul>
            <h4 id="0">
                Bits [5:2]
              </h4>
              <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
            <h4 id="EOImode">EOImode, bit [1]
              </h4>
              <p>EOI mode for the current Security state. Controls whether a write to an End of Interrupt register also deactivates the interrupt:</p>
            <table class="valuetable"><tr><th>EOImode</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide both priority drop and interrupt deactivation functionality. Accesses to <a href="AArch32-icc_dir.html">ICC_DIR</a> are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_eoir0.html">ICC_EOIR0</a> and <a href="AArch32-icc_eoir1.html">ICC_EOIR1</a> provide priority drop functionality only. <a href="AArch32-icc_dir.html">ICC_DIR</a> provides interrupt deactivation functionality.</p>
                </td></tr></table>
              <p>If EL3 is implemented:</p>
            
              <ul>
                <li>
                  If EL3 is using AArch32, this bit is an alias of ICC_MCTLR.EOImode_EL1{S, NS} where S or NS corresponds to the current Security state.
                </li>
                <li>
                  If EL3 is using AArch64, this bit is an alias of ICC_CTLR_EL3.EOImode_EL1{S, NS} where S or NS corresponds to the current Security state.
                </li>
              </ul>
            
              <p>If EL3 is not implemented, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is read-only or read-write:</p>
            
              <ul>
                <li>
                  If this bit is read-only, an implementation can choose to make this field RAZ/WI or RAO/WI.
                </li>
                <li>
                  If this bit is read/write, it resets to zero.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, if this field is implemented as an RW field, it resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><h4 id="CBPR">CBPR, bit [0]
              </h4>
              <p>Common Binary Point Register. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 interrupts:</p>
            <table class="valuetable"><tr><th>CBPR</th><th>Meaning</th></tr><tr><td class="bitfield">0</td><td>
                  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for Group 0 interrupts only.</p>
                
                  <p><a href="AArch32-icc_bpr1.html">ICC_BPR1</a> determines the preemption group for Group 1 interrupts.</p>
                </td></tr><tr><td class="bitfield">1</td><td>
                  <p><a href="AArch32-icc_bpr0.html">ICC_BPR0</a> determines the preemption group for both Group 0 and Group 1 interrupts.</p>
                </td></tr></table>
              <p>If EL3 is implemented:</p>
            
              <ul>
                <li>
                  If EL3 is using AArch32, this bit is an alias of ICC_MCTLR.CBPR_EL1{S,NS} where S or NS corresponds to the current Security state.
                </li>
                <li>
                  If EL3 is using AArch64, this bit is an alias of ICC_CTLR_EL3.CBPR_EL1{S,NS} where S or NS corresponds to the current Security state.
                </li>
                <li>
                  If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 0, this bit is read-only.
                </li>
                <li>
                  If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 1, this bit is read/write.
                </li>
              </ul>
            
              <p>If EL3 is not implemented, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this bit is read-only or read-write:</p>
            
              <ul>
                <li>
                  If this bit is read-only, an implementation can choose to make this field RAZ/WI or RAO/WI.
                </li>
                <li>
                  If this bit is read/write, it resets to zero.
                </li>
              </ul>
            <p>When this register has an architecturally-defined reset value, this field resets to a value that is architecturally <span class="arm-defined-word">UNKNOWN</span>.</p><div class="access_mechanisms"><h2>Accessing the ICC_CTLR</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRC with the following syntax:</p><p class="asm-code">MRC  
    &lt;syntax&gt;</p></div><div class="access_instruction"><p>This register can be written using MCR with the following syntax:</p><p class="asm-code">MCR  
    &lt;syntax&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;syntax&gt;
      </th><th>opc1</th><th>opc2</th><th>CRn</th><th>coproc</th><th>CRm</th></tr><tr><td>p15, 0, 
                &lt;Rt&gt;, c12, c12, 4</td><td>000</td><td>100</td><td>1100</td><td>1111</td><td>1100</td></tr></table><ul></ul></div>
          <p>When <span class="xref">HCR</span>.{FMO, IMO} != {0, 0}, execution of this encoding at Non-secure EL1 results in an access to <a href="AArch32-icv_ctlr.html">ICV_CTLR</a>.</p>
        <h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th rowspan="2">
        &lt;syntax&gt;
      </th><th class="accessibility_control" colspan="3">
          Control
        </th><th colspan="3">
        Accessibility
      </th></tr><tr><th class="accessibility_control">FMO</th><th class="accessibility_control">IMO</th><th class="accessibility_control">TGE</th><th>EL0</th><th>EL1</th><th>EL2</th></tr></table>
            <p>ICC_CTLR is only accessible at Non-secure EL1 when <span class="xref">HCR</span>.{FMO, IMO} == {0, 0}.</p>
          
            <div class="note"><span class="note-header">Note</span>
              <p>When <span class="xref">HCR</span>.{FMO, IMO} != {0, 0}, at Non-secure EL1, the instruction encoding used to access ICC_CTLR results in an access to <a href="AArch32-icv_ctlr.html">ICV_CTLR</a>.</p>
            </div>
          <h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when accessing this register.</p></div><p>
            Not dependent on other configuration bits:
          </p><ul><li><p>If <a href="AArch32-icc_sre.html">ICC_SRE</a>.SRE==0, accesses to this register from EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p></li><li><p>If <a href="AArch32-icc_hsre.html">ICC_HSRE</a>.SRE==0, accesses to this register from EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p></li><li><p>If <a href="AArch32-ich_hcr.html">ICH_HCR</a>.TC==1, accesses to this register from EL1 are trapped to EL2.</p></li></ul><p>
        When
        EL2 is implemented
        :
      </p><ul><li><p>If <a href="AArch32-hstr.html">HSTR</a>.T12==1, accesses to this register from EL1 are trapped to Hyp mode.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">10/08/2016 10:36</p><p class="copyconf">Copyright © 2010-2016 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
