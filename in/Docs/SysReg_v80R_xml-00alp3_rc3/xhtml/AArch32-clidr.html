<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CLIDR</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><hr /><h1 class="register-section">CLIDR, Cache Level ID Register</h1><p>The CLIDR characteristics are:</p><h2>Purpose</h2>
          <p>Identifies the type of cache, or caches, that are implemented at each level and can be managed using the architected cache maintenance instructions that operate by set/way, up to a maximum of seven levels. Also identifies the Level of Coherence (LoC) and Level of Unification (LoU) for the cache hierarchy.</p>
        <p>This 
        register
       is part of the Identification registers functional group.</p><h2>Configuration</h2><p>There are no configuration notes.</p><h2>Attributes</h2>
          <p>CLIDR is a 32-bit register.</p>
        <h2>Field descriptions</h2><p>The CLIDR bit assignments are:</p><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="2"><a href="#ICB">ICB</a></td><td class="lr" colspan="3"><a href="#LoUU">LoUU</a></td><td class="lr" colspan="3"><a href="#LoC">LoC</a></td><td class="lr" colspan="3"><a href="#LoUIS">LoUIS</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype7</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype6</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype5</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype4</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype3</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype2</a></td><td class="lr" colspan="3"><a href="#Ctype">Ctype1</a></td></tr></tbody></table><h4 id="ICB">ICB, bits [31:30]
                  </h4>
              <p>Inner cache boundary. This field indicates the boundary for caching Inner Cacheable memory regions.</p>
            
              <p>The possible values are:</p>
            <table class="valuetable"><tr><th>ICB</th><th>Meaning</th></tr><tr><td class="bitfield">00</td><td>
                  <p>Not disclosed by this mechanism.</p>
                </td></tr><tr><td class="bitfield">01</td><td>
                  <p>L1 cache is the highest Inner Cacheable level.</p>
                </td></tr><tr><td class="bitfield">10</td><td>
                  <p>L2 cache is the highest Inner Cacheable level.</p>
                </td></tr><tr><td class="bitfield">11</td><td>
                  <p>L3 cache is the highest Inner Cacheable level.</p>
                </td></tr></table><h4 id="LoUU">LoUU, bits [29:27]
                  </h4>
              <p>Level of Unification Uniprocessor for the cache hierarchy.</p>
            <h4 id="LoC">LoC, bits [26:24]
                  </h4>
              <p>Level of Coherence for the cache hierarchy.</p>
            <h4 id="LoUIS">LoUIS, bits [23:21]
                  </h4>
              <p>Level of Unification Inner Shareable for the cache hierarchy.</p>
            <h4 id="Ctype">Ctype&lt;n&gt;, bits [3(n-1)+2:3(n-1)], for n = 1 to 7</h4>
              <p>Cache Type fields. Indicate the type of cache that is implemented and can be managed using the architected cache maintenance instructions that operate by set/way at each level, from Level 1 up to a maximum of seven levels of cache hierarchy. Possible values of each field are:</p>
            <table class="valuetable"><tr><th>Ctype&lt;n&gt;</th><th>Meaning</th></tr><tr><td class="bitfield">000</td><td>
                  <p>No cache.</p>
                </td></tr><tr><td class="bitfield">001</td><td>
                  <p>Instruction cache only.</p>
                </td></tr><tr><td class="bitfield">010</td><td>
                  <p>Data cache only.</p>
                </td></tr><tr><td class="bitfield">011</td><td>
                  <p>Separate instruction and data caches.</p>
                </td></tr><tr><td class="bitfield">100</td><td>
                  <p>Unified cache.</p>
                </td></tr></table>
              <p>All other values are reserved.</p>
            
              <p>If software reads the Cache Type fields from Ctype1 upwards, once it has seen a value of 000, no caches that can be managed using the architected cache maintenance instructions that operate by set/way exist at further-out levels of the hierarchy. So, for example, if Ctype3 is the first Cache Type field with a value of 000, the values of Ctype4 to Ctype7 must be ignored.</p>
            <div class="access_mechanisms"><h2>Accessing the CLIDR</h2><div class="access_instructions"><div class="access_instruction"><p>This register can be read using MRC with the following syntax:</p><p class="asm-code">MRC  
    &lt;syntax&gt;</p></div><p>This syntax uses the following encoding in the System instruction encoding space:</p><table class="access_instructions"><tr><th rowspan="1">
        &lt;syntax&gt;
      </th><th>opc1</th><th>opc2</th><th>CRn</th><th>coproc</th><th>CRm</th></tr><tr><td>p15, 1, 
                &lt;Rt&gt;, c0, c0, 1</td><td>001</td><td>001</td><td>0000</td><td>1111</td><td>0000</td></tr></table><ul></ul></div><h3>Accessibility</h3><p>The register is accessible as follows:</p><table class="accessibility"><tr><th rowspan="2">
        &lt;syntax&gt;
      </th><th class="accessibility_control" colspan="1">
          Control
        </th><th colspan="3">
        Accessibility
      </th></tr><tr><th class="accessibility_control">TGE</th><th>EL0</th><th>EL1</th><th>EL2</th></tr><tr><td>p15, 1, 
                &lt;Rt&gt;, c0, c0, 1</td><td class="accessibility_control">0</td><td>
        -
      </td><td>RO</td><td>RO</td></tr><tr><td>p15, 1, 
                &lt;Rt&gt;, c0, c0, 1</td><td class="accessibility_control">1</td><td>
        -
      </td><td>
        n/a
      </td><td>RO</td></tr></table><h3>Traps and enables</h3><div class="traps_intro"><p>For a description of the prioritization of any generated exceptions, see section G1.11.2 (Exception priority order) in the <i>ARM<sup>®</sup> Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile</i> for exceptions taken to AArch32 state, and section D1.13.2 (Synchronous exception prioritization) for exceptions taken to AArch64 state. Subject to the prioritization rules, the following traps and enables are applicable when accessing this register.</p></div><p>
        When
        EL2 is implemented
        :
      </p><ul><li><p>If <a href="AArch32-hcr.html">HCR</a>.TID2==1, read accesses to this register from EL1 are trapped to Hyp mode.</p></li><li><p>If <a href="AArch32-hstr.html">HSTR</a>.T0==1, read accesses to this register from EL1 are trapped to Hyp mode.</p></li></ul></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td></tr></table><p class="versions">10/08/2016 10:36</p><p class="copyconf">Copyright © 2010-2016 ARM Limited or its affiliates. All rights reserved. This document is Confidential.</p></body>
</html>
