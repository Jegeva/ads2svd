<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<boards xmlns="http://com.arm.targetconfigurationeditor" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://com.arm.targetconfigurationeditor ../../Schemas/board-01.xsd">
    <board endianess="little" name="zynq7000_ahb" power_domain_support="Unsupported" trustzone="Supported" type="BOARD">
        <memory name="M_AFI0" offset="0xf8008000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">afi0</gui_name>
            <description language="en">afi0</description>
        </memory>
        <memory name="M_AFI1" offset="0xf8009000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">afi1</gui_name>
            <description language="en">afi1</description>
        </memory>
        <memory name="M_AFI2" offset="0xf800a000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">afi2</gui_name>
            <description language="en">afi2</description>
        </memory>
        <memory name="M_AFI3" offset="0xf800b000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">afi3</gui_name>
            <description language="en">afi3</description>
        </memory>
        <memory name="M_CAN0" offset="0xe0008000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">can0</gui_name>
            <description language="en">can0</description>
        </memory>
        <memory name="M_CAN1" offset="0xe0009000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">can1</gui_name>
            <description language="en">can1</description>
        </memory>
        <memory name="M_DDRC" offset="0xf8006000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">ddrc</gui_name>
            <description language="en">ddrc</description>
        </memory>
        <memory name="M_DEBUG_AXIM" offset="0xf880c000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_axim</gui_name>
            <description language="en">debug_axim</description>
        </memory>
        <memory name="M_DEBUG_CPU_CTI0" offset="0xf8898000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cpu_cti0</gui_name>
            <description language="en">debug_cpu_cti0</description>
        </memory>
        <memory name="M_DEBUG_CPU_CTI1" offset="0xf8899000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cpu_cti1</gui_name>
            <description language="en">debug_cpu_cti1</description>
        </memory>
        <memory name="M_DEBUG_CPU_PMU0" offset="0xf8891000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cpu_pmu0</gui_name>
            <description language="en">debug_cpu_pmu0</description>
        </memory>
        <memory name="M_DEBUG_CPU_PMU1" offset="0xf8893000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cpu_pmu1</gui_name>
            <description language="en">debug_cpu_pmu1</description>
        </memory>
        <memory name="M_DEBUG_CPU_PTM0" offset="0xf889c000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cpu_ptm0</gui_name>
            <description language="en">debug_cpu_ptm0</description>
        </memory>
        <memory name="M_DEBUG_CPU_PTM1" offset="0xf889d000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cpu_ptm1</gui_name>
            <description language="en">debug_cpu_ptm1</description>
        </memory>
        <memory name="M_DEBUG_CTI_AXIM" offset="0xf880a000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cti_axim</gui_name>
            <description language="en">debug_cti_axim</description>
        </memory>
        <memory name="M_DEBUG_CTI_ETB_TPIU" offset="0xf8802000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cti_etb_tpiu</gui_name>
            <description language="en">debug_cti_etb_tpiu</description>
        </memory>
        <memory name="M_DEBUG_CTI_FTM" offset="0xf8809000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_cti_ftm</gui_name>
            <description language="en">debug_cti_ftm</description>
        </memory>
        <memory name="M_DEBUG_DAP_ROM" offset="0xf8800000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_dap_rom</gui_name>
            <description language="en">debug_dap_rom</description>
        </memory>
        <memory name="M_DEBUG_ETB" offset="0xf8801000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_etb</gui_name>
            <description language="en">debug_etb</description>
        </memory>
        <memory name="M_DEBUG_FTM" offset="0xf880b000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_ftm</gui_name>
            <description language="en">debug_ftm</description>
        </memory>
        <memory name="M_DEBUG_FUNNEL" offset="0xf8804000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_funnel</gui_name>
            <description language="en">debug_funnel</description>
        </memory>
        <memory name="M_DEBUG_ITM" offset="0xf8805000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_itm</gui_name>
            <description language="en">debug_itm</description>
        </memory>
        <memory name="M_DEBUG_TPIU" offset="0xf8803000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">debug_tpiu</gui_name>
            <description language="en">debug_tpiu</description>
        </memory>
        <memory name="M_DEVCFG" offset="0xf8007000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">devcfg</gui_name>
            <description language="en">devcfg</description>
        </memory>
        <memory name="M_DMAC0_NS" offset="0xf8004000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">dmac0_ns</gui_name>
            <description language="en">dmac0_ns</description>
        </memory>
        <memory name="M_DMAC0_S" offset="0xf8003000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">dmac0_s</gui_name>
            <description language="en">dmac0_s</description>
        </memory>
        <memory name="M_GEM0" offset="0xe000b000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">gem0</gui_name>
            <description language="en">gem0</description>
        </memory>
        <memory name="M_GEM1" offset="0xe000c000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">gem1</gui_name>
            <description language="en">gem1</description>
        </memory>
        <memory name="M_GPIO" offset="0xe000a000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">gpio</gui_name>
            <description language="en">gpio</description>
        </memory>
        <memory name="M_GPV_QOS301_CPU" offset="0xf8946000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">gpv_qos301_cpu</gui_name>
            <description language="en">gpv_qos301_cpu</description>
        </memory>
        <memory name="M_GPV_QOS301_DMAC" offset="0xf8947000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">gpv_qos301_dmac</gui_name>
            <description language="en">gpv_qos301_dmac</description>
        </memory>
        <memory name="M_GPV_QOS301_IOU" offset="0xf8948000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">gpv_qos301_iou</gui_name>
            <description language="en">gpv_qos301_iou</description>
        </memory>
        <memory name="M_I2C0" offset="0xe0004000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">i2c0</gui_name>
            <description language="en">i2c0</description>
        </memory>
        <memory name="M_I2C1" offset="0xe0005000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">i2c1</gui_name>
            <description language="en">i2c1</description>
        </memory>
        <memory name="M_OCM" offset="0xf800c000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">ocm</gui_name>
            <description language="en">ocm</description>
        </memory>
        <memory name="M_QSPI" offset="0xe000d000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">qspi</gui_name>
            <description language="en">qspi</description>
        </memory>
        <memory name="M_SD0" offset="0xe0100000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">sd0</gui_name>
            <description language="en">sd0</description>
        </memory>
        <memory name="M_SD1" offset="0xe0101000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">sd1</gui_name>
            <description language="en">sd1</description>
        </memory>
        <memory name="M_SLCR" offset="0xf8000000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">slcr</gui_name>
            <description language="en">slcr</description>
        </memory>
        <memory name="M_SMCC" offset="0xe000e000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">smcc</gui_name>
            <description language="en">smcc</description>
        </memory>
        <memory name="M_SPI0" offset="0xe0006000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">spi0</gui_name>
            <description language="en">spi0</description>
        </memory>
        <memory name="M_SPI1" offset="0xe0007000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">spi1</gui_name>
            <description language="en">spi1</description>
        </memory>
        <memory name="M_SWDT" offset="0xf8005000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">swdt</gui_name>
            <description language="en">swdt</description>
        </memory>
        <memory name="M_TTC0" offset="0xf8001000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">ttc0</gui_name>
            <description language="en">ttc0</description>
        </memory>
        <memory name="M_TTC1" offset="0xf8002000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">ttc1</gui_name>
            <description language="en">ttc1</description>
        </memory>
        <memory name="M_UART0" offset="0xe0000000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">uart0</gui_name>
            <description language="en">uart0</description>
        </memory>
        <memory name="M_UART1" offset="0xe0001000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">uart1</gui_name>
            <description language="en">uart1</description>
        </memory>
        <memory name="M_USB0" offset="0xe0002000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">usb0</gui_name>
            <description language="en">usb0</description>
        </memory>
        <memory name="M_USB1" offset="0xe0003000" size="0x1000" tz_world="Non-Secure">
            <gui_name language="en">usb1</gui_name>
            <description language="en">usb1</description>
        </memory>
        <peripheral address_type="Non-Secure" base_addr="M_AFI0" name="AFI0" offset="0xf8008000">
            <gui_name language="en">afi0</gui_name>
            <description language="en">afi0</description>
            <register name="AFI0_RDCHAN_CTRL" offset="0xf8008000" size="0x4">
                <gui_name language="en">AFI_RDCHAN_CTRL</gui_name>
                <description language="en">Read Channel Control Register: Control fields for Read Channel operation</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the RdCmdQ to be promoted if higher priority transactions are backed up behind it. The entire RdCmdQ will therefore be promoted when the fabric RdQos signal is promoted.
When disabled, only the new read commands issued will receive the promotion.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding read commands from the fabric
0 - The maximum number of outstanding read commands is always taken from APB register field, rdIssueCap0
1 - The maximum outstanding number of
read commands is selected from the fabric input, axds_rdissuecap1_en, as follows:
Max Outstanding Read Commands =
axds_rdissuecap1_en ? rdIssueCap1 : rdIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, AFI_RDQOS.staticQos
1 - The qos bits are dynamically driven from the fabric input, axds_arqos[3:0]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Read Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI0_RDCHAN_ISSUINGCAP" offset="0xf8008004" size="0x4">
                <gui_name language="en">AFI_RDCHAN_ISSUINGCAP</gui_name>
                <description language="en">Read Issuing Capability Register: Sets the maximum number of Outstanding Read Commands allowed (Issuing Capability). Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_rdissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap1_ENUM" high_bit="6" low_bit="4" name="rdIssueCap1">
                    <gui_name language="en">rdIssueCap1</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap0_ENUM" high_bit="2" low_bit="0" name="rdIssueCap0">
                    <gui_name language="en">rdIssueCap0</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI0_RDQOS" offset="0xf8008008" size="0x4">
                <gui_name language="en">AFI_RDQOS</gui_name>
                <description language="en">QOS Read Channel Register: Sets the static Qos value to be used for the read channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all read commands enqueued into the RdCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_RDQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the read channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI0_RDDEBUG" offset="0xf8008010" size="0x4">
                <gui_name language="en">AFI_RDDEBUG</gui_name>
                <description language="en">Read Channel Debug Register: Miscellaneous debug fields for the Read channel. Not to be used for functional purposes.</description>
                <bitField access="Read Only" enumerationId="AFI_RDDEBUG_OutRdCmds_ENUM" high_bit="4" low_bit="1" name="OutRdCmds">
                    <gui_name language="en">OutRdCmds</gui_name>
                    <description language="en">Returns the number of read commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="RdDataFifoOverflow">
                    <gui_name language="en">RdDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the RdDataFIFO overflows</description>
                </bitField>
            </register>
            <register name="AFI0_WRCHAN_CTRL" offset="0xf8008014" size="0x4">
                <gui_name language="en">AFI_WRCHAN_CTRL</gui_name>
                <description language="en">Write Channel Control Register: Control fields for Write Channel operation</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrDataThreshold_ENUM" high_bit="11" low_bit="8" name="WrDataThreshold">
                    <gui_name language="en">WrDataThreshold</gui_name>
                    <description language="en">Sets the threshold at which to send the write command. Note that this is measured in data beats, and is therefore dependent on the '32bitEn' field.
4'b0000: Send Write Command When 1 data beat is pushed into the Write Data FIFO
4'b0001: Send Write Command When 2 data beats are pushed into the Write Data FIFO' ' '4'b1111: Send Write Command When 16 data beats are pushed into the Write Data FIFO
Note: If this field is programmed to be less than the actual burst length of the write command, the 'Wlast' will take priority. For example, if 'WrDataThreshold' is set to 4'b1111 (indicates 16 beats), and a Wlast is received after 8 beats, the write command is sent.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrCmdReleaseMode_ENUM" high_bit="5" low_bit="4" name="WrCmdReleaseMode">
                    <gui_name language="en">WrCmdReleaseMode</gui_name>
                    <description language="en">Mode of Write Command Release.
2'b00: Release Wr Command on 'Wlast' enqueue into Write Data FIFO
2'b01: Release Wr Command on a particular threshold being reached on the enqueue into Write Data FIFO. The 'WrDataThreshold' field is used to program the actual threshold.
2'b10: Release Wr Command immediately it is received.
2'b11: Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the WrCmdQ to be promoted if higher priority transactions are backed up behind it. The entire WrCmdQ will therefore be 'promoted' when the fabric 'WrQos' signal is promoted.
When disabled, only the new write commands issued will receive the 'promotion'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding write commands from the fabric
0 - The maximum number of outstanding write commands is always taken from APB register field, 'wrIssueCap0'1 - The maximum outstanding number of
write commands is selected from the fabric input, 'axds_wrissuecap1_en', as follows:
Max Outstanding Write Commands =
axds_wrissuecap1_en ? wrIssueCap1 : wrIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, 'AFI_WRQOS.staticQos'1 - The qos bits are dynamically driven from the fabric input, 'axds_awqos[3:0]'</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Write Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI0_WRCHAN_ISSUINGCAP" offset="0xf8008018" size="0x4">
                <gui_name language="en">AFI_WRCHAN_ISSUINGCAP</gui_name>
                <description language="en">Write Issuing Capability Register: Sets the maximum number of Outstanding Write Commands (Issuing Capability) allowed. Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_wrissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap1_ENUM" high_bit="6" low_bit="4" name="wrIssueCap1">
                    <gui_name language="en">wrIssueCap1</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap0_ENUM" high_bit="2" low_bit="0" name="wrIssueCap0">
                    <gui_name language="en">wrIssueCap0</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI0_WRQOS" offset="0xf800801c" size="0x4">
                <gui_name language="en">AFI_WRQOS</gui_name>
                <description language="en">QOS Write Channel Register: Sets the static Qos value to be used for the write channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all write commands enqueued into the WrCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_WRQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the write channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI0_WRDEBUG" offset="0xf8008024" size="0x4">
                <gui_name language="en">AFI_WRDEBUG</gui_name>
                <description language="en">Write Channel Debug Register</description>
                <bitField access="Read Only" enumerationId="AFI_WRDEBUG_OutWrCmds_ENUM" high_bit="4" low_bit="1" name="OutWrCmds">
                    <gui_name language="en">OutWrCmds</gui_name>
                    <description language="en">Returns the number of write commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="WrDataFifoOverflow">
                    <gui_name language="en">WrDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the WrDataFIFO overflows</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_AFI1" name="AFI1" offset="0xf8009000">
            <gui_name language="en">afi1</gui_name>
            <description language="en">afi1</description>
            <register name="AFI1_RDCHAN_CTRL" offset="0xf8009000" size="0x4">
                <gui_name language="en">AFI_RDCHAN_CTRL</gui_name>
                <description language="en">Read Channel Control Register: Control fields for Read Channel operation</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the RdCmdQ to be promoted if higher priority transactions are backed up behind it. The entire RdCmdQ will therefore be promoted when the fabric RdQos signal is promoted.
When disabled, only the new read commands issued will receive the promotion.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding read commands from the fabric
0 - The maximum number of outstanding read commands is always taken from APB register field, rdIssueCap0
1 - The maximum outstanding number of
read commands is selected from the fabric input, axds_rdissuecap1_en, as follows:
Max Outstanding Read Commands =
axds_rdissuecap1_en ? rdIssueCap1 : rdIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, AFI_RDQOS.staticQos
1 - The qos bits are dynamically driven from the fabric input, axds_arqos[3:0]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Read Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI1_RDCHAN_ISSUINGCAP" offset="0xf8009004" size="0x4">
                <gui_name language="en">AFI_RDCHAN_ISSUINGCAP</gui_name>
                <description language="en">Read Issuing Capability Register: Sets the maximum number of Outstanding Read Commands allowed (Issuing Capability). Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_rdissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap1_ENUM" high_bit="6" low_bit="4" name="rdIssueCap1">
                    <gui_name language="en">rdIssueCap1</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap0_ENUM" high_bit="2" low_bit="0" name="rdIssueCap0">
                    <gui_name language="en">rdIssueCap0</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI1_RDQOS" offset="0xf8009008" size="0x4">
                <gui_name language="en">AFI_RDQOS</gui_name>
                <description language="en">QOS Read Channel Register: Sets the static Qos value to be used for the read channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all read commands enqueued into the RdCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_RDQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the read channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI1_RDDEBUG" offset="0xf8009010" size="0x4">
                <gui_name language="en">AFI_RDDEBUG</gui_name>
                <description language="en">Read Channel Debug Register: Miscellaneous debug fields for the Read channel. Not to be used for functional purposes.</description>
                <bitField access="Read Only" enumerationId="AFI_RDDEBUG_OutRdCmds_ENUM" high_bit="4" low_bit="1" name="OutRdCmds">
                    <gui_name language="en">OutRdCmds</gui_name>
                    <description language="en">Returns the number of read commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="RdDataFifoOverflow">
                    <gui_name language="en">RdDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the RdDataFIFO overflows</description>
                </bitField>
            </register>
            <register name="AFI1_WRCHAN_CTRL" offset="0xf8009014" size="0x4">
                <gui_name language="en">AFI_WRCHAN_CTRL</gui_name>
                <description language="en">Write Channel Control Register: Control fields for Write Channel operation</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrDataThreshold_ENUM" high_bit="11" low_bit="8" name="WrDataThreshold">
                    <gui_name language="en">WrDataThreshold</gui_name>
                    <description language="en">Sets the threshold at which to send the write command. Note that this is measured in data beats, and is therefore dependent on the '32bitEn' field.
4'b0000: Send Write Command When 1 data beat is pushed into the Write Data FIFO
4'b0001: Send Write Command When 2 data beats are pushed into the Write Data FIFO' ' '4'b1111: Send Write Command When 16 data beats are pushed into the Write Data FIFO
Note: If this field is programmed to be less than the actual burst length of the write command, the 'Wlast' will take priority. For example, if 'WrDataThreshold' is set to 4'b1111 (indicates 16 beats), and a Wlast is received after 8 beats, the write command is sent.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrCmdReleaseMode_ENUM" high_bit="5" low_bit="4" name="WrCmdReleaseMode">
                    <gui_name language="en">WrCmdReleaseMode</gui_name>
                    <description language="en">Mode of Write Command Release.
2'b00: Release Wr Command on 'Wlast' enqueue into Write Data FIFO
2'b01: Release Wr Command on a particular threshold being reached on the enqueue into Write Data FIFO. The 'WrDataThreshold' field is used to program the actual threshold.
2'b10: Release Wr Command immediately it is received.
2'b11: Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the WrCmdQ to be promoted if higher priority transactions are backed up behind it. The entire WrCmdQ will therefore be 'promoted' when the fabric 'WrQos' signal is promoted.
When disabled, only the new write commands issued will receive the 'promotion'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding write commands from the fabric
0 - The maximum number of outstanding write commands is always taken from APB register field, 'wrIssueCap0'1 - The maximum outstanding number of
write commands is selected from the fabric input, 'axds_wrissuecap1_en', as follows:
Max Outstanding Write Commands =
axds_wrissuecap1_en ? wrIssueCap1 : wrIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, 'AFI_WRQOS.staticQos'1 - The qos bits are dynamically driven from the fabric input, 'axds_awqos[3:0]'</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Write Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI1_WRCHAN_ISSUINGCAP" offset="0xf8009018" size="0x4">
                <gui_name language="en">AFI_WRCHAN_ISSUINGCAP</gui_name>
                <description language="en">Write Issuing Capability Register: Sets the maximum number of Outstanding Write Commands (Issuing Capability) allowed. Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_wrissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap1_ENUM" high_bit="6" low_bit="4" name="wrIssueCap1">
                    <gui_name language="en">wrIssueCap1</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap0_ENUM" high_bit="2" low_bit="0" name="wrIssueCap0">
                    <gui_name language="en">wrIssueCap0</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI1_WRQOS" offset="0xf800901c" size="0x4">
                <gui_name language="en">AFI_WRQOS</gui_name>
                <description language="en">QOS Write Channel Register: Sets the static Qos value to be used for the write channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all write commands enqueued into the WrCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_WRQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the write channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI1_WRDEBUG" offset="0xf8009024" size="0x4">
                <gui_name language="en">AFI_WRDEBUG</gui_name>
                <description language="en">Write Channel Debug Register</description>
                <bitField access="Read Only" enumerationId="AFI_WRDEBUG_OutWrCmds_ENUM" high_bit="4" low_bit="1" name="OutWrCmds">
                    <gui_name language="en">OutWrCmds</gui_name>
                    <description language="en">Returns the number of write commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="WrDataFifoOverflow">
                    <gui_name language="en">WrDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the WrDataFIFO overflows</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_AFI2" name="AFI2" offset="0xf800a000">
            <gui_name language="en">afi2</gui_name>
            <description language="en">afi2</description>
            <register name="AFI2_RDCHAN_CTRL" offset="0xf800a000" size="0x4">
                <gui_name language="en">AFI_RDCHAN_CTRL</gui_name>
                <description language="en">Read Channel Control Register: Control fields for Read Channel operation</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the RdCmdQ to be promoted if higher priority transactions are backed up behind it. The entire RdCmdQ will therefore be promoted when the fabric RdQos signal is promoted.
When disabled, only the new read commands issued will receive the promotion.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding read commands from the fabric
0 - The maximum number of outstanding read commands is always taken from APB register field, rdIssueCap0
1 - The maximum outstanding number of
read commands is selected from the fabric input, axds_rdissuecap1_en, as follows:
Max Outstanding Read Commands =
axds_rdissuecap1_en ? rdIssueCap1 : rdIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, AFI_RDQOS.staticQos
1 - The qos bits are dynamically driven from the fabric input, axds_arqos[3:0]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Read Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI2_RDCHAN_ISSUINGCAP" offset="0xf800a004" size="0x4">
                <gui_name language="en">AFI_RDCHAN_ISSUINGCAP</gui_name>
                <description language="en">Read Issuing Capability Register: Sets the maximum number of Outstanding Read Commands allowed (Issuing Capability). Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_rdissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap1_ENUM" high_bit="6" low_bit="4" name="rdIssueCap1">
                    <gui_name language="en">rdIssueCap1</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap0_ENUM" high_bit="2" low_bit="0" name="rdIssueCap0">
                    <gui_name language="en">rdIssueCap0</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI2_RDQOS" offset="0xf800a008" size="0x4">
                <gui_name language="en">AFI_RDQOS</gui_name>
                <description language="en">QOS Read Channel Register: Sets the static Qos value to be used for the read channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all read commands enqueued into the RdCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_RDQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the read channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI2_RDDEBUG" offset="0xf800a010" size="0x4">
                <gui_name language="en">AFI_RDDEBUG</gui_name>
                <description language="en">Read Channel Debug Register: Miscellaneous debug fields for the Read channel. Not to be used for functional purposes.</description>
                <bitField access="Read Only" enumerationId="AFI_RDDEBUG_OutRdCmds_ENUM" high_bit="4" low_bit="1" name="OutRdCmds">
                    <gui_name language="en">OutRdCmds</gui_name>
                    <description language="en">Returns the number of read commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="RdDataFifoOverflow">
                    <gui_name language="en">RdDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the RdDataFIFO overflows</description>
                </bitField>
            </register>
            <register name="AFI2_WRCHAN_CTRL" offset="0xf800a014" size="0x4">
                <gui_name language="en">AFI_WRCHAN_CTRL</gui_name>
                <description language="en">Write Channel Control Register: Control fields for Write Channel operation</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrDataThreshold_ENUM" high_bit="11" low_bit="8" name="WrDataThreshold">
                    <gui_name language="en">WrDataThreshold</gui_name>
                    <description language="en">Sets the threshold at which to send the write command. Note that this is measured in data beats, and is therefore dependent on the '32bitEn' field.
4'b0000: Send Write Command When 1 data beat is pushed into the Write Data FIFO
4'b0001: Send Write Command When 2 data beats are pushed into the Write Data FIFO' ' '4'b1111: Send Write Command When 16 data beats are pushed into the Write Data FIFO
Note: If this field is programmed to be less than the actual burst length of the write command, the 'Wlast' will take priority. For example, if 'WrDataThreshold' is set to 4'b1111 (indicates 16 beats), and a Wlast is received after 8 beats, the write command is sent.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrCmdReleaseMode_ENUM" high_bit="5" low_bit="4" name="WrCmdReleaseMode">
                    <gui_name language="en">WrCmdReleaseMode</gui_name>
                    <description language="en">Mode of Write Command Release.
2'b00: Release Wr Command on 'Wlast' enqueue into Write Data FIFO
2'b01: Release Wr Command on a particular threshold being reached on the enqueue into Write Data FIFO. The 'WrDataThreshold' field is used to program the actual threshold.
2'b10: Release Wr Command immediately it is received.
2'b11: Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the WrCmdQ to be promoted if higher priority transactions are backed up behind it. The entire WrCmdQ will therefore be 'promoted' when the fabric 'WrQos' signal is promoted.
When disabled, only the new write commands issued will receive the 'promotion'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding write commands from the fabric
0 - The maximum number of outstanding write commands is always taken from APB register field, 'wrIssueCap0'1 - The maximum outstanding number of
write commands is selected from the fabric input, 'axds_wrissuecap1_en', as follows:
Max Outstanding Write Commands =
axds_wrissuecap1_en ? wrIssueCap1 : wrIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, 'AFI_WRQOS.staticQos'1 - The qos bits are dynamically driven from the fabric input, 'axds_awqos[3:0]'</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Write Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI2_WRCHAN_ISSUINGCAP" offset="0xf800a018" size="0x4">
                <gui_name language="en">AFI_WRCHAN_ISSUINGCAP</gui_name>
                <description language="en">Write Issuing Capability Register: Sets the maximum number of Outstanding Write Commands (Issuing Capability) allowed. Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_wrissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap1_ENUM" high_bit="6" low_bit="4" name="wrIssueCap1">
                    <gui_name language="en">wrIssueCap1</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap0_ENUM" high_bit="2" low_bit="0" name="wrIssueCap0">
                    <gui_name language="en">wrIssueCap0</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI2_WRQOS" offset="0xf800a01c" size="0x4">
                <gui_name language="en">AFI_WRQOS</gui_name>
                <description language="en">QOS Write Channel Register: Sets the static Qos value to be used for the write channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all write commands enqueued into the WrCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_WRQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the write channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI2_WRDEBUG" offset="0xf800a024" size="0x4">
                <gui_name language="en">AFI_WRDEBUG</gui_name>
                <description language="en">Write Channel Debug Register</description>
                <bitField access="Read Only" enumerationId="AFI_WRDEBUG_OutWrCmds_ENUM" high_bit="4" low_bit="1" name="OutWrCmds">
                    <gui_name language="en">OutWrCmds</gui_name>
                    <description language="en">Returns the number of write commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="WrDataFifoOverflow">
                    <gui_name language="en">WrDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the WrDataFIFO overflows</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_AFI3" name="AFI3" offset="0xf800b000">
            <gui_name language="en">afi3</gui_name>
            <description language="en">afi3</description>
            <register name="AFI3_RDCHAN_CTRL" offset="0xf800b000" size="0x4">
                <gui_name language="en">AFI_RDCHAN_CTRL</gui_name>
                <description language="en">Read Channel Control Register: Control fields for Read Channel operation</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the RdCmdQ to be promoted if higher priority transactions are backed up behind it. The entire RdCmdQ will therefore be promoted when the fabric RdQos signal is promoted.
When disabled, only the new read commands issued will receive the promotion.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding read commands from the fabric
0 - The maximum number of outstanding read commands is always taken from APB register field, rdIssueCap0
1 - The maximum outstanding number of
read commands is selected from the fabric input, axds_rdissuecap1_en, as follows:
Max Outstanding Read Commands =
axds_rdissuecap1_en ? rdIssueCap1 : rdIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, AFI_RDQOS.staticQos
1 - The qos bits are dynamically driven from the fabric input, axds_arqos[3:0]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Read Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI3_RDCHAN_ISSUINGCAP" offset="0xf800b004" size="0x4">
                <gui_name language="en">AFI_RDCHAN_ISSUINGCAP</gui_name>
                <description language="en">Read Issuing Capability Register: Sets the maximum number of Outstanding Read Commands allowed (Issuing Capability). Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_rdissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap1_ENUM" high_bit="6" low_bit="4" name="rdIssueCap1">
                    <gui_name language="en">rdIssueCap1</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_RDCHAN_ISSUINGCAP_rdIssueCap0_ENUM" high_bit="2" low_bit="0" name="rdIssueCap0">
                    <gui_name language="en">rdIssueCap0</gui_name>
                    <description language="en">Max number of outstanding read commands (Read Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI3_RDQOS" offset="0xf800b008" size="0x4">
                <gui_name language="en">AFI_RDQOS</gui_name>
                <description language="en">QOS Read Channel Register: Sets the static Qos value to be used for the read channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all read commands enqueued into the RdCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_RDQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the read channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI3_RDDEBUG" offset="0xf800b010" size="0x4">
                <gui_name language="en">AFI_RDDEBUG</gui_name>
                <description language="en">Read Channel Debug Register: Miscellaneous debug fields for the Read channel. Not to be used for functional purposes.</description>
                <bitField access="Read Only" enumerationId="AFI_RDDEBUG_OutRdCmds_ENUM" high_bit="4" low_bit="1" name="OutRdCmds">
                    <gui_name language="en">OutRdCmds</gui_name>
                    <description language="en">Returns the number of read commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="RdDataFifoOverflow">
                    <gui_name language="en">RdDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the RdDataFIFO overflows</description>
                </bitField>
            </register>
            <register name="AFI3_WRCHAN_CTRL" offset="0xf800b014" size="0x4">
                <gui_name language="en">AFI_WRCHAN_CTRL</gui_name>
                <description language="en">Write Channel Control Register: Control fields for Write Channel operation</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrDataThreshold_ENUM" high_bit="11" low_bit="8" name="WrDataThreshold">
                    <gui_name language="en">WrDataThreshold</gui_name>
                    <description language="en">Sets the threshold at which to send the write command. Note that this is measured in data beats, and is therefore dependent on the '32bitEn' field.
4'b0000: Send Write Command When 1 data beat is pushed into the Write Data FIFO
4'b0001: Send Write Command When 2 data beats are pushed into the Write Data FIFO' ' '4'b1111: Send Write Command When 16 data beats are pushed into the Write Data FIFO
Note: If this field is programmed to be less than the actual burst length of the write command, the 'Wlast' will take priority. For example, if 'WrDataThreshold' is set to 4'b1111 (indicates 16 beats), and a Wlast is received after 8 beats, the write command is sent.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_WrCmdReleaseMode_ENUM" high_bit="5" low_bit="4" name="WrCmdReleaseMode">
                    <gui_name language="en">WrCmdReleaseMode</gui_name>
                    <description language="en">Mode of Write Command Release.
2'b00: Release Wr Command on 'Wlast' enqueue into Write Data FIFO
2'b01: Release Wr Command on a particular threshold being reached on the enqueue into Write Data FIFO. The 'WrDataThreshold' field is used to program the actual threshold.
2'b10: Release Wr Command immediately it is received.
2'b11: Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="QosHeadOfCmdQEn">
                    <gui_name language="en">QosHeadOfCmdQEn</gui_name>
                    <description language="en">When set, allows the priority of a transaction at the head of the WrCmdQ to be promoted if higher priority transactions are backed up behind it. The entire WrCmdQ will therefore be 'promoted' when the fabric 'WrQos' signal is promoted.
When disabled, only the new write commands issued will receive the 'promotion'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricOutCmdEn_ENUM" high_bit="2" low_bit="2" name="FabricOutCmdEn">
                    <gui_name language="en">FabricOutCmdEn</gui_name>
                    <description language="en">Enable control of outstanding write commands from the fabric
0 - The maximum number of outstanding write commands is always taken from APB register field, 'wrIssueCap0'1 - The maximum outstanding number of
write commands is selected from the fabric input, 'axds_wrissuecap1_en', as follows:
Max Outstanding Write Commands =
axds_wrissuecap1_en ? wrIssueCap1 : wrIssueCap0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_FabricQosEn_ENUM" high_bit="1" low_bit="1" name="FabricQosEn">
                    <gui_name language="en">FabricQosEn</gui_name>
                    <description language="en">Enable control of qos from the fabric
0 - The qos bits are derived from APB register, 'AFI_WRQOS.staticQos'1 - The qos bits are dynamically driven from the fabric input, 'axds_awqos[3:0]'</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_CTRL_n32BitEn_ENUM" high_bit="0" low_bit="0" name="n32BitEn">
                    <gui_name language="en">n32BitEn</gui_name>
                    <description language="en">Configures the Write Channel as a 32-bit interface.
1 - 32-bit enabled
0 - 64-bit enabled</description>
                </bitField>
            </register>
            <register name="AFI3_WRCHAN_ISSUINGCAP" offset="0xf800b018" size="0x4">
                <gui_name language="en">AFI_WRCHAN_ISSUINGCAP</gui_name>
                <description language="en">Write Issuing Capability Register: Sets the maximum number of Outstanding Write Commands (Issuing Capability) allowed. Refers to the commands that can be outstanding from the AFI to the SAM switch and back. Fields are selected by the 'axds_wrissuecap1_en' input.</description>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap1_ENUM" high_bit="6" low_bit="4" name="wrIssueCap1">
                    <gui_name language="en">wrIssueCap1</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 1:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFI_WRCHAN_ISSUINGCAP_wrIssueCap0_ENUM" high_bit="2" low_bit="0" name="wrIssueCap0">
                    <gui_name language="en">wrIssueCap0</gui_name>
                    <description language="en">Max number of outstanding write commands (Write Issuing Capability) field 0:
3'b000: 1 command
3'b001: 2 commands' ' '3'b111: 8 commands</description>
                </bitField>
            </register>
            <register name="AFI3_WRQOS" offset="0xf800b01c" size="0x4">
                <gui_name language="en">AFI_WRQOS</gui_name>
                <description language="en">QOS Write Channel Register: Sets the static Qos value to be used for the write channel. If APB register field, 'FabricQosEn' is 0 or ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 1), this static Qos value will be applied to all write commands enqueued into the WrCmdQ. If ('FabricQosEn' is 1 and 'QosHeadOfCmdQEn' is 0), this static Qos field will be ignored.</description>
                <bitField access="Read Write" enumerationId="AFI_WRQOS_staticQos_ENUM" high_bit="3" low_bit="0" name="staticQos">
                    <gui_name language="en">staticQos</gui_name>
                    <description language="en">Sets the level of the Qos field to be used for the write channel
4'b0000: Lowest Priority' ' '4'b1111: Highest Priority</description>
                </bitField>
            </register>
            <register name="AFI3_WRDEBUG" offset="0xf800b024" size="0x4">
                <gui_name language="en">AFI_WRDEBUG</gui_name>
                <description language="en">Write Channel Debug Register</description>
                <bitField access="Read Only" enumerationId="AFI_WRDEBUG_OutWrCmds_ENUM" high_bit="4" low_bit="1" name="OutWrCmds">
                    <gui_name language="en">OutWrCmds</gui_name>
                    <description language="en">Returns the number of write commands in flight between the AFI and the SAM switch
4'h0: 0
4'h1: 1
etc</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="WrDataFifoOverflow">
                    <gui_name language="en">WrDataFifoOverflow</gui_name>
                    <description language="en">Bit is set if the WrDataFIFO overflows</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_CAN0" name="CAN0" offset="0xe0008000">
            <gui_name language="en">can0</gui_name>
            <description language="en">can0</description>
            <register name="CAN0_SRR" offset="0xe0008000" size="0x4">
                <gui_name language="en">SRR</gui_name>
                <description language="en">Software Reset Register</description>
                <bitField access="Read Write" enumerationId="SRR_CEN_ENUM" high_bit="1" low_bit="1" name="CEN">
                    <gui_name language="en">CEN</gui_name>
                    <description language="en">Can Enable
The Enable bit for the CAN controller.
1 = The CAN controller is in Loop Back, Sleep or Normal mode depending on the LBACK and SLEEP bits in the MSR.
0 = The CAN controller is in the Configuration mode.
If the CEN bit is changed during core operation, it is
recommended to reset the core so that operations start afresh.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="SRR_SRST_ENUM" high_bit="0" low_bit="0" name="SRST">
                    <gui_name language="en">SRST</gui_name>
                    <description language="en">Reset
The Software reset bit for the CAN controller.
1 = CAN controller is reset.
If a 1 is written to this bit, all the CAN controller configuration registers (including the SRR) are reset. Reads to this bit always return a 0.</description>
                </bitField>
            </register>
            <register name="CAN0_MSR" offset="0xe0008004" size="0x4">
                <gui_name language="en">MSR</gui_name>
                <description language="en">Mode Select Register</description>
                <bitField access="Read Write" enumerationId="MSR_SNOOP_ENUM" high_bit="2" low_bit="2" name="SNOOP">
                    <gui_name language="en">SNOOP</gui_name>
                    <description language="en">Snoop Mode Select
The Snoop Mode Select bit.
1 = CAN controller is in Snoop mode.
0 = CAN controller is in Normal, Loop Back, Configuration, or Sleep mode.
This bit can be written to only when CEN bit in SRR is 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MSR_LBACK_ENUM" high_bit="1" low_bit="1" name="LBACK">
                    <gui_name language="en">LBACK</gui_name>
                    <description language="en">Loop Back Mode Select
The Loop Back Mode Select bit.
1 = CAN controller is in Loop Back mode.
0 = CAN controller is in Normal, Snoop, Configuration, or Sleep mode.
This bit can be written to only when CEN bit in SRR is 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MSR_SLEEP_ENUM" high_bit="0" low_bit="0" name="SLEEP">
                    <gui_name language="en">SLEEP</gui_name>
                    <description language="en">Sleep Mode Select
The Sleep Mode select bit.
1 = CAN controller is in Sleep mode.
0 = CAN controller is in Normal, Snoop, Configuration or Loop Back mode.
This bit is cleared when the CAN controller wakes up from the Sleep mode.</description>
                </bitField>
            </register>
            <register name="CAN0_BRPR" offset="0xe0008008" size="0x4">
                <gui_name language="en">BRPR</gui_name>
                <description language="en">Baud Rate Prescaler Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="BRP">
                    <gui_name language="en">BRP</gui_name>
                    <description language="en">Baud Rate Prescaler
These bits indicate the prescaler value. The actual
value ranges from 1 to 256.</description>
                </bitField>
            </register>
            <register name="CAN0_BTR" offset="0xe000800c" size="0x4">
                <gui_name language="en">BTR</gui_name>
                <description language="en">Bit Timing Register</description>
                <bitField access="Read Write" high_bit="8" low_bit="7" name="SJW">
                    <gui_name language="en">SJW</gui_name>
                    <description language="en">Synchronization Jump Width
Indicates the Synchronization Jump Width as specified in the CAN 2.0A and CAN 2.0B standard. The actual value is one more than the value written to the register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="4" name="TS2">
                    <gui_name language="en">TS2</gui_name>
                    <description language="en">Time Segment 2
Indicates Phase Segment 2 as specified in the CAN 2.0A and CAN 2.0B standard. The actual value is one more than the value written to the register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="TS1">
                    <gui_name language="en">TS1</gui_name>
                    <description language="en">Time Segment 1
Indicates the Sum of Propagation Segment and Phase
Segment 1 as specified in the CAN 2.0A and CAN 2.0B
standard. The actual value is one more than the value
written to the register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="CAN0_ECR" offset="0xe0008010" size="0x4">
                <gui_name language="en">ECR</gui_name>
                <description language="en">Error Counter Register</description>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="REC">
                    <gui_name language="en">REC</gui_name>
                    <description language="en">Receive Error Counter
Indicates the Value of the Receive Error Counter.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="TEC">
                    <gui_name language="en">TEC</gui_name>
                    <description language="en">Transmit Error Counter
Indicates the Value of the Transmit Error Counter.</description>
                </bitField>
            </register>
            <register name="CAN0_ESR" offset="0xe0008014" size="0x4">
                <gui_name language="en">ESR</gui_name>
                <description language="en">Error Status Register</description>
                <bitField access="Read Write" enumerationId="ESR_ACKER_ENUM" high_bit="4" low_bit="4" name="ACKER">
                    <gui_name language="en">ACKER</gui_name>
                    <description language="en">ACK Error
Indicates an acknowledgement error.
1 = Indicates an acknowledgement error has
occurred.
0 = Indicates an acknowledgement error has not
occurred on the bus since the last write to this
register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_BERR_ENUM" high_bit="3" low_bit="3" name="BERR">
                    <gui_name language="en">BERR</gui_name>
                    <description language="en">Bit Error
Indicates the received bit is not the same as the
transmitted bit during bus communication.
1 = Indicates a bit error has occurred.
0 = Indicates a bit error has not occurred on the bus
since the last write to this register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_STER_ENUM" high_bit="2" low_bit="2" name="STER">
                    <gui_name language="en">STER</gui_name>
                    <description language="en">Stuff Error
Indicates an error if there is a stuffing violation.
1 = Indicates a stuff error has occurred.
0 = Indicates a stuff error has not occurred on the
bus since the last write to this register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_FMER_ENUM" high_bit="1" low_bit="1" name="FMER">
                    <gui_name language="en">FMER</gui_name>
                    <description language="en">Form Error
Indicates an error in one of the fixed form fields in the
message frame.
1 = Indicates a form error has occurred.
0 = Indicates a form error has not occurred on the
bus since the last write to this register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_CRCER_ENUM" high_bit="0" low_bit="0" name="CRCER">
                    <gui_name language="en">CRCER</gui_name>
                    <description language="en">CRC Error
Indicates a CRC error has occurred.
1 = Indicates a CRC error has occurred.
0 = Indicates a CRC error has not occurred on the
bus since the last write to this register.
If this bit is set, writing a 1 clears it.
In case of a CRC Error and a CRC delimiter corruption, only the FMER bit is set.</description>
                </bitField>
            </register>
            <register name="CAN0_SR" offset="0xe0008018" size="0x4">
                <gui_name language="en">SR</gui_name>
                <description language="en">Status Register</description>
                <bitField access="Read Only" enumerationId="SR_SNOOP_ENUM" high_bit="12" low_bit="12" name="SNOOP">
                    <gui_name language="en">SNOOP</gui_name>
                    <description language="en">Snoop Mode
Indicates the CAN controller is in Snoop Mode.
1 = Indicates the CAN controller is in Snoop Mode.
0 = Indicates the CAN controller is not in Snoop mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_ACFBSY_ENUM" high_bit="11" low_bit="11" name="ACFBSY">
                    <gui_name language="en">ACFBSY</gui_name>
                    <description language="en">Acceptance Filter Busy
This bit indicates that the Acceptance Filter Mask
Registers and the Acceptance Filter ID Registers
cannot be written to.
1 = Acceptance Filter Mask Registers and
Acceptance Filter ID Registers cannot be written
to.
0 = Acceptance Filter Mask Registers and the
Acceptance Filter ID Registers can be written to.
This bit exists only when the number of acceptance
filters is not 0
This bit is set when a 0 is written to any of the valid
UAF bits in the Acceptance Filter Register.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_TXFLL_ENUM" high_bit="10" low_bit="10" name="TXFLL">
                    <gui_name language="en">TXFLL</gui_name>
                    <description language="en">Transmit FIFO Full
Indicates that the TX FIFO is full.
1 = Indicates the TX FIFO is full.
0 = Indicates the TX FIFO is not full.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_TXBFLL_ENUM" high_bit="9" low_bit="9" name="TXBFLL">
                    <gui_name language="en">TXBFLL</gui_name>
                    <description language="en">High Priority Transmit Buffer Full
Indicates the High Priority Transmit Buffer is full.
1 = Indicates the High Priority Transmit Buffer is full.
0 = Indicates the High Priority Transmit Buffer is not full.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_ESTAT_ENUM" high_bit="8" low_bit="7" name="ESTAT">
                    <gui_name language="en">ESTAT</gui_name>
                    <description language="en">Error Status
Indicates the error status of the CAN controller.
00 = Indicates Configuration Mode (CONFIG = 1).
Error State is undefined.
01 = Indicates Error Active State.
11 = Indicates Error Passive State.
10 = Indicates Bus Off State.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_ERRWRN_ENUM" high_bit="6" low_bit="6" name="ERRWRN">
                    <gui_name language="en">ERRWRN</gui_name>
                    <description language="en">Error Warning
Indicates that either the Transmit Error counter or the
Receive Error counter has exceeded a value of 96.
1 = One or more error counters have a value greater
than or equal to 96.
0 = Neither of the error counters has a value greater
than or equal to 96.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_BBSY_ENUM" high_bit="5" low_bit="5" name="BBSY">
                    <gui_name language="en">BBSY</gui_name>
                    <description language="en">Bus Busy
Indicates the CAN bus status.
1 = Indicates that the CAN controller is either
receiving a message or transmitting a message.
0 = Indicates that the CAN controller is either in
Configuration mode or the bus is idle.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_BIDLE_ENUM" high_bit="4" low_bit="4" name="BIDLE">
                    <gui_name language="en">BIDLE</gui_name>
                    <description language="en">Bus Idle
Indicates the CAN bus status.
1 = Indicates no bus communication is taking place.
0 = Indicates the CAN controller is either in
Configuration mode or the bus is busy.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_NORMAL_ENUM" high_bit="3" low_bit="3" name="NORMAL">
                    <gui_name language="en">NORMAL</gui_name>
                    <description language="en">Normal Mode
Indicates the CAN controller is in Normal Mode.
1 = Indicates the CAN controller is in Normal Mode.
0 = Indicates the CAN controller is not in Normal
mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_SLEEP_ENUM" high_bit="2" low_bit="2" name="SLEEP">
                    <gui_name language="en">SLEEP</gui_name>
                    <description language="en">Sleep Mode
Indicates the CAN controller is in Sleep mode.
1 = Indicates the CAN controller is in Sleep mode.
0 = Indicates the CAN controller is not in Sleep mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_LBACK_ENUM" high_bit="1" low_bit="1" name="LBACK">
                    <gui_name language="en">LBACK</gui_name>
                    <description language="en">Loop Back Mode
Indicates the CAN controller is in Loop Back mode.
1 = Indicates the CAN controller is in Loop Back
mode.
0 = Indicates the CAN controller is not in Loop Back
mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_CONFIG_ENUM" high_bit="0" low_bit="0" name="CONFIG">
                    <gui_name language="en">CONFIG</gui_name>
                    <description language="en">Configuration Mode Indicator
Indicates the CAN controller is in Configuration mode.
1 = Indicates the CAN controller is in Configuration
mode.
0 = Indicates the CAN controller is not in
Configuration mode.</description>
                </bitField>
            </register>
            <register name="CAN0_ISR" offset="0xe000801c" size="0x4">
                <gui_name language="en">ISR</gui_name>
                <description language="en">Interrupt Status Register</description>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="TXFEMP">
                    <gui_name language="en">TXFEMP</gui_name>
                    <description language="en">Transmit FIFO EmptyInterrupt
A 1 indicates that the Transmit FIFO is empty.
The interrupt continues to assert as long as the TX
FIFO is empty.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="TXFWMEMP">
                    <gui_name language="en">TXFWMEMP</gui_name>
                    <description language="en">Transmit FIFO Watermark Empty Interrupt
A 1 indicates that the TX FIFO is empty based on
watermark programming.
The interrupt continues to assert as long as the number
of empty spaces in the TX FIFO is greater than TX FIFO
empty watermark.
This bit can be cleared only by writing to the Interrupt
Clear Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="RXFWMFLL">
                    <gui_name language="en">RXFWMFLL</gui_name>
                    <description language="en">Receive FIFO Watermark Full Interrupt
A 1 indicates that the RX FIFO is full based on
watermark programming.
The interrupt continues to assert as long as the RX
FIFO count is above RX FIFO Full watermark.
This bit can be cleared only by writing to the Interrupt
Clear Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="WKUP">
                    <gui_name language="en">WKUP</gui_name>
                    <description language="en">Wake up Interrupt
A 1 indicates that the CAN controller entered Normal
mode from Sleep Mode.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN
bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="SLP">
                    <gui_name language="en">SLP</gui_name>
                    <description language="en">Sleep Interrupt
A 1 indicates that the CAN controller entered Sleep mode.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="BSOFF">
                    <gui_name language="en">BSOFF</gui_name>
                    <description language="en">Bus Off Interrupt
A 1 indicates that the CAN controller entered the Bus Off state.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="ERROR">
                    <gui_name language="en">ERROR</gui_name>
                    <description language="en">Error Interrupt
A 1 indicates that an error occurred during message transmission or reception.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="RXNEMP">
                    <gui_name language="en">RXNEMP</gui_name>
                    <description language="en">Receive FIFO Not Empty Interrupt
A 1 indicates that the Receive FIFO is not empty.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="RXOFLW">
                    <gui_name language="en">RXOFLW</gui_name>
                    <description language="en">RX FIFO Overflow Interrupt
A 1 indicates that a message has been lost. This condition occurs when a new message is being received and the Receive FIFO is Full.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="RXUFLW">
                    <gui_name language="en">RXUFLW</gui_name>
                    <description language="en">RX FIFO Underflow Interrupt
A 1 indicates that a read operation was attempted on an empty RX FIFO.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="RXOK">
                    <gui_name language="en">RXOK</gui_name>
                    <description language="en">New Message Received Interrupt
A 1 indicates that a message was received successfully and stored into the RX FIFO.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="TXBFLL">
                    <gui_name language="en">TXBFLL</gui_name>
                    <description language="en">High Priority Transmit Buffer Full Interrupt
A 1 indicates that the High Priority Transmit Buffer is full.
The status of the bit is unaffected if write transactions occur on the High Priority Transmit Buffer when it is already full.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="TXFLL">
                    <gui_name language="en">TXFLL</gui_name>
                    <description language="en">Transmit FIFO Full Interrupt
A 1 indicates that the TX FIFO is full.
The status of the bit is unaffected if write transactions occur on the Transmit FIFO when it is already full.
This bit can be cleared only by writing to the Interrupt Clear Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="TXOK">
                    <gui_name language="en">TXOK</gui_name>
                    <description language="en">Transmission Successful Interrupt
A 1 indicates that a message was transmitted successfully.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
In Loop Back mode, both TXOK and RXOK bits are set. The RXOK bit is set before the TXOK bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ARBLST">
                    <gui_name language="en">ARBLST</gui_name>
                    <description language="en">Arbitration Lost Interrupt
A 1 indicates that arbitration was lost during message transmission.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
            </register>
            <register name="CAN0_IER" offset="0xe0008020" size="0x4">
                <gui_name language="en">IER</gui_name>
                <description language="en">Interrupt Enable Register</description>
                <bitField access="Read Write" enumerationId="IER_ETXFEMP_ENUM" high_bit="14" low_bit="14" name="ETXFEMP">
                    <gui_name language="en">ETXFEMP</gui_name>
                    <description language="en">Enable TXFIFO Empty Interrupt
Writes to this bit enable or disable interrupts when the
TXFEMP bit in the ISR is set.
1 = Enable interrupt generation if TXFEMP bit in ISR is set.
0 = Disable interrupt generation if TXFEMP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXFWMEMP_ENUM" high_bit="13" low_bit="13" name="ETXFWMEMP">
                    <gui_name language="en">ETXFWMEMP</gui_name>
                    <description language="en">Enable TXFIFO watermark Empty Interrupt
Writes to this bit enable or disable interrupts when the
TXFWMEMP bit in the ISR is set.
1 = Enable interrupt generation if TXFWMEMP bit in ISR is set.
0 = Disable interrupt generation if TXFWMEMP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXFWMFLL_ENUM" high_bit="12" low_bit="12" name="ERXFWMFLL">
                    <gui_name language="en">ERXFWMFLL</gui_name>
                    <description language="en">Enable RXFIFO watermark Full Interrupt
Writes to this bit enable or disable interrupts when the RXFLL bit in the ISR is set.
1 = Enable interrupt generation if RXFWMFLL bit in ISR is set.
0 = Disable interrupt generation if RXFWMFLL bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EWKUP_ENUM" high_bit="11" low_bit="11" name="EWKUP">
                    <gui_name language="en">EWKUP</gui_name>
                    <description language="en">Enable Wake up Interrupt
Writes to this bit enable or disable interrupts when the
WKUP bit in the ISR is set.
1 = Enable interrupt generation if WKUP bit in ISR is set.
0 = Disable interrupt generation if WKUP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ESLP_ENUM" high_bit="10" low_bit="10" name="ESLP">
                    <gui_name language="en">ESLP</gui_name>
                    <description language="en">Enable Sleep Interrupt
Writes to this bit enable or disable interrupts when the
SLP bit in the ISR is set.
1 = Enable interrupt generation if SLP bit in ISR is set.
0 = Disable interrupt generation if SLP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EBSOFF_ENUM" high_bit="9" low_bit="9" name="EBSOFF">
                    <gui_name language="en">EBSOFF</gui_name>
                    <description language="en">Enable Bus OFF Interrupt
Writes to this bit enable or disable interrupts when the
BSOFF bit in the ISR is set.
1 = Enable interrupt generation if BSOFF bit in ISR is set.
0 = Disable interrupt generation if BSOFF bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EERROR_ENUM" high_bit="8" low_bit="8" name="EERROR">
                    <gui_name language="en">EERROR</gui_name>
                    <description language="en">Enable Error Interrupt
Writes to this bit enable or disable interrupts when the
ERROR bit in the ISR is set.
1 = Enable interrupt generation if ERROR bit in ISR is
set.
0 = Disable interrupt generation if ERROR bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXNEMP_ENUM" high_bit="7" low_bit="7" name="ERXNEMP">
                    <gui_name language="en">ERXNEMP</gui_name>
                    <description language="en">Enable Receive FIFO Not Empty Interrupt
Writes to this bit enable or disable interrupts when the
RXNEMP bit in the ISR is set.
1 = Enable interrupt generation if RXNEMP bit in ISR is
set.
0 = Disable interrupt generation if RXNEMP bit in ISR
is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXOFLW_ENUM" high_bit="6" low_bit="6" name="ERXOFLW">
                    <gui_name language="en">ERXOFLW</gui_name>
                    <description language="en">Enable RX FIFO Overflow Interrupt
Writes to this bit enable or disable interrupts when the
RXOFLW bit in the ISR is set.
1 = Enable interrupt generation if RXOFLW bit in ISR is
set.
0 = Disable interrupt generation if RXOFLW bit in ISR
is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXUFLW_ENUM" high_bit="5" low_bit="5" name="ERXUFLW">
                    <gui_name language="en">ERXUFLW</gui_name>
                    <description language="en">Enable RX FIFO Underflow Interrupt
Writes to this bit enable or disable interrupts when the
RXUFLW bit in the ISR is set.
1 = Enable interrupt generation if RXUFLW bit in ISR is
set.
0 = Disable interrupt generation if RXUFLW bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXOK_ENUM" high_bit="4" low_bit="4" name="ERXOK">
                    <gui_name language="en">ERXOK</gui_name>
                    <description language="en">Enable New Message Received Interrupt
Writes to this bit enable or disable interrupts when the
RXOK bit in the ISR is set.
1 = Enable interrupt generation if RXOK bit in ISR is
set.
0 = Disable interrupt generation if RXOK bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXBFLL_ENUM" high_bit="3" low_bit="3" name="ETXBFLL">
                    <gui_name language="en">ETXBFLL</gui_name>
                    <description language="en">Enable High Priority Transmit Buffer Full Interrupt
Writes to this bit enable or disable interrupts when the
TXBFLL bit in the ISR is set.
1 = Enable interrupt generation if TXBFLL bit in ISR is
set.
0 = Disable interrupt generation if TXBFLL bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXFLL_ENUM" high_bit="2" low_bit="2" name="ETXFLL">
                    <gui_name language="en">ETXFLL</gui_name>
                    <description language="en">Enable Transmit FIFO Full Interrupt
Writes to this bit enable or disable interrupts when
TXFLL bit in the ISR is set.
1 = Enable interrupt generation if TXFLL bit in ISR is
set.
0 = Disable interrupt generation if TXFLL bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXOK_ENUM" high_bit="1" low_bit="1" name="ETXOK">
                    <gui_name language="en">ETXOK</gui_name>
                    <description language="en">Enable Transmission Successful Interrupt
Writes to this bit enable or disable interrupts when the
TXOK bit in the ISR is set.
1 = Enable interrupt generation if TXOK bit in ISR is set.
0 = Disable interrupt generation if TXOK bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EARBLST_ENUM" high_bit="0" low_bit="0" name="EARBLST">
                    <gui_name language="en">EARBLST</gui_name>
                    <description language="en">Enable Arbitration Lost Interrupt
Writes to this bit enable or disable interrupts when the
ARBLST bit in the ISR is set.
1 = Enable interrupt generation if ARBLST bit in ISR is
set.
0 = Disable interrupt generation if ARBLST bit in ISR is
set.</description>
                </bitField>
            </register>
            <register name="CAN0_ICR" offset="0xe0008024" size="0x4">
                <gui_name language="en">ICR</gui_name>
                <description language="en">Interrupt Clear Register</description>
                <bitField access="Write Only" high_bit="14" low_bit="14" name="CTXFEMP">
                    <gui_name language="en">CTXFEMP</gui_name>
                    <description language="en">Clear TXFIFO Empty Interrupt
Writing a 1 to this bit clears the TXFEMP bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="13" name="CTXFWMEMP">
                    <gui_name language="en">CTXFWMEMP</gui_name>
                    <description language="en">Clear TXFIFO Watermark Empty Interrupt
Writing a 1 to this bit clears the TXFWMEMP bit in
the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="CRXFWMFLL">
                    <gui_name language="en">CRXFWMFLL</gui_name>
                    <description language="en">Clear RXFIFO Watermark Full Interrupt
Writing a 1 to this bit clears the RXFWMFLL bit in
the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="CWKUP">
                    <gui_name language="en">CWKUP</gui_name>
                    <description language="en">Clear Wake up Interrupt
Writing a 1 to this bit clears the WKUP bit in the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="CSLP">
                    <gui_name language="en">CSLP</gui_name>
                    <description language="en">Clear Sleep Interrupt
Writing a 1 to this bit clears the SLP bit in the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="CBSOFF">
                    <gui_name language="en">CBSOFF</gui_name>
                    <description language="en">Clear Bus Off Interrupt
Writing a 1 to this bit clears the BSOFF bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="8" low_bit="8" name="CERROR">
                    <gui_name language="en">CERROR</gui_name>
                    <description language="en">Clear Error Interrupt
Writing a 1 to this bit clears the ERROR bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="7" name="CRXNEMP">
                    <gui_name language="en">CRXNEMP</gui_name>
                    <description language="en">Clear Receive FIFO Not Empty Interrupt
Writing a 1 to this bit clears the RXNEMP bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="CRXOFLW">
                    <gui_name language="en">CRXOFLW</gui_name>
                    <description language="en">Clear RX FIFO Overflow Interrupt
Writing a 1 to this bit clears the RXOFLW bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="CRXUFLW">
                    <gui_name language="en">CRXUFLW</gui_name>
                    <description language="en">Clear RX FIFO Underflow Interrupt
Writing a 1 to this bit clears the RXUFLW bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="CRXOK">
                    <gui_name language="en">CRXOK</gui_name>
                    <description language="en">Clear New Message Received Interrupt
Writing a 1 to this bit clears the RXOK bit in the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="CTXBFLL">
                    <gui_name language="en">CTXBFLL</gui_name>
                    <description language="en">Clear High Priority Transmit Buffer Full Interrupt
Writing a 1 to this bit clears the TXBFLL bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="CTXFLL">
                    <gui_name language="en">CTXFLL</gui_name>
                    <description language="en">Clear Transmit FIFO Full Interrupt
Writing a 1 to this bit clears the TXFLL bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="CTXOK">
                    <gui_name language="en">CTXOK</gui_name>
                    <description language="en">Clear Arbitration Lost Interrupt
Writing a 1 to this bit clears the ARBLST bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="CARBLST">
                    <gui_name language="en">CARBLST</gui_name>
                    <description language="en">Clear Arbitration Lost Interrupt
Writing a 1 to this bit clears the ARBLST bit in the
ISR.</description>
                </bitField>
            </register>
            <register name="CAN0_TCR" offset="0xe0008028" size="0x4">
                <gui_name language="en">TCR</gui_name>
                <description language="en">Timestamp Control Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="CTS">
                    <gui_name language="en">CTS</gui_name>
                    <description language="en">Clear Timestamp
Internal free running counter is cleared to 0 when
CTS=1. This bit only needs to be written once with a 1
to clear the counter. The bit will automatically return to
0.</description>
                </bitField>
            </register>
            <register name="CAN0_WIR" offset="0xe000802c" size="0x4">
                <gui_name language="en">WIR</gui_name>
                <description language="en">Watermark Interrupt Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="EW">
                    <gui_name language="en">EW</gui_name>
                    <description language="en">TXFIFO Empty watermark
TXFIFO generates an EMPTY interrupt based on the
value programmed in this field. The valid range is
(1-63). Only bits 18-23 are writable. No protection is
given for illegal programming in this field.
This field can be written to only when CEN bit in SRR is
0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="FW">
                    <gui_name language="en">FW</gui_name>
                    <description language="en">RXFIFO Full watermark
RXFIFO generates FULL interrupt based on the value
programmed in this field. The valid range is (1-63). Only
bits 26-31 are writable. No protection is given for illegal
programming in this field. This field can be written to
only when CEN bit in SRR is 0.</description>
                </bitField>
            </register>
            <register access="Write Only" name="CAN0_TXFIFO_ID" offset="0xe0008030" size="0x4">
                <gui_name language="en">TXFIFO_ID</gui_name>
                <description language="en">transmit message fifo message identifier</description>
                <bitField access="Write Only" high_bit="31" low_bit="21" name="IDH">
                    <gui_name language="en">IDH</gui_name>
                    <description language="en">Standard Message ID
The Identifier portion for a Standard Frame is 11 bits.
These bits indicate the Standard Frame ID.
This field is valid for both Standard and Extended
Frames.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXFIFO_ID_SRRRTR_ENUM" high_bit="20" low_bit="20" name="SRRRTR">
                    <gui_name language="en">SRRRTR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
This bit differentiates between data frames and
remote frames. Valid only for Standard Frames. For
Extended frames this bit is 1.
1 = Indicates that the message frame is a Remote
Frame.
0 = Indicates that the message frame is a Data
Frame.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXFIFO_ID_IDE_ENUM" high_bit="19" low_bit="19" name="IDE">
                    <gui_name language="en">IDE</gui_name>
                    <description language="en">Identifier Extension
This bit differentiates between frames using the
Standard Identifier and those using the Extended
Identifier. Valid for both Standard and Extended
Frames.
1 = Indicates the use of an Extended Message
Identifier.
0= Indicates the use of a Standard Message
Identifier.</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="1" name="IDL">
                    <gui_name language="en">IDL</gui_name>
                    <description language="en">Extended Message ID
This field indicates the Extended Identifier.
Valid only for Extended Frames.
For Standard Frames, reads from this field return 0s
For Standard Frames, writes to this field should be 0s</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXFIFO_ID_RTR_ENUM" high_bit="0" low_bit="0" name="RTR">
                    <gui_name language="en">RTR</gui_name>
                    <description language="en">Remote Transmission Request
This bit differentiates between data frames and
remote frames.
Valid only for Extended Frames.
1 = Indicates the message object is a Remote Frame
0 = Indicates the message object is a Data Frame
For Standard Frames, reads from this bit returns 0
For Standard Frames, writes to this bit should be 0</description>
                </bitField>
            </register>
            <register name="CAN0_TXFIFO_DLC" offset="0xe0008034" size="0x4">
                <gui_name language="en">TXFIFO_DLC</gui_name>
                <description language="en">transmit message fifo data length code</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="DLC">
                    <gui_name language="en">DLC</gui_name>
                    <description language="en">Data Length Code
This is the data length portion of the control field of
the CAN frame. This indicates the number valid data
bytes in Data Word 1 and Data Word 2 registers.</description>
                </bitField>
            </register>
            <register name="CAN0_TXFIFO_DATA1" offset="0xe0008038" size="0x4">
                <gui_name language="en">TXFIFO_DATA1</gui_name>
                <description language="en">transmit message fifo data word 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 0
Reads from this field return invalid data if the
message has no data.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 1
Reads from this field return invalid data if the
message has only 1 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 2
Reads from this field return invalid data if the
message has only 2 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 3
Reads from this field return invalid data if the
message has only 3 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN0_TXFIFO_DATA2" offset="0xe000803c" size="0x4">
                <gui_name language="en">TXFIFO_DATA2</gui_name>
                <description language="en">transmit message fifo data word 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 4
Reads from this field return invalid data if the
message has only 4 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 5
Reads from this field return invalid data if the
message has only 5 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 6
Reads from this field return invalid data if the
message has only 6 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 7
Reads from this field return invalid data if the
message has 7 byte of data or fewer</description>
                </bitField>
            </register>
            <register access="Write Only" name="CAN0_TXHPB_ID" offset="0xe0008040" size="0x4">
                <gui_name language="en">TXHPB_ID</gui_name>
                <description language="en">transmit high priority buffer message identifier</description>
                <bitField access="Write Only" high_bit="31" low_bit="21" name="IDH">
                    <gui_name language="en">IDH</gui_name>
                    <description language="en">Standard Message ID
The Identifier portion for a Standard Frame is 11 bits.
These bits indicate the Standard Frame ID.
This field is valid for both Standard and Extended
Frames.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXHPB_ID_SRRRTR_ENUM" high_bit="20" low_bit="20" name="SRRRTR">
                    <gui_name language="en">SRRRTR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
This bit differentiates between data frames and
remote frames. Valid only for Standard Frames. For
Extended frames this bit is 1.
1 = Indicates that the message frame is a Remote
Frame.
0 = Indicates that the message frame is a Data
Frame.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXHPB_ID_IDE_ENUM" high_bit="19" low_bit="19" name="IDE">
                    <gui_name language="en">IDE</gui_name>
                    <description language="en">Identifier Extension
This bit differentiates between frames using the
Standard Identifier and those using the Extended
Identifier. Valid for both Standard and Extended
Frames.
1 = Indicates the use of an Extended Message
Identifier.
0= Indicates the use of a Standard Message
Identifier.</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="1" name="IDL">
                    <gui_name language="en">IDL</gui_name>
                    <description language="en">Extended Message ID
This field indicates the Extended Identifier.
Valid only for Extended Frames.
For Standard Frames, reads from this field return 0s
For Standard Frames, writes to this field should be 0s</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXHPB_ID_RTR_ENUM" high_bit="0" low_bit="0" name="RTR">
                    <gui_name language="en">RTR</gui_name>
                    <description language="en">Remote Transmission Request
This bit differentiates between data frames and
remote frames.
Valid only for Extended Frames.
1 = Indicates the message object is a Remote Frame
0 = Indicates the message object is a Data Frame
For Standard Frames, reads from this bit returns 0
For Standard Frames, writes to this bit should be 0</description>
                </bitField>
            </register>
            <register name="CAN0_TXHPB_DLC" offset="0xe0008044" size="0x4">
                <gui_name language="en">TXHPB_DLC</gui_name>
                <description language="en">transmit high priority buffer data length code</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="DLC">
                    <gui_name language="en">DLC</gui_name>
                    <description language="en">Data Length Code
This is the data length portion of the control field of
the CAN frame. This indicates the number valid data
bytes in Data Word 1 and Data Word 2 registers.</description>
                </bitField>
            </register>
            <register name="CAN0_TXHPB_DATA1" offset="0xe0008048" size="0x4">
                <gui_name language="en">TXHPB_DATA1</gui_name>
                <description language="en">transmit high priority buffer data word 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 0
Reads from this field return invalid data if the
message has no data.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 1
Reads from this field return invalid data if the
message has only 1 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 2
Reads from this field return invalid data if the
message has only 2 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 3
Reads from this field return invalid data if the
message has only 3 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN0_TXHPB_DATA2" offset="0xe000804c" size="0x4">
                <gui_name language="en">TXHPB_DATA2</gui_name>
                <description language="en">transmit high priority buffer data word 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 4
Reads from this field return invalid data if the
message has only 4 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 5
Reads from this field return invalid data if the
message has only 5 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 6
Reads from this field return invalid data if the
message has only 6 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 7
Reads from this field return invalid data if the
message has 7 byte of data or fewer</description>
                </bitField>
            </register>
            <register access="Read Only" name="CAN0_RXFIFO_ID" offset="0xe0008050" size="0x4">
                <gui_name language="en">RXFIFO_ID</gui_name>
                <description language="en">receive message fifo message identifier</description>
                <bitField access="Read Only" high_bit="31" low_bit="21" name="IDH">
                    <gui_name language="en">IDH</gui_name>
                    <description language="en">Standard Message ID
The Identifier portion for a Standard Frame is 11 bits.
These bits indicate the Standard Frame ID.
This field is valid for both Standard and Extended
Frames.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="RXFIFO_ID_SRRRTR_ENUM" high_bit="20" low_bit="20" name="SRRRTR">
                    <gui_name language="en">SRRRTR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
This bit differentiates between data frames and
remote frames. Valid only for Standard Frames. For
Extended frames this bit is 1.
1 = Indicates that the message frame is a Remote
Frame.
0 = Indicates that the message frame is a Data
Frame.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="RXFIFO_ID_IDE_ENUM" high_bit="19" low_bit="19" name="IDE">
                    <gui_name language="en">IDE</gui_name>
                    <description language="en">Identifier Extension
This bit differentiates between frames using the
Standard Identifier and those using the Extended
Identifier. Valid for both Standard and Extended
Frames.
1 = Indicates the use of an Extended Message
Identifier.
0= Indicates the use of a Standard Message
Identifier.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="1" name="IDL">
                    <gui_name language="en">IDL</gui_name>
                    <description language="en">Extended Message ID
This field indicates the Extended Identifier.
Valid only for Extended Frames.
For Standard Frames, reads from this field return 0s
For Standard Frames, writes to this field should be 0s</description>
                </bitField>
                <bitField access="Read Only" enumerationId="RXFIFO_ID_RTR_ENUM" high_bit="0" low_bit="0" name="RTR">
                    <gui_name language="en">RTR</gui_name>
                    <description language="en">Remote Transmission Request
This bit differentiates between data frames and
remote frames.
Valid only for Extended Frames.
1 = Indicates the message object is a Remote Frame
0 = Indicates the message object is a Data Frame
For Standard Frames, reads from this bit returns 0
For Standard Frames, writes to this bit should be 0</description>
                </bitField>
            </register>
            <register name="CAN0_RXFIFO_DLC" offset="0xe0008054" size="0x4">
                <gui_name language="en">RXFIFO_DLC</gui_name>
                <description language="en">receive message fifo data length code</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="DLC">
                    <gui_name language="en">DLC</gui_name>
                    <description language="en">Data Length Code
This is the data length portion of the control field of
the CAN frame. This indicates the number valid data
bytes in Data Word 1 and Data Word 2 registers.</description>
                </bitField>
            </register>
            <register name="CAN0_RXFIFO_DATA1" offset="0xe0008058" size="0x4">
                <gui_name language="en">RXFIFO_DATA1</gui_name>
                <description language="en">receive message fifo data word 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 0
Reads from this field return invalid data if the
message has no data.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 1
Reads from this field return invalid data if the
message has only 1 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 2
Reads from this field return invalid data if the
message has only 2 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 3
Reads from this field return invalid data if the
message has only 3 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN0_RXFIFO_DATA2" offset="0xe000805c" size="0x4">
                <gui_name language="en">RXFIFO_DATA2</gui_name>
                <description language="en">receive message fifo data word 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 4
Reads from this field return invalid data if the
message has only 4 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 5
Reads from this field return invalid data if the
message has only 5 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 6
Reads from this field return invalid data if the
message has only 6 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 7
Reads from this field return invalid data if the
message has 7 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN0_AFR" offset="0xe0008060" size="0x4">
                <gui_name language="en">AFR</gui_name>
                <description language="en">Acceptance Filter Register</description>
                <bitField access="Read Write" enumerationId="AFR_UAF4_ENUM" high_bit="3" low_bit="3" name="UAF4">
                    <gui_name language="en">UAF4</gui_name>
                    <description language="en">Use Acceptance Filter Number 4
Enables the use of acceptance filter pair 4.
1 = Indicates Acceptance Filter Mask Register 4 and
Acceptance Filter ID Register 4 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 4 and
Acceptance Filter ID Register 4 are not used for
acceptance filtering.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFR_UAF3_ENUM" high_bit="2" low_bit="2" name="UAF3">
                    <gui_name language="en">UAF3</gui_name>
                    <description language="en">Use Acceptance Filter Number 3
Enables the use of acceptance filter pair 3.
1 = Indicates Acceptance Filter Mask Register 3 and
Acceptance Filter ID Register 3 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 3 and
Acceptance Filter ID Register 3 are not used for
acceptance filtering.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFR_UAF2_ENUM" high_bit="1" low_bit="1" name="UAF2">
                    <gui_name language="en">UAF2</gui_name>
                    <description language="en">Use Acceptance Filter Number 2
Enables the use of acceptance filter pair 2.
1 = Indicates Acceptance Filter Mask Register 2 and
Acceptance Filter ID Register 2 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 2 and
Acceptance Filter ID Register 2 are not used for
acceptance filtering.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFR_UAF1_ENUM" high_bit="0" low_bit="0" name="UAF1">
                    <gui_name language="en">UAF1</gui_name>
                    <description language="en">Use Acceptance Filter Number 1.
Enables the use of acceptance filter pair 1.
1 = Indicates Acceptance Filter Mask Register 1 and
Acceptance Filter ID Register 1 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 1 and
Acceptance Filter ID Register 1 are not used for
acceptance filtering.</description>
                </bitField>
            </register>
            <register name="CAN0_AFMR1" offset="0xe0008064" size="0x4">
                <gui_name language="en">AFMR1</gui_name>
                <description language="en">Acceptance Filter Mask Register 1</description>
                <bitField access="Read Write" enumerationId="AFMR1_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN0_AFIR1" offset="0xe0008068" size="0x4">
                <gui_name language="en">AFIR1</gui_name>
                <description language="en">Acceptance Filter ID Register 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
            <register name="CAN0_AFMR2" offset="0xe000806c" size="0x4">
                <gui_name language="en">AFMR2</gui_name>
                <description language="en">Acceptance Filter Mask Register 2</description>
                <bitField access="Read Write" enumerationId="AFMR2_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN0_AFIR2" offset="0xe0008070" size="0x4">
                <gui_name language="en">AFIR2</gui_name>
                <description language="en">Acceptance Filter ID Register 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
            <register name="CAN0_AFMR3" offset="0xe0008074" size="0x4">
                <gui_name language="en">AFMR3</gui_name>
                <description language="en">Acceptance Filter Mask Register 3</description>
                <bitField access="Read Write" enumerationId="AFMR3_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN0_AFIR3" offset="0xe0008078" size="0x4">
                <gui_name language="en">AFIR3</gui_name>
                <description language="en">Acceptance Filter ID Register 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
            <register name="CAN0_AFMR4" offset="0xe000807c" size="0x4">
                <gui_name language="en">AFMR4</gui_name>
                <description language="en">Acceptance Filter Mask Register 4</description>
                <bitField access="Read Write" enumerationId="AFMR4_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN0_AFIR4" offset="0xe0008080" size="0x4">
                <gui_name language="en">AFIR4</gui_name>
                <description language="en">Acceptance Filter ID Register 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
        </peripheral>
                <peripheral address_type="Non-Secure" base_addr="M_CAN1" name="CAN1" offset="0xe0009000">
            <gui_name language="en">can1</gui_name>
            <description language="en">can1</description>
            <register name="CAN1_SRR" offset="0xe0009000" size="0x4">
                <gui_name language="en">SRR</gui_name>
                <description language="en">Software Reset Register</description>
                <bitField access="Read Write" enumerationId="SRR_CEN_ENUM" high_bit="1" low_bit="1" name="CEN">
                    <gui_name language="en">CEN</gui_name>
                    <description language="en">Can Enable
The Enable bit for the CAN controller.
1 = The CAN controller is in Loop Back, Sleep or Normal mode depending on the LBACK and SLEEP bits in the MSR.
0 = The CAN controller is in the Configuration mode.
If the CEN bit is changed during core operation, it is
recommended to reset the core so that operations start afresh.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="SRR_SRST_ENUM" high_bit="0" low_bit="0" name="SRST">
                    <gui_name language="en">SRST</gui_name>
                    <description language="en">Reset
The Software reset bit for the CAN controller.
1 = CAN controller is reset.
If a 1 is written to this bit, all the CAN controller configuration registers (including the SRR) are reset. Reads to this bit always return a 0.</description>
                </bitField>
            </register>
            <register name="CAN1_MSR" offset="0xe0009004" size="0x4">
                <gui_name language="en">MSR</gui_name>
                <description language="en">Mode Select Register</description>
                <bitField access="Read Write" enumerationId="MSR_SNOOP_ENUM" high_bit="2" low_bit="2" name="SNOOP">
                    <gui_name language="en">SNOOP</gui_name>
                    <description language="en">Snoop Mode Select
The Snoop Mode Select bit.
1 = CAN controller is in Snoop mode.
0 = CAN controller is in Normal, Loop Back, Configuration, or Sleep mode.
This bit can be written to only when CEN bit in SRR is 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MSR_LBACK_ENUM" high_bit="1" low_bit="1" name="LBACK">
                    <gui_name language="en">LBACK</gui_name>
                    <description language="en">Loop Back Mode Select
The Loop Back Mode Select bit.
1 = CAN controller is in Loop Back mode.
0 = CAN controller is in Normal, Snoop, Configuration, or Sleep mode.
This bit can be written to only when CEN bit in SRR is 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MSR_SLEEP_ENUM" high_bit="0" low_bit="0" name="SLEEP">
                    <gui_name language="en">SLEEP</gui_name>
                    <description language="en">Sleep Mode Select
The Sleep Mode select bit.
1 = CAN controller is in Sleep mode.
0 = CAN controller is in Normal, Snoop, Configuration or Loop Back mode.
This bit is cleared when the CAN controller wakes up from the Sleep mode.</description>
                </bitField>
            </register>
            <register name="CAN1_BRPR" offset="0xe0009008" size="0x4">
                <gui_name language="en">BRPR</gui_name>
                <description language="en">Baud Rate Prescaler Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="BRP">
                    <gui_name language="en">BRP</gui_name>
                    <description language="en">Baud Rate Prescaler
These bits indicate the prescaler value. The actual
value ranges from 1 to 256.</description>
                </bitField>
            </register>
            <register name="CAN1_BTR" offset="0xe000900c" size="0x4">
                <gui_name language="en">BTR</gui_name>
                <description language="en">Bit Timing Register</description>
                <bitField access="Read Write" high_bit="8" low_bit="7" name="SJW">
                    <gui_name language="en">SJW</gui_name>
                    <description language="en">Synchronization Jump Width
Indicates the Synchronization Jump Width as specified in the CAN 2.0A and CAN 2.0B standard. The actual value is one more than the value written to the register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="4" name="TS2">
                    <gui_name language="en">TS2</gui_name>
                    <description language="en">Time Segment 2
Indicates Phase Segment 2 as specified in the CAN 2.0A and CAN 2.0B standard. The actual value is one more than the value written to the register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="TS1">
                    <gui_name language="en">TS1</gui_name>
                    <description language="en">Time Segment 1
Indicates the Sum of Propagation Segment and Phase
Segment 1 as specified in the CAN 2.0A and CAN 2.0B
standard. The actual value is one more than the value
written to the register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="CAN1_ECR" offset="0xe0009010" size="0x4">
                <gui_name language="en">ECR</gui_name>
                <description language="en">Error Counter Register</description>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="REC">
                    <gui_name language="en">REC</gui_name>
                    <description language="en">Receive Error Counter
Indicates the Value of the Receive Error Counter.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="TEC">
                    <gui_name language="en">TEC</gui_name>
                    <description language="en">Transmit Error Counter
Indicates the Value of the Transmit Error Counter.</description>
                </bitField>
            </register>
            <register name="CAN1_ESR" offset="0xe0009014" size="0x4">
                <gui_name language="en">ESR</gui_name>
                <description language="en">Error Status Register</description>
                <bitField access="Read Write" enumerationId="ESR_ACKER_ENUM" high_bit="4" low_bit="4" name="ACKER">
                    <gui_name language="en">ACKER</gui_name>
                    <description language="en">ACK Error
Indicates an acknowledgement error.
1 = Indicates an acknowledgement error has
occurred.
0 = Indicates an acknowledgement error has not
occurred on the bus since the last write to this
register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_BERR_ENUM" high_bit="3" low_bit="3" name="BERR">
                    <gui_name language="en">BERR</gui_name>
                    <description language="en">Bit Error
Indicates the received bit is not the same as the
transmitted bit during bus communication.
1 = Indicates a bit error has occurred.
0 = Indicates a bit error has not occurred on the bus
since the last write to this register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_STER_ENUM" high_bit="2" low_bit="2" name="STER">
                    <gui_name language="en">STER</gui_name>
                    <description language="en">Stuff Error
Indicates an error if there is a stuffing violation.
1 = Indicates a stuff error has occurred.
0 = Indicates a stuff error has not occurred on the
bus since the last write to this register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_FMER_ENUM" high_bit="1" low_bit="1" name="FMER">
                    <gui_name language="en">FMER</gui_name>
                    <description language="en">Form Error
Indicates an error in one of the fixed form fields in the
message frame.
1 = Indicates a form error has occurred.
0 = Indicates a form error has not occurred on the
bus since the last write to this register.
If this bit is set, writing a 1 clears it.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ESR_CRCER_ENUM" high_bit="0" low_bit="0" name="CRCER">
                    <gui_name language="en">CRCER</gui_name>
                    <description language="en">CRC Error
Indicates a CRC error has occurred.
1 = Indicates a CRC error has occurred.
0 = Indicates a CRC error has not occurred on the
bus since the last write to this register.
If this bit is set, writing a 1 clears it.
In case of a CRC Error and a CRC delimiter corruption, only the FMER bit is set.</description>
                </bitField>
            </register>
            <register name="CAN1_SR" offset="0xe0009018" size="0x4">
                <gui_name language="en">SR</gui_name>
                <description language="en">Status Register</description>
                <bitField access="Read Only" enumerationId="SR_SNOOP_ENUM" high_bit="12" low_bit="12" name="SNOOP">
                    <gui_name language="en">SNOOP</gui_name>
                    <description language="en">Snoop Mode
Indicates the CAN controller is in Snoop Mode.
1 = Indicates the CAN controller is in Snoop Mode.
0 = Indicates the CAN controller is not in Snoop mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_ACFBSY_ENUM" high_bit="11" low_bit="11" name="ACFBSY">
                    <gui_name language="en">ACFBSY</gui_name>
                    <description language="en">Acceptance Filter Busy
This bit indicates that the Acceptance Filter Mask
Registers and the Acceptance Filter ID Registers
cannot be written to.
1 = Acceptance Filter Mask Registers and
Acceptance Filter ID Registers cannot be written
to.
0 = Acceptance Filter Mask Registers and the
Acceptance Filter ID Registers can be written to.
This bit exists only when the number of acceptance
filters is not 0
This bit is set when a 0 is written to any of the valid
UAF bits in the Acceptance Filter Register.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_TXFLL_ENUM" high_bit="10" low_bit="10" name="TXFLL">
                    <gui_name language="en">TXFLL</gui_name>
                    <description language="en">Transmit FIFO Full
Indicates that the TX FIFO is full.
1 = Indicates the TX FIFO is full.
0 = Indicates the TX FIFO is not full.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_TXBFLL_ENUM" high_bit="9" low_bit="9" name="TXBFLL">
                    <gui_name language="en">TXBFLL</gui_name>
                    <description language="en">High Priority Transmit Buffer Full
Indicates the High Priority Transmit Buffer is full.
1 = Indicates the High Priority Transmit Buffer is full.
0 = Indicates the High Priority Transmit Buffer is not full.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_ESTAT_ENUM" high_bit="8" low_bit="7" name="ESTAT">
                    <gui_name language="en">ESTAT</gui_name>
                    <description language="en">Error Status
Indicates the error status of the CAN controller.
00 = Indicates Configuration Mode (CONFIG = 1).
Error State is undefined.
01 = Indicates Error Active State.
11 = Indicates Error Passive State.
10 = Indicates Bus Off State.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_ERRWRN_ENUM" high_bit="6" low_bit="6" name="ERRWRN">
                    <gui_name language="en">ERRWRN</gui_name>
                    <description language="en">Error Warning
Indicates that either the Transmit Error counter or the
Receive Error counter has exceeded a value of 96.
1 = One or more error counters have a value greater
than or equal to 96.
0 = Neither of the error counters has a value greater
than or equal to 96.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_BBSY_ENUM" high_bit="5" low_bit="5" name="BBSY">
                    <gui_name language="en">BBSY</gui_name>
                    <description language="en">Bus Busy
Indicates the CAN bus status.
1 = Indicates that the CAN controller is either
receiving a message or transmitting a message.
0 = Indicates that the CAN controller is either in
Configuration mode or the bus is idle.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_BIDLE_ENUM" high_bit="4" low_bit="4" name="BIDLE">
                    <gui_name language="en">BIDLE</gui_name>
                    <description language="en">Bus Idle
Indicates the CAN bus status.
1 = Indicates no bus communication is taking place.
0 = Indicates the CAN controller is either in
Configuration mode or the bus is busy.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_NORMAL_ENUM" high_bit="3" low_bit="3" name="NORMAL">
                    <gui_name language="en">NORMAL</gui_name>
                    <description language="en">Normal Mode
Indicates the CAN controller is in Normal Mode.
1 = Indicates the CAN controller is in Normal Mode.
0 = Indicates the CAN controller is not in Normal
mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_SLEEP_ENUM" high_bit="2" low_bit="2" name="SLEEP">
                    <gui_name language="en">SLEEP</gui_name>
                    <description language="en">Sleep Mode
Indicates the CAN controller is in Sleep mode.
1 = Indicates the CAN controller is in Sleep mode.
0 = Indicates the CAN controller is not in Sleep mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_LBACK_ENUM" high_bit="1" low_bit="1" name="LBACK">
                    <gui_name language="en">LBACK</gui_name>
                    <description language="en">Loop Back Mode
Indicates the CAN controller is in Loop Back mode.
1 = Indicates the CAN controller is in Loop Back
mode.
0 = Indicates the CAN controller is not in Loop Back
mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="SR_CONFIG_ENUM" high_bit="0" low_bit="0" name="CONFIG">
                    <gui_name language="en">CONFIG</gui_name>
                    <description language="en">Configuration Mode Indicator
Indicates the CAN controller is in Configuration mode.
1 = Indicates the CAN controller is in Configuration
mode.
0 = Indicates the CAN controller is not in
Configuration mode.</description>
                </bitField>
            </register>
            <register name="CAN1_ISR" offset="0xe000901c" size="0x4">
                <gui_name language="en">ISR</gui_name>
                <description language="en">Interrupt Status Register</description>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="TXFEMP">
                    <gui_name language="en">TXFEMP</gui_name>
                    <description language="en">Transmit FIFO EmptyInterrupt
A 1 indicates that the Transmit FIFO is empty.
The interrupt continues to assert as long as the TX
FIFO is empty.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="TXFWMEMP">
                    <gui_name language="en">TXFWMEMP</gui_name>
                    <description language="en">Transmit FIFO Watermark Empty Interrupt
A 1 indicates that the TX FIFO is empty based on
watermark programming.
The interrupt continues to assert as long as the number
of empty spaces in the TX FIFO is greater than TX FIFO
empty watermark.
This bit can be cleared only by writing to the Interrupt
Clear Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="RXFWMFLL">
                    <gui_name language="en">RXFWMFLL</gui_name>
                    <description language="en">Receive FIFO Watermark Full Interrupt
A 1 indicates that the RX FIFO is full based on
watermark programming.
The interrupt continues to assert as long as the RX
FIFO count is above RX FIFO Full watermark.
This bit can be cleared only by writing to the Interrupt
Clear Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="WKUP">
                    <gui_name language="en">WKUP</gui_name>
                    <description language="en">Wake up Interrupt
A 1 indicates that the CAN controller entered Normal
mode from Sleep Mode.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN
bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="SLP">
                    <gui_name language="en">SLP</gui_name>
                    <description language="en">Sleep Interrupt
A 1 indicates that the CAN controller entered Sleep mode.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="BSOFF">
                    <gui_name language="en">BSOFF</gui_name>
                    <description language="en">Bus Off Interrupt
A 1 indicates that the CAN controller entered the Bus Off state.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="ERROR">
                    <gui_name language="en">ERROR</gui_name>
                    <description language="en">Error Interrupt
A 1 indicates that an error occurred during message transmission or reception.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="RXNEMP">
                    <gui_name language="en">RXNEMP</gui_name>
                    <description language="en">Receive FIFO Not Empty Interrupt
A 1 indicates that the Receive FIFO is not empty.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="RXOFLW">
                    <gui_name language="en">RXOFLW</gui_name>
                    <description language="en">RX FIFO Overflow Interrupt
A 1 indicates that a message has been lost. This condition occurs when a new message is being received and the Receive FIFO is Full.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="RXUFLW">
                    <gui_name language="en">RXUFLW</gui_name>
                    <description language="en">RX FIFO Underflow Interrupt
A 1 indicates that a read operation was attempted on an empty RX FIFO.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="RXOK">
                    <gui_name language="en">RXOK</gui_name>
                    <description language="en">New Message Received Interrupt
A 1 indicates that a message was received successfully and stored into the RX FIFO.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="TXBFLL">
                    <gui_name language="en">TXBFLL</gui_name>
                    <description language="en">High Priority Transmit Buffer Full Interrupt
A 1 indicates that the High Priority Transmit Buffer is full.
The status of the bit is unaffected if write transactions occur on the High Priority Transmit Buffer when it is already full.
This bit can be cleared only by writing to the ICR.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="TXFLL">
                    <gui_name language="en">TXFLL</gui_name>
                    <description language="en">Transmit FIFO Full Interrupt
A 1 indicates that the TX FIFO is full.
The status of the bit is unaffected if write transactions occur on the Transmit FIFO when it is already full.
This bit can be cleared only by writing to the Interrupt Clear Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="TXOK">
                    <gui_name language="en">TXOK</gui_name>
                    <description language="en">Transmission Successful Interrupt
A 1 indicates that a message was transmitted successfully.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
In Loop Back mode, both TXOK and RXOK bits are set. The RXOK bit is set before the TXOK bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ARBLST">
                    <gui_name language="en">ARBLST</gui_name>
                    <description language="en">Arbitration Lost Interrupt
A 1 indicates that arbitration was lost during message transmission.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.</description>
                </bitField>
            </register>
            <register name="CAN1_IER" offset="0xe0009020" size="0x4">
                <gui_name language="en">IER</gui_name>
                <description language="en">Interrupt Enable Register</description>
                <bitField access="Read Write" enumerationId="IER_ETXFEMP_ENUM" high_bit="14" low_bit="14" name="ETXFEMP">
                    <gui_name language="en">ETXFEMP</gui_name>
                    <description language="en">Enable TXFIFO Empty Interrupt
Writes to this bit enable or disable interrupts when the
TXFEMP bit in the ISR is set.
1 = Enable interrupt generation if TXFEMP bit in ISR is set.
0 = Disable interrupt generation if TXFEMP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXFWMEMP_ENUM" high_bit="13" low_bit="13" name="ETXFWMEMP">
                    <gui_name language="en">ETXFWMEMP</gui_name>
                    <description language="en">Enable TXFIFO watermark Empty Interrupt
Writes to this bit enable or disable interrupts when the
TXFWMEMP bit in the ISR is set.
1 = Enable interrupt generation if TXFWMEMP bit in ISR is set.
0 = Disable interrupt generation if TXFWMEMP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXFWMFLL_ENUM" high_bit="12" low_bit="12" name="ERXFWMFLL">
                    <gui_name language="en">ERXFWMFLL</gui_name>
                    <description language="en">Enable RXFIFO watermark Full Interrupt
Writes to this bit enable or disable interrupts when the RXFLL bit in the ISR is set.
1 = Enable interrupt generation if RXFWMFLL bit in ISR is set.
0 = Disable interrupt generation if RXFWMFLL bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EWKUP_ENUM" high_bit="11" low_bit="11" name="EWKUP">
                    <gui_name language="en">EWKUP</gui_name>
                    <description language="en">Enable Wake up Interrupt
Writes to this bit enable or disable interrupts when the
WKUP bit in the ISR is set.
1 = Enable interrupt generation if WKUP bit in ISR is set.
0 = Disable interrupt generation if WKUP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ESLP_ENUM" high_bit="10" low_bit="10" name="ESLP">
                    <gui_name language="en">ESLP</gui_name>
                    <description language="en">Enable Sleep Interrupt
Writes to this bit enable or disable interrupts when the
SLP bit in the ISR is set.
1 = Enable interrupt generation if SLP bit in ISR is set.
0 = Disable interrupt generation if SLP bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EBSOFF_ENUM" high_bit="9" low_bit="9" name="EBSOFF">
                    <gui_name language="en">EBSOFF</gui_name>
                    <description language="en">Enable Bus OFF Interrupt
Writes to this bit enable or disable interrupts when the
BSOFF bit in the ISR is set.
1 = Enable interrupt generation if BSOFF bit in ISR is set.
0 = Disable interrupt generation if BSOFF bit in ISR is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EERROR_ENUM" high_bit="8" low_bit="8" name="EERROR">
                    <gui_name language="en">EERROR</gui_name>
                    <description language="en">Enable Error Interrupt
Writes to this bit enable or disable interrupts when the
ERROR bit in the ISR is set.
1 = Enable interrupt generation if ERROR bit in ISR is
set.
0 = Disable interrupt generation if ERROR bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXNEMP_ENUM" high_bit="7" low_bit="7" name="ERXNEMP">
                    <gui_name language="en">ERXNEMP</gui_name>
                    <description language="en">Enable Receive FIFO Not Empty Interrupt
Writes to this bit enable or disable interrupts when the
RXNEMP bit in the ISR is set.
1 = Enable interrupt generation if RXNEMP bit in ISR is
set.
0 = Disable interrupt generation if RXNEMP bit in ISR
is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXOFLW_ENUM" high_bit="6" low_bit="6" name="ERXOFLW">
                    <gui_name language="en">ERXOFLW</gui_name>
                    <description language="en">Enable RX FIFO Overflow Interrupt
Writes to this bit enable or disable interrupts when the
RXOFLW bit in the ISR is set.
1 = Enable interrupt generation if RXOFLW bit in ISR is
set.
0 = Disable interrupt generation if RXOFLW bit in ISR
is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXUFLW_ENUM" high_bit="5" low_bit="5" name="ERXUFLW">
                    <gui_name language="en">ERXUFLW</gui_name>
                    <description language="en">Enable RX FIFO Underflow Interrupt
Writes to this bit enable or disable interrupts when the
RXUFLW bit in the ISR is set.
1 = Enable interrupt generation if RXUFLW bit in ISR is
set.
0 = Disable interrupt generation if RXUFLW bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ERXOK_ENUM" high_bit="4" low_bit="4" name="ERXOK">
                    <gui_name language="en">ERXOK</gui_name>
                    <description language="en">Enable New Message Received Interrupt
Writes to this bit enable or disable interrupts when the
RXOK bit in the ISR is set.
1 = Enable interrupt generation if RXOK bit in ISR is
set.
0 = Disable interrupt generation if RXOK bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXBFLL_ENUM" high_bit="3" low_bit="3" name="ETXBFLL">
                    <gui_name language="en">ETXBFLL</gui_name>
                    <description language="en">Enable High Priority Transmit Buffer Full Interrupt
Writes to this bit enable or disable interrupts when the
TXBFLL bit in the ISR is set.
1 = Enable interrupt generation if TXBFLL bit in ISR is
set.
0 = Disable interrupt generation if TXBFLL bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXFLL_ENUM" high_bit="2" low_bit="2" name="ETXFLL">
                    <gui_name language="en">ETXFLL</gui_name>
                    <description language="en">Enable Transmit FIFO Full Interrupt
Writes to this bit enable or disable interrupts when
TXFLL bit in the ISR is set.
1 = Enable interrupt generation if TXFLL bit in ISR is
set.
0 = Disable interrupt generation if TXFLL bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_ETXOK_ENUM" high_bit="1" low_bit="1" name="ETXOK">
                    <gui_name language="en">ETXOK</gui_name>
                    <description language="en">Enable Transmission Successful Interrupt
Writes to this bit enable or disable interrupts when the
TXOK bit in the ISR is set.
1 = Enable interrupt generation if TXOK bit in ISR is set.
0 = Disable interrupt generation if TXOK bit in ISR is
set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IER_EARBLST_ENUM" high_bit="0" low_bit="0" name="EARBLST">
                    <gui_name language="en">EARBLST</gui_name>
                    <description language="en">Enable Arbitration Lost Interrupt
Writes to this bit enable or disable interrupts when the
ARBLST bit in the ISR is set.
1 = Enable interrupt generation if ARBLST bit in ISR is
set.
0 = Disable interrupt generation if ARBLST bit in ISR is
set.</description>
                </bitField>
            </register>
            <register name="CAN1_ICR" offset="0xe0009024" size="0x4">
                <gui_name language="en">ICR</gui_name>
                <description language="en">Interrupt Clear Register</description>
                <bitField access="Write Only" high_bit="14" low_bit="14" name="CTXFEMP">
                    <gui_name language="en">CTXFEMP</gui_name>
                    <description language="en">Clear TXFIFO Empty Interrupt
Writing a 1 to this bit clears the TXFEMP bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="13" name="CTXFWMEMP">
                    <gui_name language="en">CTXFWMEMP</gui_name>
                    <description language="en">Clear TXFIFO Watermark Empty Interrupt
Writing a 1 to this bit clears the TXFWMEMP bit in
the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="CRXFWMFLL">
                    <gui_name language="en">CRXFWMFLL</gui_name>
                    <description language="en">Clear RXFIFO Watermark Full Interrupt
Writing a 1 to this bit clears the RXFWMFLL bit in
the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="CWKUP">
                    <gui_name language="en">CWKUP</gui_name>
                    <description language="en">Clear Wake up Interrupt
Writing a 1 to this bit clears the WKUP bit in the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="CSLP">
                    <gui_name language="en">CSLP</gui_name>
                    <description language="en">Clear Sleep Interrupt
Writing a 1 to this bit clears the SLP bit in the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="CBSOFF">
                    <gui_name language="en">CBSOFF</gui_name>
                    <description language="en">Clear Bus Off Interrupt
Writing a 1 to this bit clears the BSOFF bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="8" low_bit="8" name="CERROR">
                    <gui_name language="en">CERROR</gui_name>
                    <description language="en">Clear Error Interrupt
Writing a 1 to this bit clears the ERROR bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="7" name="CRXNEMP">
                    <gui_name language="en">CRXNEMP</gui_name>
                    <description language="en">Clear Receive FIFO Not Empty Interrupt
Writing a 1 to this bit clears the RXNEMP bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="CRXOFLW">
                    <gui_name language="en">CRXOFLW</gui_name>
                    <description language="en">Clear RX FIFO Overflow Interrupt
Writing a 1 to this bit clears the RXOFLW bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="CRXUFLW">
                    <gui_name language="en">CRXUFLW</gui_name>
                    <description language="en">Clear RX FIFO Underflow Interrupt
Writing a 1 to this bit clears the RXUFLW bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="CRXOK">
                    <gui_name language="en">CRXOK</gui_name>
                    <description language="en">Clear New Message Received Interrupt
Writing a 1 to this bit clears the RXOK bit in the ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="CTXBFLL">
                    <gui_name language="en">CTXBFLL</gui_name>
                    <description language="en">Clear High Priority Transmit Buffer Full Interrupt
Writing a 1 to this bit clears the TXBFLL bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="CTXFLL">
                    <gui_name language="en">CTXFLL</gui_name>
                    <description language="en">Clear Transmit FIFO Full Interrupt
Writing a 1 to this bit clears the TXFLL bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="CTXOK">
                    <gui_name language="en">CTXOK</gui_name>
                    <description language="en">Clear Arbitration Lost Interrupt
Writing a 1 to this bit clears the ARBLST bit in the
ISR.</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="CARBLST">
                    <gui_name language="en">CARBLST</gui_name>
                    <description language="en">Clear Arbitration Lost Interrupt
Writing a 1 to this bit clears the ARBLST bit in the
ISR.</description>
                </bitField>
            </register>
            <register name="CAN1_TCR" offset="0xe0009028" size="0x4">
                <gui_name language="en">TCR</gui_name>
                <description language="en">Timestamp Control Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="CTS">
                    <gui_name language="en">CTS</gui_name>
                    <description language="en">Clear Timestamp
Internal free running counter is cleared to 0 when
CTS=1. This bit only needs to be written once with a 1
to clear the counter. The bit will automatically return to
0.</description>
                </bitField>
            </register>
            <register name="CAN1_WIR" offset="0xe000902c" size="0x4">
                <gui_name language="en">WIR</gui_name>
                <description language="en">Watermark Interrupt Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="EW">
                    <gui_name language="en">EW</gui_name>
                    <description language="en">TXFIFO Empty watermark
TXFIFO generates an EMPTY interrupt based on the
value programmed in this field. The valid range is
(1-63). Only bits 18-23 are writable. No protection is
given for illegal programming in this field.
This field can be written to only when CEN bit in SRR is
0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="FW">
                    <gui_name language="en">FW</gui_name>
                    <description language="en">RXFIFO Full watermark
RXFIFO generates FULL interrupt based on the value
programmed in this field. The valid range is (1-63). Only
bits 26-31 are writable. No protection is given for illegal
programming in this field. This field can be written to
only when CEN bit in SRR is 0.</description>
                </bitField>
            </register>
            <register access="Write Only" name="CAN1_TXFIFO_ID" offset="0xe0009030" size="0x4">
                <gui_name language="en">TXFIFO_ID</gui_name>
                <description language="en">transmit message fifo message identifier</description>
                <bitField access="Write Only" high_bit="31" low_bit="21" name="IDH">
                    <gui_name language="en">IDH</gui_name>
                    <description language="en">Standard Message ID
The Identifier portion for a Standard Frame is 11 bits.
These bits indicate the Standard Frame ID.
This field is valid for both Standard and Extended
Frames.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXFIFO_ID_SRRRTR_ENUM" high_bit="20" low_bit="20" name="SRRRTR">
                    <gui_name language="en">SRRRTR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
This bit differentiates between data frames and
remote frames. Valid only for Standard Frames. For
Extended frames this bit is 1.
1 = Indicates that the message frame is a Remote
Frame.
0 = Indicates that the message frame is a Data
Frame.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXFIFO_ID_IDE_ENUM" high_bit="19" low_bit="19" name="IDE">
                    <gui_name language="en">IDE</gui_name>
                    <description language="en">Identifier Extension
This bit differentiates between frames using the
Standard Identifier and those using the Extended
Identifier. Valid for both Standard and Extended
Frames.
1 = Indicates the use of an Extended Message
Identifier.
0= Indicates the use of a Standard Message
Identifier.</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="1" name="IDL">
                    <gui_name language="en">IDL</gui_name>
                    <description language="en">Extended Message ID
This field indicates the Extended Identifier.
Valid only for Extended Frames.
For Standard Frames, reads from this field return 0s
For Standard Frames, writes to this field should be 0s</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXFIFO_ID_RTR_ENUM" high_bit="0" low_bit="0" name="RTR">
                    <gui_name language="en">RTR</gui_name>
                    <description language="en">Remote Transmission Request
This bit differentiates between data frames and
remote frames.
Valid only for Extended Frames.
1 = Indicates the message object is a Remote Frame
0 = Indicates the message object is a Data Frame
For Standard Frames, reads from this bit returns 0
For Standard Frames, writes to this bit should be 0</description>
                </bitField>
            </register>
            <register name="CAN1_TXFIFO_DLC" offset="0xe0009034" size="0x4">
                <gui_name language="en">TXFIFO_DLC</gui_name>
                <description language="en">transmit message fifo data length code</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="DLC">
                    <gui_name language="en">DLC</gui_name>
                    <description language="en">Data Length Code
This is the data length portion of the control field of
the CAN frame. This indicates the number valid data
bytes in Data Word 1 and Data Word 2 registers.</description>
                </bitField>
            </register>
            <register name="CAN1_TXFIFO_DATA1" offset="0xe0009038" size="0x4">
                <gui_name language="en">TXFIFO_DATA1</gui_name>
                <description language="en">transmit message fifo data word 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 0
Reads from this field return invalid data if the
message has no data.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 1
Reads from this field return invalid data if the
message has only 1 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 2
Reads from this field return invalid data if the
message has only 2 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 3
Reads from this field return invalid data if the
message has only 3 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN1_TXFIFO_DATA2" offset="0xe000903c" size="0x4">
                <gui_name language="en">TXFIFO_DATA2</gui_name>
                <description language="en">transmit message fifo data word 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 4
Reads from this field return invalid data if the
message has only 4 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 5
Reads from this field return invalid data if the
message has only 5 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 6
Reads from this field return invalid data if the
message has only 6 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 7
Reads from this field return invalid data if the
message has 7 byte of data or fewer</description>
                </bitField>
            </register>
            <register access="Write Only" name="CAN1_TXHPB_ID" offset="0xe0009040" size="0x4">
                <gui_name language="en">TXHPB_ID</gui_name>
                <description language="en">transmit high priority buffer message identifier</description>
                <bitField access="Write Only" high_bit="31" low_bit="21" name="IDH">
                    <gui_name language="en">IDH</gui_name>
                    <description language="en">Standard Message ID
The Identifier portion for a Standard Frame is 11 bits.
These bits indicate the Standard Frame ID.
This field is valid for both Standard and Extended
Frames.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXHPB_ID_SRRRTR_ENUM" high_bit="20" low_bit="20" name="SRRRTR">
                    <gui_name language="en">SRRRTR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
This bit differentiates between data frames and
remote frames. Valid only for Standard Frames. For
Extended frames this bit is 1.
1 = Indicates that the message frame is a Remote
Frame.
0 = Indicates that the message frame is a Data
Frame.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXHPB_ID_IDE_ENUM" high_bit="19" low_bit="19" name="IDE">
                    <gui_name language="en">IDE</gui_name>
                    <description language="en">Identifier Extension
This bit differentiates between frames using the
Standard Identifier and those using the Extended
Identifier. Valid for both Standard and Extended
Frames.
1 = Indicates the use of an Extended Message
Identifier.
0= Indicates the use of a Standard Message
Identifier.</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="1" name="IDL">
                    <gui_name language="en">IDL</gui_name>
                    <description language="en">Extended Message ID
This field indicates the Extended Identifier.
Valid only for Extended Frames.
For Standard Frames, reads from this field return 0s
For Standard Frames, writes to this field should be 0s</description>
                </bitField>
                <bitField access="Write Only" enumerationId="TXHPB_ID_RTR_ENUM" high_bit="0" low_bit="0" name="RTR">
                    <gui_name language="en">RTR</gui_name>
                    <description language="en">Remote Transmission Request
This bit differentiates between data frames and
remote frames.
Valid only for Extended Frames.
1 = Indicates the message object is a Remote Frame
0 = Indicates the message object is a Data Frame
For Standard Frames, reads from this bit returns 0
For Standard Frames, writes to this bit should be 0</description>
                </bitField>
            </register>
            <register name="CAN1_TXHPB_DLC" offset="0xe0009044" size="0x4">
                <gui_name language="en">TXHPB_DLC</gui_name>
                <description language="en">transmit high priority buffer data length code</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="DLC">
                    <gui_name language="en">DLC</gui_name>
                    <description language="en">Data Length Code
This is the data length portion of the control field of
the CAN frame. This indicates the number valid data
bytes in Data Word 1 and Data Word 2 registers.</description>
                </bitField>
            </register>
            <register name="CAN1_TXHPB_DATA1" offset="0xe0009048" size="0x4">
                <gui_name language="en">TXHPB_DATA1</gui_name>
                <description language="en">transmit high priority buffer data word 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 0
Reads from this field return invalid data if the
message has no data.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 1
Reads from this field return invalid data if the
message has only 1 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 2
Reads from this field return invalid data if the
message has only 2 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 3
Reads from this field return invalid data if the
message has only 3 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN1_TXHPB_DATA2" offset="0xe000904c" size="0x4">
                <gui_name language="en">TXHPB_DATA2</gui_name>
                <description language="en">transmit high priority buffer data word 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 4
Reads from this field return invalid data if the
message has only 4 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 5
Reads from this field return invalid data if the
message has only 5 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 6
Reads from this field return invalid data if the
message has only 6 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 7
Reads from this field return invalid data if the
message has 7 byte of data or fewer</description>
                </bitField>
            </register>
            <register access="Read Only" name="CAN1_RXFIFO_ID" offset="0xe0009050" size="0x4">
                <gui_name language="en">RXFIFO_ID</gui_name>
                <description language="en">receive message fifo message identifier</description>
                <bitField access="Read Only" high_bit="31" low_bit="21" name="IDH">
                    <gui_name language="en">IDH</gui_name>
                    <description language="en">Standard Message ID
The Identifier portion for a Standard Frame is 11 bits.
These bits indicate the Standard Frame ID.
This field is valid for both Standard and Extended
Frames.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="RXFIFO_ID_SRRRTR_ENUM" high_bit="20" low_bit="20" name="SRRRTR">
                    <gui_name language="en">SRRRTR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
This bit differentiates between data frames and
remote frames. Valid only for Standard Frames. For
Extended frames this bit is 1.
1 = Indicates that the message frame is a Remote
Frame.
0 = Indicates that the message frame is a Data
Frame.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="RXFIFO_ID_IDE_ENUM" high_bit="19" low_bit="19" name="IDE">
                    <gui_name language="en">IDE</gui_name>
                    <description language="en">Identifier Extension
This bit differentiates between frames using the
Standard Identifier and those using the Extended
Identifier. Valid for both Standard and Extended
Frames.
1 = Indicates the use of an Extended Message
Identifier.
0= Indicates the use of a Standard Message
Identifier.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="1" name="IDL">
                    <gui_name language="en">IDL</gui_name>
                    <description language="en">Extended Message ID
This field indicates the Extended Identifier.
Valid only for Extended Frames.
For Standard Frames, reads from this field return 0s
For Standard Frames, writes to this field should be 0s</description>
                </bitField>
                <bitField access="Read Only" enumerationId="RXFIFO_ID_RTR_ENUM" high_bit="0" low_bit="0" name="RTR">
                    <gui_name language="en">RTR</gui_name>
                    <description language="en">Remote Transmission Request
This bit differentiates between data frames and
remote frames.
Valid only for Extended Frames.
1 = Indicates the message object is a Remote Frame
0 = Indicates the message object is a Data Frame
For Standard Frames, reads from this bit returns 0
For Standard Frames, writes to this bit should be 0</description>
                </bitField>
            </register>
            <register name="CAN1_RXFIFO_DLC" offset="0xe0009054" size="0x4">
                <gui_name language="en">RXFIFO_DLC</gui_name>
                <description language="en">receive message fifo data length code</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="DLC">
                    <gui_name language="en">DLC</gui_name>
                    <description language="en">Data Length Code
This is the data length portion of the control field of
the CAN frame. This indicates the number valid data
bytes in Data Word 1 and Data Word 2 registers.</description>
                </bitField>
            </register>
            <register name="CAN1_RXFIFO_DATA1" offset="0xe0009058" size="0x4">
                <gui_name language="en">RXFIFO_DATA1</gui_name>
                <description language="en">receive message fifo data word 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 0
Reads from this field return invalid data if the
message has no data.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 1
Reads from this field return invalid data if the
message has only 1 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 2
Reads from this field return invalid data if the
message has only 2 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 3
Reads from this field return invalid data if the
message has only 3 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN1_RXFIFO_DATA2" offset="0xe000905c" size="0x4">
                <gui_name language="en">RXFIFO_DATA2</gui_name>
                <description language="en">receive message fifo data word 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="DB0">
                    <gui_name language="en">DB0</gui_name>
                    <description language="en">Data Byte 4
Reads from this field return invalid data if the
message has only 4 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="DB1">
                    <gui_name language="en">DB1</gui_name>
                    <description language="en">Data Byte 5
Reads from this field return invalid data if the
message has only 5 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="DB2">
                    <gui_name language="en">DB2</gui_name>
                    <description language="en">Data Byte 6
Reads from this field return invalid data if the
message has only 6 byte of data or fewer</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="DB3">
                    <gui_name language="en">DB3</gui_name>
                    <description language="en">Data Byte 7
Reads from this field return invalid data if the
message has 7 byte of data or fewer</description>
                </bitField>
            </register>
            <register name="CAN1_AFR" offset="0xe0009060" size="0x4">
                <gui_name language="en">AFR</gui_name>
                <description language="en">Acceptance Filter Register</description>
                <bitField access="Read Write" enumerationId="AFR_UAF4_ENUM" high_bit="3" low_bit="3" name="UAF4">
                    <gui_name language="en">UAF4</gui_name>
                    <description language="en">Use Acceptance Filter Number 4
Enables the use of acceptance filter pair 4.
1 = Indicates Acceptance Filter Mask Register 4 and
Acceptance Filter ID Register 4 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 4 and
Acceptance Filter ID Register 4 are not used for
acceptance filtering.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFR_UAF3_ENUM" high_bit="2" low_bit="2" name="UAF3">
                    <gui_name language="en">UAF3</gui_name>
                    <description language="en">Use Acceptance Filter Number 3
Enables the use of acceptance filter pair 3.
1 = Indicates Acceptance Filter Mask Register 3 and
Acceptance Filter ID Register 3 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 3 and
Acceptance Filter ID Register 3 are not used for
acceptance filtering.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFR_UAF2_ENUM" high_bit="1" low_bit="1" name="UAF2">
                    <gui_name language="en">UAF2</gui_name>
                    <description language="en">Use Acceptance Filter Number 2
Enables the use of acceptance filter pair 2.
1 = Indicates Acceptance Filter Mask Register 2 and
Acceptance Filter ID Register 2 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 2 and
Acceptance Filter ID Register 2 are not used for
acceptance filtering.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFR_UAF1_ENUM" high_bit="0" low_bit="0" name="UAF1">
                    <gui_name language="en">UAF1</gui_name>
                    <description language="en">Use Acceptance Filter Number 1.
Enables the use of acceptance filter pair 1.
1 = Indicates Acceptance Filter Mask Register 1 and
Acceptance Filter ID Register 1 are used for
acceptance filtering.
0 = Indicates Acceptance Filter Mask Register 1 and
Acceptance Filter ID Register 1 are not used for
acceptance filtering.</description>
                </bitField>
            </register>
            <register name="CAN1_AFMR1" offset="0xe0009064" size="0x4">
                <gui_name language="en">AFMR1</gui_name>
                <description language="en">Acceptance Filter Mask Register 1</description>
                <bitField access="Read Write" enumerationId="AFMR1_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR1_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN1_AFIR1" offset="0xe0009068" size="0x4">
                <gui_name language="en">AFIR1</gui_name>
                <description language="en">Acceptance Filter ID Register 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
            <register name="CAN1_AFMR2" offset="0xe000906c" size="0x4">
                <gui_name language="en">AFMR2</gui_name>
                <description language="en">Acceptance Filter Mask Register 2</description>
                <bitField access="Read Write" enumerationId="AFMR2_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR2_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN1_AFIR2" offset="0xe0009070" size="0x4">
                <gui_name language="en">AFIR2</gui_name>
                <description language="en">Acceptance Filter ID Register 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
            <register name="CAN1_AFMR3" offset="0xe0009074" size="0x4">
                <gui_name language="en">AFMR3</gui_name>
                <description language="en">Acceptance Filter Mask Register 3</description>
                <bitField access="Read Write" enumerationId="AFMR3_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR3_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN1_AFIR3" offset="0xe0009078" size="0x4">
                <gui_name language="en">AFIR3</gui_name>
                <description language="en">Acceptance Filter ID Register 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
            <register name="CAN1_AFMR4" offset="0xe000907c" size="0x4">
                <gui_name language="en">AFMR4</gui_name>
                <description language="en">Acceptance Filter Mask Register 4</description>
                <bitField access="Read Write" enumerationId="AFMR4_AMIDH_ENUM" high_bit="31" low_bit="21" name="AMIDH">
                    <gui_name language="en">AMIDH</gui_name>
                    <description language="en">Standard Message ID Mask
These bits are used for masking the Identifier in a
Standard Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMSRR_ENUM" high_bit="20" low_bit="20" name="AMSRR">
                    <gui_name language="en">AMSRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request Mask
This bit is used for masking the RTR bit in a Standard
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMIDE_ENUM" high_bit="19" low_bit="19" name="AMIDE">
                    <gui_name language="en">AMIDE</gui_name>
                    <description language="en">Identifier Extension Mask
Used for masking the IDE bit in CAN frames.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 0, this mask is applicable to
only Standard frames.
If AMIDE = 1 and the AIIDE bit in the corresponding
Acceptance ID register is 1, this mask is applicable to
only extended frames.
If AMIDE = 0 this mask is applicable to Standard
frame.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMIDL_ENUM" high_bit="18" low_bit="1" name="AMIDL">
                    <gui_name language="en">AMIDL</gui_name>
                    <description language="en">Extended Message ID Mask
These bits are used for masking the Identifier in an
Extended Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="AFMR4_AMRTR_ENUM" high_bit="0" low_bit="0" name="AMRTR">
                    <gui_name language="en">AMRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask.
This bit is used for masking the RTR bit in an Extended
Frame.
1= Indicates the corresponding bit in Acceptance
Mask ID Register is used when comparing the
incoming message identifier.
0 = Indicates the corresponding bit in Acceptance
Mask ID Register is not used when comparing the
incoming message identifier.</description>
                </bitField>
            </register>
            <register name="CAN1_AFIR4" offset="0xe0009080" size="0x4">
                <gui_name language="en">AFIR4</gui_name>
                <description language="en">Acceptance Filter ID Register 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="21" name="AIIDH">
                    <gui_name language="en">AIIDH</gui_name>
                    <description language="en">Standard Message ID
Standard Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AISRR">
                    <gui_name language="en">AISRR</gui_name>
                    <description language="en">Substitute Remote Transmission Request
Indicates the Remote Transmission Request bit for
Standard frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="AIIDE">
                    <gui_name language="en">AIIDE</gui_name>
                    <description language="en">Identifier Extension
Differentiates between Standard and Extended
frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="1" name="AIIDL">
                    <gui_name language="en">AIIDL</gui_name>
                    <description language="en">Extended Message ID Mask
Extended Identifier</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AIRTR">
                    <gui_name language="en">AIRTR</gui_name>
                    <description language="en">Remote Transmission Request Mask
RTR bit for Extended frames.</description>
                </bitField>
            </register>
        </peripheral>  
        <peripheral address_type="Non-Secure" base_addr="M_DDRC" name="DDRC" offset="0xf8006000">
            <gui_name language="en">ddrc</gui_name>
            <description language="en">ddrc</description>
            <register name="DDRC_CTRL" offset="0xf8006000" size="0x4">
                <gui_name language="en">ddrc_ctrl</gui_name>
                <description language="en">DDRC Control Register</description>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_dis_auto_refresh_ENUM" high_bit="16" low_bit="16" name="reg_ddrc_dis_auto_refresh">
                    <gui_name language="en">reg_ddrc_dis_auto_refresh</gui_name>
                    <description language="en">Disable auto-refresh.
0 = do not disable auto-refresh generated by the controller. This input is changeable on the fly.
1 = disable auto-refresh generated by the controller. This input is changeable on the fly.
Note: When this transitions from 0 to 1, any pending refreshes will be immediately scheduled by the controller.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_dis_act_bypass_ENUM" high_bit="15" low_bit="15" name="reg_ddrc_dis_act_bypass">
                    <gui_name language="en">reg_ddrc_dis_act_bypass</gui_name>
                    <description language="en">Only present in designs supporting activate bypass. For Debug only.
0 = Do not disable bypass path for high priority read activates.
1 = disable bypass path for high priority read activates.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_dis_rd_bypass_ENUM" high_bit="14" low_bit="14" name="reg_ddrc_dis_rd_bypass">
                    <gui_name language="en">reg_ddrc_dis_rd_bypass</gui_name>
                    <description language="en">Only present in designs supporting read bypass. For Debug only.
0 = Do not disable bypass path for high priority read page hits.
1 = disable bypass path for high priority read page hits.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="7" name="reg_ddrc_rdwr_idle_gap">
                    <gui_name language="en">reg_ddrc_rdwr_idle_gap</gui_name>
                    <description language="en">When the preferred transaction store is empty for this many clock cycles, switch to the alternate transaction store if it is non-empty. The read transaction store (both high and low priority) is the default preferred transaction store and the write transaction store is the alternate store. When 'Prefer write over read' is set this is reversed.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_burst8_refresh_ENUM" high_bit="6" low_bit="4" name="reg_ddrc_burst8_refresh">
                    <gui_name language="en">reg_ddrc_burst8_refresh</gui_name>
                    <description language="en">Refresh timeout register. Programmed value plus one will be the number of refresh timeouts that will be allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes; therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for burst_of_N_refresh slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.
0 = single refresh
1 = burst-of-2
.
7 = burst-of-8 refresh</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_data_bus_width_ENUM" high_bit="3" low_bit="2" name="reg_ddrc_data_bus_width">
                    <gui_name language="en">reg_ddrc_data_bus_width</gui_name>
                    <description language="en">DDR bus width control
00 = 32 bit DDR bus
01 = 16 bit DDR bus
1x = reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_powerdown_en_ENUM" high_bit="1" low_bit="1" name="reg_ddrc_powerdown_en">
                    <gui_name language="en">reg_ddrc_powerdown_en</gui_name>
                    <description language="en">Controller power down control.
0 = DDRC powerdown disabled
1 = the controller goes into power down after a programmable number of cycles 'Maximum idle clocks before power down' (reg_ddrc_powerdown_to_x32).
Note: This register bit may be reprogrammed during the course of normal operation.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ddrc_ctrl_reg_ddrc_soft_rstb_ENUM" high_bit="0" low_bit="0" name="reg_ddrc_soft_rstb">
                    <gui_name language="en">reg_ddrc_soft_rstb</gui_name>
                    <description language="en">Active low soft reset.
0 = Resets the controller
1 = Takes the controller out of reset
Note: Controller must be taken out of reset only after all other registers have been programmed.</description>
                </bitField>
            </register>
            <register name="DDRC_TWO_RANK_CFG" offset="0xf8006004" size="0x4">
                <gui_name language="en">Two_rank_cfg</gui_name>
                <description language="en">Two rank configuration register</description>
                <bitField access="Read Write" enumerationId="Two_rank_cfg_reg_ddrc_addrmap_4bank_ram_ENUM" high_bit="28" low_bit="28" name="reg_ddrc_addrmap_4bank_ram">
                    <gui_name language="en">reg_ddrc_addrmap_4bank_ram</gui_name>
                    <description language="en">Only present if MEMC_SIMPLE_ADDR_MAP is defined.
Since MEMC_SIMPLE_ADDR_MAP is not defined, Reserved
1 = Set the address map for 4 Bank RAMs</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Two_rank_cfg_reg_ddrc_addrmap_open_bank_ENUM" high_bit="27" low_bit="27" name="reg_ddrc_addrmap_open_bank">
                    <gui_name language="en">reg_ddrc_addrmap_open_bank</gui_name>
                    <description language="en">Only present if MEMC_SIMPLE_ADDR_MAP is defined.
Since MEMC_SIMPLE_ADDR_MAP is not defined, Reserved
1 = Set the address map to Open Bank mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Two_rank_cfg_reg_ddrc_addrmap_cs_bit1_ENUM" high_bit="26" low_bit="22" name="reg_ddrc_addrmap_cs_bit1">
                    <gui_name language="en">reg_ddrc_addrmap_cs_bit1</gui_name>
                    <description language="en">Only present for multi-rank configurations.
Selects the address bit used as rank address bit 1.
Valid Range: 0 to 25, and 31
Internal Base: 10
The selected address bit is determined by adding the Internal Base to the value of this field. If set to 31, rank address bit 1 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Two_rank_cfg_reg_ddrc_diff_rank_rd_2cycle_gap_ENUM" high_bit="21" low_bit="21" name="reg_ddrc_diff_rank_rd_2cycle_gap">
                    <gui_name language="en">reg_ddrc_diff_rank_rd_2cycle_gap</gui_name>
                    <description language="en">Only present for multi-rank configurations. The two cycle gap is required for mDDR only, due to the large variance in tDQSCK in mDDR.
0 = schedule a 1-cycle gap in data responses when performing consecutive reads to different ranks
1 = schedule 2 cycle gap for the same</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Two_rank_cfg_reg_ddrc_wr_odt_block_ENUM" high_bit="20" low_bit="19" name="reg_ddrc_wr_odt_block">
                    <gui_name language="en">reg_ddrc_wr_odt_block</gui_name>
                    <description language="en">00 = block read/write scheduling for 1-cycle when
Write requires changing ODT settings
01 = block read/write scheduling for 2 cycles when Write requires changing ODT settings
10 = block read/write scheduling for 3 cycles when Write requires changing ODT settings
11 = Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="14" name="reg_ddrc_addrmap_cs_bit0">
                    <gui_name language="en">reg_ddrc_addrmap_cs_bit0</gui_name>
                    <description language="en">Only present for multi-rank configurations.
Selects the address bit used as rank address bit 0.
Valid Range: 0 to 25, and 31
Internal Base: 9. The selected address bit is determined by adding the Internal Base to the value of this field.
If set to 31, rank address bit 0 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Two_rank_cfg_reg_ddrc_active_ranks_ENUM" high_bit="13" low_bit="12" name="reg_ddrc_active_ranks">
                    <gui_name language="en">reg_ddrc_active_ranks</gui_name>
                    <description language="en">Only present for multi-rank configurations.
Each bit represents one rank.
1=populated; 0=unpopulated
01 = One Rank
11 = Two Ranks
Others = Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="reg_ddrc_t_rfc_nom_x32">
                    <gui_name language="en">reg_ddrc_t_rfc_nom_x32</gui_name>
                    <description language="en">tREFI - Average time between refreshes. Unit: in multiples of 32 clocks.
DRAM RELATED.
Default value is set for DDR3.</description>
                </bitField>
            </register>
            <register name="DDRC_HPR_REG" offset="0xf8006008" size="0x4">
                <gui_name language="en">HPR_reg</gui_name>
                <description language="en">HPR Queue control register</description>
                <bitField access="Read Write" high_bit="25" low_bit="22" name="reg_ddrc_hpr_xact_run_length">
                    <gui_name language="en">reg_ddrc_hpr_xact_run_length</gui_name>
                    <description language="en">Number of transactions that will be serviced once the HPR queue goes critical is the smaller of this number and the number of transactions available.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="11" name="reg_ddrc_hpr_max_starve_x32">
                    <gui_name language="en">reg_ddrc_hpr_max_starve_x32</gui_name>
                    <description language="en">Number of clocks that the HPR queue can be starved
before it goes critical.
Unit: 32 clocks</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_ddrc_hpr_min_non_critical_x32">
                    <gui_name language="en">reg_ddrc_hpr_min_non_critical_x32</gui_name>
                    <description language="en">Number of clocks that the HPR queue is guaranteed to
be non-critical.
Unit: 32 clocks</description>
                </bitField>
            </register>
            <register name="DDRC_LPR_REG" offset="0xf800600c" size="0x4">
                <gui_name language="en">LPR_reg</gui_name>
                <description language="en">LPR Queue control register</description>
                <bitField access="Read Write" high_bit="25" low_bit="22" name="reg_ddrc_lpr_xact_run_length">
                    <gui_name language="en">reg_ddrc_lpr_xact_run_length</gui_name>
                    <description language="en">Number of transactions that will be serviced once the LPR queue goes critical is the smaller of this number and the number of transactions available</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="11" name="reg_ddrc_lpr_max_starve_x32">
                    <gui_name language="en">reg_ddrc_lpr_max_starve_x32</gui_name>
                    <description language="en">Number of clocks that the LPR queue can be starved before it goes critical.
Unit: 32 clocks</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_ddrc_lpr_min_non_critical_x32">
                    <gui_name language="en">reg_ddrc_lpr_min_non_critical_x32</gui_name>
                    <description language="en">Number of clocks that the LPR queue is guaranteed to be non-critical.
Unit: 32 clocks</description>
                </bitField>
            </register>
            <register name="DDRC_WR_REG" offset="0xf8006010" size="0x4">
                <gui_name language="en">WR_reg</gui_name>
                <description language="en">WR Queue control register</description>
                <bitField access="Read Write" high_bit="25" low_bit="15" name="reg_ddrc_w_max_starve_x32">
                    <gui_name language="en">reg_ddrc_w_max_starve_x32</gui_name>
                    <description language="en">Number of clocks that the Write queue can be starved before it goes critical.
Unit: 32 clocks.
FOR PERFORMANCE ONLY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="11" name="reg_ddrc_w_xact_run_length">
                    <gui_name language="en">reg_ddrc_w_xact_run_length</gui_name>
                    <description language="en">Number of transactions that will be serviced once the WR queue goes critical is the smaller of this number and the number of transactions available</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_ddrc_w_min_non_critical_x32">
                    <gui_name language="en">reg_ddrc_w_min_non_critical_x32</gui_name>
                    <description language="en">Number of clock cycles that the WR queue is
guaranteed to be non-critical.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_PARAM_REG0" offset="0xf8006014" size="0x4">
                <gui_name language="en">DRAM_param_reg0</gui_name>
                <description language="en">DRAM Parameters register 0</description>
                <bitField access="Read Write" high_bit="20" low_bit="14" name="reg_ddrc_post_selfref_gap_x32">
                    <gui_name language="en">reg_ddrc_post_selfref_gap_x32</gui_name>
                    <description language="en">Minimum time to wait after coming out of self refresh before doing anything. This must be bigger than all the constraints that exist. (spec: Maximum of tXSNR and tXSRD and tXSDLL which is 512 clocks).
Unit: in multiples of 32 clocks
DRAM RELATED</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="6" name="reg_ddrc_t_rfc_min">
                    <gui_name language="en">reg_ddrc_t_rfc_min</gui_name>
                    <description language="en">tRFC(min) - Minimum time from refresh to refresh or activate (spec: 75ns to 195ns).
DRAM RELATED.
Default value is set for DDR3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="reg_ddrc_t_rc">
                    <gui_name language="en">reg_ddrc_t_rc</gui_name>
                    <description language="en">tRC - Min time between activates to same bank (spec: 65 ns for DDR2-400 and smaller for faster parts).
DRAM RELATED.
Default value is set for DDR3.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_PARAM_REG1" offset="0xf8006018" size="0x4">
                <gui_name language="en">DRAM_param_reg1</gui_name>
                <description language="en">DRAM Parameters register 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="reg_ddrc_t_cke">
                    <gui_name language="en">reg_ddrc_t_cke</gui_name>
                    <description language="en">Minimum number of cycles of CKE HIGH/LOW during power down and self refresh.
LPDDR2 mode: Set this to the larger of tCKE or tCKESR. Non-LPDDR2 designs: Set this to tCKE value.
Unit: clocks.</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="22" name="reg_ddrc_t_ras_min">
                    <gui_name language="en">reg_ddrc_t_ras_min</gui_name>
                    <description language="en">tRAS(min) - Minimum time between activate and precharge to the same bank(spec: 45 ns).
Unit: clocks
DRAM RELATED.
Default value is set for DDR3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="16" name="reg_ddrc_t_ras_max">
                    <gui_name language="en">reg_ddrc_t_ras_max</gui_name>
                    <description language="en">tRAS(max) - Maximum time between activate and precharge to same bank. Maximum time that a page can be kept open (spec: 70 us). If this is zero. The page is closed after each transaction.
Unit: Multiples of 1024 clocks
DRAM RELATED.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="10" name="reg_ddrc_t_faw">
                    <gui_name language="en">reg_ddrc_t_faw</gui_name>
                    <description language="en">tFAW - At most 4 banks must be activated in a rolling window of tFAW cycles.
Unit: clocks
DRAM RELATED.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="5" name="reg_ddrc_powerdown_to_x32">
                    <gui_name language="en">reg_ddrc_powerdown_to_x32</gui_name>
                    <description language="en">After this many clocks of NOP or DESELECT the controller will put the DRAM into power down. This must be enabled in the Master Control Register.
Unit: Multiples of 32 clocks.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="0" name="reg_ddrc_wr2pre">
                    <gui_name language="en">reg_ddrc_wr2pre</gui_name>
                    <description language="en">Minimum time between write and precharge to same bank
Non-LPDDR2 -&gt; WL + BL/2 + tWR
LPDDR2 -&gt; WL + BL/2 + tWR + 1
Unit: Clocks where, WL = write latency. BL = burst length.
This must match the value programmed in the BL bit of the mode register to the DRAM. BST is not supported at present. tWR = write recovery time. This comes directly from the DRAM specs.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_PARAM_REG2" offset="0xf800601c" size="0x4">
                <gui_name language="en">DRAM_param_reg2</gui_name>
                <description language="en">DRAM Parameters register 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="reg_ddrc_t_rcd">
                    <gui_name language="en">reg_ddrc_t_rcd</gui_name>
                    <description language="en">tRCD - AL Minimum time from activate to read or write command to same bank Min value for this is 1.
AL = Additive Latency
DRAM RELATED</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg2_reg_ddrc_rd2pre_ENUM" high_bit="27" low_bit="23" name="reg_ddrc_rd2pre">
                    <gui_name language="en">reg_ddrc_rd2pre</gui_name>
                    <description language="en">Minimum time from read to precharge of same bank
DDR2 -&gt; AL + BL/2 + max(tRTP, 2) - 2
DDR3 -&gt; AL + max (tRTP, 4)
mDDR -&gt; BL/2
LPDDR2 -&gt; BL/2 + tRTP - 1
AL = Additive Latency BL = DRAM Burst Length tRTP = value from spec DRAM RELATED</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="20" name="reg_ddrc_pad_pd">
                    <gui_name language="en">reg_ddrc_pad_pd</gui_name>
                    <description language="en">If pads have a power-saving mode, this is the greater of the time for the pads to enter power down or the time for the pads to exit power down. Used only in non-DFI designs.
Unit: clocks.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="15" name="reg_ddrc_t_xp">
                    <gui_name language="en">reg_ddrc_t_xp</gui_name>
                    <description language="en">tXP: Minimum time after power down exit to any operation.
DRAM RELATED.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="10" name="reg_ddrc_wr2rd">
                    <gui_name language="en">reg_ddrc_wr2rd</gui_name>
                    <description language="en">Minimum time from write command to read command. Includes time for bus turnaround and recovery times and all per-bank, per-rank, and global constraints.
non-LPDDR2 -&gt; WL + tWTR + BL/2
LPDDR2 -&gt; WL + tWTR + BL/2 + 1
Unit: clocks. Where, WL = Write latency, BL = burst length.
This should match the value. Programmed in the BL bit of the mode register to the DRAM.
tWTR = internal WRITE to READ command delay. This comes directly from the DRAM specs.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="5" name="reg_ddrc_rd2wr">
                    <gui_name language="en">reg_ddrc_rd2wr</gui_name>
                    <description language="en">Minimum time from read command to write command. Include time for bus turnaround and all per-bank, per-rank, and global constraints.
non-LPDDR2
-&gt;
RL + BL/2 + 2 - WL
LPDDR2 -&gt; RL + BL/2 + RU(tDQSCKmax / tCK) + 1 - WL
Write Pre-amble and DQ/DQS jitter timer is included in the above equation.
DRAM RELATED.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg2_reg_ddrc_write_latency_ENUM" high_bit="4" low_bit="0" name="reg_ddrc_write_latency">
                    <gui_name language="en">reg_ddrc_write_latency</gui_name>
                    <description language="en">Time from write command to write data on DDRC to PHY Interface. (PHY adds an extra flop delay on the write data path; hence this value is one less than the write latency of the DRAM device itself).
DDR2/3 -&gt; WL -1
LPDDR
-&gt; 1
LPDDR2 -&gt;WL Where WL = Write Latency of DRAM
DRAM RELATED.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_PARAM_REG3" offset="0xf8006020" size="0x4">
                <gui_name language="en">DRAM_param_reg3</gui_name>
                <description language="en">DRAM Parameters register 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="reg_ddrc_loopback">
                    <gui_name language="en">reg_ddrc_loopback</gui_name>
                    <description language="en">unused</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg3_reg_ddrc_dis_pad_pd_ENUM" high_bit="30" low_bit="30" name="reg_ddrc_dis_pad_pd">
                    <gui_name language="en">reg_ddrc_dis_pad_pd</gui_name>
                    <description language="en">1 = disable the pad power down feature
0 = Enable the pad power down feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="reg_phy_mode_ddr1_ddr2">
                    <gui_name language="en">reg_phy_mode_ddr1_ddr2</gui_name>
                    <description language="en">unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="24" name="reg_ddrc_read_latency">
                    <gui_name language="en">reg_ddrc_read_latency</gui_name>
                    <description language="en">Set to RL. Time from Read command to Read data on
DRAM interface.
Unit: clocks
This signal is present for designs supporting LPDDR/LPDDR2 DRAM only. It is used to calculate when DRAM clock may be stopped. RL = Read Latency of DRAM
Note: This signal is present for designs supporting LPDDR/LPDDR2 DRAM only. It is used to calculate when DRAM clock may be stopped.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="reg_ddrc_clock_stop_en">
                    <gui_name language="en">reg_ddrc_clock_stop_en</gui_name>
                    <description language="en">1=enable the assertion of stop_clk to the PHY whenever a clock is not required by LPDDR/ LPDDR2.
0=stop_clk will never be asserted.
Note: This is only present for implementations supporting LPDDR/LPDDR2 devices.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg3_reg_ddrc_mobile_ENUM" high_bit="22" low_bit="22" name="reg_ddrc_mobile">
                    <gui_name language="en">reg_ddrc_mobile</gui_name>
                    <description language="en">1= mobile/LPDDR DRAM device in use.
0=non-mobile DRAM device in use.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg3_reg_ddrc_sdram_ENUM" high_bit="21" low_bit="21" name="reg_ddrc_sdram">
                    <gui_name language="en">reg_ddrc_sdram</gui_name>
                    <description language="en">1 = sdram device
0 = non-sdram device</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="16" name="reg_ddrc_refresh_to_x32">
                    <gui_name language="en">reg_ddrc_refresh_to_x32</gui_name>
                    <description language="en">If the refresh timer (tRFC_nom, as known as tREFI) has expired at least once, but it has not expired burst_of_N_refresh times yet, then a 'speculative refresh' may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful, but before it is absolutely required. When the DRAM bus is idle for a period of time determined by this refresh idle timeout and the refresh timer has expired at least once since the last refresh, then a 'speculative refresh' will be performed. Speculative refreshes will continue successively until there are no refreshes pending or until new reads or writes are issued to the controller.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="reg_ddrc_t_rp">
                    <gui_name language="en">reg_ddrc_t_rp</gui_name>
                    <description language="en">tRP - Minimum time from precharge to activate of same bank.
DRAM RELATED</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="reg_ddrc_refresh_margin">
                    <gui_name language="en">reg_ddrc_refresh_margin</gui_name>
                    <description language="en">Issue critical refresh or page close this many cycles
before the critical refresh or page timer expires. It is recommended that this not be changed from the default value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="reg_ddrc_t_rrd">
                    <gui_name language="en">reg_ddrc_t_rrd</gui_name>
                    <description language="en">tRRD - Minimum time between activates from bank a
to bank b. (spec: 10ns or less)
DRAM RELATED</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="2" name="reg_ddrc_t_ccd">
                    <gui_name language="en">reg_ddrc_t_ccd</gui_name>
                    <description language="en">tCCD - Minimum time between two reads or two writes (from bank a to bank b) is this value + 1
DRAM RELATED</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_PARAM_REG4" offset="0xf8006024" size="0x4">
                <gui_name language="en">DRAM_param_reg4</gui_name>
                <description language="en">DRAM Parameters register 4</description>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="reg_ddrc_mr_rdata_valid">
                    <gui_name language="en">reg_ddrc_mr_rdata_valid</gui_name>
                    <description language="en">This bit indicates whether the Mode Register Read
Data present at address 0xA9 is valid or not. This bit is 1'b0 by default. This bit will be cleared (1'b0), whenever a Mode Register Read command is issued. This bit will be set to 1'b1, when the Mode Register Read Data is written to register 0xA9.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg4_reg_ddrc_mr_type_ENUM" high_bit="26" low_bit="26" name="reg_ddrc_mr_type">
                    <gui_name language="en">reg_ddrc_mr_type</gui_name>
                    <description language="en">Indicates whether the Mode register operation is read
or write
1 = read
0 = write</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DRAM_param_reg4_ddrc_reg_mr_wr_busy_ENUM" high_bit="25" low_bit="25" name="ddrc_reg_mr_wr_busy">
                    <gui_name language="en">ddrc_reg_mr_wr_busy</gui_name>
                    <description language="en">Core must initiate a MR write / read operation only if this signal is low. This signal goes high in the clock after the controller accepts the write / read request. It goes low when (i) MR write command has been issued to the DRAM (ii) MR Read data has been returned to Controller. Any MR write / read command that is received when 'ddrc_reg_mr_wr_busy' is high is not accepted.
1 = Indicates that mode register write / read operation is in progress.
0 = Indicates that the core can initiate a mode register write / read operation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="9" name="reg_ddrc_mr_data">
                    <gui_name language="en">reg_ddrc_mr_data</gui_name>
                    <description language="en">Mode register write data - for non-LPDDR2 modes.
For LPDDR2, these 16-bits are interpreted as
Writes: \'7bMR Addr[7:0], MR Data[7:0]\'7d.
Reads: \'7bMR Addr[7:0], Don't Care[7:0]\'7d</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg4_reg_ddrc_mr_addr_ENUM" high_bit="8" low_bit="7" name="reg_ddrc_mr_addr">
                    <gui_name language="en">reg_ddrc_mr_addr</gui_name>
                    <description language="en">Mode register address - for non-LPDDR2 modes.
This register is don't care in LPDDR2 mode
00 = MR0
01 = MR1
10 = MR2
11 = MR3</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="reg_ddrc_mr_wr">
                    <gui_name language="en">reg_ddrc_mr_wr</gui_name>
                    <description language="en">A low to high signal on this signal will do a mode
register write or read. Controller will accept this command, if this signal is detected high and 'ddrc_reg_mr_wr_busy' is detected low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="2" name="reg_ddrc_max_rank_rd">
                    <gui_name language="en">reg_ddrc_max_rank_rd</gui_name>
                    <description language="en">Only present for multi-rank configurations
Background: Reads to the same rank can be performed back-to-back. Reads from different ranks require additional 1-cycle latency in between (to avoid possible data bus contention). The controller arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is scheduled, there is a clock cycle in which only reads from the same bank are eligible to be scheduled. This prevents reads from other ranks from having fair access to the data bus. This parameter represents the maximum number of 64-byte reads (or 32B reads in some short read cases) that can be scheduled consecutively to the same rank. After this number is reached, a 1-cycle delay is inserted by the scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers increase bandwidth utilization, lower numbers increase fairness (and hence worst-case latency). FOR PERFORMANCE ONLY.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg4_reg_ddrc_prefer_write_ENUM" high_bit="1" low_bit="1" name="reg_ddrc_prefer_write">
                    <gui_name language="en">reg_ddrc_prefer_write</gui_name>
                    <description language="en">1 = Bank selector prefers writes over reads</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_param_reg4_reg_ddrc_en_2t_timing_mode_ENUM" high_bit="0" low_bit="0" name="reg_ddrc_en_2t_timing_mode">
                    <gui_name language="en">reg_ddrc_en_2t_timing_mode</gui_name>
                    <description language="en">1 = DDRC will use 2T timing
0 = DDRC will use 1T timing</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_INIT_PARAM" offset="0xf8006028" size="0x2">
                <gui_name language="en">DRAM_init_param</gui_name>
                <description language="en">DRAM initialization parameters register</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="reg_ddrc_t_mrd">
                    <gui_name language="en">reg_ddrc_t_mrd</gui_name>
                    <description language="en">tMRD - Cycles between Load Mode commands DRAM RELATED Default value is set for DDR3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="7" name="reg_ddrc_pre_ocd_x32">
                    <gui_name language="en">reg_ddrc_pre_ocd_x32</gui_name>
                    <description language="en">Wait period before driving the 'OCD Complete' command to DRAM. Units are in counts of a global timer that pulses every 32 clock cycles. There is no known spec requirement for this. It may be set to zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="reg_ddrc_final_wait_x32">
                    <gui_name language="en">reg_ddrc_final_wait_x32</gui_name>
                    <description language="en">Cycles to wait after completing the DRAM init sequence
before starting the dynamic scheduler. Units are in counts of a global timer that pulses every 32 clock cycles. Default value is set for DDR3.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_EMR_REG" offset="0xf800602c" size="0x4">
                <gui_name language="en">DRAM_EMR_reg</gui_name>
                <description language="en">DRAM EMR2, EMR3 access register</description>
                <bitField access="Read Write" high_bit="31" low_bit="16" name="reg_ddrc_emr3">
                    <gui_name language="en">reg_ddrc_emr3</gui_name>
                    <description language="en">Non LPDDR2- Value to be loaded into DRAM EMR3 registers. Used in non-LPDDR2 designs only.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="reg_ddrc_emr2">
                    <gui_name language="en">reg_ddrc_emr2</gui_name>
                    <description language="en">Non LPDDR2- Value to be loaded into DRAM EMR2 registers. For LPDDR2 - Value to Write to the MR3 register</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_EMR_MR_REG" offset="0xf8006030" size="0x4">
                <gui_name language="en">DRAM_EMR_MR_reg</gui_name>
                <description language="en">DRAM EMR, MR access register</description>
                <bitField access="Read Write" high_bit="31" low_bit="16" name="reg_ddrc_emr">
                    <gui_name language="en">reg_ddrc_emr</gui_name>
                    <description language="en">Non LPDDR2-Value
to be loaded into DRAM EMR registers. Bits [9:7] are for OCD and the setting in this register is ignored. The controller sets those bits appropriately. For LPDDR2 - Value to Write to the MR2 register</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="reg_ddrc_mr">
                    <gui_name language="en">reg_ddrc_mr</gui_name>
                    <description language="en">Non LPDDR2-Value to be loaded into the DRAM Mode register. Bit 8 is for DLL and the setting here is ignored. The controller sets appropriately. For LPDDR2 - Value to Write to the MR1 register</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_BURST8_RDWR" offset="0xf8006034" size="0x4">
                <gui_name language="en">DRAM_burst8_rdwr</gui_name>
                <description language="en">DRAM burst 8 read/write register</description>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="reg_ddrc_burstchop">
                    <gui_name language="en">reg_ddrc_burstchop</gui_name>
                    <description language="en">Feature not supported. When 1, Controller is out in burstchop mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="16" name="reg_ddrc_post_cke_x1024">
                    <gui_name language="en">reg_ddrc_post_cke_x1024</gui_name>
                    <description language="en">Cycles to wait after driving CKE high to start the DRAM initialization sequence.
Units: 1024 clocks.
DDR2 typically require a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2 - Typically require this to be programmed for a delay of 200 us.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="4" name="reg_ddrc_pre_cke_x1024">
                    <gui_name language="en">reg_ddrc_pre_cke_x1024</gui_name>
                    <description language="en">Cycles to wait after reset before driving CKE high to start the DRAM initialization sequence.
Units: 1024 clock cycles.
DDR2 Specifications typically require this to be programmed for a delay of &gt;= 200 us.
LPDDR2 - tINIT0 of 20 ms (max) + tINIT1 of 100 ns (min)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_burst8_rdwr_reg_ddrc_burst_rdwr_ENUM" high_bit="3" low_bit="0" name="reg_ddrc_burst_rdwr">
                    <gui_name language="en">reg_ddrc_burst_rdwr</gui_name>
                    <description language="en">This controls the burst size used to access the DRAM. This must match the BL mode register setting in the DRAM. In LPDDR and LPDDR2, Burst length of 16 is supported only in Half Bus Width mode. Every input read/write command has 4 cycles of data associated with it and that is not enough data for doing Burst Length16 in Full Bus Width mode.
0010 - Burst length of 4
0100 - Burst length of 8
1000 - Burst length of 16 (only supported for LPDDR AND LPDDR2)
All other values are reserved</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_DISABLE_DQ" offset="0xf8006038" size="0x2">
                <gui_name language="en">DRAM_disable_DQ</gui_name>
                <description language="en">DRAM Disable DQ register</description>
                <bitField access="Read Write" high_bit="12" low_bit="9" name="reg_phy_dq0_wait_t">
                    <gui_name language="en">reg_phy_dq0_wait_t</gui_name>
                    <description language="en">Not Applicable in this PHY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="reg_phy_rd_level_start">
                    <gui_name language="en">reg_phy_rd_level_start</gui_name>
                    <description language="en">Not Applicable in this PHY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="reg_phy_wr_level_start">
                    <gui_name language="en">reg_phy_wr_level_start</gui_name>
                    <description language="en">Not Applicable in this PHY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="reg_phy_debug_mode">
                    <gui_name language="en">reg_phy_debug_mode</gui_name>
                    <description language="en">Not Applicable in this PHY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_ddrc_dis_dq">
                    <gui_name language="en">reg_ddrc_dis_dq</gui_name>
                    <description language="en">When 1, DDRC will not de-queue any transactions from the CAM. Bypass will also be disabled. All transactions will be queued in the CAM. This is for debug only; no reads or writes are issued to DRAM as long as this is asserted. This bit is intended to be switched on-the-fly</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="reg_ddrc_force_low_pri_n">
                    <gui_name language="en">reg_ddrc_force_low_pri_n</gui_name>
                    <description language="en">Active Low signal. When asserted (0), all incoming transactions will be forced to low priority. Forcing the incoming transactions to low priority implicitly turns OFF Bypass. Otherwise, HPR is allowed if enabled in the AXI priority read registers.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_ADDR_MAP_BANK" offset="0xf800603c" size="0x4">
                <gui_name language="en">DRAM_addr_map_bank</gui_name>
                <description language="en">Selects the address bits used as DRAM bank address bits</description>
                <bitField access="Read Write" enumerationId="DRAM_addr_map_bank_reg_ddrc_addrmap_col_b6_ENUM" high_bit="19" low_bit="16" name="reg_ddrc_addrmap_col_b6">
                    <gui_name language="en">reg_ddrc_addrmap_col_b6</gui_name>
                    <description language="en">Full bus width mode: Selects the address bits used as column address bits 7. Half bus width mode:
Selects the address bits used as column address bits 8. Valid range is 0-7. Internal Base 9. The selected address bit for each of the column address bits is determined by adding the Internal Base to the value of this field.
Internal base: 9</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_addr_map_bank_reg_ddrc_addrmap_col_b5_ENUM" high_bit="15" low_bit="12" name="reg_ddrc_addrmap_col_b5">
                    <gui_name language="en">reg_ddrc_addrmap_col_b5</gui_name>
                    <description language="en">Full bus width mode: Selects the address bits used as column address bits 6. Half bus width mode:
Selects the address bits used as column address bits 7. Valid range is 0-7. Internal Base 8. The selected address bit for each of the column address bits is determined by adding the Internal Base to the value of this field.
Internal base: 9</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="reg_ddrc_addrmap_bank_b2">
                    <gui_name language="en">reg_ddrc_addrmap_bank_b2</gui_name>
                    <description language="en">Selects the AXI address bit used as bank address bit 2. Valid range 0 to 14, and 15. Internal Base: 7. The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, bank address bit 2 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="reg_ddrc_addrmap_bank_b1">
                    <gui_name language="en">reg_ddrc_addrmap_bank_b1</gui_name>
                    <description language="en">Selects the address bits used as bank address bit 1. Valid Range: 0 to 14; Internal Base: 6.
The selected address bit for each of the bank address bits is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_ddrc_addrmap_bank_b0">
                    <gui_name language="en">reg_ddrc_addrmap_bank_b0</gui_name>
                    <description language="en">Selects the address bits used as bank address bit 0. Valid Range: 0 to 14 Internal Base: 5
The selected address bit for each of the bank address bits is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_ADDR_MAP_COL" offset="0xf8006040" size="0x4">
                <gui_name language="en">DRAM_addr_map_col</gui_name>
                <description language="en">Selects the address bits used as DRAM column address bits</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="reg_ddrc_addrmap_col_b11">
                    <gui_name language="en">reg_ddrc_addrmap_col_b11</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 13. (Column address bit 12 in LPDDR2 mode) Half bus width mode: Unused. To make it unused, this should be set to 15. (Column address bit 13 in LPDDR2 mode)
Valid Range: 0 to 7, and 15.
Internal Base: 14.
The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, this column address bit is set to 0. Note: Per JEDEC DDR2 spec, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2, there is a dedicated bit for auto-precharge in the CA bus, and hence column bit 10 is used.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="24" name="reg_ddrc_addrmap_col_b10">
                    <gui_name language="en">reg_ddrc_addrmap_col_b10</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 12. (Column address bit 11 in LPDDR2 mode) Half bus width mode: Selects the address bit used as column address bit 13. (Column address bit 12 in LPDDR2 mode) Valid Range: 0 to 7, and 15.
Internal Base: 13
The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, this column address bit is set to 0. Note: Per JEDEC DDR2 spec, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2, there is a dedicated bit for auto-precharge in the CA bus, and hence column bit 10 is used.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="20" name="reg_ddrc_addrmap_col_b9">
                    <gui_name language="en">reg_ddrc_addrmap_col_b9</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 11. (Column address bit 10 in LPDDR2 mode)
Half bus width mode: Selects the address bit used as column address bit 12. (Column address bit 11 in LPDDR2 mode)
Valid Range: 0 to 7, and 15
Internal Base: 12
The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, this column address bit is set to 0.
Note: Per JEDEC DDR2 spec, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2, there is a dedicated bit for auto-precharge in the CA bus, and hence column bit 10 is used.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_addr_map_col_reg_ddrc_addrmap_col_b8_ENUM" high_bit="19" low_bit="16" name="reg_ddrc_addrmap_col_b8">
                    <gui_name language="en">reg_ddrc_addrmap_col_b8</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 9.
Half bus width mode: Selects the address bit used as column address bit 11. (Column address bit 10 in LPDDR2 mode)
Valid Range: 0 to 7, and 15
Internal Base: 11
The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, this column address bit is set to 0.
Note: Per JEDEC spec, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2, there is a dedicated bit for auto-precharge in the CA bus, and hence column bit 10 is used.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="reg_ddrc_addrmap_col_b7">
                    <gui_name language="en">reg_ddrc_addrmap_col_b7</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 8.
Half bus width mode: Selects the address bit used as column address bit 9.
Valid Range: 0 to 7, and 15.
Internal Base: 10.
The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, this column address bit is set to 0.
Note: Per JEDEC spec, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.In LPDDR2, there is a dedicated bit for auto-precharge in the CA bus, and hence column bit 10 is used.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="reg_ddrc_addrmap_col_b4">
                    <gui_name language="en">reg_ddrc_addrmap_col_b4</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 5.
Half bus width mode: Selects the address bit used as column address bits 6. Valid Range: 0 to 7.
Internal Base: 7.
The selected address bit for each of the column address bits is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DRAM_addr_map_col_reg_ddrc_addrmap_col_b3_ENUM" high_bit="7" low_bit="4" name="reg_ddrc_addrmap_col_b3">
                    <gui_name language="en">reg_ddrc_addrmap_col_b3</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 4.
Half bus width mode: Selects the address bit used as column address bit 5.
Valid Range: 0 to 7
Internal Base: 6
The selected address bit is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_ddrc_addrmap_col_b2">
                    <gui_name language="en">reg_ddrc_addrmap_col_b2</gui_name>
                    <description language="en">Full bus width mode: Selects the address bit used as column address bit 3.
Half bus width mode: Selects the address bit used as column address bit 4.
Valid Range: 0 to 7. Internal Base: 5
The selected address bit is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_ADDR_MAP_ROW" offset="0xf8006044" size="0x4">
                <gui_name language="en">DRAM_addr_map_row</gui_name>
                <description language="en">Selects the address bits used as DRAM row address bits</description>
                <bitField access="Read Write" high_bit="27" low_bit="24" name="reg_ddrc_addrmap_row_b15">
                    <gui_name language="en">reg_ddrc_addrmap_row_b15</gui_name>
                    <description language="en">Selects the AXI address bit used as row address bit 15. Valid Range: 0 to 11, and 15 Internal Base: 24 The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, row address bit 15 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="20" name="reg_ddrc_addrmap_row_b14">
                    <gui_name language="en">reg_ddrc_addrmap_row_b14</gui_name>
                    <description language="en">Selects theAXI
address bit used as row address bit 14. Valid Range: 0 to 11, and 15 Internal Base: 23 The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, row address bit 14 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="16" name="reg_ddrc_addrmap_row_b13">
                    <gui_name language="en">reg_ddrc_addrmap_row_b13</gui_name>
                    <description language="en">Selects the AXI address bit used as row address bit 13. Valid Range: 0 to 11, and 15 Internal Base: 22 The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, row address bit 13 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="reg_ddrc_addrmap_row_b12">
                    <gui_name language="en">reg_ddrc_addrmap_row_b12</gui_name>
                    <description language="en">Selects the AXI address bit used as row address bit 12. Valid Range: 0 to 11, and 15 Internal Base: 21 The selected address bit is determined by adding the Internal Base to the value of this field. If set to 15, row address bit 12 is set to 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="reg_ddrc_addrmap_row_b2_11">
                    <gui_name language="en">reg_ddrc_addrmap_row_b2_11</gui_name>
                    <description language="en">Selects the AXI address bits used as row address bits 2 to 11. Valid Range: 0 to 11. Internal Base: 11 (for row address bit 2) to 20 (for row address bit 11) The selected address bit for each of the row address bits is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="reg_ddrc_addrmap_row_b1">
                    <gui_name language="en">reg_ddrc_addrmap_row_b1</gui_name>
                    <description language="en">Selects the AXI address bits used as row address bit 1. Valid Range: 0 to 11. Internal Base: 10 The selected address bit for each of the row address bits is determined by adding the Internal Base to the value of this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_ddrc_addrmap_row_b0">
                    <gui_name language="en">reg_ddrc_addrmap_row_b0</gui_name>
                    <description language="en">Selects the AXI address bits used as row address bit 0. Valid Range: 0 to 11. Internal Base: 9
The selected address bit for each of the row address bits is determined by adding the Internal Base to the value of this field</description>
                </bitField>
            </register>
            <register name="DDRC_DRAM_ODT_REG" offset="0xf8006048" size="0x4">
                <gui_name language="en">DRAM_ODT_reg</gui_name>
                <description language="en">DRAM ODT register</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="reg_ddrc_rank3_wr_odt">
                    <gui_name language="en">reg_ddrc_rank3_wr_odt</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="reg_ddrc_rank3_rd_odt">
                    <gui_name language="en">reg_ddrc_rank3_rd_odt</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="21" name="reg_ddrc_rank2_wr_odt">
                    <gui_name language="en">reg_ddrc_rank2_wr_odt</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="18" name="reg_ddrc_rank2_rd_odt">
                    <gui_name language="en">reg_ddrc_rank2_rd_odt</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="16" name="reg_phy_idle_local_odt">
                    <gui_name language="en">reg_phy_idle_local_odt</gui_name>
                    <description language="en">Value to drive on the 2-bit local_odt PHY outputs when output enable is not asserted and a read is not in progress. Typically this is the value required to disable termination to save power when idle.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="14" name="reg_phy_wr_local_odt">
                    <gui_name language="en">reg_phy_wr_local_odt</gui_name>
                    <description language="en">Value to drive on the 2-bit local_odt PHY outputs when write levelling is enabled for DQS.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="12" name="reg_phy_rd_local_odt">
                    <gui_name language="en">reg_phy_rd_local_odt</gui_name>
                    <description language="en">Value to drive on the 2-bit local_odt PHY outputs when output enable is not asserted and a read is in progress (where 'in progress' is defined as after a read command is issued and until all read data has been returned all the way to the controller.) Typically this is set to the value required to enable termination at the desired strength for read usage.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="9" name="reg_ddrc_rank1_wr_odt">
                    <gui_name language="en">reg_ddrc_rank1_wr_odt</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="6" name="reg_ddrc_rank1_rd_odt">
                    <gui_name language="en">reg_ddrc_rank1_rd_odt</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="reg_ddrc_rank0_wr_odt">
                    <gui_name language="en">reg_ddrc_rank0_wr_odt</gui_name>
                    <description language="en">[1:0] - Indicates which remote ODT's must be turned on during a write to rank 0. Each of the 2 ranks has a remote ODT (in the DRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; Rank 1 is controlled by bit next to the LSB.
For each rank, set its bit to 1 to enable its ODT.
[2] - If 1 then local ODT is enabled during writes to rank 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="reg_ddrc_rank0_rd_odt">
                    <gui_name language="en">reg_ddrc_rank0_rd_odt</gui_name>
                    <description language="en">Unused.
[1:0] - Indicates which remote ODT's must be turned ON during a read to rank 0. Each of the 2 ranks has a remote ODT (in the DRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; Rank 1 is controlled by bit next to the LSB. For each rank, set its bit to 1 to enable its ODT.
[2] - If 1 then local ODT is enabled during reads to rank 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_DBG_REG" offset="0xf800604c" size="0x4">
                <gui_name language="en">phy_dbg_reg</gui_name>
                <description language="en">PHY debug register</description>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="phy_reg_bc_fifo_re3">
                    <gui_name language="en">phy_reg_bc_fifo_re3</gui_name>
                    <description language="en">Debug read capture FIFO read enable for data slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="phy_reg_bc_fifo_we3">
                    <gui_name language="en">phy_reg_bc_fifo_we3</gui_name>
                    <description language="en">Debug read capture FIFO write enable, for data slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="phy_reg_bc_dqs_oe3">
                    <gui_name language="en">phy_reg_bc_dqs_oe3</gui_name>
                    <description language="en">Debug DQS output enable for data slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="phy_reg_bc_dq_oe3">
                    <gui_name language="en">phy_reg_bc_dq_oe3</gui_name>
                    <description language="en">Debug DQ output enable for data slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="phy_reg_bc_fifo_re2">
                    <gui_name language="en">phy_reg_bc_fifo_re2</gui_name>
                    <description language="en">Debug read capture FIFO read enable for data slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="phy_reg_bc_fifo_we2">
                    <gui_name language="en">phy_reg_bc_fifo_we2</gui_name>
                    <description language="en">Debug read capture FIFO write enable, for data slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="phy_reg_bc_dqs_oe2">
                    <gui_name language="en">phy_reg_bc_dqs_oe2</gui_name>
                    <description language="en">Debug DQS output enable for data slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="phy_reg_bc_dq_oe2">
                    <gui_name language="en">phy_reg_bc_dq_oe2</gui_name>
                    <description language="en">Debug DQ output enable for data slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="phy_reg_bc_fifo_re1">
                    <gui_name language="en">phy_reg_bc_fifo_re1</gui_name>
                    <description language="en">Debug read capture FIFO read enable for data slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="phy_reg_bc_fifo_we1">
                    <gui_name language="en">phy_reg_bc_fifo_we1</gui_name>
                    <description language="en">Debug read capture FIFO write enable, for data slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="phy_reg_bc_dqs_oe1">
                    <gui_name language="en">phy_reg_bc_dqs_oe1</gui_name>
                    <description language="en">Debug DQS output enable for data slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="phy_reg_bc_dq_oe1">
                    <gui_name language="en">phy_reg_bc_dq_oe1</gui_name>
                    <description language="en">Debug DQ output enable for data slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="phy_reg_bc_fifo_re0">
                    <gui_name language="en">phy_reg_bc_fifo_re0</gui_name>
                    <description language="en">Debug read capture FIFO read enable for data slice 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="phy_reg_bc_fifo_we0">
                    <gui_name language="en">phy_reg_bc_fifo_we0</gui_name>
                    <description language="en">Debug read capture FIFO write enable, for data slice 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="phy_reg_bc_dqs_oe0">
                    <gui_name language="en">phy_reg_bc_dqs_oe0</gui_name>
                    <description language="en">Debug DQS output enable for data slice 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="phy_reg_bc_dq_oe0">
                    <gui_name language="en">phy_reg_bc_dq_oe0</gui_name>
                    <description language="en">Debug DQ output enable for data slice 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="phy_reg_rdc_fifo_rst_err_cnt">
                    <gui_name language="en">phy_reg_rdc_fifo_rst_err_cnt</gui_name>
                    <description language="en">Counter for counting how many times the pointers of read capture FIFO differ when they are reset by dll_calib.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_CMD_TIMEOUT_RDDATA_CPT" offset="0xf8006050" size="0x4">
                <gui_name language="en">phy_cmd_timeout_rddata_cpt</gui_name>
                <description language="en">PHY command time out and read data capture FIFO register</description>
                <bitField access="Read Write" high_bit="31" low_bit="28" name="reg_phy_wrlvl_num_of_dq0">
                    <gui_name language="en">reg_phy_wrlvl_num_of_dq0</gui_name>
                    <description language="en">This register value determines register determines the number of samples used for each ratio increment during Write Leveling.
Num_of_iteration = reg_phy_wrlvl_num_of_dq0 + 1
The recommended value for this register is 8. Accuracy is better with higher value, but this will cause leveling to run longer.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="24" name="reg_phy_gatelvl_num_of_dq0">
                    <gui_name language="en">reg_phy_gatelvl_num_of_dq0</gui_name>
                    <description language="en">This register value determines register determines the number of samples used for each ratio increment during
Gate Training.
Num_of_iteration = reg_phy_gatelvl_num_of_dq0 + 1 The recommended value for this register is 8. Accuracy is better with higher value, but this will cause leveling to run longer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_cmd_timeout_rddata_cpt_reg_phy_clk_stall_level_ENUM" high_bit="19" low_bit="19" name="reg_phy_clk_stall_level">
                    <gui_name language="en">reg_phy_clk_stall_level</gui_name>
                    <description language="en">1 = stall clock, for DLL aging control</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_phy_dis_phy_ctrl_rstn">
                    <gui_name language="en">reg_phy_dis_phy_ctrl_rstn</gui_name>
                    <description language="en">Disable the reset from Phy Ctrl macro. 1: PHY Ctrl macro reset port is always HIGH 0: PHY Ctrl macro gets power on reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_cmd_timeout_rddata_cpt_reg_phy_rdc_fifo_rst_err_cnt_clr_ENUM" high_bit="17" low_bit="17" name="reg_phy_rdc_fifo_rst_err_cnt_clr">
                    <gui_name language="en">reg_phy_rdc_fifo_rst_err_cnt_clr</gui_name>
                    <description language="en">Clear/reset for counter rdc_fifo_rst_err_cnt[3:0].
0: no clear, 1: clear.
Note: This is a synchronous dynamic signal that must have timing closed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_phy_use_fixed_re">
                    <gui_name language="en">reg_phy_use_fixed_re</gui_name>
                    <description language="en">When 1: PHY generates FIFO read enable after fixed number of clock cycles as defined by reg_phy_rdc_we_to_re_delay[3:0].
When 0: PHY uses the not_empty method to do the read enable generation.
Note: This port must be set HIGH during training/leveling process i.e. when ddrc_dfi_wrlvl_en/ ddrc_dfi_rdlvl_en/ ddrc_dfi_rdlvl_gate_en port is set HIGH.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="reg_phy_rdc_fifo_rst_disable">
                    <gui_name language="en">reg_phy_rdc_fifo_rst_disable</gui_name>
                    <description language="en">When 1, disable counting the number of times the Read Data Capture FIFO has been reset when the FIFO was not empty.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="reg_phy_rdc_we_to_re_delay">
                    <gui_name language="en">reg_phy_rdc_we_to_re_delay</gui_name>
                    <description language="en">This register value + 1 give the number of clock cycles between writing into the Read Capture FIFO and the read operation.
The setting of this register determines the read data timing and depends upon total delay in the system for read operation which include fly-by delays, trace delay, clkout_invert etc.
This is used only if reg_phy_use_fixed_re=1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="reg_phy_wr_cmd_to_data">
                    <gui_name language="en">reg_phy_wr_cmd_to_data</gui_name>
                    <description language="en">Not used in DFI PHY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_phy_rd_cmd_to_data">
                    <gui_name language="en">reg_phy_rd_cmd_to_data</gui_name>
                    <description language="en">Not used in DFI PHY.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_MODE_STS_REG" offset="0xf8006054" size="0x4">
                <gui_name language="en">mode_sts_reg</gui_name>
                <description language="en">Controller operation mode status registers</description>
                <bitField access="Read Only" high_bit="20" low_bit="16" name="ddrc_reg_dbg_hpr_q_depth">
                    <gui_name language="en">ddrc_reg_dbg_hpr_q_depth</gui_name>
                    <description language="en">Indicates the number of entries currently in the HPR CAM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="10" name="ddrc_reg_dbg_lpr_q_depth">
                    <gui_name language="en">ddrc_reg_dbg_lpr_q_depth</gui_name>
                    <description language="en">Indicates the number of entries currently in the LPR CAM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="4" name="ddrc_reg_dbg_wr_q_depth">
                    <gui_name language="en">ddrc_reg_dbg_wr_q_depth</gui_name>
                    <description language="en">Indicates the number of entries currently in the WR CAM.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="mode_sts_reg_ddrc_reg_dbg_stall_ENUM" high_bit="3" low_bit="3" name="ddrc_reg_dbg_stall">
                    <gui_name language="en">ddrc_reg_dbg_stall</gui_name>
                    <description language="en">1 indicates that no commands are accepted by the controller.
0 indicates that commands are being accepted.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="mode_sts_reg_ddrc_reg_operating_mode_ENUM" high_bit="2" low_bit="0" name="ddrc_reg_operating_mode">
                    <gui_name language="en">ddrc_reg_operating_mode</gui_name>
                    <description language="en">Gives the status of the controller.
0 = DDRC Init
1 = Normal operation
2 = Power-down mode
3 = Self-refresh mode
4 and above = deep power down mode (LPDDR2 only)</description>
                </bitField>
            </register>
            <register name="DDRC_DLL_CALIB" offset="0xf8006058" size="0x4">
                <gui_name language="en">DLL_calib</gui_name>
                <description language="en">DLL calibration register</description>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_ddrc_dis_dll_calib">
                    <gui_name language="en">reg_ddrc_dis_dll_calib</gui_name>
                    <description language="en">When 1, disable dll_calib generated by the controller. The core should issue the dll_calib signal using co_gs_dll_calib input. This input is changeable on the fly.
When 0, controller will issue dll_calib periodically</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="reg_ddrc_dll_calib_to_max_x1024">
                    <gui_name language="en">reg_ddrc_dll_calib_to_max_x1024</gui_name>
                    <description language="en">Unused in DFI Controller.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="reg_ddrc_dll_calib_to_min_x1024">
                    <gui_name language="en">reg_ddrc_dll_calib_to_min_x1024</gui_name>
                    <description language="en">Unused in DFI Controller.</description>
                </bitField>
            </register>
            <register name="DDRC_ODT_DELAY_HOLD" offset="0xf800605c" size="0x2">
                <gui_name language="en">ODT_delay_hold</gui_name>
                <description language="en">ODT delay and ODT hold register</description>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="reg_ddrc_wr_odt_hold">
                    <gui_name language="en">reg_ddrc_wr_odt_hold</gui_name>
                    <description language="en">Cycles to hold ODT for a Write Command. When 0x0, ODT signal is ON for 1 cycle. When 0x1, it is ON for 2 cycles, etc. The values to program in different modes are : DRAM Burst of 4 -2, DRAM Burst of 8 -4</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="reg_ddrc_rd_odt_hold">
                    <gui_name language="en">reg_ddrc_rd_odt_hold</gui_name>
                    <description language="en">Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="reg_ddrc_wr_odt_delay">
                    <gui_name language="en">reg_ddrc_wr_odt_delay</gui_name>
                    <description language="en">The delay, in clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting should remain constant for the entire time that DQS is driven by the controller. The suggested value for DDR2 is WL - 5 and for DDR3 is 0. WL is Write latency. DDR2 ODT has a 2-cycle on-time delay and a 2.5-cycle off-time delay.
ODT is not applicable for LPDDR and LPDDR2 modes.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_ddrc_rd_odt_delay">
                    <gui_name language="en">reg_ddrc_rd_odt_delay</gui_name>
                    <description language="en">UNUSED</description>
                </bitField>
            </register>
            <register name="DDRC_CTRL_REG1" offset="0xf8006060" size="0x2">
                <gui_name language="en">ctrl_reg1</gui_name>
                <description language="en">Controller register 1</description>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="reg_ddrc_selfref_en">
                    <gui_name language="en">reg_ddrc_selfref_en</gui_name>
                    <description language="en">If 1, then the controller will put the DRAM into self refresh when the transaction store is empty.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="reg_ddrc_dis_collision_page_opt">
                    <gui_name language="en">reg_ddrc_dis_collision_page_opt</gui_name>
                    <description language="en">When this is set to '0', auto-precharge will be disabled for the flushed command in a collision case. Collision cases are write followed by read to same address, read followed by write to same address, or write followed by write to same address with DIS_WC bit = 1 (where 'same address' comparisons exclude the two address bits representing critical word).</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="reg_ddrc_dis_wc">
                    <gui_name language="en">reg_ddrc_dis_wc</gui_name>
                    <description language="en">When 1, disable Write Combine</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="reg_ddrc_refresh_update_level">
                    <gui_name language="en">reg_ddrc_refresh_update_level</gui_name>
                    <description language="en">Toggle this signal to indicate that refresh register(s) have been updated. The value will be automatically updated when exiting soft reset. So it does not need to be toggled initially.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="reg_ddrc_auto_pre_en">
                    <gui_name language="en">reg_ddrc_auto_pre_en</gui_name>
                    <description language="en">When set, most reads and writes will be issued with auto-precharge. (Exceptions can be made for collision cases.)</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="1" name="reg_ddrc_lpr_num_entries">
                    <gui_name language="en">reg_ddrc_lpr_num_entries</gui_name>
                    <description language="en">Number of entries in the low priority transaction store is this value plus 1. In this design, by default all read ports are treated as low priority and hence the value of 0x1F. The hpr_num_entries is 32 minus this value. Bit [6] is ignored.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="reg_ddrc_pageclose">
                    <gui_name language="en">reg_ddrc_pageclose</gui_name>
                    <description language="en">If true, bank will be closed and kept closed if no transactions are available for it. If false, bank will remain open until there is a need to close it (to open a different page, or for page timeout or refresh timeout.) This does not apply when auto-refresh is used.</description>
                </bitField>
            </register>
            <register name="DDRC_CTRL_REG2" offset="0xf8006064" size="0x4">
                <gui_name language="en">ctrl_reg2</gui_name>
                <description language="en">Controller register 2</description>
                <bitField access="Read Write" enumerationId="ctrl_reg2_reg_arb_go2critical_en_ENUM" high_bit="17" low_bit="17" name="reg_arb_go2critical_en">
                    <gui_name language="en">reg_arb_go2critical_en</gui_name>
                    <description language="en">1 - Set reg_ddrc_go2critical_wr and reg_ddrc_go2critical_rd signals going to DDRC based on 'urgent' input coming from AXI master. 0 - Keep reg_ddrc_go2critical_wr and reg_ddrc_go2critical_rd signals going to DDRC at 1'b0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="5" name="reg_ddrc_go2critical_hysteresis">
                    <gui_name language="en">reg_ddrc_go2critical_hysteresis</gui_name>
                    <description language="en">Describes the number of cycles that co_gs_go2critical_rd or co_gs_go2critical_wr must be asserted before the corresponding queue moves to the 'critical' state in the DDRC. The arbiter controls the co_gs_go2critical_* signals; it is designed for use with this hysteresis field set to 0.</description>
                </bitField>
            </register>
            <register name="DDRC_CTRL_REG3" offset="0xf8006068" size="0x4">
                <gui_name language="en">ctrl_reg3</gui_name>
                <description language="en">Controller register 3</description>
                <bitField access="Read Write" high_bit="25" low_bit="16" name="reg_ddrc_dfi_t_wlmrd">
                    <gui_name language="en">reg_ddrc_dfi_t_wlmrd</gui_name>
                    <description language="en">First DQS/DQS# rising edge after write leveling mode is programmed. This is same as the tMLRD value from the DRAM spec.
Only present in designs that support DDR3 devices.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="reg_ddrc_rdlvl_rr">
                    <gui_name language="en">reg_ddrc_rdlvl_rr</gui_name>
                    <description language="en">Read leveling read-to-read delay. Specifies the minimum number of clock cycles from the assertion of a read command to the next read command. Only applicable when connecting to PHY's operating in 'PHY RdLvl Evaluation' mode. Only present in designs that support DDR3 devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="reg_ddrc_wrlvl_ww">
                    <gui_name language="en">reg_ddrc_wrlvl_ww</gui_name>
                    <description language="en">Write leveling write-to-write delay. Specifies the minimum number of clock cycles from the assertion of a ddrc_dfi_wrlvl_strobe signal to the next ddrc_dfi_wrlvl_strobe signal. Only applicable when connecting to PHY's operating in 'PHY RdLvl Evaluation' mode.
Recommended value is: (RL + reg_phy_rdc_we_to_re_delay + 50)
Only present in designs that support DDR3 and LPDDR2 devices.</description>
                </bitField>
            </register>
            <register name="DDRC_CTRL_REG4" offset="0xf800606c" size="0x2">
                <gui_name language="en">ctrl_reg4</gui_name>
                <description language="en">Controller register 4</description>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="dfi_t_ctrlupd_interval_max_x1024">
                    <gui_name language="en">dfi_t_ctrlupd_interval_max_x1024</gui_name>
                    <description language="en">This is the maximum amount of time between Controller initiated DFI update requests. This timer resets with each update request; when the timer expires, traffic is blocked for a few cycles. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DLL calibration is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Units: 1024 clocks</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="dfi_t_ctrlupd_interval_min_x1024">
                    <gui_name language="en">dfi_t_ctrlupd_interval_min_x1024</gui_name>
                    <description language="en">This is the minimum amount of time between Controller initiated DFI update requests (which will be executed whenever the controller is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the controller is idle. Units: 1024 clocks</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_REFRESH_TIMER01" offset="0xf80060a0" size="0x4">
                <gui_name language="en">CHE_REFRESH_TIMER01</gui_name>
                <description language="en">CHE_REFRESH_TIMER01</description>
                <bitField access="Read Write" high_bit="23" low_bit="12" name="refresh_timer1_start_value_x32">
                    <gui_name language="en">refresh_timer1_start_value_x32</gui_name>
                    <description language="en">Refresh Timer for Rank 0. (Only present in multi-rank configurations). Unit: in multiples of 32 clocks. FOR PERFORMANCE ONLY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="refresh_timer0_start_value_x32">
                    <gui_name language="en">refresh_timer0_start_value_x32</gui_name>
                    <description language="en">Refresh Timer for Rank 1. Unit: in multiples of 32 clocks. (Only present in multi-rank configurations). FOR PERFORMANCE ONLY.</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_T_ZQ" offset="0xf80060a4" size="0x4">
                <gui_name language="en">CHE_T_ZQ</gui_name>
                <description language="en">ZQ parameters register</description>
                <bitField access="Read Write" high_bit="31" low_bit="22" name="reg_ddrc_t_zq_short_nop">
                    <gui_name language="en">reg_ddrc_t_zq_short_nop</gui_name>
                    <description language="en">Number of cycles of NOP required after a ZQCS (ZQ calibration short) command is issued to DRAM. Units: Clock cycles This is only present for implementations supporting DDR3 and LPDDR2 devices.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="12" name="reg_ddrc_t_zq_long_nop">
                    <gui_name language="en">reg_ddrc_t_zq_long_nop</gui_name>
                    <description language="en">Number of cycles of NOP required after a ZQCL (ZQ calibration long) command is issued to DRAM. Units: Clock cycles This is only present for implementations supporting DDR3 and LPDDR2 devices.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="2" name="reg_ddrc_t_mod">
                    <gui_name language="en">reg_ddrc_t_mod</gui_name>
                    <description language="en">Mode register set command update delay (minimum the larger of 12 clock cycles or 15ns)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_ddrc_ddr3">
                    <gui_name language="en">reg_ddrc_ddr3</gui_name>
                    <description language="en">Indicates operating in DDR2/DDR3 mode. Default value is set for DDR3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="reg_ddrc_dis_auto_zq">
                    <gui_name language="en">reg_ddrc_dis_auto_zq</gui_name>
                    <description language="en">1=disable controller generation of ZQCS command. Co_gs_zq_calib_short can be used instead to control ZQ calibration commands. 0=internally generate ZQCS commands based on reg_ddrc_t_zq_short_interval_x1024 This is only present for implementations supporting DDR3 and LPDDR2 devices.</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_T_ZQ_SHORT_INTERVAL_REG" offset="0xf80060a8" size="0x4">
                <gui_name language="en">CHE_T_ZQ_Short_Interval_Reg</gui_name>
                <description language="en">Misc parameters register</description>
                <bitField access="Read Write" high_bit="27" low_bit="20" name="dram_rstn_x1024">
                    <gui_name language="en">dram_rstn_x1024</gui_name>
                    <description language="en">Number of cycles to assert DRAM reset signal during init sequence. Units: 1024 Clock cycles. Applicable for DDR3 only.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="0" name="t_zq_short_interval_x1024">
                    <gui_name language="en">t_zq_short_interval_x1024</gui_name>
                    <description language="en">Average interval to wait between automatically issuing ZQCS (ZQ calibration short) commands to DDR3 devices. Meaningless if reg_ddrc_dis_auto_zq=1. Units: 1024 Clock cycles. Applicable for DDR3 and LPDDR2 devices.</description>
                </bitField>
            </register>
            <register name="DDRC_DEEP_PWRDWN_REG" offset="0xf80060ac" size="0x2">
                <gui_name language="en">deep_pwrdwn_reg</gui_name>
                <description language="en">Deep powerdown register</description>
                <bitField access="Read Write" high_bit="8" low_bit="1" name="deeppowerdown_to_x1024">
                    <gui_name language="en">deeppowerdown_to_x1024</gui_name>
                    <description language="en">Minimum deep power down time applicable only for LPDDR2. LPDDR exits from deep power down mode immediately after reg_ddrc_deeppowerdown_en is deasserted. For LPDDR2, Value from the spec is 500us. Units are in 1024 clock cycles. Present only in designs configured to support LPDDR or LPDDR2. FOR PERFORMANCE ONLY.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="deep_pwrdwn_reg_deeppowerdown_en_ENUM" high_bit="0" low_bit="0" name="deeppowerdown_en">
                    <gui_name language="en">deeppowerdown_en</gui_name>
                    <description language="en">1 - Controller puts the DRAM into Deep Powerdown mode when the transaction store is empty. 0 - Brings Controller out of Deep Powerdown mode Present only in designs configured to support LPDDR or LPDDR2 FOR PERFORMANCE ONLY.</description>
                </bitField>
            </register>
            <register name="DDRC_REG_2C" offset="0xf80060b0" size="0x4">
                <gui_name language="en">reg_2c</gui_name>
                <description language="en">Training control register</description>
                <bitField access="Read Write" enumerationId="reg_2c_reg_ddrc_dfi_rd_data_eye_train_ENUM" high_bit="28" low_bit="28" name="reg_ddrc_dfi_rd_data_eye_train">
                    <gui_name language="en">reg_ddrc_dfi_rd_data_eye_train</gui_name>
                    <description language="en">1 = Read Data Eye training mode has been enabled as part of init sequence. Only present in designs that support DDR3 or LPDDR2 devices.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_2c_reg_ddrc_dfi_rd_dqs_gate_level_ENUM" high_bit="27" low_bit="27" name="reg_ddrc_dfi_rd_dqs_gate_level">
                    <gui_name language="en">reg_ddrc_dfi_rd_dqs_gate_level</gui_name>
                    <description language="en">1 = Read DQS Gate Leveling mode has been enabled as part of init sequence; Valid only for DDR3 DFI designs 0= Read DQS gate leveling is disabled.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_2c_reg_ddrc_dfi_wr_level_en_ENUM" high_bit="26" low_bit="26" name="reg_ddrc_dfi_wr_level_en">
                    <gui_name language="en">reg_ddrc_dfi_wr_level_en</gui_name>
                    <description language="en">1 = Write leveling mode has been enabled as part of init sequence; Valid only for DDR3 DFI designs 0 = Write leveling disabled.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="ddrc_reg_trdlvl_max_error">
                    <gui_name language="en">ddrc_reg_trdlvl_max_error</gui_name>
                    <description language="en">When '1' indicates that the reg_ddrc_dfi_rdrlvl_max_x1024 timer has timed out. This is a Clear-on-Write register. If read leveling or gate training timed out, an error is indicated by the DDRC and this bit gets set. The value is held at that value until it is cleared.
Clearing is done by writing a '0' to this register.
Only present in designs that support DDR3 or LPDDR2 devices.</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="ddrc_reg_twrlvl_max_error">
                    <gui_name language="en">ddrc_reg_twrlvl_max_error</gui_name>
                    <description language="en">When '1' indicates that the reg_ddrc_dfi_wrlvl_max_x1024 timer has timed out. This is a Clear-on-Write register. If write leveling timed out, an error is indicated by the DDRC and this bit gets set. The value is held until it is cleared.
Clearing is done by writing a '0' to this register.
Only present in designs that support DDR3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="12" name="dfi_rdlvl_max_x1024">
                    <gui_name language="en">dfi_rdlvl_max_x1024</gui_name>
                    <description language="en">Read leveling maximum time.
Specifies the maximum number of clock cycles that the controller will wait for a response (phy_dfi_rdlvl_resp) to a read leveling enable signal (ddrc_dfi_rdlvl_en or ddrc_dfi_rdlvl_gate_en). Only applicable when connecting to PHY's operating in 'PHY RdLvl Evaluation' mode. Typical value 0xFFF Units 1024 clocks</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="dfi_wrlvl_max_x1024">
                    <gui_name language="en">dfi_wrlvl_max_x1024</gui_name>
                    <description language="en">Write leveling maximum time. Specifies the maximum number of clock cycles that the controller will wait for a response (phy_dfi_wrlvl_resp) to a write leveling enable signal (ddrc_dfi_wrlvl_en). Only applicable when connecting to PHY's operating in 'PHY WrLvl Evaluation' mode. Typical value 0xFFF Units 1024 clocks</description>
                </bitField>
            </register>
            <register name="DDRC_REG_2D" offset="0xf80060b4" size="0x2">
                <gui_name language="en">reg_2d</gui_name>
                <description language="en">Misc Debug register</description>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="reg_ddrc_dis_pre_bypass">
                    <gui_name language="en">reg_ddrc_dis_pre_bypass</gui_name>
                    <description language="en">Only present in designs supporting precharge bypass. When 1, disable bypass path for high priority precharges FOR DEBUG ONLY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="reg_ddrc_skip_ocd">
                    <gui_name language="en">reg_ddrc_skip_ocd</gui_name>
                    <description language="en">This register must be kept at 1'b1. 1'b0 is NOT supported. 1 - Indicates the controller to skip OCD adjustment step during DDR2 initialization. OCD_Default and OCD_Exit are performed instead. 0 - Not supported.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="0" name="reg_ddrc_2t_delay">
                    <gui_name language="en">reg_ddrc_2t_delay</gui_name>
                    <description language="en">Selects the clock edge in which chip select (CSN) and CKE is asserted. Unsupported feature.</description>
                </bitField>
            </register>
            <register name="DDRC_DFI_TIMING" offset="0xf80060b8" size="0x4">
                <gui_name language="en">dfi_timing</gui_name>
                <description language="en">DFI timing register</description>
                <bitField access="Read Write" high_bit="24" low_bit="15" name="reg_ddrc_dfi_t_ctrlup_max">
                    <gui_name language="en">reg_ddrc_dfi_t_ctrlup_max</gui_name>
                    <description language="en">Specifies the maximum number of clock cycles that the ddrc_dfi_ctrlupd_req signal can assert.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="5" name="reg_ddrc_dfi_t_ctrlup_min">
                    <gui_name language="en">reg_ddrc_dfi_t_ctrlup_min</gui_name>
                    <description language="en">Specifies the minimum number of clock cycles that the ddrc_dfi_ctrlupd_req signal must be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="0" name="reg_ddrc_dfi_t_rddata_en">
                    <gui_name language="en">reg_ddrc_dfi_t_rddata_en</gui_name>
                    <description language="en">Time from the assertion of a READ command on the DFI interface to the assertion of the phy_dfi_rddata_en signal.
Non-LPDDR -&gt; RL-1
LPDDR -&gt; RL
Where RL is read latency of DRAM.</description>
                </bitField>
            </register>
            <register name="DDRC_REFRESH_TIMER_2" offset="0xf80060bc" size="0x4">
                <gui_name language="en">refresh_timer_2</gui_name>
                <description language="en">refresh parameters register</description>
                <bitField access="Read Write" high_bit="23" low_bit="12" name="reg_ddrc_refresh_timer3_start_value_x32">
                    <gui_name language="en">reg_ddrc_refresh_timer3_start_value_x32</gui_name>
                    <description language="en">Refresh Timer for Rank 3 (Only present in 4-rank configurations). Unit: in multiples of 32 clocks (Only present in multi-rank configurations). FOR PERFORMANCE ONLY.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="reg_ddrc_refresh_timer2_start_value_x32">
                    <gui_name language="en">reg_ddrc_refresh_timer2_start_value_x32</gui_name>
                    <description language="en">Refresh Timer for Rank 2 (Only present in 4-rank configurations). Unit: in multiples of 32 clocks (Only present in multi-rank configurations). FOR PERFORMANCE ONLY.</description>
                </bitField>
            </register>
            <register name="DDRC_NC_TIMING" offset="0xf80060c0" size="0x4">
                <gui_name language="en">nc_timing</gui_name>
                <description language="en">Unused register</description>
                <bitField access="Read Write" high_bit="21" low_bit="11" name="reg_ddrc_lpr_min_non_critical">
                    <gui_name language="en">reg_ddrc_lpr_min_non_critical</gui_name>
                    <description language="en">Unused.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_ddrc_hpr_min_non_critical">
                    <gui_name language="en">reg_ddrc_hpr_min_non_critical</gui_name>
                    <description language="en">Unused.</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_ECC_CONTROL_REG_OFFSET" offset="0xf80060c4" size="0x2">
                <gui_name language="en">CHE_ECC_CONTROL_REG_OFFSET</gui_name>
                <description language="en">ECC error clear register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="Clear_Correctable_DRAM_ECC_error">
                    <gui_name language="en">Clear_Correctable_DRAM_ECC_error</gui_name>
                    <description language="en">Writing 1 to this bit will clear the correctable log valid bit and the correctable error counters.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="Clear_Uncorrectable_DRAM_ECC_error">
                    <gui_name language="en">Clear_Uncorrectable_DRAM_ECC_error</gui_name>
                    <description language="en">Writing 1 to this bit will clear the uncorrectable log valid bit and the uncorrectable error counters.</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_CORR_ECC_LOG_REG_OFFSET" offset="0xf80060c8" size="0x2">
                <gui_name language="en">CHE_CORR_ECC_LOG_REG_OFFSET</gui_name>
                <description language="en">ECC error correction register</description>
                <bitField access="Read Write" high_bit="7" low_bit="1" name="ECC_CORRECTED_BIT_NUM">
                    <gui_name language="en">ECC_CORRECTED_BIT_NUM</gui_name>
                    <description language="en">Indicator of the bit number syndrome in error for single-bit errors. The field is 7-bit wide to handle 72-bits of data.
This is an encoded value with ECC bits placed in between data. The encoding is given in section 5.4 Correctable bit number from the lowest error lane is reported here. There are only 13-valid bits going to an ECC lane (8-data + 5-ECC). Only 4-bits are needed to encode a max value of d'13. Bit[7] of this register is used to indicate the exact byte lane. When a error happens, if CORR_ECC_LOG_COL[0] from register 0x33 is 1'b0, then the error happened in Lane 0 or 1. If CORR_ECC_LOG_COL[0] is 1'b1, then the error happened in Lane 2 or 3. Bit[7] of this register indicates whether the error is from upper or lower byte lane. If it is 0, then it is lower byte lane and if it is 1, then it is upper byte lane. Together with CORR_ECC_LOG_COL[0] and bit[7] of this register, the exact byte lane with correctable error can be determined.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="CORR_ECC_LOG_VALID">
                    <gui_name language="en">CORR_ECC_LOG_VALID</gui_name>
                    <description language="en">Set to '1' when a correctable ECC error is captured. As long as this is '1' no further ECC errors will be captured. This is cleared when a '1' is written to register bit[1] of ECC CONTROL REGISTER (0x31)</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_CORR_ECC_ADDR_REG_OFFSET" offset="0xf80060cc" size="0x4">
                <gui_name language="en">CHE_CORR_ECC_ADDR_REG_OFFSET</gui_name>
                <description language="en">ECC error correction address log register</description>
                <bitField access="Read Only" high_bit="30" low_bit="28" name="CORR_ECC_LOG_BANK">
                    <gui_name language="en">CORR_ECC_LOG_BANK</gui_name>
                    <description language="en">Bank[2:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="12" name="CORR_ECC_LOG_ROW">
                    <gui_name language="en">CORR_ECC_LOG_ROW</gui_name>
                    <description language="en">Row[15:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="0" name="CORR_ECC_LOG_COL">
                    <gui_name language="en">CORR_ECC_LOG_COL</gui_name>
                    <description language="en">Col[11:0]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_CORR_ECC_DATA_31_0_REG_OFFSET" offset="0xf80060d0" size="0x4">
                <gui_name language="en">CHE_CORR_ECC_DATA_31_0_REG_OFFSET</gui_name>
                <description language="en">ECC error correction data log low register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="CORR_ECC_LOG_DAT_31_0">
                    <gui_name language="en">CORR_ECC_LOG_DAT_31_0</gui_name>
                    <description language="en">bits [31:0] of the data that caused the captured correctable ECC error. (Data associated with the first ECC error if multiple errors occurred since CORR_ECC_LOG_VALID was cleared). Since each ECC engine handles 8-bits of data, only the lower 8-bits of this register have valid data. The upper 24-bits will always be 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_CORR_ECC_DATA_63_32_REG_OFFSET" offset="0xf80060d4" size="0x4">
                <gui_name language="en">CHE_CORR_ECC_DATA_63_32_REG_OFFSET</gui_name>
                <description language="en">ECC error correction data log mid register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="CORR_ECC_LOG_DAT_63_32">
                    <gui_name language="en">CORR_ECC_LOG_DAT_63_32</gui_name>
                    <description language="en">bits [63:32] of the data that caused the captured correctable ECC error. (Data associated with the first ECC error if multiple errors occurred since CORR_ECC_LOG_VALID was cleared) Since each ECC engine handles 8-bits of data and that is logged in register 0x34, all the 32-bits of this register will always be 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_CORR_ECC_DATA_71_64_REG_OFFSET" offset="0xf80060d8" size="0x2">
                <gui_name language="en">CHE_CORR_ECC_DATA_71_64_REG_OFFSET</gui_name>
                <description language="en">ECC error correction data log hi register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CORR_ECC_LOG_DAT_71_64">
                    <gui_name language="en">CORR_ECC_LOG_DAT_71_64</gui_name>
                    <description language="en">bits [71:64] of the data that caused the captured correctable ECC error. (Data associated with the first ECC error if multiple errors occurred since CORR_ECC_LOG_VALID was cleared) 5-bits of ECC are calculated over 8-bits of data. Bits[68:64] carries these 5-bits. Bits[71:69] are always 0.</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_UNCORR_ECC_LOG_REG_OFFSET" offset="0xf80060dc" size="0x2">
                <gui_name language="en">CHE_UNCORR_ECC_LOG_REG_OFFSET</gui_name>
                <description language="en">ECC unrecoverable error status register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="UNCORR_ECC_LOG_VALID">
                    <gui_name language="en">UNCORR_ECC_LOG_VALID</gui_name>
                    <description language="en">Set to '1' when an uncorrectable ECC error is captured. As long as this is '1' no further ECC errors will be captured. This is cleared when a '1' is written to register bit[0] of ECC CONTROL REGISTER (0x31).</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_UNCORR_ECC_ADDR_REG_OFFSET" offset="0xf80060e0" size="0x4">
                <gui_name language="en">CHE_UNCORR_ECC_ADDR_REG_OFFSET</gui_name>
                <description language="en">ECC unrecoverable error address register</description>
                <bitField access="Read Only" high_bit="30" low_bit="28" name="UNCORR_ECC_LOG_BANK">
                    <gui_name language="en">UNCORR_ECC_LOG_BANK</gui_name>
                    <description language="en">Bank[2:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="12" name="UNCORR_ECC_LOG_ROW">
                    <gui_name language="en">UNCORR_ECC_LOG_ROW</gui_name>
                    <description language="en">Row[15:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="0" name="UNCORR_ECC_LOG_COL">
                    <gui_name language="en">UNCORR_ECC_LOG_COL</gui_name>
                    <description language="en">Col[11:0]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_UNCORR_ECC_DATA_31_0_REG_OFFSET" offset="0xf80060e4" size="0x4">
                <gui_name language="en">CHE_UNCORR_ECC_DATA_31_0_REG_OFFSET</gui_name>
                <description language="en">ECC unrecoverable error data low register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="UNCORR_ECC_LOG_DAT_31_0">
                    <gui_name language="en">UNCORR_ECC_LOG_DAT_31_0</gui_name>
                    <description language="en">bits [31:0] of the data that caused the captured uncorrectable ECC error. (Data associated with the first ECC error if multiple errors occurred since UNCORR_ECC_LOG_VALID was cleared). Since each ECC engine handles 8-bits of data, only the lower 8-bits of this register have valid data. The upper 24-bits will always be 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_UNCORR_ECC_DATA_63_32_REG_OFFSET" offset="0xf80060e8" size="0x4">
                <gui_name language="en">CHE_UNCORR_ECC_DATA_63_32_REG_OFFSET</gui_name>
                <description language="en">ECC unrecoverable error data middle register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="UNCORR_ECC_LOG_DAT_63_32">
                    <gui_name language="en">UNCORR_ECC_LOG_DAT_63_32</gui_name>
                    <description language="en">bits [63:32] of the data that caused the captured uncorrectable ECC error. (Data associated with the first ECC error if multiple errors occurred since CORR_ECC_LOG_VALID was cleared) Since each ECC engine handles 8-bits of data and that is logged in register 0x34, all the 32-bits of this register will always be 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_UNCORR_ECC_DATA_71_64_REG_OFFSET" offset="0xf80060ec" size="0x2">
                <gui_name language="en">CHE_UNCORR_ECC_DATA_71_64_REG_OFFSET</gui_name>
                <description language="en">ECC unrecoverable error data hi register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="UNCORR_ECC_LOG_DAT_71_64">
                    <gui_name language="en">UNCORR_ECC_LOG_DAT_71_64</gui_name>
                    <description language="en">bits [71:64] of the data that caused the captured uncorrectable ECC error. (Data associated with the first ECC error if multiple errors occurred since UNCORR_ECC_LOG_VALID was cleared) 5-bits of ECC are calculated over 8-bits of data. Bits[68:64] carries these 5-bits. Bits[71:69] are always 0.</description>
                </bitField>
            </register>
            <register name="DDRC_CHE_ECC_STATS_REG_OFFSET" offset="0xf80060f0" size="0x2">
                <gui_name language="en">CHE_ECC_STATS_REG_OFFSET</gui_name>
                <description language="en">ECC error count register</description>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="STAT_NUM_CORR_ERR">
                    <gui_name language="en">STAT_NUM_CORR_ERR</gui_name>
                    <description language="en">Returns the number of correctable ECC errors seen since the last read. Counter saturates at max value. This is cleared when a '1' is written to register bit[1] of ECC CONTROL REGISTER (0x58).</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="STAT_NUM_UNCORR_ERR">
                    <gui_name language="en">STAT_NUM_UNCORR_ERR</gui_name>
                    <description language="en">Returns the number of un-correctable errors since the last read. Counter saturates at max value. This is cleared when a '1' is written to register bit[0] of ECC CONTROL REGISTER (0x58).</description>
                </bitField>
            </register>
            <register name="DDRC_ECC_SCRUB" offset="0xf80060f4" size="0x2">
                <gui_name language="en">ECC_scrub</gui_name>
                <description language="en">ECC mode/scrub register</description>
                <bitField access="Read Write" enumerationId="ECC_scrub_reg_ddrc_dis_scrub_ENUM" high_bit="3" low_bit="3" name="reg_ddrc_dis_scrub">
                    <gui_name language="en">reg_ddrc_dis_scrub</gui_name>
                    <description language="en">This feature is NOT supported. Only default value works.
1 - Disable ECC scrubs
0 - Enable ECC scrubs Valid only when reg_ddrc_ecc_mode = 3'b100.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ECC_scrub_reg_ddrc_ecc_mode_ENUM" high_bit="2" low_bit="0" name="reg_ddrc_ecc_mode">
                    <gui_name language="en">reg_ddrc_ecc_mode</gui_name>
                    <description language="en">DRAM ECC Mode. The only valid values that works for this project are 3'b000 (No ECC) and 3'b100 (SEC/DED over 1-beat). To run the design in ECC mode, set reg_ddrc_data_bus_width to 2'b01 (Half bus width) and reg_ddrc_ecc_mode to 3'b100. In this mode, there will be 16-data bits + 6-bit ECC on the DRAM bus. Controller must NOT be put in full bus width mode, when ECC is turned ON.
000 - No ECC,
001 - Reserved
010 - Parity
011 - Reserved
100 - SEC/DED over 1-beat
101 - SEC/DED over multiple beats
110 - Device Correction
111 - Reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_ECC_CORR_BIT_MASK_31_0_REG_OFFSET" offset="0xf80060f8" size="0x4">
                <gui_name language="en">CHE_ECC_CORR_BIT_MASK_31_0_REG_OFFSET</gui_name>
                <description language="en">ECC data mask low register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="ddrc_reg_ecc_corr_bit_mask">
                    <gui_name language="en">ddrc_reg_ecc_corr_bit_mask</gui_name>
                    <description language="en">Bits [31:0] of ddrc_reg_ecc_corr_bit_mask register. Indicates the mask of the corrected data. 1 - on any bit indicates that the bit has been corrected by the DRAM ECC logic 0 - on any bit indicates that the bit has NOT been corrected by the DRAM ECC logic. Valid when any bit of 'ddrc_reg_ecc_corrected_err' is high.This mask doesn't indicate any correction that has been made in the ECC check bits. If there are errors in multiple lanes, then this signal will have the mask for the lowest lane. Each ECC engine works on 8-bits of data. Hence only the lower 8-bits carry valid information. Upper 24-bits are always 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_CHE_ECC_CORR_BIT_MASK_63_32_REG_OFFSET" offset="0xf80060fc" size="0x4">
                <gui_name language="en">CHE_ECC_CORR_BIT_MASK_63_32_REG_OFFSET</gui_name>
                <description language="en">ECC data mask hi register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="ddrc_reg_ecc_corr_bit_mask">
                    <gui_name language="en">ddrc_reg_ecc_corr_bit_mask</gui_name>
                    <description language="en">Bits [63:32] of ddrc_reg_ecc_corr_bit_mask register. Indicates the mask of the corrected data. 1 - on any bit indicates that the bit has been corrected by the DRAM ECC logic 0 - on any bit indicates that the bit has NOT been corrected by the DRAM ECC logic. Valid when any bit of 'ddrc_reg_ecc_corrected_err' is high. This mask doesn't indicate any correction that has been made in the ECC check bits. If there are errors in multiple lanes, then this signal will have the mask for the lowest lane. Each ECC engine works on 8-bits of data and this is reported in register 0x3E. All 32-bits of this register are 0 always.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_RCVR_ENABLE" offset="0xf8006114" size="0x2">
                <gui_name language="en">phy_rcvr_enable</gui_name>
                <description language="en">Phy receiver enable register</description>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="reg_phy_dif_off">
                    <gui_name language="en">reg_phy_dif_off</gui_name>
                    <description language="en">Value to drive to IO receiver enable pins when turning it OFF.
When in powerdown or self-refresh (CKE=0) this value will be sent to the IOs to control receiver on/off.
IOD is the size specified by the IO_DIFEN_SIZE parameter.
Depending on the IO, one of these signals dif_on or dif_off can be used.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_phy_dif_on">
                    <gui_name language="en">reg_phy_dif_on</gui_name>
                    <description language="en">Value to drive to IO receiver enable pins when turning it ON.
When NOT in powerdown or self-refresh (when CKE=1) this value will be sent to the IOs to control receiver on/off.
IOD is the size specified by the IO_DIFEN_SIZE parameter.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_CONFIG0" offset="0xf8006118" size="0x4">
                <gui_name language="en">PHY_Config0</gui_name>
                <description language="en">PHY configuration register for data slice 0.</description>
                <bitField access="Read Write" high_bit="30" low_bit="24" name="reg_phy_dq_offset">
                    <gui_name language="en">reg_phy_dq_offset</gui_name>
                    <description language="en">Offset value from DQS to DQ. Default value: 0x40 (for 90 degree shift).
This is only used when reg_phy_use_wr_level=1.
#Note 1: When a port width (W) is multiple of N instances of Ranks or Slices, each instance will get W/N bits. Instance n will get (n+1)*(W/N) -1: n (W/N) bits where n (0, 1, to N-1) is the instance number of Rank or Slice.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="15" name="reg_phy_bist_err_clr">
                    <gui_name language="en">reg_phy_bist_err_clr</gui_name>
                    <description language="en">Clear the mismatch error flag from the BIST Checker. 1'b1: sticky error flag is cleared 1'b0: No effect</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="6" name="reg_phy_bist_shift_dq">
                    <gui_name language="en">reg_phy_bist_shift_dq</gui_name>
                    <description language="en">Determines whether early shifting is required for a particular DQ bit when reg_phy_bist_mode is 2'b10; 1'b1: PRBS pattern shifted early by 1 bit. 1'b0: PRBS pattern without any shift.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config0_reg_phy_board_lpbk_rx_ENUM" high_bit="5" low_bit="5" name="reg_phy_board_lpbk_rx">
                    <gui_name language="en">reg_phy_board_lpbk_rx</gui_name>
                    <description language="en">External Board Loopback testing.
1: This Slice behaves as Receiver for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="reg_phy_board_lpbk_tx">
                    <gui_name language="en">reg_phy_board_lpbk_tx</gui_name>
                    <description language="en">External Board Loopback testing. 1: This Slice behaves as Transmitter for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="reg_phy_wrlvl_inc_mode">
                    <gui_name language="en">reg_phy_wrlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="reg_phy_gatelvl_inc_mode">
                    <gui_name language="en">reg_phy_gatelvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_phy_rdlvl_inc_mode">
                    <gui_name language="en">reg_phy_rdlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config0_reg_phy_data_slice_in_use_ENUM" high_bit="0" low_bit="0" name="reg_phy_data_slice_in_use">
                    <gui_name language="en">reg_phy_data_slice_in_use</gui_name>
                    <description language="en">Data bus width selection for Read FIFO RE generation. One bit for each data slice.
1: data slice is valid.
0: read data responses are ignored.
Note: The Phy Data Slice 0 must always be enabled.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_CONFIG1" offset="0xf800611c" size="0x4">
                <gui_name language="en">PHY_Config1</gui_name>
                <description language="en">PHY configuration register for data slice 1.</description>
                <bitField access="Read Write" high_bit="30" low_bit="24" name="reg_phy_dq_offset">
                    <gui_name language="en">reg_phy_dq_offset</gui_name>
                    <description language="en">Offset value from DQS to DQ. Default value: 0x40 (for 90 degree shift).
This is only used when reg_phy_use_wr_level=1.
#Note 1: When a port width (W) is multiple of N instances of Ranks or Slices, each instance will get W/N bits. Instance n will get (n+1)*(W/N) -1: n (W/N) bits where n (0, 1, to N-1) is the instance number of Rank or Slice.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="15" name="reg_phy_bist_err_clr">
                    <gui_name language="en">reg_phy_bist_err_clr</gui_name>
                    <description language="en">Clear the mismatch error flag from the BIST Checker. 1'b1: sticky error flag is cleared 1'b0: No effect</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="6" name="reg_phy_bist_shift_dq">
                    <gui_name language="en">reg_phy_bist_shift_dq</gui_name>
                    <description language="en">Determines whether early shifting is required for a particular DQ bit when reg_phy_bist_mode is 2'b10; 1'b1: PRBS pattern shifted early by 1 bit. 1'b0: PRBS pattern without any shift.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config1_reg_phy_board_lpbk_rx_ENUM" high_bit="5" low_bit="5" name="reg_phy_board_lpbk_rx">
                    <gui_name language="en">reg_phy_board_lpbk_rx</gui_name>
                    <description language="en">External Board Loopback testing.
1: This Slice behaves as Receiver for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="reg_phy_board_lpbk_tx">
                    <gui_name language="en">reg_phy_board_lpbk_tx</gui_name>
                    <description language="en">External Board Loopback testing. 1: This Slice behaves as Transmitter for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="reg_phy_wrlvl_inc_mode">
                    <gui_name language="en">reg_phy_wrlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="reg_phy_gatelvl_inc_mode">
                    <gui_name language="en">reg_phy_gatelvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_phy_rdlvl_inc_mode">
                    <gui_name language="en">reg_phy_rdlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config1_reg_phy_data_slice_in_use_ENUM" high_bit="0" low_bit="0" name="reg_phy_data_slice_in_use">
                    <gui_name language="en">reg_phy_data_slice_in_use</gui_name>
                    <description language="en">Data bus width selection for Read FIFO RE generation. One bit for each data slice.
1: data slice is valid.
0: read data responses are ignored.
Note: The Phy Data Slice 0 must always be enabled.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_CONFIG2" offset="0xf8006120" size="0x4">
                <gui_name language="en">PHY_Config2</gui_name>
                <description language="en">PHY configuration register for data slice 2.</description>
                <bitField access="Read Write" high_bit="30" low_bit="24" name="reg_phy_dq_offset">
                    <gui_name language="en">reg_phy_dq_offset</gui_name>
                    <description language="en">Offset value from DQS to DQ. Default value: 0x40 (for 90 degree shift).
This is only used when reg_phy_use_wr_level=1.
#Note 1: When a port width (W) is multiple of N instances of Ranks or Slices, each instance will get W/N bits. Instance n will get (n+1)*(W/N) -1: n (W/N) bits where n (0, 1, to N-1) is the instance number of Rank or Slice.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="15" name="reg_phy_bist_err_clr">
                    <gui_name language="en">reg_phy_bist_err_clr</gui_name>
                    <description language="en">Clear the mismatch error flag from the BIST Checker. 1'b1: sticky error flag is cleared 1'b0: No effect</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="6" name="reg_phy_bist_shift_dq">
                    <gui_name language="en">reg_phy_bist_shift_dq</gui_name>
                    <description language="en">Determines whether early shifting is required for a particular DQ bit when reg_phy_bist_mode is 2'b10; 1'b1: PRBS pattern shifted early by 1 bit. 1'b0: PRBS pattern without any shift.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config2_reg_phy_board_lpbk_rx_ENUM" high_bit="5" low_bit="5" name="reg_phy_board_lpbk_rx">
                    <gui_name language="en">reg_phy_board_lpbk_rx</gui_name>
                    <description language="en">External Board Loopback testing.
1: This Slice behaves as Receiver for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="reg_phy_board_lpbk_tx">
                    <gui_name language="en">reg_phy_board_lpbk_tx</gui_name>
                    <description language="en">External Board Loopback testing. 1: This Slice behaves as Transmitter for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="reg_phy_wrlvl_inc_mode">
                    <gui_name language="en">reg_phy_wrlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="reg_phy_gatelvl_inc_mode">
                    <gui_name language="en">reg_phy_gatelvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_phy_rdlvl_inc_mode">
                    <gui_name language="en">reg_phy_rdlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config2_reg_phy_data_slice_in_use_ENUM" high_bit="0" low_bit="0" name="reg_phy_data_slice_in_use">
                    <gui_name language="en">reg_phy_data_slice_in_use</gui_name>
                    <description language="en">Data bus width selection for Read FIFO RE generation. One bit for each data slice.
1: data slice is valid.
0: read data responses are ignored.
Note: The Phy Data Slice 0 must always be enabled.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_CONFIG3" offset="0xf8006124" size="0x4">
                <gui_name language="en">PHY_Config3</gui_name>
                <description language="en">PHY configuration register for data slice 3.</description>
                <bitField access="Read Write" high_bit="30" low_bit="24" name="reg_phy_dq_offset">
                    <gui_name language="en">reg_phy_dq_offset</gui_name>
                    <description language="en">Offset value from DQS to DQ. Default value: 0x40 (for 90 degree shift).
This is only used when reg_phy_use_wr_level=1.
#Note 1: When a port width (W) is multiple of N instances of Ranks or Slices, each instance will get W/N bits. Instance n will get (n+1)*(W/N) -1: n (W/N) bits where n (0, 1, to N-1) is the instance number of Rank or Slice.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="15" name="reg_phy_bist_err_clr">
                    <gui_name language="en">reg_phy_bist_err_clr</gui_name>
                    <description language="en">Clear the mismatch error flag from the BIST Checker. 1'b1: sticky error flag is cleared 1'b0: No effect</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="6" name="reg_phy_bist_shift_dq">
                    <gui_name language="en">reg_phy_bist_shift_dq</gui_name>
                    <description language="en">Determines whether early shifting is required for a particular DQ bit when reg_phy_bist_mode is 2'b10; 1'b1: PRBS pattern shifted early by 1 bit. 1'b0: PRBS pattern without any shift.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config3_reg_phy_board_lpbk_rx_ENUM" high_bit="5" low_bit="5" name="reg_phy_board_lpbk_rx">
                    <gui_name language="en">reg_phy_board_lpbk_rx</gui_name>
                    <description language="en">External Board Loopback testing.
1: This Slice behaves as Receiver for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="reg_phy_board_lpbk_tx">
                    <gui_name language="en">reg_phy_board_lpbk_tx</gui_name>
                    <description language="en">External Board Loopback testing. 1: This Slice behaves as Transmitter for board loopback. 0: disable
This port must be set '0' always except when in external board level loopback test mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="reg_phy_wrlvl_inc_mode">
                    <gui_name language="en">reg_phy_wrlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="reg_phy_gatelvl_inc_mode">
                    <gui_name language="en">reg_phy_gatelvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_phy_rdlvl_inc_mode">
                    <gui_name language="en">reg_phy_rdlvl_inc_mode</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PHY_Config3_reg_phy_data_slice_in_use_ENUM" high_bit="0" low_bit="0" name="reg_phy_data_slice_in_use">
                    <gui_name language="en">reg_phy_data_slice_in_use</gui_name>
                    <description language="en">Data bus width selection for Read FIFO RE generation. One bit for each data slice.
1: data slice is valid.
0: read data responses are ignored.
Note: The Phy Data Slice 0 must always be enabled.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_INIT_RATIO0" offset="0xf800612c" size="0x4">
                <gui_name language="en">phy_init_ratio0</gui_name>
                <description language="en">PHY init ratio register for data slice 0.</description>
                <bitField access="Read Write" high_bit="19" low_bit="10" name="reg_phy_gatelvl_init_ratio">
                    <gui_name language="en">reg_phy_gatelvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used Gate Leveling FSM</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wrlvl_init_ratio">
                    <gui_name language="en">reg_phy_wrlvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used by Write Leveling FSM</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_INIT_RATIO1" offset="0xf8006130" size="0x4">
                <gui_name language="en">phy_init_ratio1</gui_name>
                <description language="en">PHY init ratio register for data slice 1.</description>
                <bitField access="Read Write" high_bit="19" low_bit="10" name="reg_phy_gatelvl_init_ratio">
                    <gui_name language="en">reg_phy_gatelvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used Gate Leveling FSM</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wrlvl_init_ratio">
                    <gui_name language="en">reg_phy_wrlvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used by Write Leveling FSM</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_INIT_RATIO2" offset="0xf8006134" size="0x4">
                <gui_name language="en">phy_init_ratio2</gui_name>
                <description language="en">PHY init ratio register for data slice 2.</description>
                <bitField access="Read Write" high_bit="19" low_bit="10" name="reg_phy_gatelvl_init_ratio">
                    <gui_name language="en">reg_phy_gatelvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used Gate Leveling FSM</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wrlvl_init_ratio">
                    <gui_name language="en">reg_phy_wrlvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used by Write Leveling FSM</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_INIT_RATIO3" offset="0xf8006138" size="0x4">
                <gui_name language="en">phy_init_ratio3</gui_name>
                <description language="en">PHY init ratio register for data slice 3.</description>
                <bitField access="Read Write" high_bit="19" low_bit="10" name="reg_phy_gatelvl_init_ratio">
                    <gui_name language="en">reg_phy_gatelvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used Gate Leveling FSM</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wrlvl_init_ratio">
                    <gui_name language="en">reg_phy_wrlvl_init_ratio</gui_name>
                    <description language="en">The user programmable init ratio used by Write Leveling FSM</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_RD_DQS_CFG0" offset="0xf8006140" size="0x4">
                <gui_name language="en">phy_rd_dqs_cfg0</gui_name>
                <description language="en">PHY read DQS configuration register for data slice 0.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_rd_dqs_slave_delay">
                    <gui_name language="en">reg_phy_rd_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_rd_dqs_slave_force is 1, replace delay/tap value for read DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_rd_dqs_cfg0_reg_phy_rd_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_rd_dqs_slave_force">
                    <gui_name language="en">reg_phy_rd_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for read DQS slave DLL with the value of the debug_rd_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_rd_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_rd_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for read DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the read DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line. Provide a default value of 0x40 for most applications</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_RD_DQS_CFG1" offset="0xf8006144" size="0x4">
                <gui_name language="en">phy_rd_dqs_cfg1</gui_name>
                <description language="en">PHY read DQS configuration register for data slice 1.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_rd_dqs_slave_delay">
                    <gui_name language="en">reg_phy_rd_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_rd_dqs_slave_force is 1, replace delay/tap value for read DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_rd_dqs_cfg1_reg_phy_rd_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_rd_dqs_slave_force">
                    <gui_name language="en">reg_phy_rd_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for read DQS slave DLL with the value of the debug_rd_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_rd_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_rd_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for read DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the read DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line. Provide a default value of 0x40 for most applications</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_RD_DQS_CFG2" offset="0xf8006148" size="0x4">
                <gui_name language="en">phy_rd_dqs_cfg2</gui_name>
                <description language="en">PHY read DQS configuration register for data slice 2.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_rd_dqs_slave_delay">
                    <gui_name language="en">reg_phy_rd_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_rd_dqs_slave_force is 1, replace delay/tap value for read DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_rd_dqs_cfg2_reg_phy_rd_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_rd_dqs_slave_force">
                    <gui_name language="en">reg_phy_rd_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for read DQS slave DLL with the value of the debug_rd_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_rd_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_rd_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for read DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the read DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line. Provide a default value of 0x40 for most applications</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_RD_DQS_CFG3" offset="0xf800614c" size="0x4">
                <gui_name language="en">phy_rd_dqs_cfg3</gui_name>
                <description language="en">PHY read DQS configuration register for data slice 3.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_rd_dqs_slave_delay">
                    <gui_name language="en">reg_phy_rd_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_rd_dqs_slave_force is 1, replace delay/tap value for read DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_rd_dqs_cfg3_reg_phy_rd_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_rd_dqs_slave_force">
                    <gui_name language="en">reg_phy_rd_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for read DQS slave DLL with the value of the debug_rd_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_rd_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_rd_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for read DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the read DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line. Provide a default value of 0x40 for most applications</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WR_DQS_CFG0" offset="0xf8006154" size="0x4">
                <gui_name language="en">phy_wr_dqs_cfg0</gui_name>
                <description language="en">PHY write DQS configuration register for data slice 0.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_dqs_slave_delay">
                    <gui_name language="en">reg_phy_wr_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_dqs_slave_force is 1, replace delay/tap value for write DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_wr_dqs_cfg0_reg_phy_wr_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_dqs_slave_force">
                    <gui_name language="en">reg_phy_wr_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write DQS slave DLL with the value of the reg_phy_wr_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_wr_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for write DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WR_DQS_CFG1" offset="0xf8006158" size="0x4">
                <gui_name language="en">phy_wr_dqs_cfg1</gui_name>
                <description language="en">PHY write DQS configuration register for data slice 1.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_dqs_slave_delay">
                    <gui_name language="en">reg_phy_wr_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_dqs_slave_force is 1, replace delay/tap value for write DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_wr_dqs_cfg1_reg_phy_wr_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_dqs_slave_force">
                    <gui_name language="en">reg_phy_wr_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write DQS slave DLL with the value of the reg_phy_wr_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_wr_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for write DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WR_DQS_CFG2" offset="0xf800615c" size="0x4">
                <gui_name language="en">phy_wr_dqs_cfg2</gui_name>
                <description language="en">PHY write DQS configuration register for data slice 2.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_dqs_slave_delay">
                    <gui_name language="en">reg_phy_wr_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_dqs_slave_force is 1, replace delay/tap value for write DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_wr_dqs_cfg2_reg_phy_wr_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_dqs_slave_force">
                    <gui_name language="en">reg_phy_wr_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write DQS slave DLL with the value of the reg_phy_wr_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_wr_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for write DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WR_DQS_CFG3" offset="0xf8006160" size="0x4">
                <gui_name language="en">phy_wr_dqs_cfg3</gui_name>
                <description language="en">PHY write DQS configuration register for data slice 3.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_dqs_slave_delay">
                    <gui_name language="en">reg_phy_wr_dqs_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_dqs_slave_force is 1, replace delay/tap value for write DQS slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_wr_dqs_cfg3_reg_phy_wr_dqs_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_dqs_slave_force">
                    <gui_name language="en">reg_phy_wr_dqs_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write DQS slave DLL with the value of the reg_phy_wr_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_dqs_slave_ratio">
                    <gui_name language="en">reg_phy_wr_dqs_slave_ratio</gui_name>
                    <description language="en">Ratio value for write DQS slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQS in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WE_CFG0" offset="0xf8006168" size="0x4">
                <gui_name language="en">phy_we_cfg0</gui_name>
                <description language="en">PHY fifo write enable configuration register for data slice 0.</description>
                <bitField access="Read Write" high_bit="20" low_bit="12" name="reg_phy_fifo_we_in_delay">
                    <gui_name language="en">reg_phy_fifo_we_in_delay</gui_name>
                    <description language="en">Delay value to be used when debug_fifo_we_in_forceX is set to 1. R is the number of Ranks supported.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_we_cfg0_reg_phy_fifo_we_in_force_ENUM" high_bit="11" low_bit="11" name="reg_phy_fifo_we_in_force">
                    <gui_name language="en">reg_phy_fifo_we_in_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for fifo_we_X slave DLL with the value of the debug_fifo_we_in_delayX bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_phy_fifo_we_slave_ratio">
                    <gui_name language="en">reg_phy_fifo_we_slave_ratio</gui_name>
                    <description language="en">Ratio value to be used when fifo_we_X_force_mode is set to 0.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WE_CFG1" offset="0xf800616c" size="0x4">
                <gui_name language="en">phy_we_cfg1</gui_name>
                <description language="en">PHY fifo write enable configuration register for data slice 1.</description>
                <bitField access="Read Write" high_bit="20" low_bit="12" name="reg_phy_fifo_we_in_delay">
                    <gui_name language="en">reg_phy_fifo_we_in_delay</gui_name>
                    <description language="en">Delay value to be used when debug_fifo_we_in_forceX is set to 1. R is the number of Ranks supported.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_we_cfg1_reg_phy_fifo_we_in_force_ENUM" high_bit="11" low_bit="11" name="reg_phy_fifo_we_in_force">
                    <gui_name language="en">reg_phy_fifo_we_in_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for fifo_we_X slave DLL with the value of the debug_fifo_we_in_delayX bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_phy_fifo_we_slave_ratio">
                    <gui_name language="en">reg_phy_fifo_we_slave_ratio</gui_name>
                    <description language="en">Ratio value to be used when fifo_we_X_force_mode is set to 0.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WE_CFG2" offset="0xf8006170" size="0x4">
                <gui_name language="en">phy_we_cfg2</gui_name>
                <description language="en">PHY fifo write enable configuration register for data slice 2.</description>
                <bitField access="Read Write" high_bit="20" low_bit="12" name="reg_phy_fifo_we_in_delay">
                    <gui_name language="en">reg_phy_fifo_we_in_delay</gui_name>
                    <description language="en">Delay value to be used when debug_fifo_we_in_forceX is set to 1. R is the number of Ranks supported.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_we_cfg2_reg_phy_fifo_we_in_force_ENUM" high_bit="11" low_bit="11" name="reg_phy_fifo_we_in_force">
                    <gui_name language="en">reg_phy_fifo_we_in_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for fifo_we_X slave DLL with the value of the debug_fifo_we_in_delayX bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_phy_fifo_we_slave_ratio">
                    <gui_name language="en">reg_phy_fifo_we_slave_ratio</gui_name>
                    <description language="en">Ratio value to be used when fifo_we_X_force_mode is set to 0.</description>
                </bitField>
            </register>
            <register name="DDRC_PHY_WE_CFG3" offset="0xf8006174" size="0x4">
                <gui_name language="en">phy_we_cfg3</gui_name>
                <description language="en">PHY fifo write enable configuration register for data slice 3.</description>
                <bitField access="Read Write" high_bit="20" low_bit="12" name="reg_phy_fifo_we_in_delay">
                    <gui_name language="en">reg_phy_fifo_we_in_delay</gui_name>
                    <description language="en">Delay value to be used when debug_fifo_we_in_forceX is set to 1. R is the number of Ranks supported.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="phy_we_cfg3_reg_phy_fifo_we_in_force_ENUM" high_bit="11" low_bit="11" name="reg_phy_fifo_we_in_force">
                    <gui_name language="en">reg_phy_fifo_we_in_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for fifo_we_X slave DLL with the value of the debug_fifo_we_in_delayX bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="0" name="reg_phy_fifo_we_slave_ratio">
                    <gui_name language="en">reg_phy_fifo_we_slave_ratio</gui_name>
                    <description language="en">Ratio value to be used when fifo_we_X_force_mode is set to 0.</description>
                </bitField>
            </register>
            <register name="DDRC_WR_DATA_SLV0" offset="0xf800617c" size="0x4">
                <gui_name language="en">wr_data_slv0</gui_name>
                <description language="en">PHY write data slave ratio configuration register for data slice 0.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_data_slave_delay">
                    <gui_name language="en">reg_phy_wr_data_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_data_slave_force is 1, replace delay/tap value for write data slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="wr_data_slv0_reg_phy_wr_data_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_data_slave_force">
                    <gui_name language="en">reg_phy_wr_data_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write data slave DLL with the value of the reg_phy_wr_data_slave_force bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_data_slave_ratio">
                    <gui_name language="en">reg_phy_wr_data_slave_ratio</gui_name>
                    <description language="en">Ratio value for write data slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQ muxes in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_WR_DATA_SLV1" offset="0xf8006180" size="0x4">
                <gui_name language="en">wr_data_slv1</gui_name>
                <description language="en">PHY write data slave ratio configuration register for data slice 1.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_data_slave_delay">
                    <gui_name language="en">reg_phy_wr_data_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_data_slave_force is 1, replace delay/tap value for write data slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="wr_data_slv1_reg_phy_wr_data_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_data_slave_force">
                    <gui_name language="en">reg_phy_wr_data_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write data slave DLL with the value of the reg_phy_wr_data_slave_force bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_data_slave_ratio">
                    <gui_name language="en">reg_phy_wr_data_slave_ratio</gui_name>
                    <description language="en">Ratio value for write data slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQ muxes in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_WR_DATA_SLV2" offset="0xf8006184" size="0x4">
                <gui_name language="en">wr_data_slv2</gui_name>
                <description language="en">PHY write data slave ratio configuration register for data slice 2.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_data_slave_delay">
                    <gui_name language="en">reg_phy_wr_data_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_data_slave_force is 1, replace delay/tap value for write data slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="wr_data_slv2_reg_phy_wr_data_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_data_slave_force">
                    <gui_name language="en">reg_phy_wr_data_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write data slave DLL with the value of the reg_phy_wr_data_slave_force bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_data_slave_ratio">
                    <gui_name language="en">reg_phy_wr_data_slave_ratio</gui_name>
                    <description language="en">Ratio value for write data slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQ muxes in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_WR_DATA_SLV3" offset="0xf8006188" size="0x4">
                <gui_name language="en">wr_data_slv3</gui_name>
                <description language="en">PHY write data slave ratio configuration register for data slice 3.</description>
                <bitField access="Read Write" high_bit="19" low_bit="11" name="reg_phy_wr_data_slave_delay">
                    <gui_name language="en">reg_phy_wr_data_slave_delay</gui_name>
                    <description language="en">If reg_phy_wr_data_slave_force is 1, replace delay/tap value for write data slave DLL with this value.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="wr_data_slv3_reg_phy_wr_data_slave_force_ENUM" high_bit="10" low_bit="10" name="reg_phy_wr_data_slave_force">
                    <gui_name language="en">reg_phy_wr_data_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for write data slave DLL with the value of the reg_phy_wr_data_slave_force bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_phy_wr_data_slave_ratio">
                    <gui_name language="en">reg_phy_wr_data_slave_ratio</gui_name>
                    <description language="en">Ratio value for write data slave DLL. This is the fraction of a clock cycle represented by the shift to be applied to the write DQ muxes in units of 256ths. In other words, the full-cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
            </register>
            <register name="DDRC_REG_64" offset="0xf8006190" size="0x4">
                <gui_name language="en">reg_64</gui_name>
                <description language="en">Training control register (2)</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="reg_phy_int_lpbk">
                    <gui_name language="en">reg_phy_int_lpbk</gui_name>
                    <description language="en">1=enables the PHY internal loopback for DQ,DQS,DM before Ios. By default must be 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="reg_phy_cmd_latency">
                    <gui_name language="en">reg_phy_cmd_latency</gui_name>
                    <description language="en">If set to 1, command comes to phy_ctrl through a flop.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_64_reg_phy_lpddr_ENUM" high_bit="29" low_bit="29" name="reg_phy_lpddr">
                    <gui_name language="en">reg_phy_lpddr</gui_name>
                    <description language="en">1= mobile/LPDDR DRAM device in use. 0=non-LPDDR DRAM device in use.</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="reg_phy_use_rank0_delays">
                    <gui_name language="en">reg_phy_use_rank0_delays</gui_name>
                    <description language="en">Delay selection 1- Rank 0 delays are used for all ranks 0- Each Rank uses its own delay</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="21" name="reg_phy_ctrl_slave_delay">
                    <gui_name language="en">reg_phy_ctrl_slave_delay</gui_name>
                    <description language="en">If reg_phy_rd_dqs_slave_force is 1, replace delay/tap value for address/command timing slave DLL with this value. This is a bit value, the remaining 2 bits are in register 0x65 bits[19:18].</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_64_reg_phy_ctrl_slave_force_ENUM" high_bit="20" low_bit="20" name="reg_phy_ctrl_slave_force">
                    <gui_name language="en">reg_phy_ctrl_slave_force</gui_name>
                    <description language="en">1: overwrite the delay/tap value for address/command timing slave DLL with the value of the reg_phy_rd_dqs_slave_delay bus.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="10" name="reg_phy_ctrl_slave_ratio">
                    <gui_name language="en">reg_phy_ctrl_slave_ratio</gui_name>
                    <description language="en">Ratio value for address/command launch timing in phy_ctrl macro. This is the fraction of a clock cycle represented by the shift to be applied to the read DQS in units of 256ths. In other words, the full cycle tap value from the master DLL will be scaled by this number over 256 to get the delay value for the slave delay line.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="reg_phy_sel_logic">
                    <gui_name language="en">reg_phy_sel_logic</gui_name>
                    <description language="en">Selects one of the two read leveling algorithms.'b0 = Select algorithm # 1'b1 = Select algorithm # 2
Please refer to Read Data Eye Training section in PHY User Guide for details about the Read Leveling algorithms</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="reg_phy_all_dq_mpr_rd_resp">
                    <gui_name language="en">reg_phy_all_dq_mpr_rd_resp</gui_name>
                    <description language="en">1=assume DRAM provides read response on all DQ bits. (In this mode, dq_in[7:0] are OR'd together and dq_in[15:8] are AND'd together.)
0=(default) best for DRAM read responses on only 1 DQ bit; works with reduced accuracy if DRAM provides read response on all bits. (In this mode dq_in[7:0] are OR'd together and dq_in[15:8] are OR'd together.)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_64_reg_phy_invert_clkout_ENUM" high_bit="7" low_bit="7" name="reg_phy_invert_clkout">
                    <gui_name language="en">reg_phy_invert_clkout</gui_name>
                    <description language="en">Inverts the polarity of DRAM clock.
0: core clock is passed on to DRAM
1: inverted core clock is passed on to DRAM.
Use this when CLK can arrive at a DRAM device ahead of DQS or coincidence with DQS based on board topology. This effectively delays the CLK to the DRAM device by half -cycle, providing a CLK edge that DQS can align to during leveling.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_64_reg_phy_bist_mode_ENUM" high_bit="6" low_bit="5" name="reg_phy_bist_mode">
                    <gui_name language="en">reg_phy_bist_mode</gui_name>
                    <description language="en">The mode bits select the pattern type generated by the BIST generator. All the patterns are transmitted continuously once enabled.
2'b00: constant pattern (0 repeated on each DQ bit)
2'b01: low freq pattern (00001111 repeated on each DQ bit)
2'b10: PRBS pattern (2^7-1 PRBS pattern repeated on each DQ bit) Each DQ bit always has same data value except when early shifting in PRBS mode is requested</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="reg_phy_bist_force_err">
                    <gui_name language="en">reg_phy_bist_force_err</gui_name>
                    <description language="en">This register bit is used to check that BIST checker is not giving false pass.
When this port is set 1, data bit gets inverted before sending out to the external memory and BIST checker must return a mismatch error.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="reg_phy_bist_enable">
                    <gui_name language="en">reg_phy_bist_enable</gui_name>
                    <description language="en">Enable the internal BIST generation and checker logic when this port is set HIGH. Setting this port as 0 will stop the BIST generator/checker.
In order to run BIST tests, this port must be set along with reg_phy_loopback.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_64_reg_phy_at_spd_atpg_ENUM" high_bit="2" low_bit="2" name="reg_phy_at_spd_atpg">
                    <gui_name language="en">reg_phy_at_spd_atpg</gui_name>
                    <description language="en">1 = run scan test at full clock speed but with less coverage
0 = run scan test at slow clock speed but with high coverage
During normal function mode, this port must be set 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_phy_bl2">
                    <gui_name language="en">reg_phy_bl2</gui_name>
                    <description language="en">Reserved for future Use.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="reg_phy_loopback">
                    <gui_name language="en">reg_phy_loopback</gui_name>
                    <description language="en">Loopback testing. 1: enable, 0: disable</description>
                </bitField>
            </register>
            <register name="DDRC_REG_65" offset="0xf8006194" size="0x4">
                <gui_name language="en">reg_65</gui_name>
                <description language="en">Training control register (3)</description>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="reg_phy_ctrl_slave_delay">
                    <gui_name language="en">reg_phy_ctrl_slave_delay</gui_name>
                    <description language="en">If reg-phy_rd_dqs_slave_force is 1, replace delay/tap value for address/command timing slave DLL with this value</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_phy_dis_calib_rst">
                    <gui_name language="en">reg_phy_dis_calib_rst</gui_name>
                    <description language="en">Disable the dll_calib (internally generated) signal from resetting the Read Capture FIFO pointers and portions of phy_data.
Note: dll_calib is
(i) generated by dfi_ctrl_upd_req or
(ii) by the PHY when it detects that the clock frequency variation has exceeded the bounds set by reg_phy_dll_lock_diff or
(iii) periodically throughout the leveling process.
dll_calib will update the slave DL with PVT-compensated values according to master DLL outputs</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_65_reg_phy_use_rd_data_eye_level_ENUM" high_bit="16" low_bit="16" name="reg_phy_use_rd_data_eye_level">
                    <gui_name language="en">reg_phy_use_rd_data_eye_level</gui_name>
                    <description language="en">Read Data Eye training control.
0: Use register programmed ratio values
1: Use ratio for delay line calculated by data eye leveling
Note: This is a Synchronous dynamic signal that requires timing closure</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_65_reg_phy_use_rd_dqs_gate_level_ENUM" high_bit="15" low_bit="15" name="reg_phy_use_rd_dqs_gate_level">
                    <gui_name language="en">reg_phy_use_rd_dqs_gate_level</gui_name>
                    <description language="en">Read DQS Gate training control.
0: Use register programmed ratio values
1: Use ratio for delay line calculated by DQS gate leveling
Note: This is a Synchronous dynamic signal that requires timing closure.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="reg_65_reg_phy_use_wr_level_ENUM" high_bit="14" low_bit="14" name="reg_phy_use_wr_level">
                    <gui_name language="en">reg_phy_use_wr_level</gui_name>
                    <description language="en">Write Leveling training control.
0: Use register programmed ratio values
1: Use ratio for delay line calculated by write leveling
Note: This is a Synchronous dynamic signal that requires timing closure.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="10" name="reg_phy_dll_lock_diff">
                    <gui_name language="en">reg_phy_dll_lock_diff</gui_name>
                    <description language="en">The Maximum number of delay line taps variation allowed while maintaining the master DLL lock.
When the PHY is in locked state and the variation on the clock exceeds the variation indicated by the register, the lock signal is deasserted</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="5" name="reg_phy_rd_rl_delay">
                    <gui_name language="en">reg_phy_rd_rl_delay</gui_name>
                    <description language="en">This delay determines when to select the active rank's ratio logic delay for Read Data and Read DQS slave delay lines after PHY receives a read command at Control Interface.
The programmed value must be (Read Latency - 3) with a minimum value of 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="0" name="reg_phy_wr_rl_delay">
                    <gui_name language="en">reg_phy_wr_rl_delay</gui_name>
                    <description language="en">This delay determines when to select the active rank's ratio logic delay for Write Data and Write DQS slave delay lines after PHY receives a write command at Control Interface.
The programmed value must be (Write Latency - 4) with a minimum value of 1.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG69_6C0" offset="0xf80061a4" size="0x4">
                <gui_name language="en">reg69_6c0</gui_name>
                <description language="en">Training results for data slice 0.</description>
                <bitField access="Read Only" high_bit="28" low_bit="20" name="phy_reg_status_fifo_we_slave_dll_value">
                    <gui_name language="en">phy_reg_status_fifo_we_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to FIFO WE slave DLL.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="phy_reg_rdlvl_fifowein_ratio">
                    <gui_name language="en">phy_reg_rdlvl_fifowein_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Gate training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_bist_err">
                    <gui_name language="en">phy_reg_bist_err</gui_name>
                    <description language="en">Mismatch error flag from the BIST Checker. 1 bit per data slice. 1'b1: Pattern mismatch error 1'b0: All patterns matched This is a sticky flag. In order to clear this bit, port reg_phy_bist_err_clr must be set HIGH.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG69_6C1" offset="0xf80061a8" size="0x4">
                <gui_name language="en">reg69_6c1</gui_name>
                <description language="en">Training results for data slice 1.</description>
                <bitField access="Read Only" high_bit="28" low_bit="20" name="phy_reg_status_fifo_we_slave_dll_value">
                    <gui_name language="en">phy_reg_status_fifo_we_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to FIFO WE slave DLL.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="phy_reg_rdlvl_fifowein_ratio">
                    <gui_name language="en">phy_reg_rdlvl_fifowein_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Gate training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_bist_err">
                    <gui_name language="en">phy_reg_bist_err</gui_name>
                    <description language="en">Mismatch error flag from the BIST Checker. 1 bit per data slice. 1'b1: Pattern mismatch error 1'b0: All patterns matched This is a sticky flag. In order to clear this bit, port reg_phy_bist_err_clr must be set HIGH.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG69_6C2" offset="0xf80061ac" size="0x4">
                <gui_name language="en">reg69_6c2</gui_name>
                <description language="en">Training results for data slice 2.</description>
                <bitField access="Read Only" high_bit="28" low_bit="20" name="phy_reg_status_fifo_we_slave_dll_value">
                    <gui_name language="en">phy_reg_status_fifo_we_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to FIFO WE slave DLL.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="phy_reg_rdlvl_fifowein_ratio">
                    <gui_name language="en">phy_reg_rdlvl_fifowein_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Gate training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_bist_err">
                    <gui_name language="en">phy_reg_bist_err</gui_name>
                    <description language="en">Mismatch error flag from the BIST Checker. 1 bit per data slice. 1'b1: Pattern mismatch error 1'b0: All patterns matched This is a sticky flag. In order to clear this bit, port reg_phy_bist_err_clr must be set HIGH.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG69_6C3" offset="0xf80061b0" size="0x4">
                <gui_name language="en">reg69_6c3</gui_name>
                <description language="en">Training results for data slice 3.</description>
                <bitField access="Read Only" high_bit="28" low_bit="20" name="phy_reg_status_fifo_we_slave_dll_value">
                    <gui_name language="en">phy_reg_status_fifo_we_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to FIFO WE slave DLL.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="phy_reg_rdlvl_fifowein_ratio">
                    <gui_name language="en">phy_reg_rdlvl_fifowein_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Gate training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_bist_err">
                    <gui_name language="en">phy_reg_bist_err</gui_name>
                    <description language="en">Mismatch error flag from the BIST Checker. 1 bit per data slice. 1'b1: Pattern mismatch error 1'b0: All patterns matched This is a sticky flag. In order to clear this bit, port reg_phy_bist_err_clr must be set HIGH.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG6E_710" offset="0xf80061b8" size="0x4">
                <gui_name language="en">reg6e_710</gui_name>
                <description language="en">Training results (2) for data slice 0.</description>
                <bitField access="Read Only" high_bit="29" low_bit="20" name="phy_reg_rdlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_rdlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Data Eye training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="10" name="phy_reg_wrlvl_dq_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dq_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write Data.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="phy_reg_wrlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write DQS.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG6E_711" offset="0xf80061bc" size="0x4">
                <gui_name language="en">reg6e_711</gui_name>
                <description language="en">Training results (2) for data slice 1.</description>
                <bitField access="Read Only" high_bit="29" low_bit="20" name="phy_reg_rdlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_rdlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Data Eye training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="10" name="phy_reg_wrlvl_dq_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dq_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write Data.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="phy_reg_wrlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write DQS.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG6E_712" offset="0xf80061c0" size="0x4">
                <gui_name language="en">reg6e_712</gui_name>
                <description language="en">Training results (2) for data slice 2.</description>
                <bitField access="Read Only" high_bit="29" low_bit="20" name="phy_reg_rdlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_rdlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Data Eye training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="10" name="phy_reg_wrlvl_dq_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dq_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write Data.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="phy_reg_wrlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write DQS.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_REG6E_713" offset="0xf80061c4" size="0x4">
                <gui_name language="en">reg6e_713</gui_name>
                <description language="en">Training results (2) for data slice 3.</description>
                <bitField access="Read Only" high_bit="29" low_bit="20" name="phy_reg_rdlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_rdlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by Read Data Eye training FSM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="10" name="phy_reg_wrlvl_dq_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dq_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write Data.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="phy_reg_wrlvl_dqs_ratio">
                    <gui_name language="en">phy_reg_wrlvl_dqs_ratio</gui_name>
                    <description language="en">Ratio value generated by the write leveling FSM for Write DQS.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_DLL_STS0" offset="0xf80061cc" size="0x4">
                <gui_name language="en">phy_dll_sts0</gui_name>
                <description language="en">Slave DLL results for data slice 0.</description>
                <bitField access="Read Only" high_bit="26" low_bit="18" name="phy_reg_status_wr_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write DQS slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="9" name="phy_reg_status_wr_data_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_data_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write data slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_status_rd_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_rd_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to read data slave DLL</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_DLL_STS1" offset="0xf80061d0" size="0x4">
                <gui_name language="en">phy_dll_sts1</gui_name>
                <description language="en">Slave DLL results for data slice 1.</description>
                <bitField access="Read Only" high_bit="26" low_bit="18" name="phy_reg_status_wr_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write DQS slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="9" name="phy_reg_status_wr_data_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_data_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write data slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_status_rd_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_rd_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to read data slave DLL</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_DLL_STS2" offset="0xf80061d4" size="0x4">
                <gui_name language="en">phy_dll_sts2</gui_name>
                <description language="en">Slave DLL results for data slice 2.</description>
                <bitField access="Read Only" high_bit="26" low_bit="18" name="phy_reg_status_wr_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write DQS slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="9" name="phy_reg_status_wr_data_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_data_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write data slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_status_rd_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_rd_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to read data slave DLL</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_DLL_STS3" offset="0xf80061d8" size="0x4">
                <gui_name language="en">phy_dll_sts3</gui_name>
                <description language="en">Slave DLL results for data slice 3.</description>
                <bitField access="Read Only" high_bit="26" low_bit="18" name="phy_reg_status_wr_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write DQS slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="9" name="phy_reg_status_wr_data_slave_dll_value">
                    <gui_name language="en">phy_reg_status_wr_data_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to write data slave DLL</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_status_rd_dqs_slave_dll_value">
                    <gui_name language="en">phy_reg_status_rd_dqs_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to read data slave DLL</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_DLL_LOCK_STS" offset="0xf80061e0" size="0x2">
                <gui_name language="en">dll_lock_sts</gui_name>
                <description language="en">DLL Lock Status</description>
                <bitField access="Read Only" high_bit="11" low_bit="10" name="phy_reg_status_of_in_lock_state">
                    <gui_name language="en">phy_reg_status_of_in_lock_state</gui_name>
                    <description language="en">Lock status from the Output Filter module inside the Master DLL. Bit[0] - Fine delay line lock status. 1: locked, 0: unlocked. Bit[1] - Coarse delay line lock status. 1: locked, 0: unlocked.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="1" name="phy_reg_status_dll_slave_value">
                    <gui_name language="en">phy_reg_status_dll_slave_value</gui_name>
                    <description language="en">Shows the current Coarse and Fine delay values going to all the Slave DLLs [1:0] - Fine value [8:2] - Coarse value</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="phy_reg_status_dll_lock">
                    <gui_name language="en">phy_reg_status_dll_lock</gui_name>
                    <description language="en">Status signal: 1 - Master DLL is locked 0 - Master DLL is not locked</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_CTRL_STS" offset="0xf80061e4" size="0x4">
                <gui_name language="en">phy_ctrl_sts</gui_name>
                <description language="en">PHY Control status</description>
                <bitField access="Read Only" high_bit="29" low_bit="28" name="phy_reg_status_phy_ctrl_of_in_lock_state">
                    <gui_name language="en">phy_reg_status_phy_ctrl_of_in_lock_state</gui_name>
                    <description language="en">Lock status from the Output Filter module inside the PHY_CTRL Master DLL. Bit[0] - Fine delay line lock status. 1: locked, 0: unlocked. Bit[1] - Coarse delay line lock status. 1: locked, 0: unlocked.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="20" name="phy_reg_status_phy_ctrl_dll_slave_value">
                    <gui_name language="en">phy_reg_status_phy_ctrl_dll_slave_value</gui_name>
                    <description language="en">Shows the current Coarse and Fine delay value going to the PHY_CTRL Slave DLL [1:0] - Fine value [8:2] - Coarse value</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="phy_reg_status_phy_ctrl_dll_lock">
                    <gui_name language="en">phy_reg_status_phy_ctrl_dll_lock</gui_name>
                    <description language="en">PHY_CTRL Master DLL Status signal: 1 - Master DLL is locked 0 - Master DLL is not locked</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="10" name="phy_reg_status_of_out_delay_value">
                    <gui_name language="en">phy_reg_status_of_out_delay_value</gui_name>
                    <description language="en">The Coarse and Fine values coming out of the Output Filter in Master DLL. \'7bcoarse[6:0],fine[1:0]\'7d Note: No default value recommended for this register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="phy_reg_status_of_in_delay_value">
                    <gui_name language="en">phy_reg_status_of_in_delay_value</gui_name>
                    <description language="en">The Coarse and Fine values going into the Output Filter in Master DLL. \'7bcoarse[6:0],fine[1:0]\'7d
Note: No default value recommended for this register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_CTRL_STS_REG2" offset="0xf80061e8" size="0x4">
                <gui_name language="en">phy_ctrl_sts_reg2</gui_name>
                <description language="en">PHY Control status (2)</description>
                <bitField access="Read Only" high_bit="26" low_bit="18" name="phy_reg_status_phy_ctrl_slave_dll_value">
                    <gui_name language="en">phy_reg_status_phy_ctrl_slave_dll_value</gui_name>
                    <description language="en">Delay value applied to read DQS slave DLL.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="0" name="phy_reg_status_phy_ctrl_of_in_delay_value">
                    <gui_name language="en">phy_reg_status_phy_ctrl_of_in_delay_value</gui_name>
                    <description language="en">The Coarse and Fine values going into the Output Filter in PHY_CTRL Master DLL. \'7bcoarse[6:0],fine[1:0]\'7d</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_AXI_ID" offset="0xf8006200" size="0x4">
                <gui_name language="en">axi_id</gui_name>
                <description language="en">ID and revision information</description>
                <bitField access="Read Only" high_bit="25" low_bit="20" name="reg_arb_rev_num">
                    <gui_name language="en">reg_arb_rev_num</gui_name>
                    <description language="en">Revision Number</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="12" name="reg_arb_prov_num">
                    <gui_name language="en">reg_arb_prov_num</gui_name>
                    <description language="en">Prov number</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="0" name="reg_arb_part_num">
                    <gui_name language="en">reg_arb_part_num</gui_name>
                    <description language="en">Part Number</description>
                </bitField>
            </register>
            <register name="DDRC_PAGE_MASK" offset="0xf8006204" size="0x4">
                <gui_name language="en">page_mask</gui_name>
                <description language="en">Page mask register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="reg_arb_page_addr_mask">
                    <gui_name language="en">reg_arb_page_addr_mask</gui_name>
                    <description language="en">This register must be set based on the value programmed on the reg_ddrc_addrmap_* registers. Set the Column address bits to 0. Set the Page and Bank address bits to 1.
This is used for calculating page_match inside the slave modules in Arbiter. The page_match is considered during the arbitration process. This mask applies to 64-bit address and not byte address.
Setting this value to 0 disables transaction prioritization based on page/bank match.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_WR_PORT0" offset="0xf8006208" size="0x4">
                <gui_name language="en">axi_priority_wr_port0</gui_name>
                <description language="en">AXI Priority control for write port 0.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_dis_rmw_portn">
                    <gui_name language="en">reg_arb_dis_rmw_portn</gui_name>
                    <description language="en">FEATURE NOT SUPPORTED. Only 16-bit data aligned transfers allowed when ECC is used. All commands issued as Writes. No RMW support. Disable RMW command generated for this Port 1 - Disable RMW feature 0 - Enable RMW feature When Enabled and ECC mode is set all Write command generated by this port will be RMW.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_wr_portn">
                    <gui_name language="en">reg_arb_dis_page_match_wr_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_wr_portn">
                    <gui_name language="en">reg_arb_disable_urgent_wr_portn</gui_name>
                    <description language="en">Disable urgent for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_wr_portn">
                    <gui_name language="en">reg_arb_disable_aging_wr_portn</gui_name>
                    <description language="en">Disable aging for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_wr_portn">
                    <gui_name language="en">reg_arb_pri_wr_portn</gui_name>
                    <description language="en">Priority of this Write Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_WR_PORT1" offset="0xf800620c" size="0x4">
                <gui_name language="en">axi_priority_wr_port1</gui_name>
                <description language="en">AXI Priority control for write port 1.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_dis_rmw_portn">
                    <gui_name language="en">reg_arb_dis_rmw_portn</gui_name>
                    <description language="en">FEATURE NOT SUPPORTED. Only 16-bit data aligned transfers allowed when ECC is used. All commands issued as Writes. No RMW support. Disable RMW command generated for this Port 1 - Disable RMW feature 0 - Enable RMW feature When Enabled and ECC mode is set all Write command generated by this port will be RMW.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_wr_portn">
                    <gui_name language="en">reg_arb_dis_page_match_wr_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_wr_portn">
                    <gui_name language="en">reg_arb_disable_urgent_wr_portn</gui_name>
                    <description language="en">Disable urgent for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_wr_portn">
                    <gui_name language="en">reg_arb_disable_aging_wr_portn</gui_name>
                    <description language="en">Disable aging for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_wr_portn">
                    <gui_name language="en">reg_arb_pri_wr_portn</gui_name>
                    <description language="en">Priority of this Write Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_WR_PORT2" offset="0xf8006210" size="0x4">
                <gui_name language="en">axi_priority_wr_port2</gui_name>
                <description language="en">AXI Priority control for write port 2.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_dis_rmw_portn">
                    <gui_name language="en">reg_arb_dis_rmw_portn</gui_name>
                    <description language="en">FEATURE NOT SUPPORTED. Only 16-bit data aligned transfers allowed when ECC is used. All commands issued as Writes. No RMW support. Disable RMW command generated for this Port 1 - Disable RMW feature 0 - Enable RMW feature When Enabled and ECC mode is set all Write command generated by this port will be RMW.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_wr_portn">
                    <gui_name language="en">reg_arb_dis_page_match_wr_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_wr_portn">
                    <gui_name language="en">reg_arb_disable_urgent_wr_portn</gui_name>
                    <description language="en">Disable urgent for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_wr_portn">
                    <gui_name language="en">reg_arb_disable_aging_wr_portn</gui_name>
                    <description language="en">Disable aging for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_wr_portn">
                    <gui_name language="en">reg_arb_pri_wr_portn</gui_name>
                    <description language="en">Priority of this Write Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_WR_PORT3" offset="0xf8006214" size="0x4">
                <gui_name language="en">axi_priority_wr_port3</gui_name>
                <description language="en">AXI Priority control for write port 3.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_dis_rmw_portn">
                    <gui_name language="en">reg_arb_dis_rmw_portn</gui_name>
                    <description language="en">FEATURE NOT SUPPORTED. Only 16-bit data aligned transfers allowed when ECC is used. All commands issued as Writes. No RMW support. Disable RMW command generated for this Port 1 - Disable RMW feature 0 - Enable RMW feature When Enabled and ECC mode is set all Write command generated by this port will be RMW.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_wr_portn">
                    <gui_name language="en">reg_arb_dis_page_match_wr_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_wr_portn">
                    <gui_name language="en">reg_arb_disable_urgent_wr_portn</gui_name>
                    <description language="en">Disable urgent for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_wr_portn">
                    <gui_name language="en">reg_arb_disable_aging_wr_portn</gui_name>
                    <description language="en">Disable aging for this Write Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_wr_portn">
                    <gui_name language="en">reg_arb_pri_wr_portn</gui_name>
                    <description language="en">Priority of this Write Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_RD_PORT0" offset="0xf8006218" size="0x4">
                <gui_name language="en">axi_priority_rd_port0</gui_name>
                <description language="en">AXI Priority control for read port 0.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_rd_portn">
                    <gui_name language="en">reg_arb_set_hpr_rd_portn</gui_name>
                    <description language="en">Enable reads to be generated as HPR for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_rd_portn">
                    <gui_name language="en">reg_arb_dis_page_match_rd_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_rd_portn">
                    <gui_name language="en">reg_arb_disable_urgent_rd_portn</gui_name>
                    <description language="en">Disable urgent for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_rd_portn">
                    <gui_name language="en">reg_arb_disable_aging_rd_portn</gui_name>
                    <description language="en">Disable aging for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_rd_portn">
                    <gui_name language="en">reg_arb_pri_rd_portn</gui_name>
                    <description language="en">Priority of this Read Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_RD_PORT1" offset="0xf800621c" size="0x4">
                <gui_name language="en">axi_priority_rd_port1</gui_name>
                <description language="en">AXI Priority control for read port 1.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_rd_portn">
                    <gui_name language="en">reg_arb_set_hpr_rd_portn</gui_name>
                    <description language="en">Enable reads to be generated as HPR for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_rd_portn">
                    <gui_name language="en">reg_arb_dis_page_match_rd_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_rd_portn">
                    <gui_name language="en">reg_arb_disable_urgent_rd_portn</gui_name>
                    <description language="en">Disable urgent for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_rd_portn">
                    <gui_name language="en">reg_arb_disable_aging_rd_portn</gui_name>
                    <description language="en">Disable aging for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_rd_portn">
                    <gui_name language="en">reg_arb_pri_rd_portn</gui_name>
                    <description language="en">Priority of this Read Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_RD_PORT2" offset="0xf8006220" size="0x4">
                <gui_name language="en">axi_priority_rd_port2</gui_name>
                <description language="en">AXI Priority control for read port 2.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_rd_portn">
                    <gui_name language="en">reg_arb_set_hpr_rd_portn</gui_name>
                    <description language="en">Enable reads to be generated as HPR for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_rd_portn">
                    <gui_name language="en">reg_arb_dis_page_match_rd_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_rd_portn">
                    <gui_name language="en">reg_arb_disable_urgent_rd_portn</gui_name>
                    <description language="en">Disable urgent for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_rd_portn">
                    <gui_name language="en">reg_arb_disable_aging_rd_portn</gui_name>
                    <description language="en">Disable aging for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_rd_portn">
                    <gui_name language="en">reg_arb_pri_rd_portn</gui_name>
                    <description language="en">Priority of this Read Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AXI_PRIORITY_RD_PORT3" offset="0xf8006224" size="0x4">
                <gui_name language="en">axi_priority_rd_port3</gui_name>
                <description language="en">AXI Priority control for read port 3.</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_rd_portn">
                    <gui_name language="en">reg_arb_set_hpr_rd_portn</gui_name>
                    <description language="en">Enable reads to be generated as HPR for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_rd_portn">
                    <gui_name language="en">reg_arb_dis_page_match_rd_portn</gui_name>
                    <description language="en">Disable the page match feature.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_rd_portn">
                    <gui_name language="en">reg_arb_disable_urgent_rd_portn</gui_name>
                    <description language="en">Disable urgent for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_rd_portn">
                    <gui_name language="en">reg_arb_disable_aging_rd_portn</gui_name>
                    <description language="en">Disable aging for this Read Port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_rd_portn">
                    <gui_name language="en">reg_arb_pri_rd_portn</gui_name>
                    <description language="en">Priority of this Read Port n. Value in this register used to load the aging counters (when respective port request is asserted and grant is generated to that port). These register can be reprogrammed to set priority of each port. Lower the value more will be priority given to the port. For example if 0x82 (port 0) value is set to 'h3FF, and 0x83 (port 1) is set to 'h0FF, and both port0 and port1 have requests, in this case port1 will get high priority and grant will be given to port1.</description>
                </bitField>
            </register>
            <register name="DDRC_AHB_PRIORITY_CFG0" offset="0xf8006248" size="0x4">
                <gui_name language="en">AHB_priority_cfg0</gui_name>
                <description language="en">AHB Priority control for port 0 (unused).</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_ahb_portn">
                    <gui_name language="en">reg_arb_set_hpr_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_ahb_portn">
                    <gui_name language="en">reg_arb_dis_page_match_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_ahb_portn">
                    <gui_name language="en">reg_arb_disable_urgent_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_ahb_portn">
                    <gui_name language="en">reg_arb_disable_aging_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_ahb_portn">
                    <gui_name language="en">reg_arb_pri_ahb_portn</gui_name>
                    <description language="en">Unused</description>
                </bitField>
            </register>
            <register name="DDRC_AHB_PRIORITY_CFG1" offset="0xf800624c" size="0x4">
                <gui_name language="en">AHB_priority_cfg1</gui_name>
                <description language="en">AHB Priority control for port 1 (unused).</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_ahb_portn">
                    <gui_name language="en">reg_arb_set_hpr_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_ahb_portn">
                    <gui_name language="en">reg_arb_dis_page_match_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_ahb_portn">
                    <gui_name language="en">reg_arb_disable_urgent_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_ahb_portn">
                    <gui_name language="en">reg_arb_disable_aging_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_ahb_portn">
                    <gui_name language="en">reg_arb_pri_ahb_portn</gui_name>
                    <description language="en">Unused</description>
                </bitField>
            </register>
            <register name="DDRC_AHB_PRIORITY_CFG2" offset="0xf8006250" size="0x4">
                <gui_name language="en">AHB_priority_cfg2</gui_name>
                <description language="en">AHB Priority control for port 2 (unused).</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_ahb_portn">
                    <gui_name language="en">reg_arb_set_hpr_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_ahb_portn">
                    <gui_name language="en">reg_arb_dis_page_match_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_ahb_portn">
                    <gui_name language="en">reg_arb_disable_urgent_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_ahb_portn">
                    <gui_name language="en">reg_arb_disable_aging_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_ahb_portn">
                    <gui_name language="en">reg_arb_pri_ahb_portn</gui_name>
                    <description language="en">Unused</description>
                </bitField>
            </register>
            <register name="DDRC_AHB_PRIORITY_CFG3" offset="0xf8006254" size="0x4">
                <gui_name language="en">AHB_priority_cfg3</gui_name>
                <description language="en">AHB Priority control for port 3 (unused).</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="reg_arb_set_hpr_ahb_portn">
                    <gui_name language="en">reg_arb_set_hpr_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="reg_arb_dis_page_match_ahb_portn">
                    <gui_name language="en">reg_arb_dis_page_match_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="reg_arb_disable_urgent_ahb_portn">
                    <gui_name language="en">reg_arb_disable_urgent_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="reg_arb_disable_aging_ahb_portn">
                    <gui_name language="en">reg_arb_disable_aging_ahb_portn</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="reg_arb_pri_ahb_portn">
                    <gui_name language="en">reg_arb_pri_ahb_portn</gui_name>
                    <description language="en">Unused</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON0" offset="0xf8006260" size="0x4">
                <gui_name language="en">perf_mon0</gui_name>
                <description language="en">Performance monitoring register 1 for port 0.</description>
                <bitField access="Read Only" high_bit="30" low_bit="20" name="reg_max_read_latency_portn">
                    <gui_name language="en">reg_max_read_latency_portn</gui_name>
                    <description language="en">Measured Maximum Read latency.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="reg_min_read_latency_portn">
                    <gui_name language="en">reg_min_read_latency_portn</gui_name>
                    <description language="en">Measured Minimum Read latency.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON1" offset="0xf8006264" size="0x4">
                <gui_name language="en">perf_mon1</gui_name>
                <description language="en">Performance monitoring register 1 for port 1.</description>
                <bitField access="Read Only" high_bit="30" low_bit="20" name="reg_max_read_latency_portn">
                    <gui_name language="en">reg_max_read_latency_portn</gui_name>
                    <description language="en">Measured Maximum Read latency.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="reg_min_read_latency_portn">
                    <gui_name language="en">reg_min_read_latency_portn</gui_name>
                    <description language="en">Measured Minimum Read latency.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON2" offset="0xf8006268" size="0x4">
                <gui_name language="en">perf_mon2</gui_name>
                <description language="en">Performance monitoring register 1 for port 2.</description>
                <bitField access="Read Only" high_bit="30" low_bit="20" name="reg_max_read_latency_portn">
                    <gui_name language="en">reg_max_read_latency_portn</gui_name>
                    <description language="en">Measured Maximum Read latency.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="reg_min_read_latency_portn">
                    <gui_name language="en">reg_min_read_latency_portn</gui_name>
                    <description language="en">Measured Minimum Read latency.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON3" offset="0xf800626c" size="0x4">
                <gui_name language="en">perf_mon3</gui_name>
                <description language="en">Performance monitoring register 1 for port 3.</description>
                <bitField access="Read Only" high_bit="30" low_bit="20" name="reg_max_read_latency_portn">
                    <gui_name language="en">reg_max_read_latency_portn</gui_name>
                    <description language="en">Measured Maximum Read latency.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="9" name="reg_min_read_latency_portn">
                    <gui_name language="en">reg_min_read_latency_portn</gui_name>
                    <description language="en">Measured Minimum Read latency.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON20" offset="0xf8006270" size="0x4">
                <gui_name language="en">perf_mon20</gui_name>
                <description language="en">Performance monitoring register 2 for port 0.</description>
                <bitField access="Read Only" high_bit="31" low_bit="17" name="reg_measure_axi_id_portn">
                    <gui_name language="en">reg_measure_axi_id_portn</gui_name>
                    <description language="en">Performance measurements done on this programmable 15-bit AXI ID.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_wr_portn">
                    <gui_name language="en">reg_num_words_wr_portn</gui_name>
                    <description language="en">Counter reflects the number of write transactions for the write AXI ID mentioned in register 'reg_measure_axi_id'.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON21" offset="0xf8006274" size="0x4">
                <gui_name language="en">perf_mon21</gui_name>
                <description language="en">Performance monitoring register 2 for port 1.</description>
                <bitField access="Read Only" high_bit="31" low_bit="17" name="reg_measure_axi_id_portn">
                    <gui_name language="en">reg_measure_axi_id_portn</gui_name>
                    <description language="en">Performance measurements done on this programmable 15-bit AXI ID.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_wr_portn">
                    <gui_name language="en">reg_num_words_wr_portn</gui_name>
                    <description language="en">Counter reflects the number of write transactions for the write AXI ID mentioned in register 'reg_measure_axi_id'.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON22" offset="0xf8006278" size="0x4">
                <gui_name language="en">perf_mon22</gui_name>
                <description language="en">Performance monitoring register 2 for port 2.</description>
                <bitField access="Read Only" high_bit="31" low_bit="17" name="reg_measure_axi_id_portn">
                    <gui_name language="en">reg_measure_axi_id_portn</gui_name>
                    <description language="en">Performance measurements done on this programmable 15-bit AXI ID.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_wr_portn">
                    <gui_name language="en">reg_num_words_wr_portn</gui_name>
                    <description language="en">Counter reflects the number of write transactions for the write AXI ID mentioned in register 'reg_measure_axi_id'.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON23" offset="0xf800627c" size="0x4">
                <gui_name language="en">perf_mon23</gui_name>
                <description language="en">Performance monitoring register 2 for port 3.</description>
                <bitField access="Read Only" high_bit="31" low_bit="17" name="reg_measure_axi_id_portn">
                    <gui_name language="en">reg_measure_axi_id_portn</gui_name>
                    <description language="en">Performance measurements done on this programmable 15-bit AXI ID.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_wr_portn">
                    <gui_name language="en">reg_num_words_wr_portn</gui_name>
                    <description language="en">Counter reflects the number of write transactions for the write AXI ID mentioned in register 'reg_measure_axi_id'.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON30" offset="0xf8006280" size="0x2">
                <gui_name language="en">perf_mon30</gui_name>
                <description language="en">Performance monitoring register 3 for port 0.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_rd_portn">
                    <gui_name language="en">reg_num_words_rd_portn</gui_name>
                    <description language="en">Counter reflects the number of read transactions for the read AXI ID mentioned in register 'reg_measure_axi_id'</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON31" offset="0xf8006284" size="0x2">
                <gui_name language="en">perf_mon31</gui_name>
                <description language="en">Performance monitoring register 3 for port 1.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_rd_portn">
                    <gui_name language="en">reg_num_words_rd_portn</gui_name>
                    <description language="en">Counter reflects the number of read transactions for the read AXI ID mentioned in register 'reg_measure_axi_id'</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON32" offset="0xf8006288" size="0x2">
                <gui_name language="en">perf_mon32</gui_name>
                <description language="en">Performance monitoring register 3 for port 2.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_rd_portn">
                    <gui_name language="en">reg_num_words_rd_portn</gui_name>
                    <description language="en">Counter reflects the number of read transactions for the read AXI ID mentioned in register 'reg_measure_axi_id'</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PERF_MON33" offset="0xf800628c" size="0x2">
                <gui_name language="en">perf_mon33</gui_name>
                <description language="en">Performance monitoring register 3 for port 3.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="reg_num_words_rd_portn">
                    <gui_name language="en">reg_num_words_rd_portn</gui_name>
                    <description language="en">Counter reflects the number of read transactions for the read AXI ID mentioned in register 'reg_measure_axi_id'</description>
                </bitField>
            </register>
            <register name="DDRC_TRUSTED_MEM_CFG" offset="0xf8006290" size="0x2">
                <gui_name language="en">trusted_mem_cfg</gui_name>
                <description language="en">Trusted Memory configuration</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="reg_decprot">
                    <gui_name language="en">reg_decprot</gui_name>
                    <description language="en">Sets the memory regions to be secure or non-secure. The memory is divided into 64Mb sections. For a 1 Gb part, the number of regions is 16. 0 - non-secure region 1 - secure region Reserved. Not used any more.</description>
                </bitField>
            </register>
            <register name="DDRC_EXCL_ACCESS_CFG0" offset="0xf8006294" size="0x4">
                <gui_name language="en">excl_access_cfg0</gui_name>
                <description language="en">Exclusive access configuration for port 0.</description>
                <bitField access="Read Write" high_bit="17" low_bit="9" name="reg_excl_acc_id1_port">
                    <gui_name language="en">reg_excl_acc_id1_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="0" name="reg_excl_acc_id0_port">
                    <gui_name language="en">reg_excl_acc_id0_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register name="DDRC_EXCL_ACCESS_CFG1" offset="0xf8006298" size="0x4">
                <gui_name language="en">excl_access_cfg1</gui_name>
                <description language="en">Exclusive access configuration for port 1.</description>
                <bitField access="Read Write" high_bit="17" low_bit="9" name="reg_excl_acc_id1_port">
                    <gui_name language="en">reg_excl_acc_id1_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="0" name="reg_excl_acc_id0_port">
                    <gui_name language="en">reg_excl_acc_id0_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register name="DDRC_EXCL_ACCESS_CFG2" offset="0xf800629c" size="0x4">
                <gui_name language="en">excl_access_cfg2</gui_name>
                <description language="en">Exclusive access configuration for port 2.</description>
                <bitField access="Read Write" high_bit="17" low_bit="9" name="reg_excl_acc_id1_port">
                    <gui_name language="en">reg_excl_acc_id1_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="0" name="reg_excl_acc_id0_port">
                    <gui_name language="en">reg_excl_acc_id0_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register name="DDRC_EXCL_ACCESS_CFG3" offset="0xf80062a0" size="0x4">
                <gui_name language="en">excl_access_cfg3</gui_name>
                <description language="en">Exclusive access configuration for port 3.</description>
                <bitField access="Read Write" high_bit="17" low_bit="9" name="reg_excl_acc_id1_port">
                    <gui_name language="en">reg_excl_acc_id1_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="0" name="reg_excl_acc_id0_port">
                    <gui_name language="en">reg_excl_acc_id0_port</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_MODE_REG_READ" offset="0xf80062a4" size="0x4">
                <gui_name language="en">mode_reg_read</gui_name>
                <description language="en">Mode register read data</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="ddrc_reg_rd_mrr_data">
                    <gui_name language="en">ddrc_reg_rd_mrr_data</gui_name>
                    <description language="en">Mode register read Data. Valid when ddrc_co_rd_mrr_data_valid is high. Bits[7:0] carry the 8-bit MRR value. Valid for LPDDR2 only.</description>
                </bitField>
            </register>
            <register name="DDRC_LPDDR_CTRL0" offset="0xf80062a8" size="0x2">
                <gui_name language="en">lpddr_ctrl0</gui_name>
                <description language="en">LPDDR2 Control 0 Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="4" name="reg_ddrc_mr4_margin">
                    <gui_name language="en">reg_ddrc_mr4_margin</gui_name>
                    <description language="en">UNUSED</description>
                </bitField>
                <bitField access="Read Write" enumerationId="lpddr_ctrl0_reg_ddrc_derate_enable_ENUM" high_bit="2" low_bit="2" name="reg_ddrc_derate_enable">
                    <gui_name language="en">reg_ddrc_derate_enable</gui_name>
                    <description language="en">0: Timing parameter derating is disabled. 1: Timing parameter derating is enabled using MR4 read value. Present only in designs configured to support LPDDR2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="reg_ddrc_per_bank_refresh">
                    <gui_name language="en">reg_ddrc_per_bank_refresh</gui_name>
                    <description language="en">1:Per bank refresh 0:All bank refresh Per bank refresh allows traffic to flow to other banks. Per bank refresh is not supported on all LPDDR2 devices. Present only in designs configured to support LPDDR2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="reg_ddrc_lpddr2">
                    <gui_name language="en">reg_ddrc_lpddr2</gui_name>
                    <description language="en">1=LPDDR2 DRAM device in Use. 0=non-LPDDR2 device in use Present only in designs configured to support LPDDR2.</description>
                </bitField>
            </register>
            <register name="DDRC_LPDDR_CTRL1" offset="0xf80062ac" size="0x4">
                <gui_name language="en">lpddr_ctrl1</gui_name>
                <description language="en">LPDDR2 Control 1 Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="reg_ddrc_mr4_read_interval">
                    <gui_name language="en">reg_ddrc_mr4_read_interval</gui_name>
                    <description language="en">Interval between two MR4 reads, USED to derate the timing parameters. Present only in designs configured to support LPDDR2.</description>
                </bitField>
            </register>
            <register name="DDRC_LPDDR_CTRL2" offset="0xf80062b0" size="0x4">
                <gui_name language="en">lpddr_ctrl2</gui_name>
                <description language="en">LPDDR2 Control 2 Register</description>
                <bitField access="Read Write" high_bit="21" low_bit="12" name="reg_ddrc_t_mrw">
                    <gui_name language="en">reg_ddrc_t_mrw</gui_name>
                    <description language="en">Time to wait during load mode register writes. Present only in designs configured to support LPDDR2. LPDDR2 typically requires value of 5.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="4" name="reg_ddrc_idle_after_reset_x32">
                    <gui_name language="en">reg_ddrc_idle_after_reset_x32</gui_name>
                    <description language="en">Idle time after the reset command, tINIT4. Present only in designs configured to support LPDDR2. Units: 32 clock cycles.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="reg_ddrc_min_stable_clock_x1">
                    <gui_name language="en">reg_ddrc_min_stable_clock_x1</gui_name>
                    <description language="en">Time to wait after the first CKE high, tINIT2. Present only in designs configured to support LPDDR2. Units: 1 clock cycle. LPDDR2 typically requires 5 x tCK delay.</description>
                </bitField>
            </register>
            <register name="DDRC_LPDDR_CTRL3" offset="0xf80062b4" size="0x4">
                <gui_name language="en">lpddr_ctrl3</gui_name>
                <description language="en">LPDDR2 Control 3 Register</description>
                <bitField access="Read Write" high_bit="17" low_bit="8" name="reg_ddrc_dev_zqinit_x32">
                    <gui_name language="en">reg_ddrc_dev_zqinit_x32</gui_name>
                    <description language="en">ZQ initial calibration, tZQINIT. Present only in designs configured to support LPDDR2. Units: 32 clock cycles. LPDDR2 typically requires 1 us.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="reg_ddrc_max_auto_init_x1024">
                    <gui_name language="en">reg_ddrc_max_auto_init_x1024</gui_name>
                    <description language="en">Maximum duration of the auto initialization, tINIT5. Present only in designs configured to support LPDDR2. Units: 1024 clock cycles. LPDDR2 typically requires 10 us.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_WR_LVL_FSM" offset="0xf80062b8" size="0x2">
                <gui_name language="en">phy_wr_lvl_fsm</gui_name>
                <description language="en">PHY write leveling state machine status</description>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="phy_reg_wr_level_fsm_slice3">
                    <gui_name language="en">phy_reg_wr_level_fsm_slice3</gui_name>
                    <description language="en">Write Leveling State information from Slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="phy_reg_wr_level_fsm_slice2">
                    <gui_name language="en">phy_reg_wr_level_fsm_slice2</gui_name>
                    <description language="en">Write Leveling State information from Slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="4" name="phy_reg_wr_level_fsm_slice1">
                    <gui_name language="en">phy_reg_wr_level_fsm_slice1</gui_name>
                    <description language="en">Write Leveling State information from Slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="phy_reg_wr_level_fsm_slice0">
                    <gui_name language="en">phy_reg_wr_level_fsm_slice0</gui_name>
                    <description language="en">Write Leveling State information from Slice 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_RD_LVL_FSM" offset="0xf80062bc" size="0x2">
                <gui_name language="en">phy_rd_lvl_fsm</gui_name>
                <description language="en">PHY read leveling state machine status</description>
                <bitField access="Read Only" high_bit="15" low_bit="12" name="phy_reg_rd_level_fsm_slice3">
                    <gui_name language="en">phy_reg_rd_level_fsm_slice3</gui_name>
                    <description language="en">Read Leveling State information from Slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="phy_reg_rd_level_fsm_slice2">
                    <gui_name language="en">phy_reg_rd_level_fsm_slice2</gui_name>
                    <description language="en">Read Leveling State information from Slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="phy_reg_rd_level_fsm_slice1">
                    <gui_name language="en">phy_reg_rd_level_fsm_slice1</gui_name>
                    <description language="en">Read Leveling State information from Slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="phy_reg_rd_level_fsm_slice0">
                    <gui_name language="en">phy_reg_rd_level_fsm_slice0</gui_name>
                    <description language="en">Read Leveling State information from Slice 0.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DDRC_PHY_GATE_LVL_FSM" offset="0xf80062c0" size="0x2">
                <gui_name language="en">phy_gate_lvl_fsm</gui_name>
                <description language="en">PHY gate leveling state machine status</description>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="phy_reg_gate_level_fsm_slice3">
                    <gui_name language="en">phy_reg_gate_level_fsm_slice3</gui_name>
                    <description language="en">Gate Leveling State information from Slice 3.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="phy_reg_gate_level_fsm_slice2">
                    <gui_name language="en">phy_reg_gate_level_fsm_slice2</gui_name>
                    <description language="en">Gate Leveling State information from Slice 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="4" name="phy_reg_gate_level_fsm_slice1">
                    <gui_name language="en">phy_reg_gate_level_fsm_slice1</gui_name>
                    <description language="en">Gate Leveling State information from Slice 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="phy_reg_gate_level_fsm_slice0">
                    <gui_name language="en">phy_reg_gate_level_fsm_slice0</gui_name>
                    <description language="en">Gate Leveling State information from Slice 0.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_AXIM" name="DEBUG_AXIM" offset="0xf880c000">
            <gui_name language="en">debug_axim</gui_name>
            <description language="en">debug_axim</description>
            <register name="DEBUG_AXIM_GLOBAL_CTRL" offset="0xf880c000" size="0x2">
                <gui_name language="en">GLOBAL_CTRL</gui_name>
                <description language="en">Global Control Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PROG">
                    <gui_name language="en">PROG</gui_name>
                    <description language="en">Enters program mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GLBEN">
                    <gui_name language="en">GLBEN</gui_name>
                    <description language="en">Gates on ACLK and ATCLK clocks</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_GLOBAL_STATUS" offset="0xf880c004" size="0x2">
                <gui_name language="en">GLOBAL_STATUS</gui_name>
                <description language="en">Global Status Register</description>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="IDLE">
                    <gui_name language="en">IDLE</gui_name>
                    <description language="en">AXIM is idle. Essentially, this means the data flow path from AXI to ATB has been "cleared", including FIFO empty.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="SPIDEN">
                    <gui_name language="en">SPIDEN</gui_name>
                    <description language="en">SPIDEN signal status</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="DBGEN">
                    <gui_name language="en">DBGEN</gui_name>
                    <description language="en">DBGEN signal status</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="SPNIDEN">
                    <gui_name language="en">SPNIDEN</gui_name>
                    <description language="en">SPNIDEN signal status</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">NIDEN signal status</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_FILTER_CTRL" offset="0xf880c010" size="0x2">
                <gui_name language="en">FILTER_CTRL</gui_name>
                <description language="en">Filter Control Register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="B">
                    <gui_name language="en">B</gui_name>
                    <description language="en">Enable filtering for the B channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="W">
                    <gui_name language="en">W</gui_name>
                    <description language="en">Enable filtering for the W channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="AW">
                    <gui_name language="en">AW</gui_name>
                    <description language="en">Enable filtering for the AW channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="R">
                    <gui_name language="en">R</gui_name>
                    <description language="en">Enable filtering for the R channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AR">
                    <gui_name language="en">AR</gui_name>
                    <description language="en">Enable filtering for the AR channel</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_TRIGGER_CTRL" offset="0xf880c020" size="0x2">
                <gui_name language="en">TRIGGER_CTRL</gui_name>
                <description language="en">Trigger Control Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="TRIGIN">
                    <gui_name language="en">TRIGIN</gui_name>
                    <description language="en">Enable TRIGIN signal to cause AXIM to trigger</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="TRIGOUT">
                    <gui_name language="en">TRIGOUT</gui_name>
                    <description language="en">Enable TRIGOUT signal for any matched internal triggering condition</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EXT_TRIGMODE">
                    <gui_name language="en">EXT_TRIGMODE</gui_name>
                    <description language="en">Applies to external triggers</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="INT_TRIGMODE">
                    <gui_name language="en">INT_TRIGMODE</gui_name>
                    <description language="en">Applies to internal triggers</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="B">
                    <gui_name language="en">B</gui_name>
                    <description language="en">Enable triggering from the B channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="W">
                    <gui_name language="en">W</gui_name>
                    <description language="en">Enable triggering from the W channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="AW">
                    <gui_name language="en">AW</gui_name>
                    <description language="en">Enable triggering from the AW channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="R">
                    <gui_name language="en">R</gui_name>
                    <description language="en">Enable triggering from the R channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AR">
                    <gui_name language="en">AR</gui_name>
                    <description language="en">Enable triggering from the AR channel</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_TRIGGER_STATUS" offset="0xf880c024" size="0x2">
                <gui_name language="en">TRIGGER_STATUS</gui_name>
                <description language="en">Trigger Status Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="EXT_TRIGGERED">
                    <gui_name language="en">EXT_TRIGGERED</gui_name>
                    <description language="en">Indicates AXIM has been externally triggered, via the TRIGIN input signal.
If EXT_TRIGMODE in TRIGGER_CTRL is 0, only the first rising edge of TRIGIN causes a trigger packet to be generated.
If EXT_TRIGMODE in TRIGGER_CTRL is 1, a trigger packet is generated for each rising edge of TRIGIN.
Note: It is safe to write to this bit when PROG in GLOBAL_CTRL is 0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INT_TRIGGERED">
                    <gui_name language="en">INT_TRIGGERED</gui_name>
                    <description language="en">Indicates AXIM has been internally triggered, via the settings in ADDR*_* and ID*_* registers.
If INT_TRIGMODE is 0, only the first match of each of the 5 triggering conditions (AR,R,AW,W,B) causes a trigger packet to be generated.
(One trigger packet for each).
If INT_TRIGMODE is 1, a trigger packet is generated for each match of the triggering conditions (AR,R,AW,W,B).
Note: It is safe to write to this bit when PROG in GLOBAL_CTRL is 0.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_PACKET_CTRL" offset="0xf880c030" size="0x4">
                <gui_name language="en">PACKET_CTRL</gui_name>
                <description language="en">Packet Control Register</description>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="TSComp">
                    <gui_name language="en">TSComp</gui_name>
                    <description language="en">Enable compression of Timestamp packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="AWComp">
                    <gui_name language="en">AWComp</gui_name>
                    <description language="en">Enable compression of AW address packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="ARComp">
                    <gui_name language="en">ARComp</gui_name>
                    <description language="en">Enable compression of AR address packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="TRIGGER">
                    <gui_name language="en">TRIGGER</gui_name>
                    <description language="en">Enable generation of Trigger packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Enable generation of Timeout packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="LOSSREPORT">
                    <gui_name language="en">LOSSREPORT</gui_name>
                    <description language="en">Enable generation of Loss Report packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="OVERFLOW">
                    <gui_name language="en">OVERFLOW</gui_name>
                    <description language="en">Enable generation of Overflow packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TIMESTAMP">
                    <gui_name language="en">TIMESTAMP</gui_name>
                    <description language="en">Enable generation of Timestamp packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="SYNC">
                    <gui_name language="en">SYNC</gui_name>
                    <description language="en">Enable generation of Synchronization packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="B">
                    <gui_name language="en">B</gui_name>
                    <description language="en">Enable generation of B write response packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="W">
                    <gui_name language="en">W</gui_name>
                    <description language="en">Enable generation of W data packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="AW">
                    <gui_name language="en">AW</gui_name>
                    <description language="en">Enable generation of AW address packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="R">
                    <gui_name language="en">R</gui_name>
                    <description language="en">Enable generation of R data packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AR">
                    <gui_name language="en">AR</gui_name>
                    <description language="en">Enable generation of AR address packets</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_TOUT_CTRL" offset="0xf880c040" size="0x2">
                <gui_name language="en">TOUT_CTRL</gui_name>
                <description language="en">Channel Timeout Control Register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="B">
                    <gui_name language="en">B</gui_name>
                    <description language="en">Enable timeout detection for the B channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="W">
                    <gui_name language="en">W</gui_name>
                    <description language="en">Enable timeout detection for the W channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="AW">
                    <gui_name language="en">AW</gui_name>
                    <description language="en">Enable timeout detection for the AW channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="R">
                    <gui_name language="en">R</gui_name>
                    <description language="en">Enable timeout detection for the R channel</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="AR">
                    <gui_name language="en">AR</gui_name>
                    <description language="en">Enable timeout detection for the AR channel</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_TOUT_THRESH" offset="0xf880c044" size="0x4">
                <gui_name language="en">TOUT_THRESH</gui_name>
                <description language="en">Channel Timeout Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="THRESH">
                    <gui_name language="en">THRESH</gui_name>
                    <description language="en">When an AXI channel READY signal is not asserted within the number of ACLK cycles set in this register, a timeout is flagged.
A Timeout packet can set up to be generated, via a bit of the PACKET_CTRL register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_FIFO_CURRENT" offset="0xf880c050" size="0x4">
                <gui_name language="en">FIFO_CURRENT</gui_name>
                <description language="en">FIFO Current Level Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="EMPTY">
                    <gui_name language="en">EMPTY</gui_name>
                    <description language="en">FIFO empty, non-sticky</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="FULL">
                    <gui_name language="en">FULL</gui_name>
                    <description language="en">FIFO full, sticky. Reading this register will clear this bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="16" name="WATERMARK">
                    <gui_name language="en">WATERMARK</gui_name>
                    <description language="en">Highest level the FIFO has ever reached. Reading this register will reset the watermark to the current level.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="0" name="CURRENT">
                    <gui_name language="en">CURRENT</gui_name>
                    <description language="en">FIFO current level, i.e., number of entries, in bytes</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_FIFO_HYSTER" offset="0xf880c054" size="0x2">
                <gui_name language="en">FIFO_HYSTER</gui_name>
                <description language="en">FIFO Overflow Recovery Hysteresis Register</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="HYSTERESIS">
                    <gui_name language="en">HYSTERESIS</gui_name>
                    <description language="en">When overflow happens and is flagged, the overflow condition remains flagged, until the number of free entries (in bytes) in the FIFO reaches the value set in this register.
NOTE: setting this register to be less than 64 (decimal) may cause the overflow logic not to function properly.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_SYNC_CURRENT" offset="0xf880c060" size="0x2">
                <gui_name language="en">SYNC_CURRENT</gui_name>
                <description language="en">Synchronization Counter Current Value Register</description>
                <bitField access="Read Only" high_bit="11" low_bit="0" name="CURRENT">
                    <gui_name language="en">CURRENT</gui_name>
                    <description language="en">Synchronization counter current value.
The counter decrements for each byte of data output to ATB.
When reaching the following percentage of the value of the SYNC_RELOAD register:
1. Zero:
cause a Sync Packet to be generated
2. 25%:
cause the next AR packet to be full
3. 50%:
cause the next AW packet to be full
4. 75%:
cause the next Timestamp packet to be full
Whether the above full packets are output to the ATB is still subject to the settings in the PACKET_CTRL register.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_SYNC_RELOAD" offset="0xf880c064" size="0x2">
                <gui_name language="en">SYNC_RELOAD</gui_name>
                <description language="en">Synchronization Counter Reload Value Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="RELOAD">
                    <gui_name language="en">RELOAD</gui_name>
                    <description language="en">Specifies the value to be reloaded into the synchronization counter when it reaches zero.
This register determines how often, in terms of bytes sent to ATB, a Sync Packet is generated, and how often AR,AW,Timestamp packets should be full (non-compressed).</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_TSTMP_CURRENT" offset="0xf880c070" size="0x4">
                <gui_name language="en">TSTMP_CURRENT</gui_name>
                <description language="en">Timestamp Current Value Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="CURRENT">
                    <gui_name language="en">CURRENT</gui_name>
                    <description language="en">Current value of the gray-coded input port TSTMP[31:0]</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR0_MASK" offset="0xf880c200" size="0x4">
                <gui_name language="en">ADDR0_MASK</gui_name>
                <description language="en">Address Comparator Mask Register 0</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with araddr[30:2] and awaddr[30:2] before they are compared with the lower and upper bounds</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR0_LOWER" offset="0xf880c204" size="0x4">
                <gui_name language="en">ADDR0_LOWER</gui_name>
                <description language="en">Address Comparator Lower Bound Register 0</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR0_UPPER" offset="0xf880c208" size="0x4">
                <gui_name language="en">ADDR0_UPPER</gui_name>
                <description language="en">Address Comparator Upper Bound Register 0</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR0_MISC" offset="0xf880c20c" size="0x2">
                <gui_name language="en">ADDR0_MISC</gui_name>
                <description language="en">Address Comparator Miscellaneous Control Register 0</description>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="AWADDR_TRIG_IDQUAL">
                    <gui_name language="en">AWADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR0_MISC_AWADDR_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="AWADDR_TRIG_EXCINC">
                    <gui_name language="en">AWADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
triggering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="AWADDR_FILT_IDQUAL">
                    <gui_name language="en">AWADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR0_MISC_AWADDR_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="AWADDR_FILT_EXCINC">
                    <gui_name language="en">AWADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
filtering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="ARADDR_TRIG_IDQUAL">
                    <gui_name language="en">ARADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR0_MISC_ARADDR_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="ARADDR_TRIG_EXCINC">
                    <gui_name language="en">ARADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
triggering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="ARADDR_FILT_IDQUAL">
                    <gui_name language="en">ARADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR0_MISC_ARADDR_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="ARADDR_FILT_EXCINC">
                    <gui_name language="en">ARADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
filtering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR1_MASK" offset="0xf880c210" size="0x4">
                <gui_name language="en">ADDR1_MASK</gui_name>
                <description language="en">Address Comparator Mask Register 1</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with araddr[30:2] and awaddr[30:2] before they are compared with the lower and upper bounds</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR1_LOWER" offset="0xf880c214" size="0x4">
                <gui_name language="en">ADDR1_LOWER</gui_name>
                <description language="en">Address Comparator Lower Bound Register 1</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR1_UPPER" offset="0xf880c218" size="0x4">
                <gui_name language="en">ADDR1_UPPER</gui_name>
                <description language="en">Address Comparator Upper Bound Register 1</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR1_MISC" offset="0xf880c21c" size="0x2">
                <gui_name language="en">ADDR1_MISC</gui_name>
                <description language="en">Address Comparator Miscellaneous Control Register 1</description>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="AWADDR_TRIG_IDQUAL">
                    <gui_name language="en">AWADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR1_MISC_AWADDR_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="AWADDR_TRIG_EXCINC">
                    <gui_name language="en">AWADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
triggering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="AWADDR_FILT_IDQUAL">
                    <gui_name language="en">AWADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR1_MISC_AWADDR_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="AWADDR_FILT_EXCINC">
                    <gui_name language="en">AWADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
filtering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="ARADDR_TRIG_IDQUAL">
                    <gui_name language="en">ARADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR1_MISC_ARADDR_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="ARADDR_TRIG_EXCINC">
                    <gui_name language="en">ARADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
triggering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="ARADDR_FILT_IDQUAL">
                    <gui_name language="en">ARADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR1_MISC_ARADDR_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="ARADDR_FILT_EXCINC">
                    <gui_name language="en">ARADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
filtering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR2_MASK" offset="0xf880c220" size="0x4">
                <gui_name language="en">ADDR2_MASK</gui_name>
                <description language="en">Address Comparator Mask Register 2</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with araddr[30:2] and awaddr[30:2] before they are compared with the lower and upper bounds</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR2_LOWER" offset="0xf880c224" size="0x4">
                <gui_name language="en">ADDR2_LOWER</gui_name>
                <description language="en">Address Comparator Lower Bound Register 2</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR2_UPPER" offset="0xf880c228" size="0x4">
                <gui_name language="en">ADDR2_UPPER</gui_name>
                <description language="en">Address Comparator Upper Bound Register 2</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR2_MISC" offset="0xf880c22c" size="0x2">
                <gui_name language="en">ADDR2_MISC</gui_name>
                <description language="en">Address Comparator Miscellaneous Control Register 2</description>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="AWADDR_TRIG_IDQUAL">
                    <gui_name language="en">AWADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR2_MISC_AWADDR_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="AWADDR_TRIG_EXCINC">
                    <gui_name language="en">AWADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
triggering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="AWADDR_FILT_IDQUAL">
                    <gui_name language="en">AWADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR2_MISC_AWADDR_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="AWADDR_FILT_EXCINC">
                    <gui_name language="en">AWADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
filtering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="ARADDR_TRIG_IDQUAL">
                    <gui_name language="en">ARADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR2_MISC_ARADDR_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="ARADDR_TRIG_EXCINC">
                    <gui_name language="en">ARADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
triggering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="ARADDR_FILT_IDQUAL">
                    <gui_name language="en">ARADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR2_MISC_ARADDR_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="ARADDR_FILT_EXCINC">
                    <gui_name language="en">ARADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
filtering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR3_MASK" offset="0xf880c230" size="0x4">
                <gui_name language="en">ADDR3_MASK</gui_name>
                <description language="en">Address Comparator Mask Register 3</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with araddr[30:2] and awaddr[30:2] before they are compared with the lower and upper bounds</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR3_LOWER" offset="0xf880c234" size="0x4">
                <gui_name language="en">ADDR3_LOWER</gui_name>
                <description language="en">Address Comparator Lower Bound Register 3</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR3_UPPER" offset="0xf880c238" size="0x4">
                <gui_name language="en">ADDR3_UPPER</gui_name>
                <description language="en">Address Comparator Upper Bound Register 3</description>
                <bitField access="Read Write" high_bit="30" low_bit="2" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for both araddr and awaddr range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ADDR3_MISC" offset="0xf880c23c" size="0x2">
                <gui_name language="en">ADDR3_MISC</gui_name>
                <description language="en">Address Comparator Miscellaneous Control Register 3</description>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="AWADDR_TRIG_IDQUAL">
                    <gui_name language="en">AWADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR3_MISC_AWADDR_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="AWADDR_TRIG_EXCINC">
                    <gui_name language="en">AWADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
triggering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="AWADDR_FILT_IDQUAL">
                    <gui_name language="en">AWADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the awaddr range detector output is to be qualified (ANDed) by the combined output of up to 4 awid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR3_MISC_AWADDR_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="AWADDR_FILT_EXCINC">
                    <gui_name language="en">AWADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awaddr range detector participates in setting up
filtering conditions:
2'b11: awaddr range detector sets up an exclusion range
2'b10: awaddr range detector sets up an inclusion range
2'b0x: awaddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="ARADDR_TRIG_IDQUAL">
                    <gui_name language="en">ARADDR_TRIG_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR3_MISC_ARADDR_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="ARADDR_TRIG_EXCINC">
                    <gui_name language="en">ARADDR_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
triggering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="ARADDR_FILT_IDQUAL">
                    <gui_name language="en">ARADDR_FILT_IDQUAL</gui_name>
                    <description language="en">Determines whether the araddr range detector output is to be qualified (ANDed) by the combined output of up to 4 arid range detectors, before address inclusion/exclusion is applied.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ADDR3_MISC_ARADDR_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="ARADDR_FILT_EXCINC">
                    <gui_name language="en">ARADDR_FILT_EXCINC</gui_name>
                    <description language="en">Determine how araddr range detector participates in setting up
filtering conditions:
2'b11: araddr range detector sets up an exclusion range
2'b10: araddr range detector sets up an inclusion range
2'b0x: araddr range detector doesn't participate</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID0_MASK" offset="0xf880c300" size="0x2">
                <gui_name language="en">ID0_MASK</gui_name>
                <description language="en">ID Comparator Mask Register 0</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with consolidated arid, rid, awid, wid, bid before they are compared with the lower and upper bounds.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID0_LOWER" offset="0xf880c304" size="0x2">
                <gui_name language="en">ID0_LOWER</gui_name>
                <description language="en">ID Comparator Lower Bound Register 0</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID0_UPPER" offset="0xf880c308" size="0x2">
                <gui_name language="en">ID0_UPPER</gui_name>
                <description language="en">ID Comparator Upper Bound Register 0</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID0_MISC" offset="0xf880c30c" size="0x2">
                <gui_name language="en">ID0_MISC</gui_name>
                <description language="en">ID Comparator Miscellaneous Control Register 0</description>
                <bitField access="Read Write" enumerationId="ID0_MISC_WRID_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="WRID_TRIG_EXCINC">
                    <gui_name language="en">WRID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up triggering conditions:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID0_MISC_WRID_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="WRID_FILT_EXCINC">
                    <gui_name language="en">WRID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up filtering conditioning:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID0_MISC_RDID_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="RDID_TRIG_EXCINC">
                    <gui_name language="en">RDID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up triggering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID0_MISC_RDID_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="RDID_FILT_EXCINC">
                    <gui_name language="en">RDID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up filtering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID1_MASK" offset="0xf880c310" size="0x2">
                <gui_name language="en">ID1_MASK</gui_name>
                <description language="en">ID Comparator Mask Register 1</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with consolidated arid, rid, awid, wid, bid before they are compared with the lower and upper bounds.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID1_LOWER" offset="0xf880c314" size="0x2">
                <gui_name language="en">ID1_LOWER</gui_name>
                <description language="en">ID Comparator Lower Bound Register 1</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID1_UPPER" offset="0xf880c318" size="0x2">
                <gui_name language="en">ID1_UPPER</gui_name>
                <description language="en">ID Comparator Upper Bound Register 1</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID1_MISC" offset="0xf880c31c" size="0x2">
                <gui_name language="en">ID1_MISC</gui_name>
                <description language="en">ID Comparator Miscellaneous Control Register 1</description>
                <bitField access="Read Write" enumerationId="ID1_MISC_WRID_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="WRID_TRIG_EXCINC">
                    <gui_name language="en">WRID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up triggering conditions:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID1_MISC_WRID_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="WRID_FILT_EXCINC">
                    <gui_name language="en">WRID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up filtering conditioning:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID1_MISC_RDID_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="RDID_TRIG_EXCINC">
                    <gui_name language="en">RDID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up triggering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID1_MISC_RDID_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="RDID_FILT_EXCINC">
                    <gui_name language="en">RDID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up filtering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID2_MASK" offset="0xf880c320" size="0x2">
                <gui_name language="en">ID2_MASK</gui_name>
                <description language="en">ID Comparator Mask Register 2</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with consolidated arid, rid, awid, wid, bid before they are compared with the lower and upper bounds.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID2_LOWER" offset="0xf880c324" size="0x2">
                <gui_name language="en">ID2_LOWER</gui_name>
                <description language="en">ID Comparator Lower Bound Register 2</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID2_UPPER" offset="0xf880c328" size="0x2">
                <gui_name language="en">ID2_UPPER</gui_name>
                <description language="en">ID Comparator Upper Bound Register 2</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID2_MISC" offset="0xf880c32c" size="0x2">
                <gui_name language="en">ID2_MISC</gui_name>
                <description language="en">ID Comparator Miscellaneous Control Register 2</description>
                <bitField access="Read Write" enumerationId="ID2_MISC_WRID_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="WRID_TRIG_EXCINC">
                    <gui_name language="en">WRID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up triggering conditions:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID2_MISC_WRID_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="WRID_FILT_EXCINC">
                    <gui_name language="en">WRID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up filtering conditioning:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID2_MISC_RDID_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="RDID_TRIG_EXCINC">
                    <gui_name language="en">RDID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up triggering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID2_MISC_RDID_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="RDID_FILT_EXCINC">
                    <gui_name language="en">RDID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up filtering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID3_MASK" offset="0xf880c330" size="0x2">
                <gui_name language="en">ID3_MASK</gui_name>
                <description language="en">ID Comparator Mask Register 3</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="MASK">
                    <gui_name language="en">MASK</gui_name>
                    <description language="en">Mask to be ANDed with consolidated arid, rid, awid, wid, bid before they are compared with the lower and upper bounds.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID3_LOWER" offset="0xf880c334" size="0x2">
                <gui_name language="en">ID3_LOWER</gui_name>
                <description language="en">ID Comparator Lower Bound Register 3</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="LOWER_BOUND">
                    <gui_name language="en">LOWER_BOUND</gui_name>
                    <description language="en">Sets the lower bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID3_UPPER" offset="0xf880c338" size="0x2">
                <gui_name language="en">ID3_UPPER</gui_name>
                <description language="en">ID Comparator Upper Bound Register 3</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="UPPER_BOUND">
                    <gui_name language="en">UPPER_BOUND</gui_name>
                    <description language="en">Sets the upper bound for arid, rid, awid, wid, bid range detectors. Comparison is done after mask is applied.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_ID3_MISC" offset="0xf880c33c" size="0x2">
                <gui_name language="en">ID3_MISC</gui_name>
                <description language="en">ID Comparator Miscellaneous Control Register 3</description>
                <bitField access="Read Write" enumerationId="ID3_MISC_WRID_TRIG_EXCINC_ENUM" high_bit="13" low_bit="12" name="WRID_TRIG_EXCINC">
                    <gui_name language="en">WRID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up triggering conditions:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID3_MISC_WRID_FILT_EXCINC_ENUM" high_bit="9" low_bit="8" name="WRID_FILT_EXCINC">
                    <gui_name language="en">WRID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how awid, wid, bid range detectors participate in setting up filtering conditioning:
2'b11: awid, wid, bid range detectors set up an exclusion range
2'b10: awid, wid, bid range detectors set up an inclusion range
2'b0x: awid, wid, bid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID3_MISC_RDID_TRIG_EXCINC_ENUM" high_bit="5" low_bit="4" name="RDID_TRIG_EXCINC">
                    <gui_name language="en">RDID_TRIG_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up triggering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ID3_MISC_RDID_FILT_EXCINC_ENUM" high_bit="1" low_bit="0" name="RDID_FILT_EXCINC">
                    <gui_name language="en">RDID_FILT_EXCINC</gui_name>
                    <description language="en">Determine how arid, rid range detectors participate in setting up filtering conditions:
2'b11: arid, rid range detectors set up an exclusion range
2'b10: arid, rid range detectors set up an inclusion range
2'b0x: arid, rid range detectors outputs are not used</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_AXI_SEL" offset="0xf880c800" size="0x2">
                <gui_name language="en">AXI_SEL</gui_name>
                <description language="en">AXI Bus Select Register</description>
                <bitField access="Read Write" enumerationId="AXI_SEL_SEL_ENUM" high_bit="2" low_bit="0" name="SEL">
                    <gui_name language="en">SEL</gui_name>
                    <description language="en">Select the AXI bus to monitor.
Becomes AXISEL[2:0] output signals:
0-3: AXI bus between TOPSW and OCM
4: AXI bus to DDR slave port 0
5: AXI bus to DDR slave port 1
6: AXI bus to DDR slave port 2
7: AXI bus to DDR slave port 3</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_AXIM_IT_TRIGOUT" offset="0xf880ced0" size="0x2">
                <gui_name language="en">IT_TRIGOUT</gui_name>
                <description language="en">Trigger Output Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="TRIGOUT">
                    <gui_name language="en">TRIGOUT</gui_name>
                    <description language="en">Sets the value of TRIGOUT in integration mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_IT_TRIGOUTACK" offset="0xf880ced4" size="0x2">
                <gui_name language="en">IT_TRIGOUTACK</gui_name>
                <description language="en">Trigger Output Acknowledge Register</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="TRIGOUTACK">
                    <gui_name language="en">TRIGOUTACK</gui_name>
                    <description language="en">Shows the value of TRIGOUTACK in integration mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_IT_TRIGIN" offset="0xf880ced8" size="0x2">
                <gui_name language="en">IT_TRIGIN</gui_name>
                <description language="en">Trigger Input Register</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="TRIGIN">
                    <gui_name language="en">TRIGIN</gui_name>
                    <description language="en">Shows the value of TRIGIN in integration mode.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_AXIM_IT_TRIGINACK" offset="0xf880cedc" size="0x2">
                <gui_name language="en">IT_TRIGINACK</gui_name>
                <description language="en">Trigger Input Acknowledge Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="TRIGINACK">
                    <gui_name language="en">TRIGINACK</gui_name>
                    <description language="en">Sets the value of TRIGINACK in integration mode.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_AXIM_IT_ATBDATA" offset="0xf880ceec" size="0x2">
                <gui_name language="en">IT_ATBDATA</gui_name>
                <description language="en">ATB Data 0 Register</description>
                <bitField access="Write Only" high_bit="4" low_bit="0" name="ATDATAM">
                    <gui_name language="en">ATDATAM</gui_name>
                    <description language="en">Sets the value of ATBDATA[31,23,15,7,0] in integration mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_IT_ATBSTATUS" offset="0xf880cef0" size="0x2">
                <gui_name language="en">IT_ATBSTATUS</gui_name>
                <description language="en">ATB Status Register</description>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AFVALIDM">
                    <gui_name language="en">AFVALIDM</gui_name>
                    <description language="en">Returns the value of AFVALIDM in integration mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATREADYM">
                    <gui_name language="en">ATREADYM</gui_name>
                    <description language="en">Returns the value of ATREADYM in integration mode.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_AXIM_IT_ATBCTRL1" offset="0xf880cef4" size="0x2">
                <gui_name language="en">IT_ATBCTRL1</gui_name>
                <description language="en">ATB Control 1 Register</description>
                <bitField access="Write Only" high_bit="6" low_bit="0" name="ATIDM">
                    <gui_name language="en">ATIDM</gui_name>
                    <description language="en">Sets the value of ATIDM[6:0] in both integration and functional mode.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_AXIM_IT_ATBCTRL0" offset="0xf880cef8" size="0x2">
                <gui_name language="en">IT_ATBCTRL0</gui_name>
                <description language="en">ATB Control 0 Register</description>
                <bitField access="Write Only" high_bit="9" low_bit="8" name="ATBYTESM">
                    <gui_name language="en">ATBYTESM</gui_name>
                    <description language="en">Sets the value of ATBYTESM[9:8] in integration mode.</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="AFREADYM">
                    <gui_name language="en">AFREADYM</gui_name>
                    <description language="en">Sets the value of ARREADYM in integration mode.</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATVALIDM">
                    <gui_name language="en">ATVALIDM</gui_name>
                    <description language="en">Sets the value of ATVALIDM in integration mode.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_IT_CTRL" offset="0xf880cf00" size="0x2">
                <gui_name language="en">IT_CTRL</gui_name>
                <description language="en">Integration Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INTEGRATION">
                    <gui_name language="en">INTEGRATION</gui_name>
                    <description language="en">Enters the integration mode.</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_CLAIM_SET" offset="0xf880cfa0" size="0x2">
                <gui_name language="en">CLAIM_SET</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="SET">
                    <gui_name language="en">SET</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_AXIM_CLAIM_CLEAR" offset="0xf880cfa4" size="0x2">
                <gui_name language="en">CLAIM_CLEAR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_AXIM_LOCK_ACCESS" offset="0xf880cfb0" size="0x4">
                <gui_name language="en">LOCK_ACCESS</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="KEY">
                    <gui_name language="en">KEY</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), AXIM is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
AXIM is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_LOCK_STATUS" offset="0xf880cfb4" size="0x2">
                <gui_name language="en">LOCK_STATUS</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since AXIM implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether AXIM is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_AUTH_STATUS" offset="0xf880cfb8" size="0x2">
                <gui_name language="en">AUTH_STATUS</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="6" name="SNI">
                    <gui_name language="en">SNI</gui_name>
                    <description language="en">Secure non-invasive debug
If ((SPNIDEN or SPIDEN) and (NIDEN or DBGEN)) is true, this field is 2'b11, indicating the functionality is implemented and enabled.
Otherwise, this field is 2'b10 (implemented but disabled).</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="4" name="SI">
                    <gui_name language="en">SI</gui_name>
                    <description language="en">Secure invasive debug
Always 2'b00.
This functionality is not implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="2" name="NSNI">
                    <gui_name language="en">NSNI</gui_name>
                    <description language="en">Non-secure non-invasive debug
IF NIDEN or DBGEN is 1, this field is 2'b11, indicating the functionality is implemented and enabled.
Otherwise, this field is 2'b10 (implemented but disabled)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="0" name="NSI">
                    <gui_name language="en">NSI</gui_name>
                    <description language="en">Non-secure invasive debug
Always 2'b00.
This functionality is not implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_DEV_ID" offset="0xf880cfc8" size="0x4">
                <gui_name language="en">DEV_ID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="ID">
                    <gui_name language="en">ID</gui_name>
                    <description language="en">Device ID</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_DEV_TYPE" offset="0xf880cfcc" size="0x4">
                <gui_name language="en">DEV_TYPE</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="TYPE">
                    <gui_name language="en">TYPE</gui_name>
                    <description language="en">[7:4] = 0x4, Bus trace component
[3:0] = 0x3, Trace source component</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID4" offset="0xf880cfd0" size="0x4">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">[7:4] = 0x0, 4KB count
[3:0] = 0x3, JEP106 continuation code (Xilinx ID[3:0])</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID5" offset="0xf880cfd4" size="0x4">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID6" offset="0xf880cfd8" size="0x4">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID7" offset="0xf880cfdc" size="0x4">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID0" offset="0xf880cfe0" size="0x4">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">[7:0] = 0xb2, Part number bits [7:0]
(Xilinx family[2:0] + subfamily[3:0] + device_code[4])</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID1" offset="0xf880cfe4" size="0x4">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">[7:4] = 0x9: JEP106 identity bits [3:0] (Xilinx ID [7:4])
[3:0] = 0x3, Part number bits [11:8] (Xilinx family[6:3])</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID2" offset="0xf880cfe8" size="0x4">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">[7:4] = 0,
Revision (Xilinx Revision[2:0])
[3] = 1,
indicating JEP106 value is used
[2:0] = 0,
JEP106 identity bits [6:4] (Xilinx ID[10:8])</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_PERIPHID3" offset="0xf880cfec" size="0x4">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">[7:4] = 0000, RevAnd
[3:0] = 0010, Customer modified (Xilinx Device_code[3:0])</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_COMPID0" offset="0xf880cff0" size="0x4">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Component ID</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_COMPID1" offset="0xf880cff4" size="0x4">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Component ID</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_COMPID2" offset="0xf880cff8" size="0x4">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Component ID</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_AXIM_COMPID3" offset="0xf880cffc" size="0x4">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Component ID</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CPU_CTI0" name="DEBUG_CPU_CTI0" offset="0xf8898000">
            <gui_name language="en">debug_cpu_cti0</gui_name>
            <description language="en">debug_cpu_cti0</description>
            <register name="DEBUG_CPU_CTI0_CTICONTROL" offset="0xf8898000" size="0x2">
                <gui_name language="en">CTICONTROL</gui_name>
                <description language="en">CTI Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GLBEN">
                    <gui_name language="en">GLBEN</gui_name>
                    <description language="en">Enables or disables the ECT. When disabled, all cross triggering mapping logic functionality is disabled for this processor.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_CTIINTACK" offset="0xf8898010" size="0x2">
                <gui_name language="en">CTIINTACK</gui_name>
                <description language="en">CTI Interrupt Acknowledge Register</description>
                <bitField access="Write Only" enumerationId="CTIINTACK_INTACK_ENUM" high_bit="7" low_bit="0" name="INTACK">
                    <gui_name language="en">INTACK</gui_name>
                    <description language="en">Acknowledges the corresponding CTITRIGOUT output:
1 = CTITRIGOUT is acknowledged and is cleared when MAPTRIGOUT is LOW.
0 = no effect
There is one bit of the register for each CTITRIGOUT output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIAPPSET" offset="0xf8898014" size="0x2">
                <gui_name language="en">CTIAPPSET</gui_name>
                <description language="en">CTI Application Trigger Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="APPSET">
                    <gui_name language="en">APPSET</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event for the selected channel.
Read:
0 = application trigger inactive (reset)
1 = application trigger active.
Write:
0 = no effect
1 = generate channel event.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_CTIAPPCLEAR" offset="0xf8898018" size="0x2">
                <gui_name language="en">CTIAPPCLEAR</gui_name>
                <description language="en">CTI Application Trigger Clear Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPCLEAR_APPCLEAR_ENUM" high_bit="3" low_bit="0" name="APPCLEAR">
                    <gui_name language="en">APPCLEAR</gui_name>
                    <description language="en">Clears corresponding bits in the CTIAPPSET register.
1 = application trigger disabled in the CTIAPPSET register
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_CTIAPPPULSE" offset="0xf889801c" size="0x2">
                <gui_name language="en">CTIAPPPULSE</gui_name>
                <description language="en">CTI Application Pulse Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPPULSE_APPULSE_ENUM" high_bit="3" low_bit="0" name="APPULSE">
                    <gui_name language="en">APPULSE</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event pulse for the selected channel.
Write:
1 = channel event pulse generated for one CTICLK period
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN0" offset="0xf8898020" size="0x2">
                <gui_name language="en">CTIINEN0</gui_name>
                <description language="en">CTI Trigger to Channel Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN0_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN1" offset="0xf8898024" size="0x2">
                <gui_name language="en">CTIINEN1</gui_name>
                <description language="en">CTI Trigger to Channel Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN1_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN2" offset="0xf8898028" size="0x2">
                <gui_name language="en">CTIINEN2</gui_name>
                <description language="en">CTI Trigger to Channel Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN2_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN3" offset="0xf889802c" size="0x2">
                <gui_name language="en">CTIINEN3</gui_name>
                <description language="en">CTI Trigger to Channel Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN3_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN4" offset="0xf8898030" size="0x2">
                <gui_name language="en">CTIINEN4</gui_name>
                <description language="en">CTI Trigger to Channel Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN4_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN5" offset="0xf8898034" size="0x2">
                <gui_name language="en">CTIINEN5</gui_name>
                <description language="en">CTI Trigger to Channel Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN5_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN6" offset="0xf8898038" size="0x2">
                <gui_name language="en">CTIINEN6</gui_name>
                <description language="en">CTI Trigger to Channel Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN6_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIINEN7" offset="0xf889803c" size="0x2">
                <gui_name language="en">CTIINEN7</gui_name>
                <description language="en">CTI Trigger to Channel Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN7_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN0" offset="0xf88980a0" size="0x2">
                <gui_name language="en">CTIOUTEN0</gui_name>
                <description language="en">CTI Channel to Trigger Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN0_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN1" offset="0xf88980a4" size="0x2">
                <gui_name language="en">CTIOUTEN1</gui_name>
                <description language="en">CTI Channel to Trigger Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN1_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN2" offset="0xf88980a8" size="0x2">
                <gui_name language="en">CTIOUTEN2</gui_name>
                <description language="en">CTI Channel to Trigger Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN2_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN3" offset="0xf88980ac" size="0x2">
                <gui_name language="en">CTIOUTEN3</gui_name>
                <description language="en">CTI Channel to Trigger Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN3_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN4" offset="0xf88980b0" size="0x2">
                <gui_name language="en">CTIOUTEN4</gui_name>
                <description language="en">CTI Channel to Trigger Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN4_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN5" offset="0xf88980b4" size="0x2">
                <gui_name language="en">CTIOUTEN5</gui_name>
                <description language="en">CTI Channel to Trigger Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN5_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN6" offset="0xf88980b8" size="0x2">
                <gui_name language="en">CTIOUTEN6</gui_name>
                <description language="en">CTI Channel to Trigger Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN6_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIOUTEN7" offset="0xf88980bc" size="0x2">
                <gui_name language="en">CTIOUTEN7</gui_name>
                <description language="en">CTI Channel to Trigger Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN7_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_CTITRIGINSTATUS" offset="0xf8898130" size="0x2">
                <gui_name language="en">CTITRIGINSTATUS</gui_name>
                <description language="en">CTI Trigger In Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGINSTATUS_TRIGINSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGINSTATUS">
                    <gui_name language="en">TRIGINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGIN inputs:
1 = CTITRIGIN is active
0 = CTITRIGIN is inactive.
Because the register provides a view of the raw CTITRIGIN inputs, the reset value is
unknown. There is one bit of the register for each trigger input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_CTITRIGOUTSTATUS" offset="0xf8898134" size="0x2">
                <gui_name language="en">CTITRIGOUTSTATUS</gui_name>
                <description language="en">CTI Trigger Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGOUTSTATUS_TRIGOUTSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGOUTSTATUS">
                    <gui_name language="en">TRIGOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGOUT outputs.
1 = CTITRIGOUT is active
0 = CTITRIGOUT is inactive (reset).
There is one bit of the register for each trigger output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_CTICHINSTATUS" offset="0xf8898138" size="0x2">
                <gui_name language="en">CTICHINSTATUS</gui_name>
                <description language="en">CTI Channel In Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHINSTATUS_CTCHINSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHINSTATUS">
                    <gui_name language="en">CTCHINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHIN inputs:
1 = CTICHIN is active
0 = CTICHIN is inactive.
Because the register provides a view of the raw CTICHIN inputs from the CTM, the reset
value is unknown. There is one bit of the register for each channel input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_CTICHOUTSTATUS" offset="0xf889813c" size="0x2">
                <gui_name language="en">CTICHOUTSTATUS</gui_name>
                <description language="en">CTI Channel Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHOUTSTATUS_CTCHOUTSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHOUTSTATUS">
                    <gui_name language="en">CTCHOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHOUT outputs.
1 = CTICHOUT is active
0 = CTICHOUT is inactive (reset).
There is one bit of the register for each channel output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTIGATE" offset="0xf8898140" size="0x2">
                <gui_name language="en">CTIGATE</gui_name>
                <description language="en">Enable CTI Channel Gate Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CTIGATEEN3">
                    <gui_name language="en">CTIGATEEN3</gui_name>
                    <description language="en">Enable CTICHOUT3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CTIGATEEN2">
                    <gui_name language="en">CTIGATEEN2</gui_name>
                    <description language="en">Enable CTICHOUT2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CTIGATEEN1">
                    <gui_name language="en">CTIGATEEN1</gui_name>
                    <description language="en">Enable CTICHOUT1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CTIGATEEN0">
                    <gui_name language="en">CTIGATEEN0</gui_name>
                    <description language="en">Enable CTICHOUT0.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_ASICCTL" offset="0xf8898144" size="0x2">
                <gui_name language="en">ASICCTL</gui_name>
                <description language="en">External Multiplexor Control Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ASICCTL">
                    <gui_name language="en">ASICCTL</gui_name>
                    <description language="en">Implementation defined ASIC control, value written to the register is output on ASICCTL[7:0].</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_ITCHINACK" offset="0xf8898edc" size="0x2">
                <gui_name language="en">ITCHINACK</gui_name>
                <description language="en">ITCHINACK Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHINACK">
                    <gui_name language="en">CTCHINACK</gui_name>
                    <description language="en">Set the value of the CTCHINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_ITTRIGINACK" offset="0xf8898ee0" size="0x2">
                <gui_name language="en">ITTRIGINACK</gui_name>
                <description language="en">ITTRIGINACK Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGINACK">
                    <gui_name language="en">CTTRIGINACK</gui_name>
                    <description language="en">Set the value of the CTTRIGINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_ITCHOUT" offset="0xf8898ee4" size="0x2">
                <gui_name language="en">ITCHOUT</gui_name>
                <description language="en">ITCHOUT Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHOUT">
                    <gui_name language="en">CTCHOUT</gui_name>
                    <description language="en">Set the value of the CTCHOUT outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_ITTRIGOUT" offset="0xf8898ee8" size="0x2">
                <gui_name language="en">ITTRIGOUT</gui_name>
                <description language="en">ITTRIGOUT Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGOUT">
                    <gui_name language="en">CTTRIGOUT</gui_name>
                    <description language="en">Set the value of the CTTRIGOUT outputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_ITCHOUTACK" offset="0xf8898eec" size="0x2">
                <gui_name language="en">ITCHOUTACK</gui_name>
                <description language="en">ITCHOUTACK Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHOUTACK">
                    <gui_name language="en">CTCHOUTACK</gui_name>
                    <description language="en">Read the values of the CTCHOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_ITTRIGOUTACK" offset="0xf8898ef0" size="0x2">
                <gui_name language="en">ITTRIGOUTACK</gui_name>
                <description language="en">ITTRIGOUTACK Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGOUTACK">
                    <gui_name language="en">CTTRIGOUTACK</gui_name>
                    <description language="en">Read the values of the CTTRIGOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_ITCHIN" offset="0xf8898ef4" size="0x2">
                <gui_name language="en">ITCHIN</gui_name>
                <description language="en">ITCHIN Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHIN">
                    <gui_name language="en">CTCHIN</gui_name>
                    <description language="en">Read the values of the CTCHIN inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_ITTRIGIN" offset="0xf8898ef8" size="0x2">
                <gui_name language="en">ITTRIGIN</gui_name>
                <description language="en">ITTRIGIN Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGIN">
                    <gui_name language="en">CTTRIGIN</gui_name>
                    <description language="en">Read the values of the CTTRIGIN inputs</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_ITCTRL" offset="0xf8898f00" size="0x2">
                <gui_name language="en">ITCTRL</gui_name>
                <description language="en">IT Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable IT Registers</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTSR" offset="0xf8898fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="SET">
                    <gui_name language="en">SET</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI0_CTCR" offset="0xf8898fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI0_LAR" offset="0xf8898fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="KEY">
                    <gui_name language="en">KEY</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), CTI is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
CTI is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_LSR" offset="0xf8898fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since CTI implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether CTI is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_ASR" offset="0xf8898fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">Current value of noninvasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="NIDEN_CTL">
                    <gui_name language="en">NIDEN_CTL</gui_name>
                    <description language="en">Non-invasive debug controlled</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="IDEN">
                    <gui_name language="en">IDEN</gui_name>
                    <description language="en">Current value of invasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IDEN_CTL">
                    <gui_name language="en">IDEN_CTL</gui_name>
                    <description language="en">Invasive debug controlled</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_DEVID" offset="0xf8898fc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="NumChan">
                    <gui_name language="en">NumChan</gui_name>
                    <description language="en">Number of channels available</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="NumTrig">
                    <gui_name language="en">NumTrig</gui_name>
                    <description language="en">Number of triggers available</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="5" name="res">
                    <gui_name language="en">res</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="ExtMux">
                    <gui_name language="en">ExtMux</gui_name>
                    <description language="en">no external muxing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_DTIR" offset="0xf8898fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">major type is a debug control logic component, sub-type is cross trigger</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID4" offset="0xf8898fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID5" offset="0xf8898fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID6" offset="0xf8898fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID7" offset="0xf8898fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID0" offset="0xf8898fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID1" offset="0xf8898fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID2" offset="0xf8898fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_PERIPHID3" offset="0xf8898fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_COMPID0" offset="0xf8898ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_COMPID1" offset="0xf8898ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_COMPID2" offset="0xf8898ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI0_COMPID3" offset="0xf8898ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CPU_CTI1" name="DEBUG_CPU_CTI1" offset="0xf8899000">
            <gui_name language="en">debug_cpu_cti1</gui_name>
            <description language="en">debug_cpu_cti1</description>
            <register name="DEBUG_CPU_CTI1_CTICONTROL" offset="0xf8899000" size="0x2">
                <gui_name language="en">CTICONTROL</gui_name>
                <description language="en">CTI Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GLBEN">
                    <gui_name language="en">GLBEN</gui_name>
                    <description language="en">Enables or disables the ECT. When disabled, all cross triggering mapping logic functionality is disabled for this processor.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_CTIINTACK" offset="0xf8899010" size="0x2">
                <gui_name language="en">CTIINTACK</gui_name>
                <description language="en">CTI Interrupt Acknowledge Register</description>
                <bitField access="Write Only" enumerationId="CTIINTACK_INTACK_ENUM" high_bit="7" low_bit="0" name="INTACK">
                    <gui_name language="en">INTACK</gui_name>
                    <description language="en">Acknowledges the corresponding CTITRIGOUT output:
1 = CTITRIGOUT is acknowledged and is cleared when MAPTRIGOUT is LOW.
0 = no effect
There is one bit of the register for each CTITRIGOUT output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIAPPSET" offset="0xf8899014" size="0x2">
                <gui_name language="en">CTIAPPSET</gui_name>
                <description language="en">CTI Application Trigger Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="APPSET">
                    <gui_name language="en">APPSET</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event for the selected channel.
Read:
0 = application trigger inactive (reset)
1 = application trigger active.
Write:
0 = no effect
1 = generate channel event.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_CTIAPPCLEAR" offset="0xf8899018" size="0x2">
                <gui_name language="en">CTIAPPCLEAR</gui_name>
                <description language="en">CTI Application Trigger Clear Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPCLEAR_APPCLEAR_ENUM" high_bit="3" low_bit="0" name="APPCLEAR">
                    <gui_name language="en">APPCLEAR</gui_name>
                    <description language="en">Clears corresponding bits in the CTIAPPSET register.
1 = application trigger disabled in the CTIAPPSET register
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_CTIAPPPULSE" offset="0xf889901c" size="0x2">
                <gui_name language="en">CTIAPPPULSE</gui_name>
                <description language="en">CTI Application Pulse Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPPULSE_APPULSE_ENUM" high_bit="3" low_bit="0" name="APPULSE">
                    <gui_name language="en">APPULSE</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event pulse for the selected channel.
Write:
1 = channel event pulse generated for one CTICLK period
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN0" offset="0xf8899020" size="0x2">
                <gui_name language="en">CTIINEN0</gui_name>
                <description language="en">CTI Trigger to Channel Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN0_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN1" offset="0xf8899024" size="0x2">
                <gui_name language="en">CTIINEN1</gui_name>
                <description language="en">CTI Trigger to Channel Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN1_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN2" offset="0xf8899028" size="0x2">
                <gui_name language="en">CTIINEN2</gui_name>
                <description language="en">CTI Trigger to Channel Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN2_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN3" offset="0xf889902c" size="0x2">
                <gui_name language="en">CTIINEN3</gui_name>
                <description language="en">CTI Trigger to Channel Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN3_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN4" offset="0xf8899030" size="0x2">
                <gui_name language="en">CTIINEN4</gui_name>
                <description language="en">CTI Trigger to Channel Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN4_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN5" offset="0xf8899034" size="0x2">
                <gui_name language="en">CTIINEN5</gui_name>
                <description language="en">CTI Trigger to Channel Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN5_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN6" offset="0xf8899038" size="0x2">
                <gui_name language="en">CTIINEN6</gui_name>
                <description language="en">CTI Trigger to Channel Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN6_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIINEN7" offset="0xf889903c" size="0x2">
                <gui_name language="en">CTIINEN7</gui_name>
                <description language="en">CTI Trigger to Channel Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN7_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN0" offset="0xf88990a0" size="0x2">
                <gui_name language="en">CTIOUTEN0</gui_name>
                <description language="en">CTI Channel to Trigger Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN0_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN1" offset="0xf88990a4" size="0x2">
                <gui_name language="en">CTIOUTEN1</gui_name>
                <description language="en">CTI Channel to Trigger Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN1_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN2" offset="0xf88990a8" size="0x2">
                <gui_name language="en">CTIOUTEN2</gui_name>
                <description language="en">CTI Channel to Trigger Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN2_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN3" offset="0xf88990ac" size="0x2">
                <gui_name language="en">CTIOUTEN3</gui_name>
                <description language="en">CTI Channel to Trigger Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN3_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN4" offset="0xf88990b0" size="0x2">
                <gui_name language="en">CTIOUTEN4</gui_name>
                <description language="en">CTI Channel to Trigger Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN4_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN5" offset="0xf88990b4" size="0x2">
                <gui_name language="en">CTIOUTEN5</gui_name>
                <description language="en">CTI Channel to Trigger Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN5_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN6" offset="0xf88990b8" size="0x2">
                <gui_name language="en">CTIOUTEN6</gui_name>
                <description language="en">CTI Channel to Trigger Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN6_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIOUTEN7" offset="0xf88990bc" size="0x2">
                <gui_name language="en">CTIOUTEN7</gui_name>
                <description language="en">CTI Channel to Trigger Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN7_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_CTITRIGINSTATUS" offset="0xf8899130" size="0x2">
                <gui_name language="en">CTITRIGINSTATUS</gui_name>
                <description language="en">CTI Trigger In Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGINSTATUS_TRIGINSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGINSTATUS">
                    <gui_name language="en">TRIGINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGIN inputs:
1 = CTITRIGIN is active
0 = CTITRIGIN is inactive.
Because the register provides a view of the raw CTITRIGIN inputs, the reset value is
unknown. There is one bit of the register for each trigger input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_CTITRIGOUTSTATUS" offset="0xf8899134" size="0x2">
                <gui_name language="en">CTITRIGOUTSTATUS</gui_name>
                <description language="en">CTI Trigger Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGOUTSTATUS_TRIGOUTSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGOUTSTATUS">
                    <gui_name language="en">TRIGOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGOUT outputs.
1 = CTITRIGOUT is active
0 = CTITRIGOUT is inactive (reset).
There is one bit of the register for each trigger output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_CTICHINSTATUS" offset="0xf8899138" size="0x2">
                <gui_name language="en">CTICHINSTATUS</gui_name>
                <description language="en">CTI Channel In Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHINSTATUS_CTCHINSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHINSTATUS">
                    <gui_name language="en">CTCHINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHIN inputs:
1 = CTICHIN is active
0 = CTICHIN is inactive.
Because the register provides a view of the raw CTICHIN inputs from the CTM, the reset
value is unknown. There is one bit of the register for each channel input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_CTICHOUTSTATUS" offset="0xf889913c" size="0x2">
                <gui_name language="en">CTICHOUTSTATUS</gui_name>
                <description language="en">CTI Channel Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHOUTSTATUS_CTCHOUTSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHOUTSTATUS">
                    <gui_name language="en">CTCHOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHOUT outputs.
1 = CTICHOUT is active
0 = CTICHOUT is inactive (reset).
There is one bit of the register for each channel output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTIGATE" offset="0xf8899140" size="0x2">
                <gui_name language="en">CTIGATE</gui_name>
                <description language="en">Enable CTI Channel Gate Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CTIGATEEN3">
                    <gui_name language="en">CTIGATEEN3</gui_name>
                    <description language="en">Enable CTICHOUT3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CTIGATEEN2">
                    <gui_name language="en">CTIGATEEN2</gui_name>
                    <description language="en">Enable CTICHOUT2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CTIGATEEN1">
                    <gui_name language="en">CTIGATEEN1</gui_name>
                    <description language="en">Enable CTICHOUT1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CTIGATEEN0">
                    <gui_name language="en">CTIGATEEN0</gui_name>
                    <description language="en">Enable CTICHOUT0.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_ASICCTL" offset="0xf8899144" size="0x2">
                <gui_name language="en">ASICCTL</gui_name>
                <description language="en">External Multiplexor Control Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ASICCTL">
                    <gui_name language="en">ASICCTL</gui_name>
                    <description language="en">Implementation defined ASIC control, value written to the register is output on ASICCTL[7:0].</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_ITCHINACK" offset="0xf8899edc" size="0x2">
                <gui_name language="en">ITCHINACK</gui_name>
                <description language="en">ITCHINACK Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHINACK">
                    <gui_name language="en">CTCHINACK</gui_name>
                    <description language="en">Set the value of the CTCHINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_ITTRIGINACK" offset="0xf8899ee0" size="0x2">
                <gui_name language="en">ITTRIGINACK</gui_name>
                <description language="en">ITTRIGINACK Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGINACK">
                    <gui_name language="en">CTTRIGINACK</gui_name>
                    <description language="en">Set the value of the CTTRIGINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_ITCHOUT" offset="0xf8899ee4" size="0x2">
                <gui_name language="en">ITCHOUT</gui_name>
                <description language="en">ITCHOUT Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHOUT">
                    <gui_name language="en">CTCHOUT</gui_name>
                    <description language="en">Set the value of the CTCHOUT outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_ITTRIGOUT" offset="0xf8899ee8" size="0x2">
                <gui_name language="en">ITTRIGOUT</gui_name>
                <description language="en">ITTRIGOUT Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGOUT">
                    <gui_name language="en">CTTRIGOUT</gui_name>
                    <description language="en">Set the value of the CTTRIGOUT outputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_ITCHOUTACK" offset="0xf8899eec" size="0x2">
                <gui_name language="en">ITCHOUTACK</gui_name>
                <description language="en">ITCHOUTACK Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHOUTACK">
                    <gui_name language="en">CTCHOUTACK</gui_name>
                    <description language="en">Read the values of the CTCHOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_ITTRIGOUTACK" offset="0xf8899ef0" size="0x2">
                <gui_name language="en">ITTRIGOUTACK</gui_name>
                <description language="en">ITTRIGOUTACK Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGOUTACK">
                    <gui_name language="en">CTTRIGOUTACK</gui_name>
                    <description language="en">Read the values of the CTTRIGOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_ITCHIN" offset="0xf8899ef4" size="0x2">
                <gui_name language="en">ITCHIN</gui_name>
                <description language="en">ITCHIN Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHIN">
                    <gui_name language="en">CTCHIN</gui_name>
                    <description language="en">Read the values of the CTCHIN inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_ITTRIGIN" offset="0xf8899ef8" size="0x2">
                <gui_name language="en">ITTRIGIN</gui_name>
                <description language="en">ITTRIGIN Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGIN">
                    <gui_name language="en">CTTRIGIN</gui_name>
                    <description language="en">Read the values of the CTTRIGIN inputs</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_ITCTRL" offset="0xf8899f00" size="0x2">
                <gui_name language="en">ITCTRL</gui_name>
                <description language="en">IT Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable IT Registers</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTSR" offset="0xf8899fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="SET">
                    <gui_name language="en">SET</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_CTI1_CTCR" offset="0xf8899fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_CTI1_LAR" offset="0xf8899fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="KEY">
                    <gui_name language="en">KEY</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), CTI is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
CTI is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_LSR" offset="0xf8899fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since CTI implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether CTI is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_ASR" offset="0xf8899fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">Current value of noninvasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="NIDEN_CTL">
                    <gui_name language="en">NIDEN_CTL</gui_name>
                    <description language="en">Non-invasive debug controlled</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="IDEN">
                    <gui_name language="en">IDEN</gui_name>
                    <description language="en">Current value of invasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IDEN_CTL">
                    <gui_name language="en">IDEN_CTL</gui_name>
                    <description language="en">Invasive debug controlled</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_DEVID" offset="0xf8899fc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="NumChan">
                    <gui_name language="en">NumChan</gui_name>
                    <description language="en">Number of channels available</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="NumTrig">
                    <gui_name language="en">NumTrig</gui_name>
                    <description language="en">Number of triggers available</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="5" name="res">
                    <gui_name language="en">res</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="ExtMux">
                    <gui_name language="en">ExtMux</gui_name>
                    <description language="en">no external muxing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_DTIR" offset="0xf8899fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">major type is a debug control logic component, sub-type is cross trigger</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID4" offset="0xf8899fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID5" offset="0xf8899fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID6" offset="0xf8899fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID7" offset="0xf8899fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID0" offset="0xf8899fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID1" offset="0xf8899fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID2" offset="0xf8899fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_PERIPHID3" offset="0xf8899fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_COMPID0" offset="0xf8899ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_COMPID1" offset="0xf8899ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_COMPID2" offset="0xf8899ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_CTI1_COMPID3" offset="0xf8899ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CPU_PMU0" name="DEBUG_CPU_PMU0" offset="0xf8891000">
            <gui_name language="en">debug_cpu_pmu0</gui_name>
            <description language="en">debug_cpu_pmu0</description>
            <register name="DEBUG_CPU_PMU0_PMXEVCNTR0" offset="0xf8891000" size="0x4">
                <gui_name language="en">PMXEVCNTR0</gui_name>
                <description language="en">PMU event counter 0</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR0">
                    <gui_name language="en">PMXEVCNTR0</gui_name>
                    <description language="en">PMU event counter 0</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVCNTR1" offset="0xf8891004" size="0x4">
                <gui_name language="en">PMXEVCNTR1</gui_name>
                <description language="en">PMU event counter 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR1">
                    <gui_name language="en">PMXEVCNTR1</gui_name>
                    <description language="en">PMU event counter 1</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVCNTR2" offset="0xf8891008" size="0x4">
                <gui_name language="en">PMXEVCNTR2</gui_name>
                <description language="en">PMU event counter 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR2">
                    <gui_name language="en">PMXEVCNTR2</gui_name>
                    <description language="en">PMU event counter 2</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVCNTR3" offset="0xf889100c" size="0x4">
                <gui_name language="en">PMXEVCNTR3</gui_name>
                <description language="en">PMU event counter 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR3">
                    <gui_name language="en">PMXEVCNTR3</gui_name>
                    <description language="en">PMU event counter 3</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVCNTR4" offset="0xf8891010" size="0x4">
                <gui_name language="en">PMXEVCNTR4</gui_name>
                <description language="en">PMU event counter 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR4">
                    <gui_name language="en">PMXEVCNTR4</gui_name>
                    <description language="en">PMU event counter 4</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVCNTR5" offset="0xf8891014" size="0x4">
                <gui_name language="en">PMXEVCNTR5</gui_name>
                <description language="en">PMU event counter 5</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR5">
                    <gui_name language="en">PMXEVCNTR5</gui_name>
                    <description language="en">PMU event counter 5</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMCCNTR" offset="0xf889107c" size="0x4">
                <gui_name language="en">PMCCNTR</gui_name>
                <description language="en">pmccntr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCCNTR">
                    <gui_name language="en">PMCCNTR</gui_name>
                    <description language="en">pmccntr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVTYPER0" offset="0xf8891400" size="0x4">
                <gui_name language="en">PMXEVTYPER0</gui_name>
                <description language="en">pmevtyper0</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER0">
                    <gui_name language="en">PMXEVTYPER0</gui_name>
                    <description language="en">pmevtyper0</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVTYPER1" offset="0xf8891404" size="0x4">
                <gui_name language="en">PMXEVTYPER1</gui_name>
                <description language="en">pmevtyper1</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER1">
                    <gui_name language="en">PMXEVTYPER1</gui_name>
                    <description language="en">pmevtyper1</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVTYPER2" offset="0xf8891408" size="0x4">
                <gui_name language="en">PMXEVTYPER2</gui_name>
                <description language="en">pmevtyper2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER2">
                    <gui_name language="en">PMXEVTYPER2</gui_name>
                    <description language="en">pmevtyper2</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVTYPER3" offset="0xf889140c" size="0x4">
                <gui_name language="en">PMXEVTYPER3</gui_name>
                <description language="en">pmevtyper3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER3">
                    <gui_name language="en">PMXEVTYPER3</gui_name>
                    <description language="en">pmevtyper3</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVTYPER4" offset="0xf8891410" size="0x4">
                <gui_name language="en">PMXEVTYPER4</gui_name>
                <description language="en">pmevtyper4</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER4">
                    <gui_name language="en">PMXEVTYPER4</gui_name>
                    <description language="en">pmevtyper4</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMXEVTYPER5" offset="0xf8891414" size="0x4">
                <gui_name language="en">PMXEVTYPER5</gui_name>
                <description language="en">pmevtyper5</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER5">
                    <gui_name language="en">PMXEVTYPER5</gui_name>
                    <description language="en">pmevtyper5</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMCNTENSET" offset="0xf8891c00" size="0x4">
                <gui_name language="en">PMCNTENSET</gui_name>
                <description language="en">pmcntenset</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCNTENSET">
                    <gui_name language="en">PMCNTENSET</gui_name>
                    <description language="en">pmcntenset</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMCNTENCLR" offset="0xf8891c20" size="0x4">
                <gui_name language="en">PMCNTENCLR</gui_name>
                <description language="en">pmcntenclr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCNTENCLR">
                    <gui_name language="en">PMCNTENCLR</gui_name>
                    <description language="en">pmcntenclr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMINTENSET" offset="0xf8891c40" size="0x4">
                <gui_name language="en">PMINTENSET</gui_name>
                <description language="en">pmintenset</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMINTENSET">
                    <gui_name language="en">PMINTENSET</gui_name>
                    <description language="en">pmintenset</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMINTENCLR" offset="0xf8891c60" size="0x4">
                <gui_name language="en">PMINTENCLR</gui_name>
                <description language="en">pmintenclr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMINTENCLR">
                    <gui_name language="en">PMINTENCLR</gui_name>
                    <description language="en">pmintenclr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMOVSR" offset="0xf8891c80" size="0x4">
                <gui_name language="en">PMOVSR</gui_name>
                <description language="en">pmovsr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMOVSR">
                    <gui_name language="en">PMOVSR</gui_name>
                    <description language="en">pmovsr</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PMU0_PMSWINC" offset="0xf8891ca0" size="0x4">
                <gui_name language="en">PMSWINC</gui_name>
                <description language="en">pmswinc</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="PMSWINC">
                    <gui_name language="en">PMSWINC</gui_name>
                    <description language="en">pmswinc</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMCR" offset="0xf8891e04" size="0x4">
                <gui_name language="en">PMCR</gui_name>
                <description language="en">pmcr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCR">
                    <gui_name language="en">PMCR</gui_name>
                    <description language="en">pmcr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU0_PMUSERENR" offset="0xf8891e08" size="0x4">
                <gui_name language="en">PMUSERENR</gui_name>
                <description language="en">pmuserenr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMUSERENR">
                    <gui_name language="en">PMUSERENR</gui_name>
                    <description language="en">pmuserenr
This register is read-only in user mode.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CPU_PMU1" name="DEBUG_CPU_PMU1" offset="0xf8893000">
            <gui_name language="en">debug_cpu_pmu1</gui_name>
            <description language="en">debug_cpu_pmu1</description>
            <register name="DEBUG_CPU_PMU1_PMXEVCNTR0" offset="0xf8893000" size="0x4">
                <gui_name language="en">PMXEVCNTR0</gui_name>
                <description language="en">PMU event counter 0</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR0">
                    <gui_name language="en">PMXEVCNTR0</gui_name>
                    <description language="en">PMU event counter 0</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVCNTR1" offset="0xf8893004" size="0x4">
                <gui_name language="en">PMXEVCNTR1</gui_name>
                <description language="en">PMU event counter 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR1">
                    <gui_name language="en">PMXEVCNTR1</gui_name>
                    <description language="en">PMU event counter 1</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVCNTR2" offset="0xf8893008" size="0x4">
                <gui_name language="en">PMXEVCNTR2</gui_name>
                <description language="en">PMU event counter 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR2">
                    <gui_name language="en">PMXEVCNTR2</gui_name>
                    <description language="en">PMU event counter 2</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVCNTR3" offset="0xf889300c" size="0x4">
                <gui_name language="en">PMXEVCNTR3</gui_name>
                <description language="en">PMU event counter 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR3">
                    <gui_name language="en">PMXEVCNTR3</gui_name>
                    <description language="en">PMU event counter 3</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVCNTR4" offset="0xf8893010" size="0x4">
                <gui_name language="en">PMXEVCNTR4</gui_name>
                <description language="en">PMU event counter 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR4">
                    <gui_name language="en">PMXEVCNTR4</gui_name>
                    <description language="en">PMU event counter 4</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVCNTR5" offset="0xf8893014" size="0x4">
                <gui_name language="en">PMXEVCNTR5</gui_name>
                <description language="en">PMU event counter 5</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVCNTR5">
                    <gui_name language="en">PMXEVCNTR5</gui_name>
                    <description language="en">PMU event counter 5</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMCCNTR" offset="0xf889307c" size="0x4">
                <gui_name language="en">PMCCNTR</gui_name>
                <description language="en">pmccntr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCCNTR">
                    <gui_name language="en">PMCCNTR</gui_name>
                    <description language="en">pmccntr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVTYPER0" offset="0xf8893400" size="0x4">
                <gui_name language="en">PMXEVTYPER0</gui_name>
                <description language="en">pmevtyper0</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER0">
                    <gui_name language="en">PMXEVTYPER0</gui_name>
                    <description language="en">pmevtyper0</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVTYPER1" offset="0xf8893404" size="0x4">
                <gui_name language="en">PMXEVTYPER1</gui_name>
                <description language="en">pmevtyper1</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER1">
                    <gui_name language="en">PMXEVTYPER1</gui_name>
                    <description language="en">pmevtyper1</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVTYPER2" offset="0xf8893408" size="0x4">
                <gui_name language="en">PMXEVTYPER2</gui_name>
                <description language="en">pmevtyper2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER2">
                    <gui_name language="en">PMXEVTYPER2</gui_name>
                    <description language="en">pmevtyper2</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVTYPER3" offset="0xf889340c" size="0x4">
                <gui_name language="en">PMXEVTYPER3</gui_name>
                <description language="en">pmevtyper3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER3">
                    <gui_name language="en">PMXEVTYPER3</gui_name>
                    <description language="en">pmevtyper3</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVTYPER4" offset="0xf8893410" size="0x4">
                <gui_name language="en">PMXEVTYPER4</gui_name>
                <description language="en">pmevtyper4</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER4">
                    <gui_name language="en">PMXEVTYPER4</gui_name>
                    <description language="en">pmevtyper4</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMXEVTYPER5" offset="0xf8893414" size="0x4">
                <gui_name language="en">PMXEVTYPER5</gui_name>
                <description language="en">pmevtyper5</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMXEVTYPER5">
                    <gui_name language="en">PMXEVTYPER5</gui_name>
                    <description language="en">pmevtyper5</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMCNTENSET" offset="0xf8893c00" size="0x4">
                <gui_name language="en">PMCNTENSET</gui_name>
                <description language="en">pmcntenset</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCNTENSET">
                    <gui_name language="en">PMCNTENSET</gui_name>
                    <description language="en">pmcntenset</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMCNTENCLR" offset="0xf8893c20" size="0x4">
                <gui_name language="en">PMCNTENCLR</gui_name>
                <description language="en">pmcntenclr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCNTENCLR">
                    <gui_name language="en">PMCNTENCLR</gui_name>
                    <description language="en">pmcntenclr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMINTENSET" offset="0xf8893c40" size="0x4">
                <gui_name language="en">PMINTENSET</gui_name>
                <description language="en">pmintenset</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMINTENSET">
                    <gui_name language="en">PMINTENSET</gui_name>
                    <description language="en">pmintenset</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMINTENCLR" offset="0xf8893c60" size="0x4">
                <gui_name language="en">PMINTENCLR</gui_name>
                <description language="en">pmintenclr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMINTENCLR">
                    <gui_name language="en">PMINTENCLR</gui_name>
                    <description language="en">pmintenclr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMOVSR" offset="0xf8893c80" size="0x4">
                <gui_name language="en">PMOVSR</gui_name>
                <description language="en">pmovsr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMOVSR">
                    <gui_name language="en">PMOVSR</gui_name>
                    <description language="en">pmovsr</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PMU1_PMSWINC" offset="0xf8893ca0" size="0x4">
                <gui_name language="en">PMSWINC</gui_name>
                <description language="en">pmswinc</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="PMSWINC">
                    <gui_name language="en">PMSWINC</gui_name>
                    <description language="en">pmswinc</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMCR" offset="0xf8893e04" size="0x4">
                <gui_name language="en">PMCR</gui_name>
                <description language="en">pmcr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMCR">
                    <gui_name language="en">PMCR</gui_name>
                    <description language="en">pmcr</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PMU1_PMUSERENR" offset="0xf8893e08" size="0x4">
                <gui_name language="en">PMUSERENR</gui_name>
                <description language="en">pmuserenr</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="PMUSERENR">
                    <gui_name language="en">PMUSERENR</gui_name>
                    <description language="en">pmuserenr
This register is read-only in user mode.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CPU_PTM0" name="DEBUG_CPU_PTM0" offset="0xf889c000">
            <gui_name language="en">debug_cpu_ptm0</gui_name>
            <description language="en">debug_cpu_ptm0</description>
            <register name="DEBUG_CPU_PTM0_ETMCR" offset="0xf889c000" size="0x4">
                <gui_name language="en">ETMCR</gui_name>
                <description language="en">Main Control Register</description>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="ReturnStackEn">
                    <gui_name language="en">ReturnStackEn</gui_name>
                    <description language="en">Return stack enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="TimestampEn">
                    <gui_name language="en">TimestampEn</gui_name>
                    <description language="en">Timestamp enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="ProcSelect">
                    <gui_name language="en">ProcSelect</gui_name>
                    <description language="en">Select for external multiplexor if PTM is shared between multiple processors.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="14" name="ContexIDSize">
                    <gui_name language="en">ContexIDSize</gui_name>
                    <description language="en">Context ID Size</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="CycleAccurate">
                    <gui_name language="en">CycleAccurate</gui_name>
                    <description language="en">Enables cycle counting</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ProgBit">
                    <gui_name language="en">ProgBit</gui_name>
                    <description language="en">This bit must be set to b1 when the PTM is being programmed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="DebugReqCtrl">
                    <gui_name language="en">DebugReqCtrl</gui_name>
                    <description language="en">Debug Request Control
When set to b1 and the trigger event occurs, the PTMDBGRQ output is asserted until PTMDBGACK is observed. This enables a debugger to force the processor into Debug state.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="BranchOutput">
                    <gui_name language="en">BranchOutput</gui_name>
                    <description language="en">When this bit is set to b1, addresses are output for all executed branches, both direct and indirect.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PowerDown">
                    <gui_name language="en">PowerDown</gui_name>
                    <description language="en">This bit enables external control of the PTM. This bit must be cleared by the trace software tools at the beginning of a debug session.
When this bit is set to b0, both the PTM and the trace interface in the processor are enabled.
To avoid corruption of trace data, this bit must not be set before the Programming Status bit in the PTM Status Register has been read as 1.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ETMCCR" offset="0xf889c004" size="0x4">
                <gui_name language="en">ETMCCR</gui_name>
                <description language="en">Configuration Code Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="IDRegPresent">
                    <gui_name language="en">IDRegPresent</gui_name>
                    <description language="en">Indicates that the ID Register is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="SoftwareAccess">
                    <gui_name language="en">SoftwareAccess</gui_name>
                    <description language="en">Indicates that software access is supported.</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="26" name="TraceSSB">
                    <gui_name language="en">TraceSSB</gui_name>
                    <description language="en">Indicates that the trace start/stop block is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="24" name="NumCntxtIDComp">
                    <gui_name language="en">NumCntxtIDComp</gui_name>
                    <description language="en">Specifies the number of Context ID comparators, one.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="FIFOFULLLogic">
                    <gui_name language="en">FIFOFULLLogic</gui_name>
                    <description language="en">Indicates that it is not possible to stall the processor to prevent FIFO overflow.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="20" name="NumExtOut">
                    <gui_name language="en">NumExtOut</gui_name>
                    <description language="en">Specifies the number of external outputs, two.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="17" name="NumExtIn">
                    <gui_name language="en">NumExtIn</gui_name>
                    <description language="en">Specifies the number of external inputs, four.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="Sequencer">
                    <gui_name language="en">Sequencer</gui_name>
                    <description language="en">Indicates that the sequencer is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="13" name="NumCounters">
                    <gui_name language="en">NumCounters</gui_name>
                    <description language="en">Specifies the number of counters, two.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="NumAddrComp">
                    <gui_name language="en">NumAddrComp</gui_name>
                    <description language="en">Specifies the number of address comparator pairs, four.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMTRIGGER" offset="0xf889c008" size="0x4">
                <gui_name language="en">ETMTRIGGER</gui_name>
                <description language="en">Trigger Event Register</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TrigEvent">
                    <gui_name language="en">TrigEvent</gui_name>
                    <description language="en">Trigger event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSR" offset="0xf889c010" size="0x2">
                <gui_name language="en">ETMSR</gui_name>
                <description language="en">Status Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="TrigFlag">
                    <gui_name language="en">TrigFlag</gui_name>
                    <description language="en">Trigger bit. Set when the trigger occurs and prevents the trigger from being output until the PTM is next programmed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="TSSRStat">
                    <gui_name language="en">TSSRStat</gui_name>
                    <description language="en">Holds the current status of the trace start/stop resource. If set to 1, indicates that a trace start address has been matched, without a corresponding trace stop address match.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="ProgBit">
                    <gui_name language="en">ProgBit</gui_name>
                    <description language="en">Effective state of the Programming bit. You must wait for this bit to go to b1 before starting to program the PTM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Overflow">
                    <gui_name language="en">Overflow</gui_name>
                    <description language="en">If set to 1, there is an overflow that has not yet been traced.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ETMSCR" offset="0xf889c014" size="0x2">
                <gui_name language="en">ETMSCR</gui_name>
                <description language="en">System Configuration Register</description>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="NumProcs">
                    <gui_name language="en">NumProcs</gui_name>
                    <description language="en">Number of supported processors minus 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="FIFOFULL">
                    <gui_name language="en">FIFOFULL</gui_name>
                    <description language="en">FIFOFULL not supported</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMTSSCR" offset="0xf889c018" size="0x4">
                <gui_name language="en">ETMTSSCR</gui_name>
                <description language="en">TraceEnable Start/Stop Control Register</description>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="StopAddrSel">
                    <gui_name language="en">StopAddrSel</gui_name>
                    <description language="en">When a bit is set to 1, it selects a single address comparator (8-1) as a stop address for the TraceEnable
Start/Stop block. For example, if you set bit [16] to 1 it selects single address comparator 1 as a stop address.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="StartAddrSel">
                    <gui_name language="en">StartAddrSel</gui_name>
                    <description language="en">When a bit is set to 1, it selects a single address comparator (8-1) as a start address for the TraceEnable
Start/Stop block. For example, if you set bit [0] to 1 it selects single address comparator 1 as a start address.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMTECR1" offset="0xf889c024" size="0x4">
                <gui_name language="en">ETMTECR1</gui_name>
                <description language="en">TraceEnable Control Register 1</description>
                <bitField access="Read Write" enumerationId="ETMTECR1_TraceSSEn_ENUM" high_bit="25" low_bit="25" name="TraceSSEn">
                    <gui_name language="en">TraceSSEn</gui_name>
                    <description language="en">Trace start/stop control enable. The possible values of this bit are:
0 Tracing is unaffected by the trace start/stop logic.
1 Tracing is controlled by the trace on and off addresses configured for the trace start/stop logic.
The trace start/stop resource is not affected by the value of this bit.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMTECR1_ExcIncFlag_ENUM" high_bit="24" low_bit="24" name="ExcIncFlag">
                    <gui_name language="en">ExcIncFlag</gui_name>
                    <description language="en">Exclude/include flag. The possible values of this bit are:
0 Include. The specified address range comparators indicate the regions where tracing can occur.
No tracing occurs outside this region.
1 Exclude. The specified address range comparators indicate regions to be excluded from the
trace. When outside an exclude region, tracing can occur.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="AddrCompSel">
                    <gui_name language="en">AddrCompSel</gui_name>
                    <description language="en">When a bit is set to 1, it selects an address range comparator, 4-1, for include/exclude control. For example, bit [0] set to 1 selects address range comparator 1.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR1" offset="0xf889c040" size="0x4">
                <gui_name language="en">ETMACVR1</gui_name>
                <description language="en">Address Comparator Value Register 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR2" offset="0xf889c044" size="0x4">
                <gui_name language="en">ETMACVR2</gui_name>
                <description language="en">Address Comparator Value Register 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR3" offset="0xf889c048" size="0x4">
                <gui_name language="en">ETMACVR3</gui_name>
                <description language="en">Address Comparator Value Register 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR4" offset="0xf889c04c" size="0x4">
                <gui_name language="en">ETMACVR4</gui_name>
                <description language="en">Address Comparator Value Register 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR5" offset="0xf889c050" size="0x4">
                <gui_name language="en">ETMACVR5</gui_name>
                <description language="en">Address Comparator Value Register 5</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR6" offset="0xf889c054" size="0x4">
                <gui_name language="en">ETMACVR6</gui_name>
                <description language="en">Address Comparator Value Register 6</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR7" offset="0xf889c058" size="0x4">
                <gui_name language="en">ETMACVR7</gui_name>
                <description language="en">Address Comparator Value Register 7</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACVR8" offset="0xf889c05c" size="0x4">
                <gui_name language="en">ETMACVR8</gui_name>
                <description language="en">Address Comparator Value Register 8</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR1" offset="0xf889c080" size="0x2">
                <gui_name language="en">ETMACTR1</gui_name>
                <description language="en">Address Comparator Access Type Register 1</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR2" offset="0xf889c084" size="0x2">
                <gui_name language="en">ETMACTR2</gui_name>
                <description language="en">Address Comparator Access Type Register 2</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR3" offset="0xf889c088" size="0x2">
                <gui_name language="en">ETMACTR3</gui_name>
                <description language="en">Address Comparator Access Type Register 3</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR4" offset="0xf889c08c" size="0x2">
                <gui_name language="en">ETMACTR4</gui_name>
                <description language="en">Address Comparator Access Type Register 4</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR5" offset="0xf889c090" size="0x2">
                <gui_name language="en">ETMACTR5</gui_name>
                <description language="en">Address Comparator Access Type Register 5</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR6" offset="0xf889c094" size="0x2">
                <gui_name language="en">ETMACTR6</gui_name>
                <description language="en">Address Comparator Access Type Register 6</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR7" offset="0xf889c098" size="0x2">
                <gui_name language="en">ETMACTR7</gui_name>
                <description language="en">Address Comparator Access Type Register 7</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMACTR8" offset="0xf889c09c" size="0x2">
                <gui_name language="en">ETMACTR8</gui_name>
                <description language="en">Address Comparator Access Type Register 8</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTRLDVR1" offset="0xf889c140" size="0x2">
                <gui_name language="en">ETMCNTRLDVR1</gui_name>
                <description language="en">Counter Reload Value Register 1</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="InitValue">
                    <gui_name language="en">InitValue</gui_name>
                    <description language="en">Counter initial value</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTRLDVR2" offset="0xf889c144" size="0x2">
                <gui_name language="en">ETMCNTRLDVR2</gui_name>
                <description language="en">Counter Reload Value Register 2</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="InitValue">
                    <gui_name language="en">InitValue</gui_name>
                    <description language="en">Counter initial value</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTENR1" offset="0xf889c150" size="0x4">
                <gui_name language="en">ETMCNTENR1</gui_name>
                <description language="en">Counter Enable Event Register 1</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutEvent">
                    <gui_name language="en">ExtOutEvent</gui_name>
                    <description language="en">Count enable event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTENR2" offset="0xf889c154" size="0x4">
                <gui_name language="en">ETMCNTENR2</gui_name>
                <description language="en">Counter Enable Event Register 2</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutEvent">
                    <gui_name language="en">ExtOutEvent</gui_name>
                    <description language="en">Count enable event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTRLDEVR1" offset="0xf889c160" size="0x4">
                <gui_name language="en">ETMCNTRLDEVR1</gui_name>
                <description language="en">Counter Reload Event Register 1</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="CntReloadEvent">
                    <gui_name language="en">CntReloadEvent</gui_name>
                    <description language="en">Count reload event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTRLDEVR2" offset="0xf889c164" size="0x4">
                <gui_name language="en">ETMCNTRLDEVR2</gui_name>
                <description language="en">Counter Reload Event Register 2</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="CntReloadEvent">
                    <gui_name language="en">CntReloadEvent</gui_name>
                    <description language="en">Count reload event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTVR1" offset="0xf889c170" size="0x2">
                <gui_name language="en">ETMCNTVR1</gui_name>
                <description language="en">Counter Value Register 1</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CurrCount">
                    <gui_name language="en">CurrCount</gui_name>
                    <description language="en">Current counter value.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCNTVR2" offset="0xf889c174" size="0x2">
                <gui_name language="en">ETMCNTVR2</gui_name>
                <description language="en">Counter Value Register 2</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CurrCount">
                    <gui_name language="en">CurrCount</gui_name>
                    <description language="en">Current counter value.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQ12EVR" offset="0xf889c180" size="0x4">
                <gui_name language="en">ETMSQ12EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 12</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQ21EVR" offset="0xf889c184" size="0x4">
                <gui_name language="en">ETMSQ21EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 21</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQ23EVR" offset="0xf889c188" size="0x4">
                <gui_name language="en">ETMSQ23EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 23</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQ31EVR" offset="0xf889c18c" size="0x4">
                <gui_name language="en">ETMSQ31EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 31</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQ32EVR" offset="0xf889c190" size="0x4">
                <gui_name language="en">ETMSQ32EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 32</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQ13EVR" offset="0xf889c194" size="0x4">
                <gui_name language="en">ETMSQ13EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 13</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSQR" offset="0xf889c19c" size="0x2">
                <gui_name language="en">ETMSQR</gui_name>
                <description language="en">Current Sequencer State Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="CurrentSeqState">
                    <gui_name language="en">CurrentSeqState</gui_name>
                    <description language="en">Indicates the current sequencer state</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMEXTOUTEVR1" offset="0xf889c1a0" size="0x4">
                <gui_name language="en">ETMEXTOUTEVR1</gui_name>
                <description language="en">External Output Event Register 1</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutputEvent">
                    <gui_name language="en">ExtOutputEvent</gui_name>
                    <description language="en">External output event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMEXTOUTEVR2" offset="0xf889c1a4" size="0x4">
                <gui_name language="en">ETMEXTOUTEVR2</gui_name>
                <description language="en">External Output Event Register 2</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutputEvent">
                    <gui_name language="en">ExtOutputEvent</gui_name>
                    <description language="en">External output event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCIDCVR1" offset="0xf889c1b0" size="0x4">
                <gui_name language="en">ETMCIDCVR1</gui_name>
                <description language="en">Context ID Comparator Value Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ContextID">
                    <gui_name language="en">ContextID</gui_name>
                    <description language="en">Holds a 32-bit Context ID value</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMCIDCMR" offset="0xf889c1bc" size="0x4">
                <gui_name language="en">ETMCIDCMR</gui_name>
                <description language="en">Context ID Comparator Mask Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ContextMask">
                    <gui_name language="en">ContextMask</gui_name>
                    <description language="en">Holds a 32-bit Context ID mask</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMSYNCFR" offset="0xf889c1e0" size="0x2">
                <gui_name language="en">ETMSYNCFR</gui_name>
                <description language="en">Synchronization Frequency Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="2" name="SyncFreq">
                    <gui_name language="en">SyncFreq</gui_name>
                    <description language="en">Synchronization frequency</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ETMIDR" offset="0xf889c1e4" size="0x4">
                <gui_name language="en">ETMIDR</gui_name>
                <description language="en">ID Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="ImplCode">
                    <gui_name language="en">ImplCode</gui_name>
                    <description language="en">Implementor code. The field reads 0x41, ASCII code for A, indicating ARM Limited.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="SecExtSupp">
                    <gui_name language="en">SecExtSupp</gui_name>
                    <description language="en">Support for security extensions.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="Thumb32Supp">
                    <gui_name language="en">Thumb32Supp</gui_name>
                    <description language="en">Support for 32-bit Thumb instructions.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="MajorVer">
                    <gui_name language="en">MajorVer</gui_name>
                    <description language="en">Major architecture version number, 0b0011</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="MinorVer">
                    <gui_name language="en">MinorVer</gui_name>
                    <description language="en">Minor architecture version number, 0b0000</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="ImplRev">
                    <gui_name language="en">ImplRev</gui_name>
                    <description language="en">Implementation revision.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ETMCCER" offset="0xf889c1e8" size="0x4">
                <gui_name language="en">ETMCCER</gui_name>
                <description language="en">Configuration Code Extension Register</description>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="BarrTS">
                    <gui_name language="en">BarrTS</gui_name>
                    <description language="en">Timestamps are not generated for DMB/DSB</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="BarrWP">
                    <gui_name language="en">BarrWP</gui_name>
                    <description language="en">DMB/DSB instructions are not treated as waypoints.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="RetStack">
                    <gui_name language="en">RetStack</gui_name>
                    <description language="en">Return stack implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="Timestamp">
                    <gui_name language="en">Timestamp</gui_name>
                    <description language="en">Timestamping implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="13" name="InstrumRes">
                    <gui_name language="en">InstrumRes</gui_name>
                    <description language="en">Specifies the number of instrumentation resources.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="RegReads">
                    <gui_name language="en">RegReads</gui_name>
                    <description language="en">Indicates that all registers, except some Integration Test Registers, are readable.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="3" name="ExtInSize">
                    <gui_name language="en">ExtInSize</gui_name>
                    <description language="en">Specifies the size of the extended external input bus, 52.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="ExtInSel">
                    <gui_name language="en">ExtInSel</gui_name>
                    <description language="en">Specifies the number of extended external input selectors, 2.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMEXTINSELR" offset="0xf889c1ec" size="0x2">
                <gui_name language="en">ETMEXTINSELR</gui_name>
                <description language="en">Extended External Input Selection Register</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="ExtInSel2">
                    <gui_name language="en">ExtInSel2</gui_name>
                    <description language="en">Second extended external input selector</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="ExtInSel1">
                    <gui_name language="en">ExtInSel1</gui_name>
                    <description language="en">First extended external input selector</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMAUXCR" offset="0xf889c1fc" size="0x2">
                <gui_name language="en">ETMAUXCR</gui_name>
                <description language="en">Auxiliary Control Register</description>
                <bitField access="Read Write" enumerationId="ETMAUXCR_ForceSyncInsert_ENUM" high_bit="3" low_bit="3" name="ForceSyncInsert">
                    <gui_name language="en">ForceSyncInsert</gui_name>
                    <description language="en">Force insertion of synchronization packets, regardless of current trace activity.
Possible values for this bit are:
b0 = Synchronization packets delayed when trace activity is high. This is the reset value.
b1 = Synchronization packets inserted regardless of trace activity.
This bit might be set if synchronization packets occur too far apart. Setting this bit might cause the trace FIFO to overflow more frequently when trace activity is high.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMAUXCR_DisableWPUpdate_ENUM" high_bit="2" low_bit="2" name="DisableWPUpdate">
                    <gui_name language="en">DisableWPUpdate</gui_name>
                    <description language="en">Specifies whether the PTM issues waypoint update packets if there are more than 4096 bytes between waypoints. Possible values for this bit are:
b0 = PTM always issues update packets if there are more than 4096 bytes between waypoints. This is the reset value.
b1 = PTM does not issue waypoint update packets unless required to do so as the result of an exception or debug entry.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMAUXCR_DisableTSOnBarr_ENUM" high_bit="1" low_bit="1" name="DisableTSOnBarr">
                    <gui_name language="en">DisableTSOnBarr</gui_name>
                    <description language="en">Specifies whether the PTM issues a timestamp on a barrier instruction. Possible values for this bit are:
b0 = PTM issues timestamps on barrier instructions. This is the reset value.
b1 = PTM does not issue timestamps on barriers</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMAUXCR_DisableForcedOF_ENUM" high_bit="0" low_bit="0" name="DisableForcedOF">
                    <gui_name language="en">DisableForcedOF</gui_name>
                    <description language="en">Specifies whether the PTM enters overflow state when synchronization is requested,
and the previous synchronization sequence has not yet completed. This does not affect entry to overflow state when the FIFO becomes full. Possible values for this bit are:
b0 = Forced overflow enabled. This is the reset value.
b1 = Forced overflow disabled.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMTRACEIDR" offset="0xf889c200" size="0x2">
                <gui_name language="en">ETMTRACEIDR</gui_name>
                <description language="en">CoreSight Trace ID Register</description>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="TraceID">
                    <gui_name language="en">TraceID</gui_name>
                    <description language="en">Before trace is generated, you must program this register with a non-reserved value.
Reserved values are 0x00 and any value in the range 0x70-0x7F. The reset value of this register is 0x00.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_OSLSR" offset="0xf889c304" size="0x4">
                <gui_name language="en">OSLSR</gui_name>
                <description language="en">OS Lock Status Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Shows that OS Locking is not implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ETMPDSR" offset="0xf889c314" size="0x4">
                <gui_name language="en">ETMPDSR</gui_name>
                <description language="en">Device Power-Down Status Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Indicates that the PTM Trace Registers can be accessed.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM0_ITMISCOUT" offset="0xf889cedc" size="0x2">
                <gui_name language="en">ITMISCOUT</gui_name>
                <description language="en">Miscellaneous Outputs Register</description>
                <bitField access="Write Only" high_bit="9" low_bit="8" name="PTMEXTOUT">
                    <gui_name language="en">PTMEXTOUT</gui_name>
                    <description language="en">Drives the PTMEXTOUT[1:0] outputs</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="PTMIDLEACK">
                    <gui_name language="en">PTMIDLEACK</gui_name>
                    <description language="en">Drives the PTMIDLEACK output</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="PTMDBGREQ">
                    <gui_name language="en">PTMDBGREQ</gui_name>
                    <description language="en">Drives the PTMDBGREQ output</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ITMISCIN" offset="0xf889cee0" size="0x2">
                <gui_name language="en">ITMISCIN</gui_name>
                <description language="en">Miscellaneous Inputs Register</description>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="STANDBYWFI">
                    <gui_name language="en">STANDBYWFI</gui_name>
                    <description language="en">Returns the value of the STANDBYWFI input</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="PTMDBGACK">
                    <gui_name language="en">PTMDBGACK</gui_name>
                    <description language="en">Returns the value of the PTMDBGACK input</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="EXTIN">
                    <gui_name language="en">EXTIN</gui_name>
                    <description language="en">Returns the value of the EXTIN[3:0] inputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM0_ITTRIGGER" offset="0xf889cee8" size="0x2">
                <gui_name language="en">ITTRIGGER</gui_name>
                <description language="en">Trigger Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="PTMTRIGGER">
                    <gui_name language="en">PTMTRIGGER</gui_name>
                    <description language="en">Drives the PTMTRIGGER output</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM0_ITATBDATA0" offset="0xf889ceec" size="0x2">
                <gui_name language="en">ITATBDATA0</gui_name>
                <description language="en">ATB Data 0 Register</description>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="ATDATAM31">
                    <gui_name language="en">ATDATAM31</gui_name>
                    <description language="en">Drives the ATDATAM[31] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="ATDATAM23">
                    <gui_name language="en">ATDATAM23</gui_name>
                    <description language="en">Drives the ATDATAM[23] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="ATDATAM15">
                    <gui_name language="en">ATDATAM15</gui_name>
                    <description language="en">Drives the ATDATAM[15] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="ATDATAM7">
                    <gui_name language="en">ATDATAM7</gui_name>
                    <description language="en">Drives the ATDATAM[7] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATDATAM0">
                    <gui_name language="en">ATDATAM0</gui_name>
                    <description language="en">Drives the ATDATAM[0] output</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ITATBCTR2" offset="0xf889cef0" size="0x2">
                <gui_name language="en">ITATBCTR2</gui_name>
                <description language="en">ATB Control 2 Register</description>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AFVALIDM">
                    <gui_name language="en">AFVALIDM</gui_name>
                    <description language="en">Returns the value of the AFVALIDM input</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATREADYM">
                    <gui_name language="en">ATREADYM</gui_name>
                    <description language="en">Returns the value of the ATREADYM input</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM0_ITATBID" offset="0xf889cef4" size="0x2">
                <gui_name language="en">ITATBID</gui_name>
                <description language="en">ATB Identification Register</description>
                <bitField access="Write Only" high_bit="6" low_bit="0" name="ATIDM">
                    <gui_name language="en">ATIDM</gui_name>
                    <description language="en">Drives the ATIDM[6:0] outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM0_ITATBCTR0" offset="0xf889cef8" size="0x2">
                <gui_name language="en">ITATBCTR0</gui_name>
                <description language="en">ATB Control 0 Register</description>
                <bitField access="Write Only" high_bit="9" low_bit="8" name="ATBYTESM">
                    <gui_name language="en">ATBYTESM</gui_name>
                    <description language="en">Drives the ATBYTESM[9:8] outputs</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="AFREADYM">
                    <gui_name language="en">AFREADYM</gui_name>
                    <description language="en">Drives the AFREADYM output</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATVALIDM">
                    <gui_name language="en">ATVALIDM</gui_name>
                    <description language="en">Drives the ATVALIDM output</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_ETMITCTRL" offset="0xf889cf00" size="0x2">
                <gui_name language="en">ETMITCTRL</gui_name>
                <description language="en">Integration Mode Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable Integration Test registers.
Before entering integration mode, the PTM must be powered up and in programming mode.
This means bit 0 of the Main Control Register is set to 0, and bit 10 of the Main Control Register is set 1.
After leaving integration mode, the PTM must be reset before attempting to perform tracing.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_CTSR" offset="0xf889cfa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM0_CTCR" offset="0xf889cfa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM0_LAR" offset="0xf889cfb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), PTM is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
PTM is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_LSR" offset="0xf889cfb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since PTM implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether PTM is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_ASR" offset="0xf889cfb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="6" name="SNI">
                    <gui_name language="en">SNI</gui_name>
                    <description language="en">Secure non-invasive debug
Always 2'b00,.
This functionality is not implemented</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="4" name="SI">
                    <gui_name language="en">SI</gui_name>
                    <description language="en">Secure invasive debug
Always 2'b00.
This functionality is not implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="2" name="NSNI">
                    <gui_name language="en">NSNI</gui_name>
                    <description language="en">Non-secure non-invasive debug
IF NIDEN or DBGEN is 1, this field is 2'b11, indicating the functionality is implemented and enabled.
Otherwise, this field is 2'b10 (implemented but disabled)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="0" name="NSI">
                    <gui_name language="en">NSI</gui_name>
                    <description language="en">Non-secure invasive debug
Always 2'b00.
This functionality is not implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_DEVID" offset="0xf889cfc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Component capability</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_DTIR" offset="0xf889cfcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">A trace source and processor trace</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID4" offset="0xf889cfd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID5" offset="0xf889cfd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID6" offset="0xf889cfd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID7" offset="0xf889cfdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID0" offset="0xf889cfe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID1" offset="0xf889cfe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID2" offset="0xf889cfe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_PERIPHID3" offset="0xf889cfec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_COMPID0" offset="0xf889cff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_COMPID1" offset="0xf889cff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_COMPID2" offset="0xf889cff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM0_COMPID3" offset="0xf889cffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CPU_PTM1" name="DEBUG_CPU_PTM1" offset="0xf889d000">
            <gui_name language="en">debug_cpu_ptm1</gui_name>
            <description language="en">debug_cpu_ptm1</description>
            <register name="DEBUG_CPU_PTM1_ETMCR" offset="0xf889d000" size="0x4">
                <gui_name language="en">ETMCR</gui_name>
                <description language="en">Main Control Register</description>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="ReturnStackEn">
                    <gui_name language="en">ReturnStackEn</gui_name>
                    <description language="en">Return stack enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="TimestampEn">
                    <gui_name language="en">TimestampEn</gui_name>
                    <description language="en">Timestamp enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="ProcSelect">
                    <gui_name language="en">ProcSelect</gui_name>
                    <description language="en">Select for external multiplexor if PTM is shared between multiple processors.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="14" name="ContexIDSize">
                    <gui_name language="en">ContexIDSize</gui_name>
                    <description language="en">Context ID Size</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="CycleAccurate">
                    <gui_name language="en">CycleAccurate</gui_name>
                    <description language="en">Enables cycle counting</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ProgBit">
                    <gui_name language="en">ProgBit</gui_name>
                    <description language="en">This bit must be set to b1 when the PTM is being programmed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="DebugReqCtrl">
                    <gui_name language="en">DebugReqCtrl</gui_name>
                    <description language="en">Debug Request Control
When set to b1 and the trigger event occurs, the PTMDBGRQ output is asserted until PTMDBGACK is observed. This enables a debugger to force the processor into Debug state.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="BranchOutput">
                    <gui_name language="en">BranchOutput</gui_name>
                    <description language="en">When this bit is set to b1, addresses are output for all executed branches, both direct and indirect.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PowerDown">
                    <gui_name language="en">PowerDown</gui_name>
                    <description language="en">This bit enables external control of the PTM. This bit must be cleared by the trace software tools at the beginning of a debug session.
When this bit is set to b0, both the PTM and the trace interface in the processor are enabled.
To avoid corruption of trace data, this bit must not be set before the Programming Status bit in the PTM Status Register has been read as 1.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ETMCCR" offset="0xf889d004" size="0x4">
                <gui_name language="en">ETMCCR</gui_name>
                <description language="en">Configuration Code Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="IDRegPresent">
                    <gui_name language="en">IDRegPresent</gui_name>
                    <description language="en">Indicates that the ID Register is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="SoftwareAccess">
                    <gui_name language="en">SoftwareAccess</gui_name>
                    <description language="en">Indicates that software access is supported.</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="26" name="TraceSSB">
                    <gui_name language="en">TraceSSB</gui_name>
                    <description language="en">Indicates that the trace start/stop block is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="24" name="NumCntxtIDComp">
                    <gui_name language="en">NumCntxtIDComp</gui_name>
                    <description language="en">Specifies the number of Context ID comparators, one.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="FIFOFULLLogic">
                    <gui_name language="en">FIFOFULLLogic</gui_name>
                    <description language="en">Indicates that it is not possible to stall the processor to prevent FIFO overflow.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="20" name="NumExtOut">
                    <gui_name language="en">NumExtOut</gui_name>
                    <description language="en">Specifies the number of external outputs, two.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="17" name="NumExtIn">
                    <gui_name language="en">NumExtIn</gui_name>
                    <description language="en">Specifies the number of external inputs, four.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="Sequencer">
                    <gui_name language="en">Sequencer</gui_name>
                    <description language="en">Indicates that the sequencer is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="13" name="NumCounters">
                    <gui_name language="en">NumCounters</gui_name>
                    <description language="en">Specifies the number of counters, two.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="NumAddrComp">
                    <gui_name language="en">NumAddrComp</gui_name>
                    <description language="en">Specifies the number of address comparator pairs, four.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMTRIGGER" offset="0xf889d008" size="0x4">
                <gui_name language="en">ETMTRIGGER</gui_name>
                <description language="en">Trigger Event Register</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TrigEvent">
                    <gui_name language="en">TrigEvent</gui_name>
                    <description language="en">Trigger event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSR" offset="0xf889d010" size="0x2">
                <gui_name language="en">ETMSR</gui_name>
                <description language="en">Status Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="TrigFlag">
                    <gui_name language="en">TrigFlag</gui_name>
                    <description language="en">Trigger bit. Set when the trigger occurs and prevents the trigger from being output until the PTM is next programmed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="TSSRStat">
                    <gui_name language="en">TSSRStat</gui_name>
                    <description language="en">Holds the current status of the trace start/stop resource. If set to 1, indicates that a trace start address has been matched, without a corresponding trace stop address match.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="ProgBit">
                    <gui_name language="en">ProgBit</gui_name>
                    <description language="en">Effective state of the Programming bit. You must wait for this bit to go to b1 before starting to program the PTM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Overflow">
                    <gui_name language="en">Overflow</gui_name>
                    <description language="en">If set to 1, there is an overflow that has not yet been traced.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ETMSCR" offset="0xf889d014" size="0x2">
                <gui_name language="en">ETMSCR</gui_name>
                <description language="en">System Configuration Register</description>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="NumProcs">
                    <gui_name language="en">NumProcs</gui_name>
                    <description language="en">Number of supported processors minus 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="FIFOFULL">
                    <gui_name language="en">FIFOFULL</gui_name>
                    <description language="en">FIFOFULL not supported</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMTSSCR" offset="0xf889d018" size="0x4">
                <gui_name language="en">ETMTSSCR</gui_name>
                <description language="en">TraceEnable Start/Stop Control Register</description>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="StopAddrSel">
                    <gui_name language="en">StopAddrSel</gui_name>
                    <description language="en">When a bit is set to 1, it selects a single address comparator (8-1) as a stop address for the TraceEnable
Start/Stop block. For example, if you set bit [16] to 1 it selects single address comparator 1 as a stop address.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="StartAddrSel">
                    <gui_name language="en">StartAddrSel</gui_name>
                    <description language="en">When a bit is set to 1, it selects a single address comparator (8-1) as a start address for the TraceEnable
Start/Stop block. For example, if you set bit [0] to 1 it selects single address comparator 1 as a start address.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMTECR1" offset="0xf889d024" size="0x4">
                <gui_name language="en">ETMTECR1</gui_name>
                <description language="en">TraceEnable Control Register 1</description>
                <bitField access="Read Write" enumerationId="ETMTECR1_TraceSSEn_ENUM" high_bit="25" low_bit="25" name="TraceSSEn">
                    <gui_name language="en">TraceSSEn</gui_name>
                    <description language="en">Trace start/stop control enable. The possible values of this bit are:
0 Tracing is unaffected by the trace start/stop logic.
1 Tracing is controlled by the trace on and off addresses configured for the trace start/stop logic.
The trace start/stop resource is not affected by the value of this bit.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMTECR1_ExcIncFlag_ENUM" high_bit="24" low_bit="24" name="ExcIncFlag">
                    <gui_name language="en">ExcIncFlag</gui_name>
                    <description language="en">Exclude/include flag. The possible values of this bit are:
0 Include. The specified address range comparators indicate the regions where tracing can occur.
No tracing occurs outside this region.
1 Exclude. The specified address range comparators indicate regions to be excluded from the
trace. When outside an exclude region, tracing can occur.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="AddrCompSel">
                    <gui_name language="en">AddrCompSel</gui_name>
                    <description language="en">When a bit is set to 1, it selects an address range comparator, 4-1, for include/exclude control. For example, bit [0] set to 1 selects address range comparator 1.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR1" offset="0xf889d040" size="0x4">
                <gui_name language="en">ETMACVR1</gui_name>
                <description language="en">Address Comparator Value Register 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR2" offset="0xf889d044" size="0x4">
                <gui_name language="en">ETMACVR2</gui_name>
                <description language="en">Address Comparator Value Register 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR3" offset="0xf889d048" size="0x4">
                <gui_name language="en">ETMACVR3</gui_name>
                <description language="en">Address Comparator Value Register 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR4" offset="0xf889d04c" size="0x4">
                <gui_name language="en">ETMACVR4</gui_name>
                <description language="en">Address Comparator Value Register 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR5" offset="0xf889d050" size="0x4">
                <gui_name language="en">ETMACVR5</gui_name>
                <description language="en">Address Comparator Value Register 5</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR6" offset="0xf889d054" size="0x4">
                <gui_name language="en">ETMACVR6</gui_name>
                <description language="en">Address Comparator Value Register 6</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR7" offset="0xf889d058" size="0x4">
                <gui_name language="en">ETMACVR7</gui_name>
                <description language="en">Address Comparator Value Register 7</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACVR8" offset="0xf889d05c" size="0x4">
                <gui_name language="en">ETMACVR8</gui_name>
                <description language="en">Address Comparator Value Register 8</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Address">
                    <gui_name language="en">Address</gui_name>
                    <description language="en">Address for comparison</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR1" offset="0xf889d080" size="0x2">
                <gui_name language="en">ETMACTR1</gui_name>
                <description language="en">Address Comparator Access Type Register 1</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR2" offset="0xf889d084" size="0x2">
                <gui_name language="en">ETMACTR2</gui_name>
                <description language="en">Address Comparator Access Type Register 2</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR3" offset="0xf889d088" size="0x2">
                <gui_name language="en">ETMACTR3</gui_name>
                <description language="en">Address Comparator Access Type Register 3</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR4" offset="0xf889d08c" size="0x2">
                <gui_name language="en">ETMACTR4</gui_name>
                <description language="en">Address Comparator Access Type Register 4</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR5" offset="0xf889d090" size="0x2">
                <gui_name language="en">ETMACTR5</gui_name>
                <description language="en">Address Comparator Access Type Register 5</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR6" offset="0xf889d094" size="0x2">
                <gui_name language="en">ETMACTR6</gui_name>
                <description language="en">Address Comparator Access Type Register 6</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR7" offset="0xf889d098" size="0x2">
                <gui_name language="en">ETMACTR7</gui_name>
                <description language="en">Address Comparator Access Type Register 7</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMACTR8" offset="0xf889d09c" size="0x2">
                <gui_name language="en">ETMACTR8</gui_name>
                <description language="en">Address Comparator Access Type Register 8</description>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="SecLevelCtrl">
                    <gui_name language="en">SecLevelCtrl</gui_name>
                    <description language="en">Security level control</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ContextIDCompCtrl">
                    <gui_name language="en">ContextIDCompCtrl</gui_name>
                    <description language="en">Context ID comparator control.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="AccessType">
                    <gui_name language="en">AccessType</gui_name>
                    <description language="en">Access type. Returns the value: Instruction execute.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTRLDVR1" offset="0xf889d140" size="0x2">
                <gui_name language="en">ETMCNTRLDVR1</gui_name>
                <description language="en">Counter Reload Value Register 1</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="InitValue">
                    <gui_name language="en">InitValue</gui_name>
                    <description language="en">Counter initial value</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTRLDVR2" offset="0xf889d144" size="0x2">
                <gui_name language="en">ETMCNTRLDVR2</gui_name>
                <description language="en">Counter Reload Value Register 2</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="InitValue">
                    <gui_name language="en">InitValue</gui_name>
                    <description language="en">Counter initial value</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTENR1" offset="0xf889d150" size="0x4">
                <gui_name language="en">ETMCNTENR1</gui_name>
                <description language="en">Counter Enable Event Register 1</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutEvent">
                    <gui_name language="en">ExtOutEvent</gui_name>
                    <description language="en">Count enable event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTENR2" offset="0xf889d154" size="0x4">
                <gui_name language="en">ETMCNTENR2</gui_name>
                <description language="en">Counter Enable Event Register 2</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutEvent">
                    <gui_name language="en">ExtOutEvent</gui_name>
                    <description language="en">Count enable event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTRLDEVR1" offset="0xf889d160" size="0x4">
                <gui_name language="en">ETMCNTRLDEVR1</gui_name>
                <description language="en">Counter Reload Event Register 1</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="CntReloadEvent">
                    <gui_name language="en">CntReloadEvent</gui_name>
                    <description language="en">Count reload event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTRLDEVR2" offset="0xf889d164" size="0x4">
                <gui_name language="en">ETMCNTRLDEVR2</gui_name>
                <description language="en">Counter Reload Event Register 2</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="CntReloadEvent">
                    <gui_name language="en">CntReloadEvent</gui_name>
                    <description language="en">Count reload event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTVR1" offset="0xf889d170" size="0x2">
                <gui_name language="en">ETMCNTVR1</gui_name>
                <description language="en">Counter Value Register 1</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CurrCount">
                    <gui_name language="en">CurrCount</gui_name>
                    <description language="en">Current counter value.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCNTVR2" offset="0xf889d174" size="0x2">
                <gui_name language="en">ETMCNTVR2</gui_name>
                <description language="en">Counter Value Register 2</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CurrCount">
                    <gui_name language="en">CurrCount</gui_name>
                    <description language="en">Current counter value.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQ12EVR" offset="0xf889d180" size="0x4">
                <gui_name language="en">ETMSQ12EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 12</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQ21EVR" offset="0xf889d184" size="0x4">
                <gui_name language="en">ETMSQ21EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 21</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQ23EVR" offset="0xf889d188" size="0x4">
                <gui_name language="en">ETMSQ23EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 23</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQ31EVR" offset="0xf889d18c" size="0x4">
                <gui_name language="en">ETMSQ31EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 31</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQ32EVR" offset="0xf889d190" size="0x4">
                <gui_name language="en">ETMSQ32EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 32</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQ13EVR" offset="0xf889d194" size="0x4">
                <gui_name language="en">ETMSQ13EVR</gui_name>
                <description language="en">Sequencer State Transition Event Register 13</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="TransEvent">
                    <gui_name language="en">TransEvent</gui_name>
                    <description language="en">A Sequencer State Transition Event Register, ETMSQmnEVR, defines the event that causes the sequencer state transition from state m to state n.
The format is subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSQR" offset="0xf889d19c" size="0x2">
                <gui_name language="en">ETMSQR</gui_name>
                <description language="en">Current Sequencer State Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="CurrentSeqState">
                    <gui_name language="en">CurrentSeqState</gui_name>
                    <description language="en">Indicates the current sequencer state</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMEXTOUTEVR1" offset="0xf889d1a0" size="0x4">
                <gui_name language="en">ETMEXTOUTEVR1</gui_name>
                <description language="en">External Output Event Register 1</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutputEvent">
                    <gui_name language="en">ExtOutputEvent</gui_name>
                    <description language="en">External output event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMEXTOUTEVR2" offset="0xf889d1a4" size="0x4">
                <gui_name language="en">ETMEXTOUTEVR2</gui_name>
                <description language="en">External Output Event Register 2</description>
                <bitField access="Read Write" high_bit="16" low_bit="0" name="ExtOutputEvent">
                    <gui_name language="en">ExtOutputEvent</gui_name>
                    <description language="en">External output event. Subdivided as:
Function, bits [16:14]
Specifies the function that combines the two resources that define the event.
Resource B, bits [13:7] and Resource A, bits [6:0]
Specify the two resources that are combined by the logical operation specified by the Function field.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCIDCVR1" offset="0xf889d1b0" size="0x4">
                <gui_name language="en">ETMCIDCVR1</gui_name>
                <description language="en">Context ID Comparator Value Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ContextID">
                    <gui_name language="en">ContextID</gui_name>
                    <description language="en">Holds a 32-bit Context ID value</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMCIDCMR" offset="0xf889d1bc" size="0x4">
                <gui_name language="en">ETMCIDCMR</gui_name>
                <description language="en">Context ID Comparator Mask Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ContextMask">
                    <gui_name language="en">ContextMask</gui_name>
                    <description language="en">Holds a 32-bit Context ID mask</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMSYNCFR" offset="0xf889d1e0" size="0x2">
                <gui_name language="en">ETMSYNCFR</gui_name>
                <description language="en">Synchronization Frequency Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="2" name="SyncFreq">
                    <gui_name language="en">SyncFreq</gui_name>
                    <description language="en">Synchronization frequency</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ETMIDR" offset="0xf889d1e4" size="0x4">
                <gui_name language="en">ETMIDR</gui_name>
                <description language="en">ID Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="ImplCode">
                    <gui_name language="en">ImplCode</gui_name>
                    <description language="en">Implementor code. The field reads 0x41, ASCII code for A, indicating ARM Limited.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="SecExtSupp">
                    <gui_name language="en">SecExtSupp</gui_name>
                    <description language="en">Support for security extensions.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="Thumb32Supp">
                    <gui_name language="en">Thumb32Supp</gui_name>
                    <description language="en">Support for 32-bit Thumb instructions.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="MajorVer">
                    <gui_name language="en">MajorVer</gui_name>
                    <description language="en">Major architecture version number, 0b0011</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="MinorVer">
                    <gui_name language="en">MinorVer</gui_name>
                    <description language="en">Minor architecture version number, 0b0000</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="ImplRev">
                    <gui_name language="en">ImplRev</gui_name>
                    <description language="en">Implementation revision.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ETMCCER" offset="0xf889d1e8" size="0x4">
                <gui_name language="en">ETMCCER</gui_name>
                <description language="en">Configuration Code Extension Register</description>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="BarrTS">
                    <gui_name language="en">BarrTS</gui_name>
                    <description language="en">Timestamps are not generated for DMB/DSB</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="BarrWP">
                    <gui_name language="en">BarrWP</gui_name>
                    <description language="en">DMB/DSB instructions are not treated as waypoints.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="RetStack">
                    <gui_name language="en">RetStack</gui_name>
                    <description language="en">Return stack implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="Timestamp">
                    <gui_name language="en">Timestamp</gui_name>
                    <description language="en">Timestamping implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="13" name="InstrumRes">
                    <gui_name language="en">InstrumRes</gui_name>
                    <description language="en">Specifies the number of instrumentation resources.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="RegReads">
                    <gui_name language="en">RegReads</gui_name>
                    <description language="en">Indicates that all registers, except some Integration Test Registers, are readable.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="3" name="ExtInSize">
                    <gui_name language="en">ExtInSize</gui_name>
                    <description language="en">Specifies the size of the extended external input bus, 52.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="ExtInSel">
                    <gui_name language="en">ExtInSel</gui_name>
                    <description language="en">Specifies the number of extended external input selectors, 2.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMEXTINSELR" offset="0xf889d1ec" size="0x2">
                <gui_name language="en">ETMEXTINSELR</gui_name>
                <description language="en">Extended External Input Selection Register</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="ExtInSel2">
                    <gui_name language="en">ExtInSel2</gui_name>
                    <description language="en">Second extended external input selector</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="ExtInSel1">
                    <gui_name language="en">ExtInSel1</gui_name>
                    <description language="en">First extended external input selector</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMAUXCR" offset="0xf889d1fc" size="0x2">
                <gui_name language="en">ETMAUXCR</gui_name>
                <description language="en">Auxiliary Control Register</description>
                <bitField access="Read Write" enumerationId="ETMAUXCR_ForceSyncInsert_ENUM" high_bit="3" low_bit="3" name="ForceSyncInsert">
                    <gui_name language="en">ForceSyncInsert</gui_name>
                    <description language="en">Force insertion of synchronization packets, regardless of current trace activity.
Possible values for this bit are:
b0 = Synchronization packets delayed when trace activity is high. This is the reset value.
b1 = Synchronization packets inserted regardless of trace activity.
This bit might be set if synchronization packets occur too far apart. Setting this bit might cause the trace FIFO to overflow more frequently when trace activity is high.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMAUXCR_DisableWPUpdate_ENUM" high_bit="2" low_bit="2" name="DisableWPUpdate">
                    <gui_name language="en">DisableWPUpdate</gui_name>
                    <description language="en">Specifies whether the PTM issues waypoint update packets if there are more than 4096 bytes between waypoints. Possible values for this bit are:
b0 = PTM always issues update packets if there are more than 4096 bytes between waypoints. This is the reset value.
b1 = PTM does not issue waypoint update packets unless required to do so as the result of an exception or debug entry.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMAUXCR_DisableTSOnBarr_ENUM" high_bit="1" low_bit="1" name="DisableTSOnBarr">
                    <gui_name language="en">DisableTSOnBarr</gui_name>
                    <description language="en">Specifies whether the PTM issues a timestamp on a barrier instruction. Possible values for this bit are:
b0 = PTM issues timestamps on barrier instructions. This is the reset value.
b1 = PTM does not issue timestamps on barriers</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ETMAUXCR_DisableForcedOF_ENUM" high_bit="0" low_bit="0" name="DisableForcedOF">
                    <gui_name language="en">DisableForcedOF</gui_name>
                    <description language="en">Specifies whether the PTM enters overflow state when synchronization is requested,
and the previous synchronization sequence has not yet completed. This does not affect entry to overflow state when the FIFO becomes full. Possible values for this bit are:
b0 = Forced overflow enabled. This is the reset value.
b1 = Forced overflow disabled.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMTRACEIDR" offset="0xf889d200" size="0x2">
                <gui_name language="en">ETMTRACEIDR</gui_name>
                <description language="en">CoreSight Trace ID Register</description>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="TraceID">
                    <gui_name language="en">TraceID</gui_name>
                    <description language="en">Before trace is generated, you must program this register with a non-reserved value.
Reserved values are 0x00 and any value in the range 0x70-0x7F. The reset value of this register is 0x00.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_OSLSR" offset="0xf889d304" size="0x4">
                <gui_name language="en">OSLSR</gui_name>
                <description language="en">OS Lock Status Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Shows that OS Locking is not implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ETMPDSR" offset="0xf889d314" size="0x4">
                <gui_name language="en">ETMPDSR</gui_name>
                <description language="en">Device Power-Down Status Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Indicates that the PTM Trace Registers can be accessed.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM1_ITMISCOUT" offset="0xf889dedc" size="0x2">
                <gui_name language="en">ITMISCOUT</gui_name>
                <description language="en">Miscellaneous Outputs Register</description>
                <bitField access="Write Only" high_bit="9" low_bit="8" name="PTMEXTOUT">
                    <gui_name language="en">PTMEXTOUT</gui_name>
                    <description language="en">Drives the PTMEXTOUT[1:0] outputs</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="PTMIDLEACK">
                    <gui_name language="en">PTMIDLEACK</gui_name>
                    <description language="en">Drives the PTMIDLEACK output</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="PTMDBGREQ">
                    <gui_name language="en">PTMDBGREQ</gui_name>
                    <description language="en">Drives the PTMDBGREQ output</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ITMISCIN" offset="0xf889dee0" size="0x2">
                <gui_name language="en">ITMISCIN</gui_name>
                <description language="en">Miscellaneous Inputs Register</description>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="STANDBYWFI">
                    <gui_name language="en">STANDBYWFI</gui_name>
                    <description language="en">Returns the value of the STANDBYWFI input</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="PTMDBGACK">
                    <gui_name language="en">PTMDBGACK</gui_name>
                    <description language="en">Returns the value of the PTMDBGACK input</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="EXTIN">
                    <gui_name language="en">EXTIN</gui_name>
                    <description language="en">Returns the value of the EXTIN[3:0] inputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM1_ITTRIGGER" offset="0xf889dee8" size="0x2">
                <gui_name language="en">ITTRIGGER</gui_name>
                <description language="en">Trigger Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="PTMTRIGGER">
                    <gui_name language="en">PTMTRIGGER</gui_name>
                    <description language="en">Drives the PTMTRIGGER output</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM1_ITATBDATA0" offset="0xf889deec" size="0x2">
                <gui_name language="en">ITATBDATA0</gui_name>
                <description language="en">ATB Data 0 Register</description>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="ATDATAM31">
                    <gui_name language="en">ATDATAM31</gui_name>
                    <description language="en">Drives the ATDATAM[31] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="ATDATAM23">
                    <gui_name language="en">ATDATAM23</gui_name>
                    <description language="en">Drives the ATDATAM[23] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="ATDATAM15">
                    <gui_name language="en">ATDATAM15</gui_name>
                    <description language="en">Drives the ATDATAM[15] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="ATDATAM7">
                    <gui_name language="en">ATDATAM7</gui_name>
                    <description language="en">Drives the ATDATAM[7] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATDATAM0">
                    <gui_name language="en">ATDATAM0</gui_name>
                    <description language="en">Drives the ATDATAM[0] output</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ITATBCTR2" offset="0xf889def0" size="0x2">
                <gui_name language="en">ITATBCTR2</gui_name>
                <description language="en">ATB Control 2 Register</description>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AFVALIDM">
                    <gui_name language="en">AFVALIDM</gui_name>
                    <description language="en">Returns the value of the AFVALIDM input</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATREADYM">
                    <gui_name language="en">ATREADYM</gui_name>
                    <description language="en">Returns the value of the ATREADYM input</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM1_ITATBID" offset="0xf889def4" size="0x2">
                <gui_name language="en">ITATBID</gui_name>
                <description language="en">ATB Identification Register</description>
                <bitField access="Write Only" high_bit="6" low_bit="0" name="ATIDM">
                    <gui_name language="en">ATIDM</gui_name>
                    <description language="en">Drives the ATIDM[6:0] outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM1_ITATBCTR0" offset="0xf889def8" size="0x2">
                <gui_name language="en">ITATBCTR0</gui_name>
                <description language="en">ATB Control 0 Register</description>
                <bitField access="Write Only" high_bit="9" low_bit="8" name="ATBYTESM">
                    <gui_name language="en">ATBYTESM</gui_name>
                    <description language="en">Drives the ATBYTESM[9:8] outputs</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="AFREADYM">
                    <gui_name language="en">AFREADYM</gui_name>
                    <description language="en">Drives the AFREADYM output</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATVALIDM">
                    <gui_name language="en">ATVALIDM</gui_name>
                    <description language="en">Drives the ATVALIDM output</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_ETMITCTRL" offset="0xf889df00" size="0x2">
                <gui_name language="en">ETMITCTRL</gui_name>
                <description language="en">Integration Mode Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable Integration Test registers.
Before entering integration mode, the PTM must be powered up and in programming mode.
This means bit 0 of the Main Control Register is set to 0, and bit 10 of the Main Control Register is set 1.
After leaving integration mode, the PTM must be reset before attempting to perform tracing.</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_CTSR" offset="0xf889dfa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CPU_PTM1_CTCR" offset="0xf889dfa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CPU_PTM1_LAR" offset="0xf889dfb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), PTM is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
PTM is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_LSR" offset="0xf889dfb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since PTM implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether PTM is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_ASR" offset="0xf889dfb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="6" name="SNI">
                    <gui_name language="en">SNI</gui_name>
                    <description language="en">Secure non-invasive debug
Always 2'b00,.
This functionality is not implemented</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="4" name="SI">
                    <gui_name language="en">SI</gui_name>
                    <description language="en">Secure invasive debug
Always 2'b00.
This functionality is not implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="2" name="NSNI">
                    <gui_name language="en">NSNI</gui_name>
                    <description language="en">Non-secure non-invasive debug
IF NIDEN or DBGEN is 1, this field is 2'b11, indicating the functionality is implemented and enabled.
Otherwise, this field is 2'b10 (implemented but disabled)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="0" name="NSI">
                    <gui_name language="en">NSI</gui_name>
                    <description language="en">Non-secure invasive debug
Always 2'b00.
This functionality is not implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_DEVID" offset="0xf889dfc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Component capability</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_DTIR" offset="0xf889dfcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">A trace source and processor trace</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID4" offset="0xf889dfd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID5" offset="0xf889dfd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID6" offset="0xf889dfd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID7" offset="0xf889dfdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID0" offset="0xf889dfe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID1" offset="0xf889dfe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID2" offset="0xf889dfe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_PERIPHID3" offset="0xf889dfec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_COMPID0" offset="0xf889dff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_COMPID1" offset="0xf889dff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_COMPID2" offset="0xf889dff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CPU_PTM1_COMPID3" offset="0xf889dffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CTI_AXIM" name="DEBUG_CTI_AXIM" offset="0xf880a000">
            <gui_name language="en">debug_cti_axim</gui_name>
            <description language="en">debug_cti_axim</description>
            <register name="DEBUG_CTI_AXIM_CTICONTROL" offset="0xf880a000" size="0x2">
                <gui_name language="en">CTICONTROL</gui_name>
                <description language="en">CTI Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GLBEN">
                    <gui_name language="en">GLBEN</gui_name>
                    <description language="en">Enables or disables the ECT. When disabled, all cross triggering mapping logic functionality is disabled for this processor.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_CTIINTACK" offset="0xf880a010" size="0x2">
                <gui_name language="en">CTIINTACK</gui_name>
                <description language="en">CTI Interrupt Acknowledge Register</description>
                <bitField access="Write Only" enumerationId="CTIINTACK_INTACK_ENUM" high_bit="7" low_bit="0" name="INTACK">
                    <gui_name language="en">INTACK</gui_name>
                    <description language="en">Acknowledges the corresponding CTITRIGOUT output:
1 = CTITRIGOUT is acknowledged and is cleared when MAPTRIGOUT is LOW.
0 = no effect
There is one bit of the register for each CTITRIGOUT output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIAPPSET" offset="0xf880a014" size="0x2">
                <gui_name language="en">CTIAPPSET</gui_name>
                <description language="en">CTI Application Trigger Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="APPSET">
                    <gui_name language="en">APPSET</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event for the selected channel.
Read:
0 = application trigger inactive (reset)
1 = application trigger active.
Write:
0 = no effect
1 = generate channel event.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_CTIAPPCLEAR" offset="0xf880a018" size="0x2">
                <gui_name language="en">CTIAPPCLEAR</gui_name>
                <description language="en">CTI Application Trigger Clear Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPCLEAR_APPCLEAR_ENUM" high_bit="3" low_bit="0" name="APPCLEAR">
                    <gui_name language="en">APPCLEAR</gui_name>
                    <description language="en">Clears corresponding bits in the CTIAPPSET register.
1 = application trigger disabled in the CTIAPPSET register
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_CTIAPPPULSE" offset="0xf880a01c" size="0x2">
                <gui_name language="en">CTIAPPPULSE</gui_name>
                <description language="en">CTI Application Pulse Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPPULSE_APPULSE_ENUM" high_bit="3" low_bit="0" name="APPULSE">
                    <gui_name language="en">APPULSE</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event pulse for the selected channel.
Write:
1 = channel event pulse generated for one CTICLK period
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN0" offset="0xf880a020" size="0x2">
                <gui_name language="en">CTIINEN0</gui_name>
                <description language="en">CTI Trigger to Channel Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN0_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN1" offset="0xf880a024" size="0x2">
                <gui_name language="en">CTIINEN1</gui_name>
                <description language="en">CTI Trigger to Channel Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN1_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN2" offset="0xf880a028" size="0x2">
                <gui_name language="en">CTIINEN2</gui_name>
                <description language="en">CTI Trigger to Channel Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN2_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN3" offset="0xf880a02c" size="0x2">
                <gui_name language="en">CTIINEN3</gui_name>
                <description language="en">CTI Trigger to Channel Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN3_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN4" offset="0xf880a030" size="0x2">
                <gui_name language="en">CTIINEN4</gui_name>
                <description language="en">CTI Trigger to Channel Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN4_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN5" offset="0xf880a034" size="0x2">
                <gui_name language="en">CTIINEN5</gui_name>
                <description language="en">CTI Trigger to Channel Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN5_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN6" offset="0xf880a038" size="0x2">
                <gui_name language="en">CTIINEN6</gui_name>
                <description language="en">CTI Trigger to Channel Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN6_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIINEN7" offset="0xf880a03c" size="0x2">
                <gui_name language="en">CTIINEN7</gui_name>
                <description language="en">CTI Trigger to Channel Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN7_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN0" offset="0xf880a0a0" size="0x2">
                <gui_name language="en">CTIOUTEN0</gui_name>
                <description language="en">CTI Channel to Trigger Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN0_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN1" offset="0xf880a0a4" size="0x2">
                <gui_name language="en">CTIOUTEN1</gui_name>
                <description language="en">CTI Channel to Trigger Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN1_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN2" offset="0xf880a0a8" size="0x2">
                <gui_name language="en">CTIOUTEN2</gui_name>
                <description language="en">CTI Channel to Trigger Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN2_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN3" offset="0xf880a0ac" size="0x2">
                <gui_name language="en">CTIOUTEN3</gui_name>
                <description language="en">CTI Channel to Trigger Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN3_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN4" offset="0xf880a0b0" size="0x2">
                <gui_name language="en">CTIOUTEN4</gui_name>
                <description language="en">CTI Channel to Trigger Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN4_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN5" offset="0xf880a0b4" size="0x2">
                <gui_name language="en">CTIOUTEN5</gui_name>
                <description language="en">CTI Channel to Trigger Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN5_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN6" offset="0xf880a0b8" size="0x2">
                <gui_name language="en">CTIOUTEN6</gui_name>
                <description language="en">CTI Channel to Trigger Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN6_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIOUTEN7" offset="0xf880a0bc" size="0x2">
                <gui_name language="en">CTIOUTEN7</gui_name>
                <description language="en">CTI Channel to Trigger Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN7_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_CTITRIGINSTATUS" offset="0xf880a130" size="0x2">
                <gui_name language="en">CTITRIGINSTATUS</gui_name>
                <description language="en">CTI Trigger In Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGINSTATUS_TRIGINSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGINSTATUS">
                    <gui_name language="en">TRIGINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGIN inputs:
1 = CTITRIGIN is active
0 = CTITRIGIN is inactive.
Because the register provides a view of the raw CTITRIGIN inputs, the reset value is
unknown. There is one bit of the register for each trigger input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_CTITRIGOUTSTATUS" offset="0xf880a134" size="0x2">
                <gui_name language="en">CTITRIGOUTSTATUS</gui_name>
                <description language="en">CTI Trigger Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGOUTSTATUS_TRIGOUTSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGOUTSTATUS">
                    <gui_name language="en">TRIGOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGOUT outputs.
1 = CTITRIGOUT is active
0 = CTITRIGOUT is inactive (reset).
There is one bit of the register for each trigger output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_CTICHINSTATUS" offset="0xf880a138" size="0x2">
                <gui_name language="en">CTICHINSTATUS</gui_name>
                <description language="en">CTI Channel In Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHINSTATUS_CTCHINSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHINSTATUS">
                    <gui_name language="en">CTCHINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHIN inputs:
1 = CTICHIN is active
0 = CTICHIN is inactive.
Because the register provides a view of the raw CTICHIN inputs from the CTM, the reset
value is unknown. There is one bit of the register for each channel input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_CTICHOUTSTATUS" offset="0xf880a13c" size="0x2">
                <gui_name language="en">CTICHOUTSTATUS</gui_name>
                <description language="en">CTI Channel Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHOUTSTATUS_CTCHOUTSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHOUTSTATUS">
                    <gui_name language="en">CTCHOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHOUT outputs.
1 = CTICHOUT is active
0 = CTICHOUT is inactive (reset).
There is one bit of the register for each channel output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTIGATE" offset="0xf880a140" size="0x2">
                <gui_name language="en">CTIGATE</gui_name>
                <description language="en">Enable CTI Channel Gate Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CTIGATEEN3">
                    <gui_name language="en">CTIGATEEN3</gui_name>
                    <description language="en">Enable CTICHOUT3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CTIGATEEN2">
                    <gui_name language="en">CTIGATEEN2</gui_name>
                    <description language="en">Enable CTICHOUT2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CTIGATEEN1">
                    <gui_name language="en">CTIGATEEN1</gui_name>
                    <description language="en">Enable CTICHOUT1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CTIGATEEN0">
                    <gui_name language="en">CTIGATEEN0</gui_name>
                    <description language="en">Enable CTICHOUT0.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_ASICCTL" offset="0xf880a144" size="0x2">
                <gui_name language="en">ASICCTL</gui_name>
                <description language="en">External Multiplexor Control Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ASICCTL">
                    <gui_name language="en">ASICCTL</gui_name>
                    <description language="en">Implementation defined ASIC control, value written to the register is output on ASICCTL[7:0].</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_ITCHINACK" offset="0xf880aedc" size="0x2">
                <gui_name language="en">ITCHINACK</gui_name>
                <description language="en">ITCHINACK Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHINACK">
                    <gui_name language="en">CTCHINACK</gui_name>
                    <description language="en">Set the value of the CTCHINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_ITTRIGINACK" offset="0xf880aee0" size="0x2">
                <gui_name language="en">ITTRIGINACK</gui_name>
                <description language="en">ITTRIGINACK Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGINACK">
                    <gui_name language="en">CTTRIGINACK</gui_name>
                    <description language="en">Set the value of the CTTRIGINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_ITCHOUT" offset="0xf880aee4" size="0x2">
                <gui_name language="en">ITCHOUT</gui_name>
                <description language="en">ITCHOUT Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHOUT">
                    <gui_name language="en">CTCHOUT</gui_name>
                    <description language="en">Set the value of the CTCHOUT outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_ITTRIGOUT" offset="0xf880aee8" size="0x2">
                <gui_name language="en">ITTRIGOUT</gui_name>
                <description language="en">ITTRIGOUT Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGOUT">
                    <gui_name language="en">CTTRIGOUT</gui_name>
                    <description language="en">Set the value of the CTTRIGOUT outputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_ITCHOUTACK" offset="0xf880aeec" size="0x2">
                <gui_name language="en">ITCHOUTACK</gui_name>
                <description language="en">ITCHOUTACK Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHOUTACK">
                    <gui_name language="en">CTCHOUTACK</gui_name>
                    <description language="en">Read the values of the CTCHOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_ITTRIGOUTACK" offset="0xf880aef0" size="0x2">
                <gui_name language="en">ITTRIGOUTACK</gui_name>
                <description language="en">ITTRIGOUTACK Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGOUTACK">
                    <gui_name language="en">CTTRIGOUTACK</gui_name>
                    <description language="en">Read the values of the CTTRIGOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_ITCHIN" offset="0xf880aef4" size="0x2">
                <gui_name language="en">ITCHIN</gui_name>
                <description language="en">ITCHIN Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHIN">
                    <gui_name language="en">CTCHIN</gui_name>
                    <description language="en">Read the values of the CTCHIN inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_ITTRIGIN" offset="0xf880aef8" size="0x2">
                <gui_name language="en">ITTRIGIN</gui_name>
                <description language="en">ITTRIGIN Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGIN">
                    <gui_name language="en">CTTRIGIN</gui_name>
                    <description language="en">Read the values of the CTTRIGIN inputs</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_ITCTRL" offset="0xf880af00" size="0x2">
                <gui_name language="en">ITCTRL</gui_name>
                <description language="en">IT Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable IT Registers</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTSR" offset="0xf880afa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="SET">
                    <gui_name language="en">SET</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_AXIM_CTCR" offset="0xf880afa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_AXIM_LAR" offset="0xf880afb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="KEY">
                    <gui_name language="en">KEY</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), CTI is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
CTI is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_LSR" offset="0xf880afb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since CTI implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether CTI is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_ASR" offset="0xf880afb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">Current value of noninvasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="NIDEN_CTL">
                    <gui_name language="en">NIDEN_CTL</gui_name>
                    <description language="en">Non-invasive debug controlled</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="IDEN">
                    <gui_name language="en">IDEN</gui_name>
                    <description language="en">Current value of invasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IDEN_CTL">
                    <gui_name language="en">IDEN_CTL</gui_name>
                    <description language="en">Invasive debug controlled</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_DEVID" offset="0xf880afc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="NumChan">
                    <gui_name language="en">NumChan</gui_name>
                    <description language="en">Number of channels available</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="NumTrig">
                    <gui_name language="en">NumTrig</gui_name>
                    <description language="en">Number of triggers available</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="5" name="res">
                    <gui_name language="en">res</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="ExtMux">
                    <gui_name language="en">ExtMux</gui_name>
                    <description language="en">no external muxing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_DTIR" offset="0xf880afcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">major type is a debug control logic component, sub-type is cross trigger</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID4" offset="0xf880afd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID5" offset="0xf880afd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID6" offset="0xf880afd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID7" offset="0xf880afdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID0" offset="0xf880afe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID1" offset="0xf880afe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID2" offset="0xf880afe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_PERIPHID3" offset="0xf880afec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_COMPID0" offset="0xf880aff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_COMPID1" offset="0xf880aff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_COMPID2" offset="0xf880aff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_AXIM_COMPID3" offset="0xf880affc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CTI_ETB_TPIU" name="DEBUG_CTI_ETB_TPIU" offset="0xf8802000">
            <gui_name language="en">debug_cti_etb_tpiu</gui_name>
            <description language="en">debug_cti_etb_tpiu</description>
            <register name="DEBUG_CTI_ETB_TPIU_CTICONTROL" offset="0xf8802000" size="0x2">
                <gui_name language="en">CTICONTROL</gui_name>
                <description language="en">CTI Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GLBEN">
                    <gui_name language="en">GLBEN</gui_name>
                    <description language="en">Enables or disables the ECT. When disabled, all cross triggering mapping logic functionality is disabled for this processor.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_CTIINTACK" offset="0xf8802010" size="0x2">
                <gui_name language="en">CTIINTACK</gui_name>
                <description language="en">CTI Interrupt Acknowledge Register</description>
                <bitField access="Write Only" enumerationId="CTIINTACK_INTACK_ENUM" high_bit="7" low_bit="0" name="INTACK">
                    <gui_name language="en">INTACK</gui_name>
                    <description language="en">Acknowledges the corresponding CTITRIGOUT output:
1 = CTITRIGOUT is acknowledged and is cleared when MAPTRIGOUT is LOW.
0 = no effect
There is one bit of the register for each CTITRIGOUT output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIAPPSET" offset="0xf8802014" size="0x2">
                <gui_name language="en">CTIAPPSET</gui_name>
                <description language="en">CTI Application Trigger Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="APPSET">
                    <gui_name language="en">APPSET</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event for the selected channel.
Read:
0 = application trigger inactive (reset)
1 = application trigger active.
Write:
0 = no effect
1 = generate channel event.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_CTIAPPCLEAR" offset="0xf8802018" size="0x2">
                <gui_name language="en">CTIAPPCLEAR</gui_name>
                <description language="en">CTI Application Trigger Clear Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPCLEAR_APPCLEAR_ENUM" high_bit="3" low_bit="0" name="APPCLEAR">
                    <gui_name language="en">APPCLEAR</gui_name>
                    <description language="en">Clears corresponding bits in the CTIAPPSET register.
1 = application trigger disabled in the CTIAPPSET register
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_CTIAPPPULSE" offset="0xf880201c" size="0x2">
                <gui_name language="en">CTIAPPPULSE</gui_name>
                <description language="en">CTI Application Pulse Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPPULSE_APPULSE_ENUM" high_bit="3" low_bit="0" name="APPULSE">
                    <gui_name language="en">APPULSE</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event pulse for the selected channel.
Write:
1 = channel event pulse generated for one CTICLK period
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN0" offset="0xf8802020" size="0x2">
                <gui_name language="en">CTIINEN0</gui_name>
                <description language="en">CTI Trigger to Channel Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN0_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN1" offset="0xf8802024" size="0x2">
                <gui_name language="en">CTIINEN1</gui_name>
                <description language="en">CTI Trigger to Channel Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN1_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN2" offset="0xf8802028" size="0x2">
                <gui_name language="en">CTIINEN2</gui_name>
                <description language="en">CTI Trigger to Channel Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN2_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN3" offset="0xf880202c" size="0x2">
                <gui_name language="en">CTIINEN3</gui_name>
                <description language="en">CTI Trigger to Channel Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN3_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN4" offset="0xf8802030" size="0x2">
                <gui_name language="en">CTIINEN4</gui_name>
                <description language="en">CTI Trigger to Channel Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN4_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN5" offset="0xf8802034" size="0x2">
                <gui_name language="en">CTIINEN5</gui_name>
                <description language="en">CTI Trigger to Channel Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN5_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN6" offset="0xf8802038" size="0x2">
                <gui_name language="en">CTIINEN6</gui_name>
                <description language="en">CTI Trigger to Channel Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN6_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIINEN7" offset="0xf880203c" size="0x2">
                <gui_name language="en">CTIINEN7</gui_name>
                <description language="en">CTI Trigger to Channel Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN7_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN0" offset="0xf88020a0" size="0x2">
                <gui_name language="en">CTIOUTEN0</gui_name>
                <description language="en">CTI Channel to Trigger Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN0_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN1" offset="0xf88020a4" size="0x2">
                <gui_name language="en">CTIOUTEN1</gui_name>
                <description language="en">CTI Channel to Trigger Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN1_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN2" offset="0xf88020a8" size="0x2">
                <gui_name language="en">CTIOUTEN2</gui_name>
                <description language="en">CTI Channel to Trigger Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN2_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN3" offset="0xf88020ac" size="0x2">
                <gui_name language="en">CTIOUTEN3</gui_name>
                <description language="en">CTI Channel to Trigger Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN3_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN4" offset="0xf88020b0" size="0x2">
                <gui_name language="en">CTIOUTEN4</gui_name>
                <description language="en">CTI Channel to Trigger Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN4_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN5" offset="0xf88020b4" size="0x2">
                <gui_name language="en">CTIOUTEN5</gui_name>
                <description language="en">CTI Channel to Trigger Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN5_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN6" offset="0xf88020b8" size="0x2">
                <gui_name language="en">CTIOUTEN6</gui_name>
                <description language="en">CTI Channel to Trigger Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN6_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIOUTEN7" offset="0xf88020bc" size="0x2">
                <gui_name language="en">CTIOUTEN7</gui_name>
                <description language="en">CTI Channel to Trigger Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN7_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_CTITRIGINSTATUS" offset="0xf8802130" size="0x2">
                <gui_name language="en">CTITRIGINSTATUS</gui_name>
                <description language="en">CTI Trigger In Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGINSTATUS_TRIGINSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGINSTATUS">
                    <gui_name language="en">TRIGINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGIN inputs:
1 = CTITRIGIN is active
0 = CTITRIGIN is inactive.
Because the register provides a view of the raw CTITRIGIN inputs, the reset value is
unknown. There is one bit of the register for each trigger input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_CTITRIGOUTSTATUS" offset="0xf8802134" size="0x2">
                <gui_name language="en">CTITRIGOUTSTATUS</gui_name>
                <description language="en">CTI Trigger Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGOUTSTATUS_TRIGOUTSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGOUTSTATUS">
                    <gui_name language="en">TRIGOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGOUT outputs.
1 = CTITRIGOUT is active
0 = CTITRIGOUT is inactive (reset).
There is one bit of the register for each trigger output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_CTICHINSTATUS" offset="0xf8802138" size="0x2">
                <gui_name language="en">CTICHINSTATUS</gui_name>
                <description language="en">CTI Channel In Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHINSTATUS_CTCHINSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHINSTATUS">
                    <gui_name language="en">CTCHINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHIN inputs:
1 = CTICHIN is active
0 = CTICHIN is inactive.
Because the register provides a view of the raw CTICHIN inputs from the CTM, the reset
value is unknown. There is one bit of the register for each channel input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_CTICHOUTSTATUS" offset="0xf880213c" size="0x2">
                <gui_name language="en">CTICHOUTSTATUS</gui_name>
                <description language="en">CTI Channel Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHOUTSTATUS_CTCHOUTSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHOUTSTATUS">
                    <gui_name language="en">CTCHOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHOUT outputs.
1 = CTICHOUT is active
0 = CTICHOUT is inactive (reset).
There is one bit of the register for each channel output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTIGATE" offset="0xf8802140" size="0x2">
                <gui_name language="en">CTIGATE</gui_name>
                <description language="en">Enable CTI Channel Gate Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CTIGATEEN3">
                    <gui_name language="en">CTIGATEEN3</gui_name>
                    <description language="en">Enable CTICHOUT3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CTIGATEEN2">
                    <gui_name language="en">CTIGATEEN2</gui_name>
                    <description language="en">Enable CTICHOUT2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CTIGATEEN1">
                    <gui_name language="en">CTIGATEEN1</gui_name>
                    <description language="en">Enable CTICHOUT1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CTIGATEEN0">
                    <gui_name language="en">CTIGATEEN0</gui_name>
                    <description language="en">Enable CTICHOUT0.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_ASICCTL" offset="0xf8802144" size="0x2">
                <gui_name language="en">ASICCTL</gui_name>
                <description language="en">External Multiplexor Control Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ASICCTL">
                    <gui_name language="en">ASICCTL</gui_name>
                    <description language="en">Implementation defined ASIC control, value written to the register is output on ASICCTL[7:0].</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_ITCHINACK" offset="0xf8802edc" size="0x2">
                <gui_name language="en">ITCHINACK</gui_name>
                <description language="en">ITCHINACK Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHINACK">
                    <gui_name language="en">CTCHINACK</gui_name>
                    <description language="en">Set the value of the CTCHINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_ITTRIGINACK" offset="0xf8802ee0" size="0x2">
                <gui_name language="en">ITTRIGINACK</gui_name>
                <description language="en">ITTRIGINACK Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGINACK">
                    <gui_name language="en">CTTRIGINACK</gui_name>
                    <description language="en">Set the value of the CTTRIGINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_ITCHOUT" offset="0xf8802ee4" size="0x2">
                <gui_name language="en">ITCHOUT</gui_name>
                <description language="en">ITCHOUT Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHOUT">
                    <gui_name language="en">CTCHOUT</gui_name>
                    <description language="en">Set the value of the CTCHOUT outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_ITTRIGOUT" offset="0xf8802ee8" size="0x2">
                <gui_name language="en">ITTRIGOUT</gui_name>
                <description language="en">ITTRIGOUT Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGOUT">
                    <gui_name language="en">CTTRIGOUT</gui_name>
                    <description language="en">Set the value of the CTTRIGOUT outputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_ITCHOUTACK" offset="0xf8802eec" size="0x2">
                <gui_name language="en">ITCHOUTACK</gui_name>
                <description language="en">ITCHOUTACK Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHOUTACK">
                    <gui_name language="en">CTCHOUTACK</gui_name>
                    <description language="en">Read the values of the CTCHOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_ITTRIGOUTACK" offset="0xf8802ef0" size="0x2">
                <gui_name language="en">ITTRIGOUTACK</gui_name>
                <description language="en">ITTRIGOUTACK Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGOUTACK">
                    <gui_name language="en">CTTRIGOUTACK</gui_name>
                    <description language="en">Read the values of the CTTRIGOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_ITCHIN" offset="0xf8802ef4" size="0x2">
                <gui_name language="en">ITCHIN</gui_name>
                <description language="en">ITCHIN Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHIN">
                    <gui_name language="en">CTCHIN</gui_name>
                    <description language="en">Read the values of the CTCHIN inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_ITTRIGIN" offset="0xf8802ef8" size="0x2">
                <gui_name language="en">ITTRIGIN</gui_name>
                <description language="en">ITTRIGIN Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGIN">
                    <gui_name language="en">CTTRIGIN</gui_name>
                    <description language="en">Read the values of the CTTRIGIN inputs</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_ITCTRL" offset="0xf8802f00" size="0x2">
                <gui_name language="en">ITCTRL</gui_name>
                <description language="en">IT Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable IT Registers</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTSR" offset="0xf8802fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="SET">
                    <gui_name language="en">SET</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_ETB_TPIU_CTCR" offset="0xf8802fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_ETB_TPIU_LAR" offset="0xf8802fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="KEY">
                    <gui_name language="en">KEY</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), CTI is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
CTI is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_LSR" offset="0xf8802fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since CTI implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether CTI is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_ASR" offset="0xf8802fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">Current value of noninvasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="NIDEN_CTL">
                    <gui_name language="en">NIDEN_CTL</gui_name>
                    <description language="en">Non-invasive debug controlled</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="IDEN">
                    <gui_name language="en">IDEN</gui_name>
                    <description language="en">Current value of invasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IDEN_CTL">
                    <gui_name language="en">IDEN_CTL</gui_name>
                    <description language="en">Invasive debug controlled</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_DEVID" offset="0xf8802fc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="NumChan">
                    <gui_name language="en">NumChan</gui_name>
                    <description language="en">Number of channels available</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="NumTrig">
                    <gui_name language="en">NumTrig</gui_name>
                    <description language="en">Number of triggers available</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="5" name="res">
                    <gui_name language="en">res</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="ExtMux">
                    <gui_name language="en">ExtMux</gui_name>
                    <description language="en">no external muxing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_DTIR" offset="0xf8802fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">major type is a debug control logic component, sub-type is cross trigger</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID4" offset="0xf8802fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID5" offset="0xf8802fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID6" offset="0xf8802fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID7" offset="0xf8802fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID0" offset="0xf8802fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID1" offset="0xf8802fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID2" offset="0xf8802fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_PERIPHID3" offset="0xf8802fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_COMPID0" offset="0xf8802ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_COMPID1" offset="0xf8802ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_COMPID2" offset="0xf8802ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_ETB_TPIU_COMPID3" offset="0xf8802ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_CTI_FTM" name="DEBUG_CTI_FTM" offset="0xf8809000">
            <gui_name language="en">debug_cti_ftm</gui_name>
            <description language="en">debug_cti_ftm</description>
            <register name="DEBUG_CTI_FTM_CTICONTROL" offset="0xf8809000" size="0x2">
                <gui_name language="en">CTICONTROL</gui_name>
                <description language="en">CTI Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GLBEN">
                    <gui_name language="en">GLBEN</gui_name>
                    <description language="en">Enables or disables the ECT. When disabled, all cross triggering mapping logic functionality is disabled for this processor.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_CTIINTACK" offset="0xf8809010" size="0x2">
                <gui_name language="en">CTIINTACK</gui_name>
                <description language="en">CTI Interrupt Acknowledge Register</description>
                <bitField access="Write Only" enumerationId="CTIINTACK_INTACK_ENUM" high_bit="7" low_bit="0" name="INTACK">
                    <gui_name language="en">INTACK</gui_name>
                    <description language="en">Acknowledges the corresponding CTITRIGOUT output:
1 = CTITRIGOUT is acknowledged and is cleared when MAPTRIGOUT is LOW.
0 = no effect
There is one bit of the register for each CTITRIGOUT output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIAPPSET" offset="0xf8809014" size="0x2">
                <gui_name language="en">CTIAPPSET</gui_name>
                <description language="en">CTI Application Trigger Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="APPSET">
                    <gui_name language="en">APPSET</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event for the selected channel.
Read:
0 = application trigger inactive (reset)
1 = application trigger active.
Write:
0 = no effect
1 = generate channel event.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_CTIAPPCLEAR" offset="0xf8809018" size="0x2">
                <gui_name language="en">CTIAPPCLEAR</gui_name>
                <description language="en">CTI Application Trigger Clear Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPCLEAR_APPCLEAR_ENUM" high_bit="3" low_bit="0" name="APPCLEAR">
                    <gui_name language="en">APPCLEAR</gui_name>
                    <description language="en">Clears corresponding bits in the CTIAPPSET register.
1 = application trigger disabled in the CTIAPPSET register
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_CTIAPPPULSE" offset="0xf880901c" size="0x2">
                <gui_name language="en">CTIAPPPULSE</gui_name>
                <description language="en">CTI Application Pulse Register</description>
                <bitField access="Write Only" enumerationId="CTIAPPPULSE_APPULSE_ENUM" high_bit="3" low_bit="0" name="APPULSE">
                    <gui_name language="en">APPULSE</gui_name>
                    <description language="en">Setting a bit HIGH generates a channel event pulse for the selected channel.
Write:
1 = channel event pulse generated for one CTICLK period
0 = no effect.
There is one bit of the register for each channel.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN0" offset="0xf8809020" size="0x2">
                <gui_name language="en">CTIINEN0</gui_name>
                <description language="en">CTI Trigger to Channel Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN0_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN1" offset="0xf8809024" size="0x2">
                <gui_name language="en">CTIINEN1</gui_name>
                <description language="en">CTI Trigger to Channel Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN1_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN2" offset="0xf8809028" size="0x2">
                <gui_name language="en">CTIINEN2</gui_name>
                <description language="en">CTI Trigger to Channel Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN2_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN3" offset="0xf880902c" size="0x2">
                <gui_name language="en">CTIINEN3</gui_name>
                <description language="en">CTI Trigger to Channel Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN3_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN4" offset="0xf8809030" size="0x2">
                <gui_name language="en">CTIINEN4</gui_name>
                <description language="en">CTI Trigger to Channel Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN4_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN5" offset="0xf8809034" size="0x2">
                <gui_name language="en">CTIINEN5</gui_name>
                <description language="en">CTI Trigger to Channel Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN5_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN6" offset="0xf8809038" size="0x2">
                <gui_name language="en">CTIINEN6</gui_name>
                <description language="en">CTI Trigger to Channel Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN6_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIINEN7" offset="0xf880903c" size="0x2">
                <gui_name language="en">CTIINEN7</gui_name>
                <description language="en">CTI Trigger to Channel Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIINEN7_TRIGINEN_ENUM" high_bit="3" low_bit="0" name="TRIGINEN">
                    <gui_name language="en">TRIGINEN</gui_name>
                    <description language="en">Enables a cross trigger event to the corresponding channel when an CTITRIGIN is activated.
1 = enables the CTITRIGIN signal to generate an event on the respective channel of the CTM.
There is one bit of the register for each of the four channels. For example in register CTIINEN0,
TRIGINEN[0] set to 1 enables CTITRIGIN onto channel 0.
0 = disables the CTITRIGIN signal from generating an event on the respective channel of the
CTM.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN0" offset="0xf88090a0" size="0x2">
                <gui_name language="en">CTIOUTEN0</gui_name>
                <description language="en">CTI Channel to Trigger Enable 0 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN0_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN1" offset="0xf88090a4" size="0x2">
                <gui_name language="en">CTIOUTEN1</gui_name>
                <description language="en">CTI Channel to Trigger Enable 1 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN1_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN2" offset="0xf88090a8" size="0x2">
                <gui_name language="en">CTIOUTEN2</gui_name>
                <description language="en">CTI Channel to Trigger Enable 2 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN2_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN3" offset="0xf88090ac" size="0x2">
                <gui_name language="en">CTIOUTEN3</gui_name>
                <description language="en">CTI Channel to Trigger Enable 3 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN3_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN4" offset="0xf88090b0" size="0x2">
                <gui_name language="en">CTIOUTEN4</gui_name>
                <description language="en">CTI Channel to Trigger Enable 4 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN4_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN5" offset="0xf88090b4" size="0x2">
                <gui_name language="en">CTIOUTEN5</gui_name>
                <description language="en">CTI Channel to Trigger Enable 5 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN5_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN6" offset="0xf88090b8" size="0x2">
                <gui_name language="en">CTIOUTEN6</gui_name>
                <description language="en">CTI Channel to Trigger Enable 6 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN6_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIOUTEN7" offset="0xf88090bc" size="0x2">
                <gui_name language="en">CTIOUTEN7</gui_name>
                <description language="en">CTI Channel to Trigger Enable 7 Register</description>
                <bitField access="Read Write" enumerationId="CTIOUTEN7_TRIGOUTEN_ENUM" high_bit="3" low_bit="0" name="TRIGOUTEN">
                    <gui_name language="en">TRIGOUTEN</gui_name>
                    <description language="en">Changing the value of this bit from a 0 to a 1 enables a channel event for the corresponding
channel to generate an CTITRIGOUT output:
0 = the channel input (CTICHIN) from the CTM is not routed to the CTITRIGOUT output
1 = the channel input (CTICHIN) from the CTM is routed to the CTITRIGOUT output.
There is one bit for each of the four channels. For example in register CTIOUTEN0, enabling
bit 0 enables CTICHIN[0] to cause a trigger event on the CTITRIGOUT[0] output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_CTITRIGINSTATUS" offset="0xf8809130" size="0x2">
                <gui_name language="en">CTITRIGINSTATUS</gui_name>
                <description language="en">CTI Trigger In Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGINSTATUS_TRIGINSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGINSTATUS">
                    <gui_name language="en">TRIGINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGIN inputs:
1 = CTITRIGIN is active
0 = CTITRIGIN is inactive.
Because the register provides a view of the raw CTITRIGIN inputs, the reset value is
unknown. There is one bit of the register for each trigger input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_CTITRIGOUTSTATUS" offset="0xf8809134" size="0x2">
                <gui_name language="en">CTITRIGOUTSTATUS</gui_name>
                <description language="en">CTI Trigger Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTITRIGOUTSTATUS_TRIGOUTSTATUS_ENUM" high_bit="7" low_bit="0" name="TRIGOUTSTATUS">
                    <gui_name language="en">TRIGOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTITRIGOUT outputs.
1 = CTITRIGOUT is active
0 = CTITRIGOUT is inactive (reset).
There is one bit of the register for each trigger output.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_CTICHINSTATUS" offset="0xf8809138" size="0x2">
                <gui_name language="en">CTICHINSTATUS</gui_name>
                <description language="en">CTI Channel In Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHINSTATUS_CTCHINSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHINSTATUS">
                    <gui_name language="en">CTCHINSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHIN inputs:
1 = CTICHIN is active
0 = CTICHIN is inactive.
Because the register provides a view of the raw CTICHIN inputs from the CTM, the reset
value is unknown. There is one bit of the register for each channel input.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_CTICHOUTSTATUS" offset="0xf880913c" size="0x2">
                <gui_name language="en">CTICHOUTSTATUS</gui_name>
                <description language="en">CTI Channel Out Status Register</description>
                <bitField access="Read Only" enumerationId="CTICHOUTSTATUS_CTCHOUTSTATUS_ENUM" high_bit="3" low_bit="0" name="CTCHOUTSTATUS">
                    <gui_name language="en">CTCHOUTSTATUS</gui_name>
                    <description language="en">Shows the status of the CTICHOUT outputs.
1 = CTICHOUT is active
0 = CTICHOUT is inactive (reset).
There is one bit of the register for each channel output.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTIGATE" offset="0xf8809140" size="0x2">
                <gui_name language="en">CTIGATE</gui_name>
                <description language="en">Enable CTI Channel Gate Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CTIGATEEN3">
                    <gui_name language="en">CTIGATEEN3</gui_name>
                    <description language="en">Enable CTICHOUT3.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CTIGATEEN2">
                    <gui_name language="en">CTIGATEEN2</gui_name>
                    <description language="en">Enable CTICHOUT2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CTIGATEEN1">
                    <gui_name language="en">CTIGATEEN1</gui_name>
                    <description language="en">Enable CTICHOUT1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CTIGATEEN0">
                    <gui_name language="en">CTIGATEEN0</gui_name>
                    <description language="en">Enable CTICHOUT0.</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_ASICCTL" offset="0xf8809144" size="0x2">
                <gui_name language="en">ASICCTL</gui_name>
                <description language="en">External Multiplexor Control Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ASICCTL">
                    <gui_name language="en">ASICCTL</gui_name>
                    <description language="en">Implementation defined ASIC control, value written to the register is output on ASICCTL[7:0].</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_ITCHINACK" offset="0xf8809edc" size="0x2">
                <gui_name language="en">ITCHINACK</gui_name>
                <description language="en">ITCHINACK Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHINACK">
                    <gui_name language="en">CTCHINACK</gui_name>
                    <description language="en">Set the value of the CTCHINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_ITTRIGINACK" offset="0xf8809ee0" size="0x2">
                <gui_name language="en">ITTRIGINACK</gui_name>
                <description language="en">ITTRIGINACK Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGINACK">
                    <gui_name language="en">CTTRIGINACK</gui_name>
                    <description language="en">Set the value of the CTTRIGINACK outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_ITCHOUT" offset="0xf8809ee4" size="0x2">
                <gui_name language="en">ITCHOUT</gui_name>
                <description language="en">ITCHOUT Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="CTCHOUT">
                    <gui_name language="en">CTCHOUT</gui_name>
                    <description language="en">Set the value of the CTCHOUT outputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_ITTRIGOUT" offset="0xf8809ee8" size="0x2">
                <gui_name language="en">ITTRIGOUT</gui_name>
                <description language="en">ITTRIGOUT Register</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="CTTRIGOUT">
                    <gui_name language="en">CTTRIGOUT</gui_name>
                    <description language="en">Set the value of the CTTRIGOUT outputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_ITCHOUTACK" offset="0xf8809eec" size="0x2">
                <gui_name language="en">ITCHOUTACK</gui_name>
                <description language="en">ITCHOUTACK Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHOUTACK">
                    <gui_name language="en">CTCHOUTACK</gui_name>
                    <description language="en">Read the values of the CTCHOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_ITTRIGOUTACK" offset="0xf8809ef0" size="0x2">
                <gui_name language="en">ITTRIGOUTACK</gui_name>
                <description language="en">ITTRIGOUTACK Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGOUTACK">
                    <gui_name language="en">CTTRIGOUTACK</gui_name>
                    <description language="en">Read the values of the CTTRIGOUTACK inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_ITCHIN" offset="0xf8809ef4" size="0x2">
                <gui_name language="en">ITCHIN</gui_name>
                <description language="en">ITCHIN Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CTCHIN">
                    <gui_name language="en">CTCHIN</gui_name>
                    <description language="en">Read the values of the CTCHIN inputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_ITTRIGIN" offset="0xf8809ef8" size="0x2">
                <gui_name language="en">ITTRIGIN</gui_name>
                <description language="en">ITTRIGIN Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="CTTRIGIN">
                    <gui_name language="en">CTTRIGIN</gui_name>
                    <description language="en">Read the values of the CTTRIGIN inputs</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_ITCTRL" offset="0xf8809f00" size="0x2">
                <gui_name language="en">ITCTRL</gui_name>
                <description language="en">IT Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable IT Registers</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTSR" offset="0xf8809fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="SET">
                    <gui_name language="en">SET</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_CTI_FTM_CTCR" offset="0xf8809fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_CTI_FTM_LAR" offset="0xf8809fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="KEY">
                    <gui_name language="en">KEY</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), CTI is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
CTI is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_LSR" offset="0xf8809fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since CTI implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether CTI is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_ASR" offset="0xf8809fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">Current value of noninvasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="NIDEN_CTL">
                    <gui_name language="en">NIDEN_CTL</gui_name>
                    <description language="en">Non-invasive debug controlled</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="IDEN">
                    <gui_name language="en">IDEN</gui_name>
                    <description language="en">Current value of invasive debug enable signals</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IDEN_CTL">
                    <gui_name language="en">IDEN_CTL</gui_name>
                    <description language="en">Invasive debug controlled</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_DEVID" offset="0xf8809fc8" size="0x4">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="NumChan">
                    <gui_name language="en">NumChan</gui_name>
                    <description language="en">Number of channels available</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="NumTrig">
                    <gui_name language="en">NumTrig</gui_name>
                    <description language="en">Number of triggers available</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="5" name="res">
                    <gui_name language="en">res</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="ExtMux">
                    <gui_name language="en">ExtMux</gui_name>
                    <description language="en">no external muxing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_DTIR" offset="0xf8809fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">major type is a debug control logic component, sub-type is cross trigger</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID4" offset="0xf8809fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID5" offset="0xf8809fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID6" offset="0xf8809fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID7" offset="0xf8809fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID0" offset="0xf8809fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID1" offset="0xf8809fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID2" offset="0xf8809fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_PERIPHID3" offset="0xf8809fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_COMPID0" offset="0xf8809ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_COMPID1" offset="0xf8809ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_COMPID2" offset="0xf8809ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_CTI_FTM_COMPID3" offset="0xf8809ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_DAP_ROM" name="DEBUG_DAP_ROM" offset="0xf8800000">
            <gui_name language="en">debug_dap_rom</gui_name>
            <description language="en">debug_dap_rom</description>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY00" offset="0xf8800000" size="0x4">
                <gui_name language="en">ROMENTRY00</gui_name>
                <description language="en">ROM entry 00</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY01" offset="0xf8800004" size="0x4">
                <gui_name language="en">ROMENTRY01</gui_name>
                <description language="en">ROM entry 01</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY02" offset="0xf8800008" size="0x4">
                <gui_name language="en">ROMENTRY02</gui_name>
                <description language="en">ROM entry 02</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY03" offset="0xf880000c" size="0x4">
                <gui_name language="en">ROMENTRY03</gui_name>
                <description language="en">ROM entry 03</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY04" offset="0xf8800010" size="0x4">
                <gui_name language="en">ROMENTRY04</gui_name>
                <description language="en">ROM entry 04</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY05" offset="0xf8800014" size="0x4">
                <gui_name language="en">ROMENTRY05</gui_name>
                <description language="en">ROM entry 05</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY06" offset="0xf8800018" size="0x4">
                <gui_name language="en">ROMENTRY06</gui_name>
                <description language="en">ROM entry 06</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY07" offset="0xf880001c" size="0x4">
                <gui_name language="en">ROMENTRY07</gui_name>
                <description language="en">ROM entry 07</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY08" offset="0xf8800020" size="0x4">
                <gui_name language="en">ROMENTRY08</gui_name>
                <description language="en">ROM entry 08</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_ROMENTRY09" offset="0xf8800024" size="0x4">
                <gui_name language="en">ROMENTRY09</gui_name>
                <description language="en">ROM entry 09</description>
                <bitField access="Read Only" high_bit="31" low_bit="12" name="AddressOffset">
                    <gui_name language="en">AddressOffset</gui_name>
                    <description language="en">Base address of the component, relative to the ROM address.
Negative values are permitted using two's complement.
ComponentAddress = ROMAddress + (AddressOffset SHL 12)</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Format">
                    <gui_name language="en">Format</gui_name>
                    <description language="en">Format of ROM entry</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="EntryPresent">
                    <gui_name language="en">EntryPresent</gui_name>
                    <description language="en">Set HIGH to indicate an entry is present.</description>
                </bitField>
            </register>
            <register name="DEBUG_DAP_ROM_ROMENTRY10" offset="0xf8800028" size="0x4">
                <gui_name language="en">ROMENTRY10</gui_name>
                <description language="en">ROM entry 10</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Invalid entry</description>
                </bitField>
            </register>
            <register name="DEBUG_DAP_ROM_ROMENTRY11" offset="0xf880002c" size="0x4">
                <gui_name language="en">ROMENTRY11</gui_name>
                <description language="en">ROM entry 11</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Invalid entry</description>
                </bitField>
            </register>
            <register name="DEBUG_DAP_ROM_ROMENTRY12" offset="0xf8800030" size="0x4">
                <gui_name language="en">ROMENTRY12</gui_name>
                <description language="en">ROM entry 12</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Invalid entry</description>
                </bitField>
            </register>
            <register name="DEBUG_DAP_ROM_ROMENTRY13" offset="0xf8800034" size="0x4">
                <gui_name language="en">ROMENTRY13</gui_name>
                <description language="en">ROM entry 13</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Invalid entry</description>
                </bitField>
            </register>
            <register name="DEBUG_DAP_ROM_ROMENTRY14" offset="0xf8800038" size="0x4">
                <gui_name language="en">ROMENTRY14</gui_name>
                <description language="en">ROM entry 14</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Invalid entry</description>
                </bitField>
            </register>
            <register name="DEBUG_DAP_ROM_ROMENTRY15" offset="0xf880003c" size="0x4">
                <gui_name language="en">ROMENTRY15</gui_name>
                <description language="en">ROM entry 15</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Invalid entry</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID4" offset="0xf8800fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID5" offset="0xf8800fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID6" offset="0xf8800fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID7" offset="0xf8800fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID0" offset="0xf8800fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="PartNumber0">
                    <gui_name language="en">PartNumber0</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID1" offset="0xf8800fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID2" offset="0xf8800fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_PERIPHID3" offset="0xf8800fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_COMPID0" offset="0xf8800ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_COMPID1" offset="0xf8800ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_COMPID2" offset="0xf8800ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_DAP_ROM_COMPID3" offset="0xf8800ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_ETB" name="DEBUG_ETB" offset="0xf8801000">
            <gui_name language="en">debug_etb</gui_name>
            <description language="en">debug_etb</description>
            <register access="Read Only" name="DEBUG_ETB_RDP" offset="0xf8801004" size="0x4">
                <gui_name language="en">RDP</gui_name>
                <description language="en">RAM Depth Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Defines the depth, in words, of the trace RAM.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_STS" offset="0xf880100c" size="0x2">
                <gui_name language="en">STS</gui_name>
                <description language="en">Status Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="FtEmpty">
                    <gui_name language="en">FtEmpty</gui_name>
                    <description language="en">Formatter pipeline empty. All data stored to RAM.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="AcqComp">
                    <gui_name language="en">AcqComp</gui_name>
                    <description language="en">Acquisition complete.
The acquisition complete flag indicates that capture has been completed when the formatter stops because of any of the methods defined in the Formatter and Flush Control Register, or TraceCaptEn = 0. This also results in FtStopped in the Formatter and Flush Status Register going HIGH.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Triggered">
                    <gui_name language="en">Triggered</gui_name>
                    <description language="en">The Triggered bit is set when a trigger has been observed. This does not indicate that a trigger has been embedded in the trace data by the formatter, but is determined by the programming of the Formatter and Flush Control Register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Full">
                    <gui_name language="en">Full</gui_name>
                    <description language="en">RAM Full.
The flag indicates when the RAM write pointer has wrapped around.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_RRD" offset="0xf8801010" size="0x4">
                <gui_name language="en">RRD</gui_name>
                <description language="en">RAM Read Data Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Data read from the ETB Trace RAM.</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_RRP" offset="0xf8801014" size="0x2">
                <gui_name language="en">RRP</gui_name>
                <description language="en">RAM Read Pointer Register</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Sets the read pointer used to read entries from the Trace RAM over the APB interface.</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_RWP" offset="0xf8801018" size="0x2">
                <gui_name language="en">RWP</gui_name>
                <description language="en">RAM Write Pointer Register</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Sets the write pointer used to write entries from the CoreSight bus into the Trace RAM</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_TRG" offset="0xf880101c" size="0x2">
                <gui_name language="en">TRG</gui_name>
                <description language="en">Trigger Counter Register</description>
                <bitField access="Read Write" high_bit="9" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The counter is used as follows:
- Trace after
The counter is set to a large value, slightly less than the number of entries in the RAM.
- Trace before
The counter is set to a small value.
- Trace about
The counter is set to half the depth of the Trace RAM.
This register must not be written to when trace capture is enabled (FtStopped=0, TraceCaptEn=1). If a write is attempted, the register is not updated. A read access is permitted with trace capture enabled.</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_CTL" offset="0xf8801020" size="0x2">
                <gui_name language="en">CTL</gui_name>
                <description language="en">Control Register</description>
                <bitField access="Read Write" enumerationId="CTL_TraceCaptEn_ENUM" high_bit="0" low_bit="0" name="TraceCaptEn">
                    <gui_name language="en">TraceCaptEn</gui_name>
                    <description language="en">ETB Trace Capture Enable.
1 = enable trace capture
0 = disable trace capture.
This is the master enable bit forcing FtStopped HIGH when TraceCaptEn is LOW.
When capture is disabled, any remaining data in the ATB formatter is stored to RAM.
When all data is stored the formatter outputs FtStopped. Capture is fully disabled, or complete, when FtStopped goes HIGH.</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_RWD" offset="0xf8801024" size="0x4">
                <gui_name language="en">RWD</gui_name>
                <description language="en">RAM Write Data Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Data written to the ETB Trace RAM.
When trace capture is disabled, the contents of this register are placed into the ETB Trace RAM when this register is written to.
Writing to this register increments the RAM Write Pointer Register.
If trace capture is enabled, and this register is accessed, then a read from this register outputs 0xFFFFFFFF. Reads of this register never increment the RAM Write Pointer Register. A constant stream of 1s being output corresponds to a synchronization output from the ETB. If a write access is attempted, the data is not written into Trace RAM.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_FFSR" offset="0xf8801300" size="0x2">
                <gui_name language="en">FFSR</gui_name>
                <description language="en">Formatter and Flush Status Register</description>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="FtStopped">
                    <gui_name language="en">FtStopped</gui_name>
                    <description language="en">Formatter stopped. The formatter has received a stop request signal and all trace data and post-amble has been output. Any more trace data on the ATB interface is ignored and ATREADYS goes HIGH.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="FlInProg">
                    <gui_name language="en">FlInProg</gui_name>
                    <description language="en">Flush In Progress. This is an indication of the current state of AFVALIDS.</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_FFCR" offset="0xf8801304" size="0x2">
                <gui_name language="en">FFCR</gui_name>
                <description language="en">Formatter and Flush Control Register</description>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="StopTrig">
                    <gui_name language="en">StopTrig</gui_name>
                    <description language="en">Stop the formatter when a Trigger Event has been observed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="StopFl">
                    <gui_name language="en">StopFl</gui_name>
                    <description language="en">Stop the formatter when a flush has completed (return of AFREADYS). This forces the FIFO to drain off any part-completed packets. Setting this bit enables this function but this is clear on reset (disabled).</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="TrigFl">
                    <gui_name language="en">TrigFl</gui_name>
                    <description language="en">Indicate a trigger on Flush completion (AFREADYS being returned).</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TrigEvt">
                    <gui_name language="en">TrigEvt</gui_name>
                    <description language="en">Indicate a trigger on a Trigger Event.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TrigIn">
                    <gui_name language="en">TrigIn</gui_name>
                    <description language="en">Indicate a trigger on TRIGIN being asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="FOnMan">
                    <gui_name language="en">FOnMan</gui_name>
                    <description language="en">Manually generate a flush of the system. Setting this bit causes a flush to be generated. This is cleared when the flush has been serviced. This bit is clear on reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="FOnTrig">
                    <gui_name language="en">FOnTrig</gui_name>
                    <description language="en">Generate flush using Trigger event. Set this bit to cause a flush of data in the system when a Trigger Event occurs. This bit is clear on reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="FOnFlIn">
                    <gui_name language="en">FOnFlIn</gui_name>
                    <description language="en">Generate flush using the FLUSHIN interface. Set this bit to enable use of the FLUSHIN connection. This bit is clear on reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="EnFCont">
                    <gui_name language="en">EnFCont</gui_name>
                    <description language="en">Continuous Formatting. Continuous mode in the ETB corresponds to normal mode with the embedding of triggers. Can only be changed when FtStopped is HIGH. This bit is clear on reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="EnFTC">
                    <gui_name language="en">EnFTC</gui_name>
                    <description language="en">Enable Formatting. Do not embed Triggers into the formatted stream. Trace disable cycles and triggers are indicated by TRACECTL, where fitted. Can only be changed when FtStopped is HIGH. This bit is clear on reset.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ETB_ITMISCOP0" offset="0xf8801ee0" size="0x2">
                <gui_name language="en">ITMISCOP0</gui_name>
                <description language="en">Integration Test Miscellaneous Output Register 0</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="FULL">
                    <gui_name language="en">FULL</gui_name>
                    <description language="en">Set the value of FULL</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ACQCOMP">
                    <gui_name language="en">ACQCOMP</gui_name>
                    <description language="en">Set the value of ACQCOMP</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ETB_ITTRFLINACK" offset="0xf8801ee4" size="0x2">
                <gui_name language="en">ITTRFLINACK</gui_name>
                <description language="en">Integration Test Trigger In and Flush In Acknowledge Register</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="FLUSHINACK">
                    <gui_name language="en">FLUSHINACK</gui_name>
                    <description language="en">Set the value of FLUSHINACK</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="TRIGINACK">
                    <gui_name language="en">TRIGINACK</gui_name>
                    <description language="en">Set the value of TRIGINACK</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ETB_ITTRFLIN" offset="0xf8801ee8" size="0x2">
                <gui_name language="en">ITTRFLIN</gui_name>
                <description language="en">Integration Test Trigger In and Flush In Register</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="FLUSHIN">
                    <gui_name language="en">FLUSHIN</gui_name>
                    <description language="en">Read the value of FLUSHIN</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="TRIGIN">
                    <gui_name language="en">TRIGIN</gui_name>
                    <description language="en">Read the value of TRIGIN</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_ITATBDATA0" offset="0xf8801eec" size="0x2">
                <gui_name language="en">ITATBDATA0</gui_name>
                <description language="en">Integration Test ATB Data Register</description>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="ATDATA31">
                    <gui_name language="en">ATDATA31</gui_name>
                    <description language="en">Read the value of ATDATA[31]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="ATDATA23">
                    <gui_name language="en">ATDATA23</gui_name>
                    <description language="en">Read the value of ATDATA[23]</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="ATDATA15">
                    <gui_name language="en">ATDATA15</gui_name>
                    <description language="en">Read the value of ATDATA[15]</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="ATDATA7">
                    <gui_name language="en">ATDATA7</gui_name>
                    <description language="en">Read the value of ATDATA[7]</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATDATA0">
                    <gui_name language="en">ATDATA0</gui_name>
                    <description language="en">Read the value of ATDATA[0]</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ETB_ITATBCTR2" offset="0xf8801ef0" size="0x2">
                <gui_name language="en">ITATBCTR2</gui_name>
                <description language="en">Integration Test ATB Control Register 2</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="AFVALIDS">
                    <gui_name language="en">AFVALIDS</gui_name>
                    <description language="en">Set the value of AFVALIDS</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATREADYS">
                    <gui_name language="en">ATREADYS</gui_name>
                    <description language="en">Set the value of ATREADYS</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_ITATBCTR1" offset="0xf8801ef4" size="0x2">
                <gui_name language="en">ITATBCTR1</gui_name>
                <description language="en">Integration Test ATB Control Register 1</description>
                <bitField access="Read Only" high_bit="6" low_bit="0" name="ATID">
                    <gui_name language="en">ATID</gui_name>
                    <description language="en">Read the value of ATIDS</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_ITATBCTR0" offset="0xf8801ef8" size="0x2">
                <gui_name language="en">ITATBCTR0</gui_name>
                <description language="en">Integration Test ATB Control Register 0</description>
                <bitField access="Read Only" high_bit="9" low_bit="8" name="ATBYTES">
                    <gui_name language="en">ATBYTES</gui_name>
                    <description language="en">Read the value of ATBYTES</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AFREADY">
                    <gui_name language="en">AFREADY</gui_name>
                    <description language="en">Read the value of AFREADYS</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATVALID">
                    <gui_name language="en">ATVALID</gui_name>
                    <description language="en">Read the value of ATVALIDS</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_IMCR" offset="0xf8801f00" size="0x2">
                <gui_name language="en">IMCR</gui_name>
                <description language="en">Integration Mode Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable Integration Test registers.</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_CTSR" offset="0xf8801fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_ETB_CTCR" offset="0xf8801fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ETB_LAR" offset="0xf8801fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), ETB is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
ETB is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_LSR" offset="0xf8801fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since ETB implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether ETB is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_ASR" offset="0xf8801fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Indicates functionality not implemented</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_DEVID" offset="0xf8801fc8" size="0x2">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="SyncATCLK">
                    <gui_name language="en">SyncATCLK</gui_name>
                    <description language="en">ETB RAM is synchronous to ATCLK</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="InputMux">
                    <gui_name language="en">InputMux</gui_name>
                    <description language="en">no input multiplexing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_DTIR" offset="0xf8801fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">A trace sink and specifically an ETB</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID4" offset="0xf8801fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID5" offset="0xf8801fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID6" offset="0xf8801fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID7" offset="0xf8801fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID0" offset="0xf8801fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID1" offset="0xf8801fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID2" offset="0xf8801fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_PERIPHID3" offset="0xf8801fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_COMPID0" offset="0xf8801ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_COMPID1" offset="0xf8801ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_COMPID2" offset="0xf8801ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ETB_COMPID3" offset="0xf8801ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_FTM" name="DEBUG_FTM" offset="0xf880b000">
            <gui_name language="en">debug_ftm</gui_name>
            <description language="en">debug_ftm</description>
            <register name="DEBUG_FTM_FTMGLBCTRL" offset="0xf880b000" size="0x2">
                <gui_name language="en">FTMGLBCTRL</gui_name>
                <description language="en">FTM Global Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="FTMENABLE">
                    <gui_name language="en">FTMENABLE</gui_name>
                    <description language="en">Enable FTM</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMSTATUS" offset="0xf880b004" size="0x2">
                <gui_name language="en">FTMSTATUS</gui_name>
                <description language="en">FTM Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="IDLE">
                    <gui_name language="en">IDLE</gui_name>
                    <description language="en">FTM IDLE Status</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="SPIDEN">
                    <gui_name language="en">SPIDEN</gui_name>
                    <description language="en">Trustzone SPIDEN signal status</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="DBGEN">
                    <gui_name language="en">DBGEN</gui_name>
                    <description language="en">Trustzone DBGEN signal status</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="SPNIDEN">
                    <gui_name language="en">SPNIDEN</gui_name>
                    <description language="en">Trustzone SPNIDEN signal status</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">Trustzone NIDEN signal status</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTMSTATUS_FIFOFULL_ENUM" high_bit="2" low_bit="2" name="FIFOFULL">
                    <gui_name language="en">FIFOFULL</gui_name>
                    <description language="en">1 = FIFO is full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTMSTATUS_FIFOEMPTY_ENUM" high_bit="1" low_bit="1" name="FIFOEMPTY">
                    <gui_name language="en">FIFOEMPTY</gui_name>
                    <description language="en">1 = FIFO is empty</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="LOCKED">
                    <gui_name language="en">LOCKED</gui_name>
                    <description language="en">Always read as zero</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMCONTROL" offset="0xf880b008" size="0x2">
                <gui_name language="en">FTMCONTROL</gui_name>
                <description language="en">FTM Configuration</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CYCEN">
                    <gui_name language="en">CYCEN</gui_name>
                    <description language="en">Enable Cycle Count packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TRACEN">
                    <gui_name language="en">TRACEN</gui_name>
                    <description language="en">Enable Trace packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PROG">
                    <gui_name language="en">PROG</gui_name>
                    <description language="en">Not used</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMP2FDBG0" offset="0xf880b00c" size="0x2">
                <gui_name language="en">FTMP2FDBG0</gui_name>
                <description language="en">FPGA Debug Register P2F0</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="PSS2FPGA">
                    <gui_name language="en">PSS2FPGA</gui_name>
                    <description language="en">Signals presented to the fabric. These signals do not affect the FTM, they are provided for user specific debug. To modify the contents of this register, the SPIDEN pin must be asserted.</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMP2FDBG1" offset="0xf880b010" size="0x2">
                <gui_name language="en">FTMP2FDBG1</gui_name>
                <description language="en">FPGA Debug Register P2F1</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="PSS2FPGA">
                    <gui_name language="en">PSS2FPGA</gui_name>
                    <description language="en">Signals presented to the fabric. These signals do not affect the FTM, they are provided for user specific debug. To modify the contents of this register, the SPIDEN pin must be asserted.</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMP2FDBG2" offset="0xf880b014" size="0x2">
                <gui_name language="en">FTMP2FDBG2</gui_name>
                <description language="en">FPGA Debug Register P2F2</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="PSS2FPGA">
                    <gui_name language="en">PSS2FPGA</gui_name>
                    <description language="en">Signals presented to the fabric. These signals do not affect the FTM, they are provided for user specific debug. To modify the contents of this register, the SPIDEN pin must be asserted.</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMP2FDBG3" offset="0xf880b018" size="0x2">
                <gui_name language="en">FTMP2FDBG3</gui_name>
                <description language="en">FPGA Debug Register P2F3</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="PSS2FPGA">
                    <gui_name language="en">PSS2FPGA</gui_name>
                    <description language="en">Signals presented to the fabric. These signals do not affect the FTM, they are provided for user specific debug. To modify the contents of this register, the SPIDEN pin must be asserted.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMF2PDBG0" offset="0xf880b01c" size="0x2">
                <gui_name language="en">FTMF2PDBG0</gui_name>
                <description language="en">FPGA Debug Register F2P0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="FPGA2PSS">
                    <gui_name language="en">FPGA2PSS</gui_name>
                    <description language="en">Signals that are presented to the PSS from the Fabric.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMF2PDBG1" offset="0xf880b020" size="0x2">
                <gui_name language="en">FTMF2PDBG1</gui_name>
                <description language="en">FPGA Debug Register F2P1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="FPGA2PSS">
                    <gui_name language="en">FPGA2PSS</gui_name>
                    <description language="en">Signals that are presented to the PSS from the Fabric.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMF2PDBG2" offset="0xf880b024" size="0x2">
                <gui_name language="en">FTMF2PDBG2</gui_name>
                <description language="en">FPGA Debug Register F2P2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="FPGA2PSS">
                    <gui_name language="en">FPGA2PSS</gui_name>
                    <description language="en">Signals that are presented to the PSS from the Fabric.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMF2PDBG3" offset="0xf880b028" size="0x2">
                <gui_name language="en">FTMF2PDBG3</gui_name>
                <description language="en">FPGA Debug Register F2P3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="FPGA2PSS">
                    <gui_name language="en">FPGA2PSS</gui_name>
                    <description language="en">Signals that are presented to the PSS from the Fabric.</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_CYCOUNTPRE" offset="0xf880b02c" size="0x2">
                <gui_name language="en">CYCOUNTPRE</gui_name>
                <description language="en">AXI Cycle Count clock pre-scaler</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="PRESCALE">
                    <gui_name language="en">PRESCALE</gui_name>
                    <description language="en">The incoming clock is divided by 2^ PRESCALE. For example: PRESCALE = 15 indicates that the Cycle Counter runs at the AXI clock divided by 2^15 = 32,768 (PRESCALE = 0 indicates no clock scaling)</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMSYNCRELOAD" offset="0xf880b030" size="0x2">
                <gui_name language="en">FTMSYNCRELOAD</gui_name>
                <description language="en">FTM Synchronization Counter reload value</description>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="SYNCCOUNTTERM">
                    <gui_name language="en">SYNCCOUNTTERM</gui_name>
                    <description language="en">Reset FTM Synchronization packet counter when this number of packets has been transmitted. THIS NUMBER HAS A MINIMUM VALUE of 12.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMSYNCCOUT" offset="0xf880b034" size="0x2">
                <gui_name language="en">FTMSYNCCOUT</gui_name>
                <description language="en">FTM Synchronization Counter value</description>
                <bitField access="Read Only" high_bit="11" low_bit="0" name="SYNCCOUT">
                    <gui_name language="en">SYNCCOUT</gui_name>
                    <description language="en">Current value of the Synchronization packet counter. The initial value is zero. The counter value increments every time a packet is issued by the FTM. When the counter reaches SYNCCOUNTTERM, a Synchronization packet is emitted.</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMATID" offset="0xf880b400" size="0x2">
                <gui_name language="en">FTMATID</gui_name>
                <description language="en">FTM ATID Value Register</description>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="ATID">
                    <gui_name language="en">ATID</gui_name>
                    <description language="en">ATID value supplied to ATB bus. The upper three bits, ATID[6:4], are directly driven from this register. The lower four bits, ATID[3:0], are OR-ed with the FPGAATID[3:0] pins.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMITTRIGOUTACK" offset="0xf880bed0" size="0x2">
                <gui_name language="en">FTMITTRIGOUTACK</gui_name>
                <description language="en">Trigger Output Acknowledge Integration Test Register</description>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="TRIGACK">
                    <gui_name language="en">TRIGACK</gui_name>
                    <description language="en">Read the current value of the FTMTrigOutAck[3:0] inputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_FTM_FTMITTRIGGER" offset="0xf880bed4" size="0x2">
                <gui_name language="en">FTMITTRIGGER</gui_name>
                <description language="en">Trigger Output Integration Test Register</description>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="TRIGGER">
                    <gui_name language="en">TRIGGER</gui_name>
                    <description language="en">When ITEN is 1, this field determines the FTMTrigOut[3:0]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMITTRACEDIS" offset="0xf880bed8" size="0x2">
                <gui_name language="en">FTMITTRACEDIS</gui_name>
                <description language="en">External Trace Disable Integration Test Register</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="TRACEDIS">
                    <gui_name language="en">TRACEDIS</gui_name>
                    <description language="en">Always read as zero.</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMITCYCCOUNT" offset="0xf880bedc" size="0x4">
                <gui_name language="en">FTMITCYCCOUNT</gui_name>
                <description language="en">Cycle Counter Test Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="FTMCYCCOUNT">
                    <gui_name language="en">FTMCYCCOUNT</gui_name>
                    <description language="en">Read/write the value of the cycle counter</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_FTM_FTMITATBDATA0" offset="0xf880beec" size="0x2">
                <gui_name language="en">FTMITATBDATA0</gui_name>
                <description language="en">ATB Data Integration Test Register 0</description>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="ATDATA31">
                    <gui_name language="en">ATDATA31</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATDATAM[31] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="ATDATA23">
                    <gui_name language="en">ATDATA23</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATDATAM[23] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="ATDATA15">
                    <gui_name language="en">ATDATA15</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATDATAM[15] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="ATDATA7">
                    <gui_name language="en">ATDATA7</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATDATAM[7] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATDATA0">
                    <gui_name language="en">ATDATA0</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATDATAM[0] output</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMITATBCTR2" offset="0xf880bef0" size="0x2">
                <gui_name language="en">FTMITATBCTR2</gui_name>
                <description language="en">ATB Control Integration Test Register 2</description>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AFVALID">
                    <gui_name language="en">AFVALID</gui_name>
                    <description language="en">Read the current value of the AFVALIDM input</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATREADY">
                    <gui_name language="en">ATREADY</gui_name>
                    <description language="en">Read the current value of the ATREADYM input</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMITATBCTR1" offset="0xf880bef4" size="0x2">
                <gui_name language="en">FTMITATBCTR1</gui_name>
                <description language="en">ATB Control Integration Test Register 1</description>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="ATID_test">
                    <gui_name language="en">ATID_test</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATID output</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_FTM_FTMITATBCTR0" offset="0xf880bef8" size="0x2">
                <gui_name language="en">FTMITATBCTR0</gui_name>
                <description language="en">ATB Control Integration Test Register 0</description>
                <bitField access="Write Only" high_bit="9" low_bit="8" name="ATBYTES">
                    <gui_name language="en">ATBYTES</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATBYTESM[1:0] output</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="AFREADY">
                    <gui_name language="en">AFREADY</gui_name>
                    <description language="en">When ITEN is 1, this value determines the AFREADY output</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATVALID">
                    <gui_name language="en">ATVALID</gui_name>
                    <description language="en">When ITEN is 1, this value determines the ATVALID output</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_FTMITCR" offset="0xf880bf00" size="0x2">
                <gui_name language="en">FTMITCR</gui_name>
                <description language="en">FTM Test Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="ITEN">
                    <gui_name language="en">ITEN</gui_name>
                    <description language="en">Integration Test Enable</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_CLAIMTAGSET" offset="0xf880bfa0" size="0x2">
                <gui_name language="en">CLAIMTAGSET</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="CLAIMTAGSETVAL">
                    <gui_name language="en">CLAIMTAGSETVAL</gui_name>
                    <description language="en">Read: 1 = Claim tag implemented, 0 = not implemented
Write: 1 = Set claim tag bit, 0 = no effect</description>
                </bitField>
            </register>
            <register name="DEBUG_FTM_CLAIMTAGCLR" offset="0xf880bfa4" size="0x2">
                <gui_name language="en">CLAIMTAGCLR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="CLAIMTAGCLRVAL">
                    <gui_name language="en">CLAIMTAGCLRVAL</gui_name>
                    <description language="en">Read: value of CLAIMTAGSETVAL
Write: 1 = Clear claim tag bit, 0 = no effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_FTM_LOCK_ACCESS" offset="0xf880bfb0" size="0x4">
                <gui_name language="en">LOCK_ACCESS</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="LOCKACCESS">
                    <gui_name language="en">LOCKACCESS</gui_name>
                    <description language="en">A value of 0xC5ACCE55 allows write access to FTM, any other value blocks write access</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_LOCK_STATUS" offset="0xf880bfb4" size="0x2">
                <gui_name language="en">LOCK_STATUS</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BITACCESS">
                    <gui_name language="en">n8BITACCESS</gui_name>
                    <description language="en">8-bit lock access is not used</description>
                </bitField>
                <bitField access="Read Only" enumerationId="LOCK_STATUS_LOCKSTATUS_ENUM" high_bit="1" low_bit="1" name="LOCKSTATUS">
                    <gui_name language="en">LOCKSTATUS</gui_name>
                    <description language="en">1 = Access Locked, 0 = Access OK</description>
                </bitField>
                <bitField access="Read Only" enumerationId="LOCK_STATUS_LOCKIMP_ENUM" high_bit="0" low_bit="0" name="LOCKIMP">
                    <gui_name language="en">LOCKIMP</gui_name>
                    <description language="en">1 = Lock exists if PADDRDBG31 is low, else 0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMAUTHSTATUS" offset="0xf880bfb8" size="0x2">
                <gui_name language="en">FTMAUTHSTATUS</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="6" name="AUTH_SPNIDEN">
                    <gui_name language="en">AUTH_SPNIDEN</gui_name>
                    <description language="en">Secure Non-Invasive Debug</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="2" name="AUTH_NIDEN">
                    <gui_name language="en">AUTH_NIDEN</gui_name>
                    <description language="en">Non-Secure Non-Invasive Debug</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMDEVID" offset="0xf880bfc8" size="0x2">
                <gui_name language="en">FTMDEVID</gui_name>
                <description language="en">Device Configuration Register</description>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMDEV_TYPE" offset="0xf880bfcc" size="0x2">
                <gui_name language="en">FTMDEV_TYPE</gui_name>
                <description language="en">Device Type Identification Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="SubType">
                    <gui_name language="en">SubType</gui_name>
                    <description language="en">Sub Type: Associated with a Data Engine or Co-processor</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="MajorType">
                    <gui_name language="en">MajorType</gui_name>
                    <description language="en">Major Type: Trace Source</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID4" offset="0xf880bfd0" size="0x2">
                <gui_name language="en">FTMPERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KBCount">
                    <gui_name language="en">n4KBCount</gui_name>
                    <description language="en">4KB Count</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106">
                    <gui_name language="en">JEP106</gui_name>
                    <description language="en">JEP106 Continuation Code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID5" offset="0xf880bfd4" size="0x2">
                <gui_name language="en">FTMPERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID6" offset="0xf880bfd8" size="0x2">
                <gui_name language="en">FTMPERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID7" offset="0xf880bfdc" size="0x2">
                <gui_name language="en">FTMPERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID0" offset="0xf880bfe0" size="0x2">
                <gui_name language="en">FTMPERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="PARTNUMLOWER">
                    <gui_name language="en">PARTNUMLOWER</gui_name>
                    <description language="en">Part Number Lower</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID1" offset="0xf880bfe4" size="0x2">
                <gui_name language="en">FTMPERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106">
                    <gui_name language="en">JEP106</gui_name>
                    <description language="en">JEP106 identity bits [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PARTNUMUPPER">
                    <gui_name language="en">PARTNUMUPPER</gui_name>
                    <description language="en">Part Number Upper [11:8]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID2" offset="0xf880bfe8" size="0x2">
                <gui_name language="en">FTMPERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="REVISION">
                    <gui_name language="en">REVISION</gui_name>
                    <description language="en">Revision</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">JEDEC used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106">
                    <gui_name language="en">JEP106</gui_name>
                    <description language="en">JEP106 Identity [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMPERIPHID3" offset="0xf880bfec" size="0x2">
                <gui_name language="en">FTMPERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMCOMPONID0" offset="0xf880bff0" size="0x2">
                <gui_name language="en">FTMCOMPONID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMCOMPONID1" offset="0xf880bff4" size="0x2">
                <gui_name language="en">FTMCOMPONID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="CompClass">
                    <gui_name language="en">CompClass</gui_name>
                    <description language="en">Component Class = Coresight Component</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMCOMPONID2" offset="0xf880bff8" size="0x2">
                <gui_name language="en">FTMCOMPONID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FTM_FTMCOMPONID3" offset="0xf880bffc" size="0x2">
                <gui_name language="en">FTMCOMPONID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Preamble">
                    <gui_name language="en">Preamble</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_FUNNEL" name="DEBUG_FUNNEL" offset="0xf8804000">
            <gui_name language="en">debug_funnel</gui_name>
            <description language="en">debug_funnel</description>
            <register name="DEBUG_FUNNEL_CONTROL" offset="0xf8804000" size="0x2">
                <gui_name language="en">Control</gui_name>
                <description language="en">CSTF Control Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="MinHoldTime">
                    <gui_name language="en">MinHoldTime</gui_name>
                    <description language="en">The formatting scheme can easily become inefficient if fast switching occurs, so, where possible, this must be minimized. If a source has nothing to transmit, then
another source is selected irrespective of the minimum number of cycles. Reset is 0x3. The CSTF holds for the minimum hold time and one additional cycle.
The mFunnelum value that can be entered is 0xE and this equates to 15 cycles.
0xF is reserved.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="EnableSlave7">
                    <gui_name language="en">EnableSlave7</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="EnableSlave6">
                    <gui_name language="en">EnableSlave6</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EnableSlave5">
                    <gui_name language="en">EnableSlave5</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="EnableSlave4">
                    <gui_name language="en">EnableSlave4</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="EnableSlave3">
                    <gui_name language="en">EnableSlave3</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="EnableSlave2">
                    <gui_name language="en">EnableSlave2</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="EnableSlave1">
                    <gui_name language="en">EnableSlave1</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="EnableSlave0">
                    <gui_name language="en">EnableSlave0</gui_name>
                    <description language="en">Setting this bit enables this slave port. If the bit is not set then this has the effect of excluding the port from the priority selection scheme.</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_PRICONTROL" offset="0xf8804004" size="0x4">
                <gui_name language="en">PriControl</gui_name>
                <description language="en">CSTF Priority Control Register</description>
                <bitField access="Read Write" high_bit="23" low_bit="21" name="PriPort7">
                    <gui_name language="en">PriPort7</gui_name>
                    <description language="en">8th port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="18" name="PriPort6">
                    <gui_name language="en">PriPort6</gui_name>
                    <description language="en">7th port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="15" name="PriPort5">
                    <gui_name language="en">PriPort5</gui_name>
                    <description language="en">6th port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="12" name="PriPort4">
                    <gui_name language="en">PriPort4</gui_name>
                    <description language="en">5th port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="9" name="PriPort3">
                    <gui_name language="en">PriPort3</gui_name>
                    <description language="en">4th port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="6" name="PriPort2">
                    <gui_name language="en">PriPort2</gui_name>
                    <description language="en">3rd port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="PriPort1">
                    <gui_name language="en">PriPort1</gui_name>
                    <description language="en">2nd port priority value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="PriPort0">
                    <gui_name language="en">PriPort0</gui_name>
                    <description language="en">1st port priority value.</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_ITATBDATA0" offset="0xf8804eec" size="0x2">
                <gui_name language="en">ITATBDATA0</gui_name>
                <description language="en">Integration Test ATB Data 0 Register</description>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="ATDATA31">
                    <gui_name language="en">ATDATA31</gui_name>
                    <description language="en">Read the value of ATDATAS[31], set the value of ATDATAM[31]</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="ATDATA23">
                    <gui_name language="en">ATDATA23</gui_name>
                    <description language="en">Read the value of ATDATAS[23], set the value of ATDATAM[23]</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="ATDATA15">
                    <gui_name language="en">ATDATA15</gui_name>
                    <description language="en">Read the value of ATDATAS[15], set the value of ATDATAM[15]</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="ATDATA7">
                    <gui_name language="en">ATDATA7</gui_name>
                    <description language="en">Read the value of ATDATAS[7], set the value of ATDATAM[7]</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="ATDATA0">
                    <gui_name language="en">ATDATA0</gui_name>
                    <description language="en">Read the value of ATDATAS[0], set the value of ATDATAM[0]</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_ITATBCTR2" offset="0xf8804ef0" size="0x2">
                <gui_name language="en">ITATBCTR2</gui_name>
                <description language="en">Integration Test ATB Control 2 Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="AFREADY">
                    <gui_name language="en">AFREADY</gui_name>
                    <description language="en">Read the value of AFVALIDM. Set the value of AFVALIDS&lt;n&gt;, where &lt;n&gt; is defined by the status of the CSTF Control Register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Read the value of ATREADYM. Set the value of ATREADYS&lt;n&gt;, where &lt;n&gt; is defined by the status of the CSTF Control Register.</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_ITATBCTR1" offset="0xf8804ef4" size="0x2">
                <gui_name language="en">ITATBCTR1</gui_name>
                <description language="en">Integration Test ATB Control 1 Register</description>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="ATID">
                    <gui_name language="en">ATID</gui_name>
                    <description language="en">Read the value of ATIDS. Set the value of ATIDM.</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_ITATBCTR0" offset="0xf8804ef8" size="0x2">
                <gui_name language="en">ITATBCTR0</gui_name>
                <description language="en">Integration Test ATB Control 0 Register</description>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ATBYTES">
                    <gui_name language="en">ATBYTES</gui_name>
                    <description language="en">Read the value of ATBYTESS&lt;n&gt;. Set the value of ATBYTESM.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="AFREADY">
                    <gui_name language="en">AFREADY</gui_name>
                    <description language="en">Read the value of AFREADYS&lt;n&gt;. Set the value of AFREADYM.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="ATVALID">
                    <gui_name language="en">ATVALID</gui_name>
                    <description language="en">Read the value of ATVALIDS&lt;n&gt;. Set the value of ATVALIDM.</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_IMCR" offset="0xf8804f00" size="0x2">
                <gui_name language="en">IMCR</gui_name>
                <description language="en">Integration Mode Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable Integration Test registers.</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_CTSR" offset="0xf8804fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_FUNNEL_CTCR" offset="0xf8804fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_FUNNEL_LAR" offset="0xf8804fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), Funnel is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
Funnel is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_LSR" offset="0xf8804fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since Funnel implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether Funnel is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_ASR" offset="0xf8804fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Indicates functionality not implemented</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_DEVID" offset="0xf8804fc8" size="0x2">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="StaticPrio">
                    <gui_name language="en">StaticPrio</gui_name>
                    <description language="en">CSTF implemts a static priority scheme</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="NumInPorts">
                    <gui_name language="en">NumInPorts</gui_name>
                    <description language="en">Number of input ports</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_DTIR" offset="0xf8804fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">a trace link and specifically a funnel/router</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID4" offset="0xf8804fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID5" offset="0xf8804fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID6" offset="0xf8804fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID7" offset="0xf8804fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID0" offset="0xf8804fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID1" offset="0xf8804fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID2" offset="0xf8804fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_PERIPHID3" offset="0xf8804fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_COMPID0" offset="0xf8804ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_COMPID1" offset="0xf8804ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_COMPID2" offset="0xf8804ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_FUNNEL_COMPID3" offset="0xf8804ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_ITM" name="DEBUG_ITM" offset="0xf8805000">
            <gui_name language="en">debug_itm</gui_name>
            <description language="en">debug_itm</description>
            <register name="DEBUG_ITM_STIMPORT00" offset="0xf8805000" size="0x4">
                <gui_name language="en">StimPort00</gui_name>
                <description language="en">Stimulus Port Register 0</description>
                <bitField access="Read Write" enumerationId="StimPort00_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT01" offset="0xf8805004" size="0x4">
                <gui_name language="en">StimPort01</gui_name>
                <description language="en">Stimulus Port Register 1</description>
                <bitField access="Read Write" enumerationId="StimPort01_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT02" offset="0xf8805008" size="0x4">
                <gui_name language="en">StimPort02</gui_name>
                <description language="en">Stimulus Port Register 2</description>
                <bitField access="Read Write" enumerationId="StimPort02_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT03" offset="0xf880500c" size="0x4">
                <gui_name language="en">StimPort03</gui_name>
                <description language="en">Stimulus Port Register 3</description>
                <bitField access="Read Write" enumerationId="StimPort03_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT04" offset="0xf8805010" size="0x4">
                <gui_name language="en">StimPort04</gui_name>
                <description language="en">Stimulus Port Register 4</description>
                <bitField access="Read Write" enumerationId="StimPort04_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT05" offset="0xf8805014" size="0x4">
                <gui_name language="en">StimPort05</gui_name>
                <description language="en">Stimulus Port Register 5</description>
                <bitField access="Read Write" enumerationId="StimPort05_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT06" offset="0xf8805018" size="0x4">
                <gui_name language="en">StimPort06</gui_name>
                <description language="en">Stimulus Port Register 6</description>
                <bitField access="Read Write" enumerationId="StimPort06_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT07" offset="0xf880501c" size="0x4">
                <gui_name language="en">StimPort07</gui_name>
                <description language="en">Stimulus Port Register 7</description>
                <bitField access="Read Write" enumerationId="StimPort07_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT08" offset="0xf8805020" size="0x4">
                <gui_name language="en">StimPort08</gui_name>
                <description language="en">Stimulus Port Register 8</description>
                <bitField access="Read Write" enumerationId="StimPort08_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT09" offset="0xf8805024" size="0x4">
                <gui_name language="en">StimPort09</gui_name>
                <description language="en">Stimulus Port Register 9</description>
                <bitField access="Read Write" enumerationId="StimPort09_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT10" offset="0xf8805028" size="0x4">
                <gui_name language="en">StimPort10</gui_name>
                <description language="en">Stimulus Port Register 10</description>
                <bitField access="Read Write" enumerationId="StimPort10_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT11" offset="0xf880502c" size="0x4">
                <gui_name language="en">StimPort11</gui_name>
                <description language="en">Stimulus Port Register 11</description>
                <bitField access="Read Write" enumerationId="StimPort11_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT12" offset="0xf8805030" size="0x4">
                <gui_name language="en">StimPort12</gui_name>
                <description language="en">Stimulus Port Register 12</description>
                <bitField access="Read Write" enumerationId="StimPort12_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT13" offset="0xf8805034" size="0x4">
                <gui_name language="en">StimPort13</gui_name>
                <description language="en">Stimulus Port Register 13</description>
                <bitField access="Read Write" enumerationId="StimPort13_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT14" offset="0xf8805038" size="0x4">
                <gui_name language="en">StimPort14</gui_name>
                <description language="en">Stimulus Port Register 14</description>
                <bitField access="Read Write" enumerationId="StimPort14_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT15" offset="0xf880503c" size="0x4">
                <gui_name language="en">StimPort15</gui_name>
                <description language="en">Stimulus Port Register 15</description>
                <bitField access="Read Write" enumerationId="StimPort15_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT16" offset="0xf8805040" size="0x4">
                <gui_name language="en">StimPort16</gui_name>
                <description language="en">Stimulus Port Register 16</description>
                <bitField access="Read Write" enumerationId="StimPort16_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT17" offset="0xf8805044" size="0x4">
                <gui_name language="en">StimPort17</gui_name>
                <description language="en">Stimulus Port Register 17</description>
                <bitField access="Read Write" enumerationId="StimPort17_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT18" offset="0xf8805048" size="0x4">
                <gui_name language="en">StimPort18</gui_name>
                <description language="en">Stimulus Port Register 18</description>
                <bitField access="Read Write" enumerationId="StimPort18_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT19" offset="0xf880504c" size="0x4">
                <gui_name language="en">StimPort19</gui_name>
                <description language="en">Stimulus Port Register 19</description>
                <bitField access="Read Write" enumerationId="StimPort19_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT20" offset="0xf8805050" size="0x4">
                <gui_name language="en">StimPort20</gui_name>
                <description language="en">Stimulus Port Register 20</description>
                <bitField access="Read Write" enumerationId="StimPort20_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT21" offset="0xf8805054" size="0x4">
                <gui_name language="en">StimPort21</gui_name>
                <description language="en">Stimulus Port Register 21</description>
                <bitField access="Read Write" enumerationId="StimPort21_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT22" offset="0xf8805058" size="0x4">
                <gui_name language="en">StimPort22</gui_name>
                <description language="en">Stimulus Port Register 22</description>
                <bitField access="Read Write" enumerationId="StimPort22_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT23" offset="0xf880505c" size="0x4">
                <gui_name language="en">StimPort23</gui_name>
                <description language="en">Stimulus Port Register 23</description>
                <bitField access="Read Write" enumerationId="StimPort23_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT24" offset="0xf8805060" size="0x4">
                <gui_name language="en">StimPort24</gui_name>
                <description language="en">Stimulus Port Register 24</description>
                <bitField access="Read Write" enumerationId="StimPort24_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT25" offset="0xf8805064" size="0x4">
                <gui_name language="en">StimPort25</gui_name>
                <description language="en">Stimulus Port Register 25</description>
                <bitField access="Read Write" enumerationId="StimPort25_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT26" offset="0xf8805068" size="0x4">
                <gui_name language="en">StimPort26</gui_name>
                <description language="en">Stimulus Port Register 26</description>
                <bitField access="Read Write" enumerationId="StimPort26_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT27" offset="0xf880506c" size="0x4">
                <gui_name language="en">StimPort27</gui_name>
                <description language="en">Stimulus Port Register 27</description>
                <bitField access="Read Write" enumerationId="StimPort27_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT28" offset="0xf8805070" size="0x4">
                <gui_name language="en">StimPort28</gui_name>
                <description language="en">Stimulus Port Register 28</description>
                <bitField access="Read Write" enumerationId="StimPort28_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT29" offset="0xf8805074" size="0x4">
                <gui_name language="en">StimPort29</gui_name>
                <description language="en">Stimulus Port Register 29</description>
                <bitField access="Read Write" enumerationId="StimPort29_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT30" offset="0xf8805078" size="0x4">
                <gui_name language="en">StimPort30</gui_name>
                <description language="en">Stimulus Port Register 30</description>
                <bitField access="Read Write" enumerationId="StimPort30_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_STIMPORT31" offset="0xf880507c" size="0x4">
                <gui_name language="en">StimPort31</gui_name>
                <description language="en">Stimulus Port Register 31</description>
                <bitField access="Read Write" enumerationId="StimPort31_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each of the 32 stimulus ports is represented by a virtual address, creating 32 stimulus registers. A write to one of these locations causes data to be written into the FIFO if the corresponding bit in the Trace Enable Register is set and ITM is enabled. Reading from any of the stimulus ports returns the FIFO status (notFull(1) / Full(0)) only if the ITM is enabled. This enables more efficient core register allocation because the stimulus
address has already been generated.
The ITM transmits SWIT packets using leading zero compression. Packets can be 8, 16, or 32 bits.
The bank of 32 registers is split into a low-16 (0 to 15) and a high-16 (16 to 31). Writes to the high-16 are discarded by the ITM whenever secure non-invasive trace is disabled, regardless of how the Trace Enable Register bits [31:16] are set. Both the high-16 and
low-16 are be disabled when non-invasive trace is disabled. When an input is disabled it must not alter the interface response and must always return an OK without stalling.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_TER" offset="0xf8805e00" size="0x4">
                <gui_name language="en">TER</gui_name>
                <description language="en">Trace Enable Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Bit mask to enable tracing on ITM stimulus ports.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_TTR" offset="0xf8805e20" size="0x4">
                <gui_name language="en">TTR</gui_name>
                <description language="en">Trace Trigger Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Bit mask to enable trigger generation, TRIGOUT, on selected writes to the Stimulus Registers.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_CR" offset="0xf8805e80" size="0x4">
                <gui_name language="en">CR</gui_name>
                <description language="en">Control Register</description>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="ITMBusy">
                    <gui_name language="en">ITMBusy</gui_name>
                    <description language="en">ITM is transmitting trace and FIFO is not empty</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="16" name="TraceID">
                    <gui_name language="en">TraceID</gui_name>
                    <description language="en">ATIDM[6:0] value</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="TSPrescale">
                    <gui_name language="en">TSPrescale</gui_name>
                    <description language="en">Timestamp Prescaler</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="DWTEn">
                    <gui_name language="en">DWTEn</gui_name>
                    <description language="en">Enable DWT input port</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="SYNCEn">
                    <gui_name language="en">SYNCEn</gui_name>
                    <description language="en">Enable sync packets</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TSSEn">
                    <gui_name language="en">TSSEn</gui_name>
                    <description language="en">Enable timestamps, delta</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="ITMEn">
                    <gui_name language="en">ITMEn</gui_name>
                    <description language="en">Enable ITM Stimulus, also acts as a global enable</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_SCR" offset="0xf8805e90" size="0x2">
                <gui_name language="en">SCR</gui_name>
                <description language="en">Synchronization Control Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="SyncCount">
                    <gui_name language="en">SyncCount</gui_name>
                    <description language="en">Counter value for time between synchronization markers</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_ITTRIGOUTACK" offset="0xf8805ee4" size="0x2">
                <gui_name language="en">ITTRIGOUTACK</gui_name>
                <description language="en">Integration Test Trigger Out Acknowledge Register</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ITTRIGOUTACK">
                    <gui_name language="en">ITTRIGOUTACK</gui_name>
                    <description language="en">Read the value of TRIGOUTACK</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ITM_ITTRIGOUT" offset="0xf8805ee8" size="0x2">
                <gui_name language="en">ITTRIGOUT</gui_name>
                <description language="en">Integration Test Trigger Out Register</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ITTRIGOUT">
                    <gui_name language="en">ITTRIGOUT</gui_name>
                    <description language="en">Set the value of TRIGOUT</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ITM_ITATBDATA0" offset="0xf8805eec" size="0x2">
                <gui_name language="en">ITATBDATA0</gui_name>
                <description language="en">Integration Test ATB Data Register 0</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="ITATDATAM7">
                    <gui_name language="en">ITATDATAM7</gui_name>
                    <description language="en">Set the value of ATDATAM[7]</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ITATDATAM0">
                    <gui_name language="en">ITATDATAM0</gui_name>
                    <description language="en">Set the value of ATDATAM[0]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_ITATBCTR2" offset="0xf8805ef0" size="0x2">
                <gui_name language="en">ITATBCTR2</gui_name>
                <description language="en">Integration Test ATB Control Register 2</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ITATREADYM">
                    <gui_name language="en">ITATREADYM</gui_name>
                    <description language="en">Read the value of ATREADYM</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ITM_ITATABCTR1" offset="0xf8805ef4" size="0x2">
                <gui_name language="en">ITATABCTR1</gui_name>
                <description language="en">Integration Test ATB Control Register 1</description>
                <bitField access="Write Only" high_bit="6" low_bit="0" name="ITATIDM">
                    <gui_name language="en">ITATIDM</gui_name>
                    <description language="en">Set the value of ATIDM[6:0]</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ITM_ITATBCTR0" offset="0xf8805ef8" size="0x2">
                <gui_name language="en">ITATBCTR0</gui_name>
                <description language="en">Integration Test ATB Control Register 0</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="ITAFREADYM">
                    <gui_name language="en">ITAFREADYM</gui_name>
                    <description language="en">Set the value of AFREADYM</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ITATVALIDM">
                    <gui_name language="en">ITATVALIDM</gui_name>
                    <description language="en">Set the value of ATVALIDM</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_IMCR" offset="0xf8805f00" size="0x2">
                <gui_name language="en">IMCR</gui_name>
                <description language="en">Integration Mode Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable Integration Test registers.</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_CTSR" offset="0xf8805fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_ITM_CTCR" offset="0xf8805fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_ITM_LAR" offset="0xf8805fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), ITM is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
ITM is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_LSR" offset="0xf8805fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since ITM implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether ITM is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_ASR" offset="0xf8805fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Value is 0b1S001N00 where S is secure non-invasive debug state and N is non-secure, non-invasive debug.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_DEVID" offset="0xf8805fc8" size="0x2">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="12" low_bit="0" name="NumStimRegs">
                    <gui_name language="en">NumStimRegs</gui_name>
                    <description language="en">Number of stimulus registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_DTIR" offset="0xf8805fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Indicates a Trace Source and the stimulus is devifed from bus activity</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID4" offset="0xf8805fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID5" offset="0xf8805fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID6" offset="0xf8805fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID7" offset="0xf8805fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID0" offset="0xf8805fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID1" offset="0xf8805fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID2" offset="0xf8805fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_PERIPHID3" offset="0xf8805fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_COMPID0" offset="0xf8805ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_COMPID1" offset="0xf8805ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_COMPID2" offset="0xf8805ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_ITM_COMPID3" offset="0xf8805ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEBUG_TPIU" name="DEBUG_TPIU" offset="0xf8803000">
            <gui_name language="en">debug_tpiu</gui_name>
            <description language="en">debug_tpiu</description>
            <register name="DEBUG_TPIU_SUPPSIZE" offset="0xf8803000" size="0x4">
                <gui_name language="en">SuppSize</gui_name>
                <description language="en">Supported Port Size Register</description>
                <bitField access="Read Write" enumerationId="SuppSize_a_ENUM" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Each bit location represents a single port size that is
supported on the device, that is, 32-1 in bit locations [31:0].</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_CURRENTSIZE" offset="0xf8803004" size="0x4">
                <gui_name language="en">CurrentSize</gui_name>
                <description language="en">Current Port Size Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The Current Port Size Register has the same format as the Supported Port Sizes register but only one bit is set, and all others must be zero. Writing values with more than one bit set or setting a bit that is not indicated as supported is not supported and causes unpredictable behavior.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_SUPPTRIGMODE" offset="0xf8803100" size="0x4">
                <gui_name language="en">SuppTrigMode</gui_name>
                <description language="en">Supported Trigger Modes Register</description>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="TrgRun">
                    <gui_name language="en">TrgRun</gui_name>
                    <description language="en">Trigger Counter running. A trigger has occurred but the counter is not at zero.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="Triggered">
                    <gui_name language="en">Triggered</gui_name>
                    <description language="en">A trigger has occurred and the counter has reached zero.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="TCount8">
                    <gui_name language="en">TCount8</gui_name>
                    <description language="en">8-bit wide counter register implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Mult64k">
                    <gui_name language="en">Mult64k</gui_name>
                    <description language="en">Multiply the Trigger Counter by 65536 supported.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="Mult256">
                    <gui_name language="en">Mult256</gui_name>
                    <description language="en">Multiply the Trigger Counter by 256 supported.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="Mult16">
                    <gui_name language="en">Mult16</gui_name>
                    <description language="en">Multiply the Trigger Counter by 16 supported.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="Mult4">
                    <gui_name language="en">Mult4</gui_name>
                    <description language="en">Multiply the Trigger Counter by 4 supported.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Mult2">
                    <gui_name language="en">Mult2</gui_name>
                    <description language="en">Multiply the Trigger Counter by 2 supported.</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_TRIGCOUNT" offset="0xf8803104" size="0x2">
                <gui_name language="en">TrigCount</gui_name>
                <description language="en">Trigger Counter Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="TrigCount">
                    <gui_name language="en">TrigCount</gui_name>
                    <description language="en">8-bit counter value for the number of words to be output from the formatter before a trigger is inserted.</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_TRIGMULT" offset="0xf8803108" size="0x2">
                <gui_name language="en">TrigMult</gui_name>
                <description language="en">Trigger Multiplier Register</description>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="Mult64k">
                    <gui_name language="en">Mult64k</gui_name>
                    <description language="en">Multiply the Trigger Counter by 65536.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Mult256">
                    <gui_name language="en">Mult256</gui_name>
                    <description language="en">Multiply the Trigger Counter by 256.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="Mult16">
                    <gui_name language="en">Mult16</gui_name>
                    <description language="en">Multiply the Trigger Counter by 16.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="Mult4">
                    <gui_name language="en">Mult4</gui_name>
                    <description language="en">Multiply the Trigger Counter by 4.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="Mult2">
                    <gui_name language="en">Mult2</gui_name>
                    <description language="en">Multiply the Trigger Counter by 2.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_SUPPTEST" offset="0xf8803200" size="0x4">
                <gui_name language="en">SuppTest</gui_name>
                <description language="en">Supported Test Patterns/Modes Register</description>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="PContEn">
                    <gui_name language="en">PContEn</gui_name>
                    <description language="en">Continuous mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="PTimeEn">
                    <gui_name language="en">PTimeEn</gui_name>
                    <description language="en">Timed mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="PatF0">
                    <gui_name language="en">PatF0</gui_name>
                    <description language="en">FF/00 Pattern</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="PatA5">
                    <gui_name language="en">PatA5</gui_name>
                    <description language="en">AA/55 Pattern</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="PatW0">
                    <gui_name language="en">PatW0</gui_name>
                    <description language="en">Walking 0s Pattern</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="PatW1">
                    <gui_name language="en">PatW1</gui_name>
                    <description language="en">Walking 1s Pattern</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_CURRENTTEST" offset="0xf8803204" size="0x4">
                <gui_name language="en">CurrentTest</gui_name>
                <description language="en">Current Test Patterns/Modes Register
Only one of the modes can be set using bits 17-16, but a multiple number of bits for the patterns can be set using bits 3-0.</description>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="PContEn">
                    <gui_name language="en">PContEn</gui_name>
                    <description language="en">Continuous mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="PTimeEn">
                    <gui_name language="en">PTimeEn</gui_name>
                    <description language="en">Timed mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PatF0">
                    <gui_name language="en">PatF0</gui_name>
                    <description language="en">FF/00 Pattern</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PatA5">
                    <gui_name language="en">PatA5</gui_name>
                    <description language="en">AA/55 Pattern</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PatW0">
                    <gui_name language="en">PatW0</gui_name>
                    <description language="en">Walking 0s Pattern</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PatW1">
                    <gui_name language="en">PatW1</gui_name>
                    <description language="en">Walking 1s Pattern</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_TESTREPEATCOUNT" offset="0xf8803208" size="0x2">
                <gui_name language="en">TestRepeatCount</gui_name>
                <description language="en">TPIU Test Pattern Repeat Counter Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="PattCount">
                    <gui_name language="en">PattCount</gui_name>
                    <description language="en">8-bit counter value to indicate the number of TRACECLKIN cycles that a pattern runs for before switching to the next pattern.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_FFSR" offset="0xf8803300" size="0x2">
                <gui_name language="en">FFSR</gui_name>
                <description language="en">Formatter and Flush Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="TCPresent">
                    <gui_name language="en">TCPresent</gui_name>
                    <description language="en">If this bit is set then TRACECTL is present.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="FtStopped">
                    <gui_name language="en">FtStopped</gui_name>
                    <description language="en">Formatter stopped.
The formatter has received a stop request signal and all trace data and post-amble has been output. Any more trace data on the ATB interface is ignored and ATREADYS goes HIGH.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="FlInProg">
                    <gui_name language="en">FlInProg</gui_name>
                    <description language="en">Flush In Progress. This is an indication of the current state of AFVALIDS.</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_FFCR" offset="0xf8803304" size="0x2">
                <gui_name language="en">FFCR</gui_name>
                <description language="en">Formatter and Flush Control Register</description>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="StopTrig">
                    <gui_name language="en">StopTrig</gui_name>
                    <description language="en">Stop the formatter after a Trigger Event is observed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="StopFl">
                    <gui_name language="en">StopFl</gui_name>
                    <description language="en">Stop the formatter after a flush completes (return of AFREADYS). This forces the FIFO to drain off any part-completed packets.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="TrigFl">
                    <gui_name language="en">TrigFl</gui_name>
                    <description language="en">Indicates a trigger on Flush completion on AFREADYS being returned.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TrigEvt">
                    <gui_name language="en">TrigEvt</gui_name>
                    <description language="en">Indicates a trigger on a Trigger Event.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TrigIn">
                    <gui_name language="en">TrigIn</gui_name>
                    <description language="en">Indicates a trigger on TRIGIN being asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="FOnMan">
                    <gui_name language="en">FOnMan</gui_name>
                    <description language="en">Manually generate a flush of the system. Setting this bit causes a flush to be generated. This is cleared when this flush has been serviced.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="FOnTrig">
                    <gui_name language="en">FOnTrig</gui_name>
                    <description language="en">Generate a flush using Trigger event.
Set this bit to cause a flush of data in the system when a Trigger Event occurs.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="FOnFlIn">
                    <gui_name language="en">FOnFlIn</gui_name>
                    <description language="en">Generate flush using the FLUSHIN interface. Set this bit to enable use of the FLUSHIN connection.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="EnFCont">
                    <gui_name language="en">EnFCont</gui_name>
                    <description language="en">Continuous Formatting, no TRACECTL. Embed in trigger packets and indicate null cycles using Sync packets. Can only be changed when FtStopped is HIGH.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="EnFTC">
                    <gui_name language="en">EnFTC</gui_name>
                    <description language="en">Enable Formatting. Do not embed Triggers into the formatted stream. Trace disable cycles and triggers are indicated by TRACECTL, where fitted. Can only be changed when FtStopped is HIGH.</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_FORMATSYNCCOUNT" offset="0xf8803308" size="0x2">
                <gui_name language="en">FormatSyncCount</gui_name>
                <description language="en">Formatter Synchronization Counter Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="0" name="CycCount">
                    <gui_name language="en">CycCount</gui_name>
                    <description language="en">12-bit counter value to indicate the number of complete frames between full synchronization packets.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_EXTCTLIN" offset="0xf8803400" size="0x2">
                <gui_name language="en">EXTCTLIn</gui_name>
                <description language="en">EXTCTL In Port</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Tied to 0</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_EXTCTLOUT" offset="0xf8803404" size="0x2">
                <gui_name language="en">EXTCTLOut</gui_name>
                <description language="en">EXTCTL Out Port</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Output not connected</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_TPIU_ITTRFLINACK" offset="0xf8803ee4" size="0x2">
                <gui_name language="en">ITTRFLINACK</gui_name>
                <description language="en">Integration Test Trigger In and Flush In Acknowledge Register</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="FLUSHINACK">
                    <gui_name language="en">FLUSHINACK</gui_name>
                    <description language="en">Set the value of FLUSHINACK</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="TRIGINACK">
                    <gui_name language="en">TRIGINACK</gui_name>
                    <description language="en">Set the value of TRIGINACK</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_ITTRFLIN" offset="0xf8803ee8" size="0x2">
                <gui_name language="en">ITTRFLIN</gui_name>
                <description language="en">Integration Test Trigger In and Flush In Register</description>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="FLUSHIN">
                    <gui_name language="en">FLUSHIN</gui_name>
                    <description language="en">Read the value of FLUSHIN</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="TRIGIN">
                    <gui_name language="en">TRIGIN</gui_name>
                    <description language="en">Read the value of TRIGIN</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_ITATBDATA0" offset="0xf8803eec" size="0x2">
                <gui_name language="en">ITATBDATA0</gui_name>
                <description language="en">Integration Test ATB Data Register 0</description>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="ATDATA31">
                    <gui_name language="en">ATDATA31</gui_name>
                    <description language="en">Read the value of ATDATAS[31]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="ATDATA23">
                    <gui_name language="en">ATDATA23</gui_name>
                    <description language="en">Read the value of ATDATAS[23]</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="ATDATA15">
                    <gui_name language="en">ATDATA15</gui_name>
                    <description language="en">Read the value of ATDATAS[15]</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="ATDATA7">
                    <gui_name language="en">ATDATA7</gui_name>
                    <description language="en">Read the value of ATDATAS[7]</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATDATA0">
                    <gui_name language="en">ATDATA0</gui_name>
                    <description language="en">Read the value of ATDATAS[0]</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_TPIU_ITATBCTR2" offset="0xf8803ef0" size="0x2">
                <gui_name language="en">ITATBCTR2</gui_name>
                <description language="en">Integration Test ATB Control Register 2</description>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="AFVALID">
                    <gui_name language="en">AFVALID</gui_name>
                    <description language="en">Set the value of AFVALIDS</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="ATREADY">
                    <gui_name language="en">ATREADY</gui_name>
                    <description language="en">Set the value of ATREADYS</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_ITATBCTR1" offset="0xf8803ef4" size="0x2">
                <gui_name language="en">ITATBCTR1</gui_name>
                <description language="en">Integration Test ATB Control Register 1</description>
                <bitField access="Read Only" high_bit="6" low_bit="0" name="ATID">
                    <gui_name language="en">ATID</gui_name>
                    <description language="en">Read the value of ATIDS</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_ITATBCTR0" offset="0xf8803ef8" size="0x2">
                <gui_name language="en">ITATBCTR0</gui_name>
                <description language="en">Integration Test ATB Control Register 0</description>
                <bitField access="Read Only" high_bit="9" low_bit="8" name="ATBYTES">
                    <gui_name language="en">ATBYTES</gui_name>
                    <description language="en">Read the value of ATBYTESS</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AFREADY">
                    <gui_name language="en">AFREADY</gui_name>
                    <description language="en">Read the value of AFREADYS</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ATVALID">
                    <gui_name language="en">ATVALID</gui_name>
                    <description language="en">Read the value of ATVALIDS</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_IMCR" offset="0xf8803f00" size="0x2">
                <gui_name language="en">IMCR</gui_name>
                <description language="en">Integration Mode Control Register</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Enable Integration Test registers</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_CTSR" offset="0xf8803fa0" size="0x2">
                <gui_name language="en">CTSR</gui_name>
                <description language="en">Claim Tag Set Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read:
1= Claim tag is implemented, 0 = Claim tag is not implemented
Write:
1= Set claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register name="DEBUG_TPIU_CTCR" offset="0xf8803fa4" size="0x2">
                <gui_name language="en">CTCR</gui_name>
                <description language="en">Claim Tag Clear Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The claim tag register is used for any interrogating tools to determine if the device is being programmed or has been programmed.
Read: Current value of claim tag.
Write: 1= Clear claim tag bit, 0= No effect</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEBUG_TPIU_LAR" offset="0xf8803fb0" size="0x4">
                <gui_name language="en">LAR</gui_name>
                <description language="en">Lock Access Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Write Access Code.
Write behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
After reset (via PRESETDBGn), TPIU is locked, i.e., writes to all other registers using lower 2GB addresses are ignored.
To unlock, 0xC5ACCE55 must be written this register.
After the required registers are written, to lock again, write a value other than 0xC5ACCE55 to this register.
- PADDRDBG31=1 (upper 2GB):
TPIU is unlocked when upper 2GB addresses are used to write to all the registers.
However, write to this register is ignored using a upper 2GB address!
Note: read from this register always returns 0, regardless of PADDRDBG31.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_LSR" offset="0xf8803fb4" size="0x2">
                <gui_name language="en">LSR</gui_name>
                <description language="en">Lock Status Register</description>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="n8BIT">
                    <gui_name language="en">n8BIT</gui_name>
                    <description language="en">Set to 0 since TPIU implements a 32-bit lock access register</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="STATUS">
                    <gui_name language="en">STATUS</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
When a lower 2GB address is used to read this register, this bit indicates whether TPIU is in locked state
(1= locked, 0= unlocked).
- PADDRDBG31=1 (upper 2GB):
always returns 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="IMP">
                    <gui_name language="en">IMP</gui_name>
                    <description language="en">Read behavior depends on PADDRDBG31 pin:
- PADDRDBG31=0 (lower 2GB):
always returns 1, meaning lock mechanism are implemented.
- PADDRDBG31=1 (upper 2GB):
always returns 0, meaning lock mechanism is NOT implemented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_ASR" offset="0xf8803fb8" size="0x2">
                <gui_name language="en">ASR</gui_name>
                <description language="en">Authentication Status Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Indicates functionality not implemented</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_DEVID" offset="0xf8803fc8" size="0x2">
                <gui_name language="en">DEVID</gui_name>
                <description language="en">Device ID</description>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="UartNRZ">
                    <gui_name language="en">UartNRZ</gui_name>
                    <description language="en">UART/NRZ not supported</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="Manchester">
                    <gui_name language="en">Manchester</gui_name>
                    <description language="en">Manchester not support</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="ClockData">
                    <gui_name language="en">ClockData</gui_name>
                    <description language="en">Trace clock + data is supported</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="6" name="FifoSize">
                    <gui_name language="en">FifoSize</gui_name>
                    <description language="en">FIFO size is 4</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="AsyncClock">
                    <gui_name language="en">AsyncClock</gui_name>
                    <description language="en">ATCLK and TRACECLKIN is asynchronous</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="InputMux">
                    <gui_name language="en">InputMux</gui_name>
                    <description language="en">No input multiplexing</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_DTIR" offset="0xf8803fcc" size="0x2">
                <gui_name language="en">DTIR</gui_name>
                <description language="en">Device Type Identifier Register</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">A trace sink and aspeicifically a TPIU</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID4" offset="0xf8803fd0" size="0x2">
                <gui_name language="en">PERIPHID4</gui_name>
                <description language="en">Peripheral ID4</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="n4KB_count">
                    <gui_name language="en">n4KB_count</gui_name>
                    <description language="en">4KB Count, set to 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 continuation code</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID5" offset="0xf8803fd4" size="0x2">
                <gui_name language="en">PERIPHID5</gui_name>
                <description language="en">Peripheral ID5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID6" offset="0xf8803fd8" size="0x2">
                <gui_name language="en">PERIPHID6</gui_name>
                <description language="en">Peripheral ID6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID7" offset="0xf8803fdc" size="0x2">
                <gui_name language="en">PERIPHID7</gui_name>
                <description language="en">Peripheral ID7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID0" offset="0xf8803fe0" size="0x2">
                <gui_name language="en">PERIPHID0</gui_name>
                <description language="en">Peripheral ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">PartNumber0</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID1" offset="0xf8803fe4" size="0x2">
                <gui_name language="en">PERIPHID1</gui_name>
                <description language="en">Peripheral ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [3:0]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="PartNumber1">
                    <gui_name language="en">PartNumber1</gui_name>
                    <description language="en">PartNumber1</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID2" offset="0xf8803fe8" size="0x2">
                <gui_name language="en">PERIPHID2</gui_name>
                <description language="en">Peripheral ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevNum">
                    <gui_name language="en">RevNum</gui_name>
                    <description language="en">Revision number of Peripheral</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="JEDEC">
                    <gui_name language="en">JEDEC</gui_name>
                    <description language="en">Indicates that a JEDEC assigned value is used</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="JEP106ID">
                    <gui_name language="en">JEP106ID</gui_name>
                    <description language="en">JEP106 Identity Code [6:4]</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_PERIPHID3" offset="0xf8803fec" size="0x2">
                <gui_name language="en">PERIPHID3</gui_name>
                <description language="en">Peripheral ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="RevAnd">
                    <gui_name language="en">RevAnd</gui_name>
                    <description language="en">RevAnd, at top level</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="CustMod">
                    <gui_name language="en">CustMod</gui_name>
                    <description language="en">Customer Modified</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_COMPID0" offset="0xf8803ff0" size="0x2">
                <gui_name language="en">COMPID0</gui_name>
                <description language="en">Component ID0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_COMPID1" offset="0xf8803ff4" size="0x2">
                <gui_name language="en">COMPID1</gui_name>
                <description language="en">Component ID1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_COMPID2" offset="0xf8803ff8" size="0x2">
                <gui_name language="en">COMPID2</gui_name>
                <description language="en">Component ID2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEBUG_TPIU_COMPID3" offset="0xf8803ffc" size="0x2">
                <gui_name language="en">COMPID3</gui_name>
                <description language="en">Component ID3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Preamble</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DEVCFG" name="DEVCFG" offset="0xf8007000">
            <gui_name language="en">devcfg</gui_name>
            <description language="en">devcfg</description>
            <register name="DEVCFG_CTRL" offset="0xf8007000" size="0x4">
                <gui_name language="en">CTRL</gui_name>
                <description language="en">Control Register : This register defines basic control registers.
Some of the register bits can be locked by control bits in the LOCK Register 0x004.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="FORCE_RST">
                    <gui_name language="en">FORCE_RST</gui_name>
                    <description language="en">Force PS in to secure reset</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="PCFG_PROG_B">
                    <gui_name language="en">PCFG_PROG_B</gui_name>
                    <description language="en">Program Signal used to reset FPGA.
It is used to drive pcfg_program signal to FPGA.
It acts as PROG_b signal in FPGA fabric.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_PCFG_POR_CNT_4K_ENUM" high_bit="29" low_bit="29" name="PCFG_POR_CNT_4K">
                    <gui_name language="en">PCFG_POR_CNT_4K</gui_name>
                    <description language="en">This is to indicate to the FPGA fabric what timer to use
0 - use 64K timer
1 - use 4K timer</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_PCAP_PR_ENUM" high_bit="27" low_bit="27" name="PCAP_PR">
                    <gui_name language="en">PCAP_PR</gui_name>
                    <description language="en">This signal is used to enable Internal Partial Re-Configuration from PCAP. Default internal Partial Reconfiguration Path is through ICAP. In order to use PCAP or ICAP Partial Reconfiguration, FPGA configuration memory bit ICAP_EN bit must be set through FPGA bitstream
0 - ICAP as Internal FPGA Partial Reconfiguration Path
1 - PCAP as Internal
FPGA Partial Reconfiguration Path
This bit will be forced to 0 if APB unlock (0x034) is not done correctly</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="PCAP_MODE">
                    <gui_name language="en">PCAP_MODE</gui_name>
                    <description language="en">Enable PCAP interface and disable all FPGA external programming interface</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="QUARTER_PCAP_RATE_EN">
                    <gui_name language="en">QUARTER_PCAP_RATE_EN</gui_name>
                    <description language="en">This bit is used to force only one data is send data to FPGA every 4 PCAP clock cycles by toggling chip select output every 4 clock cycles. This is required when AES engine in FPGA is enabled for bitstream decryption. But it should also work in normal mode with quarter throughput although it is not recommended method to reduce throughput</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_MULTIBOOT_EN_ENUM" high_bit="24" low_bit="24" name="MULTIBOOT_EN">
                    <gui_name language="en">MULTIBOOT_EN</gui_name>
                    <description language="en">This bit enables multi-boot out of reset. This is power on reset register
0 - Boot from default boot image base address
1 - Boot from multi-boot offset address</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="JTAG_CHAIN_DIS">
                    <gui_name language="en">JTAG_CHAIN_DIS</gui_name>
                    <description language="en">This bit is used to disable JTAG Scan chain to protect JTAG access to FPGA Fabric</description>
                </bitField>
                <bitField access="Write Only" enumerationId="CTRL_USER_MODE_ENUM" high_bit="15" low_bit="15" name="USER_MODE">
                    <gui_name language="en">USER_MODE</gui_name>
                    <description language="en">Indicates which mode the CPU is running
0 - CPU is running in ROM Mode
1 - CPU is running in User Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="RD_ISS_IS_1">
                    <gui_name language="en">RD_ISS_IS_1</gui_name>
                    <description language="en">AXI read issuing capability is 1, if set, else the issuing capability is determined by bit 3 of the Config Register at offset 0x008</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="WR_ISS_IS_1">
                    <gui_name language="en">WR_ISS_IS_1</gui_name>
                    <description language="en">AXI write issuing capability is 1, if set, else the issuing capability is determined by bit 2 of Config Register at offset 0x008</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_PCFG_AES_FUSE_ENUM" high_bit="12" low_bit="12" name="PCFG_AES_FUSE">
                    <gui_name language="en">PCFG_AES_FUSE</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 4)
This is to indicate to the FGPA fabric the source of the AES key.
0 - BBRAM
1 - eFuse</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_PCFG_AES_EN_ENUM" high_bit="11" low_bit="9" name="PCFG_AES_EN">
                    <gui_name language="en">PCFG_AES_EN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 3)
Enable AES engine within FPGA Configuration Logic. The three bits are combined to form a single bit to enable the 'DEC' bit in FPGA configuration logic.
The three bits need to be either all 0's or 1's, any inconsistency will lead to security reset.
0 - Disable AES engine
1-
Enable AES engine
These bits will be forced to 0 if unlock (0x034) is not done correctly.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_SEU_EN_ENUM" high_bit="8" low_bit="8" name="SEU_EN">
                    <gui_name language="en">SEU_EN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 2)
This is read/write control register with locking capability.
This is set only on power on reset.
0 - Ignore SEU signal from FPGA.
1 - Reset PS when SEU is on</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CTRL_SEC_EN_ENUM" high_bit="7" low_bit="7" name="SEC_EN">
                    <gui_name language="en">SEC_EN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 1)
This bit is used to indicate whether PS is secured. Secure Boot ROM code will set this bit and locked before it passes control to user code. In that sense, this is Read Only bit from user stand point of view.
0 - PS is non-secured
1 - PS is secured</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_SPNIDEN_ENUM" high_bit="6" low_bit="6" name="SPNIDEN">
                    <gui_name language="en">SPNIDEN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 0)
Secure/priviledged Non-Invasive Debug Enable
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_SPIDEN_ENUM" high_bit="5" low_bit="5" name="SPIDEN">
                    <gui_name language="en">SPIDEN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 0)
Secure/privileged Invasive Debug Enable
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_NIDEN_ENUM" high_bit="4" low_bit="4" name="NIDEN">
                    <gui_name language="en">NIDEN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 0)
Non-Invasive Debug Enable
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_DBGEN_ENUM" high_bit="3" low_bit="3" name="DBGEN">
                    <gui_name language="en">DBGEN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 0)
Invasive Debug Enable
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CTRL_DAP_EN_ENUM" high_bit="2" low_bit="0" name="DAP_EN">
                    <gui_name language="en">DAP_EN</gui_name>
                    <description language="en">(Lockable, see 0x004, bit 0)
This is software control to signals to put ARM DAP AP into dummy bypass mode. It should be default at bypass mode when system is out of reset. Software could change its value until DBG_LOCK bit is on.
111 - Enable ARM DAP
Others - ARM DAP will be bypassed</description>
                </bitField>
            </register>
            <register name="DEVCFG_LOCK" offset="0xf8007004" size="0x4">
                <gui_name language="en">LOCK</gui_name>
                <description language="en">This register defines LOCK register used to lock changes in the Control Register 0x000 after configuration. All those LOCK register is set only register. The only way to clear those registers is power on reset signal.</description>
                <bitField access="Read Write" enumerationId="LOCK_AES_FUSE_LOCK_ENUM" high_bit="4" low_bit="4" name="AES_FUSE_LOCK">
                    <gui_name language="en">AES_FUSE_LOCK</gui_name>
                    <description language="en">This register bit is used to lock PCFG_AES_FUSE.
It requires power on reset to restore back to default 0.
0 - Open
1 - Lock</description>
                </bitField>
                <bitField access="Read Write" enumerationId="LOCK_AES_EN_LOCK_ENUM" high_bit="3" low_bit="3" name="AES_EN_LOCK">
                    <gui_name language="en">AES_EN_LOCK</gui_name>
                    <description language="en">This register is used to lock PCFG_AES_EN update. It requires power on reset to restore back to default 0.
0 - Open
1 - Lock</description>
                </bitField>
                <bitField access="Read Write" enumerationId="LOCK_SEU_LOCK_ENUM" high_bit="2" low_bit="2" name="SEU_LOCK">
                    <gui_name language="en">SEU_LOCK</gui_name>
                    <description language="en">This register is used to lock SEU_En
update. It requires power on reset to restore back to default 0.
0 - Open
1 - Lock</description>
                </bitField>
                <bitField access="Read Write" enumerationId="LOCK_SEC_LOCK_ENUM" high_bit="1" low_bit="1" name="SEC_LOCK">
                    <gui_name language="en">SEC_LOCK</gui_name>
                    <description language="en">This bit locks SEC_EN, USER_MODE. This bit is software set only. It requires power on reset to restore back to default 0.
0 - Open
1 - Locked</description>
                </bitField>
                <bitField access="Read Write" enumerationId="LOCK_DBG_LOCK_ENUM" high_bit="0" low_bit="0" name="DBG_LOCK">
                    <gui_name language="en">DBG_LOCK</gui_name>
                    <description language="en">This bit locks security configuration bits include: DAP_En,
DBGEN, DBGEN,
NIDEN, SPNIEN. This bit is software set only. It requires power on reset to restore back to default 0.
0 - Open
1 - Locked</description>
                </bitField>
            </register>
            <register name="DEVCFG_CFG" offset="0xf8007008" size="0x4">
                <gui_name language="en">CFG</gui_name>
                <description language="en">Configuration Register : This register contains configuration information for the AXI transfers, and other general setup.</description>
                <bitField access="Read Write" enumerationId="CFG_RFIFO_TH_ENUM" high_bit="11" low_bit="10" name="RFIFO_TH">
                    <gui_name language="en">RFIFO_TH</gui_name>
                    <description language="en">These two bits define Rx FIFO level that sets interrupt flag
00 - One fourth
full for read
01 - Half full for read
10 - Three fourth full for read
11 - Full for read(User could use this signal to trigger interrupt when read FIFO overflow)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_WFIFO_TH_ENUM" high_bit="9" low_bit="8" name="WFIFO_TH">
                    <gui_name language="en">WFIFO_TH</gui_name>
                    <description language="en">These two bits define Tx FIFO level that sets interrupt flag
00 - One fourth empty for write
01 - Half empty for write
10 - Three fourth empty for write
11 - empty for write</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_RCLK_EDGE_ENUM" high_bit="7" low_bit="7" name="RCLK_EDGE">
                    <gui_name language="en">RCLK_EDGE</gui_name>
                    <description language="en">Read data active clock edge
0 - falling edge
1 - rising edge</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_WCLK_EDGE_ENUM" high_bit="6" low_bit="6" name="WCLK_EDGE">
                    <gui_name language="en">WCLK_EDGE</gui_name>
                    <description language="en">Write data active clock edge
0 - falling edge
1 - rising edge</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="DISABLE_SRC_INC">
                    <gui_name language="en">DISABLE_SRC_INC</gui_name>
                    <description language="en">Disable automatic DMA AXI source address increment, if set, to allow AXI read from a keyhole address</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="DISABLE_DST_INC">
                    <gui_name language="en">DISABLE_DST_INC</gui_name>
                    <description language="en">Disable automatic DMA AXI destination address increment, if set, to allow AXI read from a keyhole address</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_RD_ISSUE_ENUM" high_bit="3" low_bit="3" name="RD_ISSUE">
                    <gui_name language="en">RD_ISSUE</gui_name>
                    <description language="en">AXI read issuing capability
0 - 4
1 - 8</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_WR_ISSUE_ENUM" high_bit="2" low_bit="2" name="WR_ISSUE">
                    <gui_name language="en">WR_ISSUE</gui_name>
                    <description language="en">AXI write issuing capability
0 - 2
1 - 4</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_RDLEN_ENUM" high_bit="1" low_bit="1" name="RDLEN">
                    <gui_name language="en">RDLEN</gui_name>
                    <description language="en">AXI read burst length
0 - burst-of-8
1 - burst-of-16</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CFG_WRLEN_ENUM" high_bit="0" low_bit="0" name="WRLEN">
                    <gui_name language="en">WRLEN</gui_name>
                    <description language="en">AXI write burst length
0 - burst-of-8
1 - burst-of-16</description>
                </bitField>
            </register>
            <register name="DEVCFG_INT_STS" offset="0xf800700c" size="0x4">
                <gui_name language="en">INT_STS</gui_name>
                <description language="en">Interrupt Status Register : This register contains interrupt status flags.
All register bits are clear on write by writing 1s to those bits that need to be cleared.
Note that individual status bits will be set if the corresponding condition is satisfied regardless of whether the interrupt mask bit in 0x010 is set.
However, external interrupt will only be generated if an interrupt status flag is set and the corresponding mask bit is not set</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="PSS_GTS_USR_B_INT">
                    <gui_name language="en">PSS_GTS_USR_B_INT</gui_name>
                    <description language="en">Tri-state IO during HIZ, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="PSS_FST_CFG_B_INT">
                    <gui_name language="en">PSS_FST_CFG_B_INT</gui_name>
                    <description language="en">First configuration done, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="PSS_GPWRDWN_B_INT">
                    <gui_name language="en">PSS_GPWRDWN_B_INT</gui_name>
                    <description language="en">Global power down, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="PSS_GTS_CFG_B_INT">
                    <gui_name language="en">PSS_GTS_CFG_B_INT</gui_name>
                    <description language="en">Tri-state IO during configuration, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="PSS_CFG_RESET_B_INT">
                    <gui_name language="en">PSS_CFG_RESET_B_INT</gui_name>
                    <description language="en">Config reset, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="AXI_WTO_INT">
                    <gui_name language="en">AXI_WTO_INT</gui_name>
                    <description language="en">AXI write address, data or response time out (&gt; 6144 cpu_1x clock cycles)</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="AXI_WERR_INT">
                    <gui_name language="en">AXI_WERR_INT</gui_name>
                    <description language="en">AXI write response error</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="AXI_RTO_INT">
                    <gui_name language="en">AXI_RTO_INT</gui_name>
                    <description language="en">AXI read address or response time out (&gt; 2048 cpu_1x clock cylces)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="AXI_RERR_INT">
                    <gui_name language="en">AXI_RERR_INT</gui_name>
                    <description language="en">AXI read response error</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="RX_FIFO_OV_INT">
                    <gui_name language="en">RX_FIFO_OV_INT</gui_name>
                    <description language="en">This bit is used to indicate that RX FIFO overflows. Incoming read data from PCAP will be dropped.
This
bit is cleared by writing a 1 to reg 0x080 bit 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="WR_FIFO_LVL_INT">
                    <gui_name language="en">WR_FIFO_LVL_INT</gui_name>
                    <description language="en">Tx FIFO level &lt; threshold, see reg 0x008</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="RD_FIFO_LVL_INT">
                    <gui_name language="en">RD_FIFO_LVL_INT</gui_name>
                    <description language="en">Rx FIFO level &gt;= threshold, see reg 0x008</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="DMA_CMD_ERR_INT">
                    <gui_name language="en">DMA_CMD_ERR_INT</gui_name>
                    <description language="en">Illegal DMA command (see description in 3.1.2)</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="DMA_Q_OV_INT">
                    <gui_name language="en">DMA_Q_OV_INT</gui_name>
                    <description language="en">DMA command queue overflows</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="DMA_DONE_INT">
                    <gui_name language="en">DMA_DONE_INT</gui_name>
                    <description language="en">This bit is used to indicate a DMA command
is done.
The bit is set either as soon as DMA is done (
PCAP may yet to finish) or both DMA and PCAP are done (see Section 3.1.2 for more details)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="D_P_DONE_INT">
                    <gui_name language="en">D_P_DONE_INT</gui_name>
                    <description language="en">Both DMA and PCAP transfers are done for intermediate and final transfers.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="P2D_LEN_ERR_INT">
                    <gui_name language="en">P2D_LEN_ERR_INT</gui_name>
                    <description language="en">Inconsistent PCAP to DMA transfer length error</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="PCFG_HMAC_ERR_INT">
                    <gui_name language="en">PCFG_HMAC_ERR_INT</gui_name>
                    <description language="en">HMAC error from FPGA</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="PCFG_SEU_ERR_INT">
                    <gui_name language="en">PCFG_SEU_ERR_INT</gui_name>
                    <description language="en">SEU status from FPGA</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="PCFG_POR_B_INT">
                    <gui_name language="en">PCFG_POR_B_INT</gui_name>
                    <description language="en">FPGA POR Indication</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PCFG_CFG_RST_INT">
                    <gui_name language="en">PCFG_CFG_RST_INT</gui_name>
                    <description language="en">Signal used to indicate FPGA under reset</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PCFG_DONE_INT">
                    <gui_name language="en">PCFG_DONE_INT</gui_name>
                    <description language="en">This is 'Done' Read-Only Status signal from FPGA</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PCFG_INIT_PE_INT">
                    <gui_name language="en">PCFG_INIT_PE_INT</gui_name>
                    <description language="en">This detects +ve edge of 'Init' signal from FPGA</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PCFG_INIT_NE_INT">
                    <gui_name language="en">PCFG_INIT_NE_INT</gui_name>
                    <description language="en">This detects -ve edge of 'Init' signal from FPGA</description>
                </bitField>
            </register>
            <register name="DEVCFG_INT_MASK" offset="0xf8007010" size="0x4">
                <gui_name language="en">INT_MASK</gui_name>
                <description language="en">Interrupt Mask Register: This register contains interrupt mask information.
Set a bit to 1 to mask the interrupt generation from the corresponding interrupting source in Interrupt Status Register 0x00C.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="M_PSS_GTS_USR_B_INT">
                    <gui_name language="en">M_PSS_GTS_USR_B_INT</gui_name>
                    <description language="en">Interrupt mask for tri-state IO during HIZ, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="M_PSS_FST_CFG_B_INT">
                    <gui_name language="en">M_PSS_FST_CFG_B_INT</gui_name>
                    <description language="en">Interrupt mask for first config done, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="M_PSS_GPWRDWN_B_INT">
                    <gui_name language="en">M_PSS_GPWRDWN_B_INT</gui_name>
                    <description language="en">Interrupt mask for global power down, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="M_PSS_GTS_CFG_B_INT">
                    <gui_name language="en">M_PSS_GTS_CFG_B_INT</gui_name>
                    <description language="en">Interrupt mask for tri-state IO in config, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="M_PSS_CFG_RESET_B_INT">
                    <gui_name language="en">M_PSS_CFG_RESET_B_INT</gui_name>
                    <description language="en">Interrupt mask for config reset, both edges</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="M_AXI_WTO_INT">
                    <gui_name language="en">M_AXI_WTO_INT</gui_name>
                    <description language="en">Interrupt mask for AXI write time out interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="M_AXI_WERR_INT">
                    <gui_name language="en">M_AXI_WERR_INT</gui_name>
                    <description language="en">Interrupt mask for AXI write response error interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="M_AXI_RTO_INT">
                    <gui_name language="en">M_AXI_RTO_INT</gui_name>
                    <description language="en">Interrupt mask for AXI read time out interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="M_AXI_RERR_INT">
                    <gui_name language="en">M_AXI_RERR_INT</gui_name>
                    <description language="en">Interrupt mask for AXI read response error interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="M_RX_FIFO_OV_INT">
                    <gui_name language="en">M_RX_FIFO_OV_INT</gui_name>
                    <description language="en">Interrupt mask for Rx FIFO overflow interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="M_WR_FIFO_LVL_INT">
                    <gui_name language="en">M_WR_FIFO_LVL_INT</gui_name>
                    <description language="en">Interrupt mask for Tx FIFO level &lt; threshold interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="M_RD_FIFO_LVL_INT">
                    <gui_name language="en">M_RD_FIFO_LVL_INT</gui_name>
                    <description language="en">Interrupt mask for Rx FIFO level &gt; threshold interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="M_DMA_CMD_ERR_INT">
                    <gui_name language="en">M_DMA_CMD_ERR_INT</gui_name>
                    <description language="en">Interrupt mask for illegal DMA command interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="M_DMA_FIFO_OV_INT">
                    <gui_name language="en">M_DMA_FIFO_OV_INT</gui_name>
                    <description language="en">Interrupt mask for DMA command FIFO overflows</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="M_DMA_DONE_INT">
                    <gui_name language="en">M_DMA_DONE_INT</gui_name>
                    <description language="en">Interrupt mask for DMA command done interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="M_D_P_DONE_INT">
                    <gui_name language="en">M_D_P_DONE_INT</gui_name>
                    <description language="en">Interrupt mask for DMA and PCAP done interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="M_P2D_LEN_ERR_INT">
                    <gui_name language="en">M_P2D_LEN_ERR_INT</gui_name>
                    <description language="en">Interrupt mask Inconsistent xfer length error interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="M_PCFG_HMAC_ERR_INT">
                    <gui_name language="en">M_PCFG_HMAC_ERR_INT</gui_name>
                    <description language="en">Interrupt mask for HMAC error</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="M_PCFG_SEU_ERR_INT">
                    <gui_name language="en">M_PCFG_SEU_ERR_INT</gui_name>
                    <description language="en">Interrupt mask for PCFG_SEU_ERR interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="M_PCFG_POR_B_INT">
                    <gui_name language="en">M_PCFG_POR_B_INT</gui_name>
                    <description language="en">Interrupt mask for PCFG_POR_B Interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="M_PCFG_CFG_RST_INT">
                    <gui_name language="en">M_PCFG_CFG_RST_INT</gui_name>
                    <description language="en">Interrupt mask for PCFG_CFG_RESET interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="M_PCFG_DONE_INT">
                    <gui_name language="en">M_PCFG_DONE_INT</gui_name>
                    <description language="en">Interrupt mask for PCFG_DONE interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="M_PCFG_INIT_PE_INT">
                    <gui_name language="en">M_PCFG_INIT_PE_INT</gui_name>
                    <description language="en">Interrupt mask for PCFG_INIT_PE interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="M_PCFG_INIT_NE_INT">
                    <gui_name language="en">M_PCFG_INIT_NE_INT</gui_name>
                    <description language="en">Interrupt mask for PCFG_INIT_NE interrupt</description>
                </bitField>
            </register>
            <register name="DEVCFG_STATUS" offset="0xf8007014" size="0x4">
                <gui_name language="en">STATUS</gui_name>
                <description language="en">Status Register: This register contains miscellaneous status.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="DMA_CMD_Q_F">
                    <gui_name language="en">DMA_CMD_Q_F</gui_name>
                    <description language="en">DMA command queue full, if set</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="DMA_CMD_Q_E">
                    <gui_name language="en">DMA_CMD_Q_E</gui_name>
                    <description language="en">DMA command queue empty, if set</description>
                </bitField>
                <bitField access="Read Write" enumerationId="STATUS_DMA_DONE_CNT_ENUM" high_bit="29" low_bit="28" name="DMA_DONE_CNT">
                    <gui_name language="en">DMA_DONE_CNT</gui_name>
                    <description language="en">Number of completed DMA transfers that have not been acknowledged by software:
00 - all finished transfers have been acknowledged
01 - one finished transfer outstanding
10 - two finished transfers outstanding
11 - three or more finished transfers outstanding
A finished transfer is acknowledged by clearing the interrupt status flag, i.e., bit 9 of the interrupt status register 0x00C.
This count is cleared by writing a 1 to either bit location.</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="20" name="RX_FIFO_LVL">
                    <gui_name language="en">RX_FIFO_LVL</gui_name>
                    <description language="en">This register is used to indicate how many valid 32-Bit words in the Rx FIFO, max. is 31</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="12" name="TX_FIFO_LVL">
                    <gui_name language="en">TX_FIFO_LVL</gui_name>
                    <description language="en">This register is used to indicate how many valid 32-Bit words in the Tx FIFO, max. is 127</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="PSS_GTS_USR_B">
                    <gui_name language="en">PSS_GTS_USR_B</gui_name>
                    <description language="en">Tri-state IO during HIZ, active low</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="PSS_FST_CFG_B">
                    <gui_name language="en">PSS_FST_CFG_B</gui_name>
                    <description language="en">First config done, active low.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="PSS_GPWRDWN_B">
                    <gui_name language="en">PSS_GPWRDWN_B</gui_name>
                    <description language="en">Global power down, active low</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="PSS_GTS_CFG_B">
                    <gui_name language="en">PSS_GTS_CFG_B</gui_name>
                    <description language="en">Tri-state IO during config, active low</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="SECURE_RST">
                    <gui_name language="en">SECURE_RST</gui_name>
                    <description language="en">This is POR only clear register used to remember secure violation reset</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="ILLEGAL_APB_ACCESS">
                    <gui_name language="en">ILLEGAL_APB_ACCESS</gui_name>
                    <description language="en">The first APB access is not done correctly, if set. POR clear</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="PSS_CFG_RESET_B">
                    <gui_name language="en">PSS_CFG_RESET_B</gui_name>
                    <description language="en">PS configuration reset, active low.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="PCFG_INIT">
                    <gui_name language="en">PCFG_INIT</gui_name>
                    <description language="en">Input signal from FPGA to indicate the init status.
+ve and -ve edge of the signal generate maskable interrupts indicated in 0x00C.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="EFUSE_SW_RESERVE">
                    <gui_name language="en">EFUSE_SW_RESERVE</gui_name>
                    <description language="en">Input signal from FPGA to indicate efuse status. This register is sticky to high.
Value depends on the efuse state.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="EFUSE_SEC_EN">
                    <gui_name language="en">EFUSE_SEC_EN</gui_name>
                    <description language="en">Input signal from FPGA to indicate efuse status. This register is sticky to high.
Value depends on the efuse state.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="EFUSE_JTAG_DIS">
                    <gui_name language="en">EFUSE_JTAG_DIS</gui_name>
                    <description language="en">Input signal from FPGA to indicate efuse status. This register is sticky to high.
Value depends on the efuse state.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="SECURE_DIS">
                    <gui_name language="en">SECURE_DIS</gui_name>
                    <description language="en">Indicate security is disabled, if asserted. CPU should check this signal first before boot sequence starts. If this signal is asserted, CPU will enter halt mode immediately</description>
                </bitField>
            </register>
            <register name="DEVCFG_DMA_SRC_ADDR" offset="0xf8007018" size="0x4">
                <gui_name language="en">DMA_SRC_ADDR</gui_name>
                <description language="en">DMA Source address Register: This register contains the source address for DMA transfer.
A DMA command consists of source address, destination address, source transfer length, and destination transfer length.
It is important that the parameters are programmed in the exact sequence as described</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ADDR">
                    <gui_name language="en">ADDR</gui_name>
                    <description language="en">Source address for DMA transfer of AXI read</description>
                </bitField>
            </register>
            <register name="DEVCFG_DMA_DST_ADDR" offset="0xf800701c" size="0x4">
                <gui_name language="en">DMA_DST_ADDR</gui_name>
                <description language="en">DMA Destination address Register: This register contains the destination address for DMA transfer.
A DMA command consists of source address, destination address, source transfer length, and destination transfer length.
It is important that the parameters are programmed in the exact sequence as described.</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ADDR">
                    <gui_name language="en">ADDR</gui_name>
                    <description language="en">Destination address for DMA transfer of AXI write</description>
                </bitField>
            </register>
            <register name="DEVCFG_DMA_SRC_LEN" offset="0xf8007020" size="0x4">
                <gui_name language="en">DMA_SRC_LEN</gui_name>
                <description language="en">DMA Source transfer Length Register: This register contains the DMA source transfer length in unit of 4-byte word.
A DMA command that consists of source address, destination address, source transfer length, and destination transfer length.
It is important that the parameters are programmed in the exact sequence as described.</description>
                <bitField access="Read Write" high_bit="26" low_bit="0" name="LEN">
                    <gui_name language="en">LEN</gui_name>
                    <description language="en">Up to 512MB data</description>
                </bitField>
            </register>
            <register name="DEVCFG_DMA_DEST_LEN" offset="0xf8007024" size="0x4">
                <gui_name language="en">DMA_DEST_LEN</gui_name>
                <description language="en">DMA Destination transfer
Length Register: This register contains the DMA destination transfer length in unit of 4-byte word.
A DMA command that consists of source address, destination address, source transfer length, and destination transfer length is accepted when this register is written to.
It is important that the parameters are programmed in the exact sequence as described.</description>
                <bitField access="Read Write" high_bit="26" low_bit="0" name="LEN">
                    <gui_name language="en">LEN</gui_name>
                    <description language="en">Up to 512MB data</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEVCFG_ROM_SHADOW" offset="0xf8007028" size="0x4">
                <gui_name language="en">ROM_SHADOW</gui_name>
                <description language="en">ROM Shadow Register: This register defines ROM shadow</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="ROM_SHADOW_EN">
                    <gui_name language="en">ROM_SHADOW_EN</gui_name>
                    <description language="en">32-Bit Shadow Register controls RAM shadow of 32 4-K ROM page in user mode</description>
                </bitField>
            </register>
            <register name="DEVCFG_MULTIBOOT_ADDR" offset="0xf800702c" size="0x4">
                <gui_name language="en">MULTIBOOT_ADDR</gui_name>
                <description language="en">MULTI Boot Addr Pointer Register: This register defines multi-boot address pointer. This register is power on reset only used to remember multi-boot address pointer set by previous boot.</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="MULTIBOOT_ADDR">
                    <gui_name language="en">MULTIBOOT_ADDR</gui_name>
                    <description language="en">Multi-Boot offset address</description>
                </bitField>
            </register>
            <register name="DEVCFG_SW_ID" offset="0xf8007030" size="0x4">
                <gui_name language="en">SW_ID</gui_name>
                <description language="en">Software ID Register: This register defines PS boot software ID. It will be used by firmware and software to perform consistent check for subsequent PS software and FPGA image loads. It is both readable and writeable after reset, and it becomes read only after system has entered user mode (bit 15 of reg 0x000 is set).</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="SW_ID">
                    <gui_name language="en">SW_ID</gui_name>
                    <description language="en">Software ID</description>
                </bitField>
            </register>
            <register name="DEVCFG_UNLOCK" offset="0xf8007034" size="0x4">
                <gui_name language="en">UNLOCK</gui_name>
                <description language="en">Unlock Register: User should use this register to unlock device configuration register to prevent code corruption in ROM by writing 0x757BDF0D into this register. Power on reset</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="UNLOCK">
                    <gui_name language="en">UNLOCK</gui_name>
                    <description language="en">Unlock value.</description>
                </bitField>
            </register>
            <register name="DEVCFG_MCTRL" offset="0xf8007080" size="0x4">
                <gui_name language="en">MCTRL</gui_name>
                <description language="en">Miscellaneous control Register: This register contains miscellaneous controls.</description>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="INT_PCAP_LPBK">
                    <gui_name language="en">INT_PCAP_LPBK</gui_name>
                    <description language="en">Internal PCAP loopback, if set</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="RFIFO_FLUSH">
                    <gui_name language="en">RFIFO_FLUSH</gui_name>
                    <description language="en">Flush Rx FIFO by writing a 1 to this bit location, the value is not sticky</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="WFIFO_FLUSH">
                    <gui_name language="en">WFIFO_FLUSH</gui_name>
                    <description language="en">Flush Tx FIFO by writing a 1 to this bit location, the value is not sticky</description>
                </bitField>
            </register>
            <register name="DEVCFG_XADCIF_CFG" offset="0xf8007100" size="0x4">
                <gui_name language="en">XADCIF_CFG</gui_name>
                <description language="en">XADC Interface Configuration Register : This register configures the XADC Interface operation</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="ENABLE">
                    <gui_name language="en">ENABLE</gui_name>
                    <description language="en">Enable PS access of the XADC, if set</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="20" name="CFIFOTH">
                    <gui_name language="en">CFIFOTH</gui_name>
                    <description language="en">Command FIFO level threshold.
Interrupt status flag is set if the FIFO level is less than or equal to the threshold</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="16" name="DFIFOTH">
                    <gui_name language="en">DFIFOTH</gui_name>
                    <description language="en">Data FIFO level threshold.
Interrupt status flag is set if FIFO level is greater than the threshold</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="WEDGE">
                    <gui_name language="en">WEDGE</gui_name>
                    <description language="en">Write launch edge : 0 - falling edge, 1 - rising edge</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="REDGE">
                    <gui_name language="en">REDGE</gui_name>
                    <description language="en">Read capture edge : 0 - falling edge, 1 - rising edge</description>
                </bitField>
                <bitField access="Read Write" enumerationId="XADCIF_CFG_TCKRATE_ENUM" high_bit="9" low_bit="8" name="TCKRATE">
                    <gui_name language="en">TCKRATE</gui_name>
                    <description language="en">XADC clock frequency control.
The base frequency is pcap_2x clock which has a nominal frequency of 200 MHz.
00 - 1/2 of pcap_2x clock frequency
01 - 1/4
of pcac_2x clock frequency
10 - 1/8 of pcap_2x clock frequency
11 - 1/16 of pcap_2x clock frequency</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="0" name="IGAP">
                    <gui_name language="en">IGAP</gui_name>
                    <description language="en">Minimum idle gap between successive commands.</description>
                </bitField>
            </register>
            <register name="DEVCFG_XADCIF_INT_STS" offset="0xf8007104" size="0x4">
                <gui_name language="en">XADCIF_INT_STS</gui_name>
                <description language="en">XADC Interface Interrupt Status Register : This register contains the interrupt status flags of the XADC interface block.
All register bits are clear on write by writing 1s to those bits that need to be cleared.
Note that individual status bits will be set if the corresponding condition is satisfied regardless of whether the interrupt mask bit in 0x108 is set.
However, external interrupt will only be generated if an interrupt status flag is set and the corresponding mask bit is not set</description>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="CFIFO_LTH">
                    <gui_name language="en">CFIFO_LTH</gui_name>
                    <description language="en">Command FIFO level less than or equal to the threshold (see register 0x100).</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="DFIFO_GTH">
                    <gui_name language="en">DFIFO_GTH</gui_name>
                    <description language="en">Data FIFO level greater than threshold (see register 0x100).</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="OT">
                    <gui_name language="en">OT</gui_name>
                    <description language="en">Over temperature alarm from XADC.
This is a latched version of the raw signal which is also available in register 0x10C</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="ALM">
                    <gui_name language="en">ALM</gui_name>
                    <description language="en">Alarm signals from XADC.
These are latched version of the raw input alarm signals which are also available in register 0x10C</description>
                </bitField>
            </register>
            <register name="DEVCFG_XADCIF_INT_MASK" offset="0xf8007108" size="0x4">
                <gui_name language="en">XADCIF_INT_MASK</gui_name>
                <description language="en">XADC Interface Interrupt Mask Register : This register contains the interrupt mask information.
Set a bit to 1 to mask the interrupt generation from the corresponding interrupting source in 0x104</description>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="M_CFIFO_LTH">
                    <gui_name language="en">M_CFIFO_LTH</gui_name>
                    <description language="en">Interrupt mask for command FIFO level threshold interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="M_DFIFO_GTH">
                    <gui_name language="en">M_DFIFO_GTH</gui_name>
                    <description language="en">Interrupt mask Data FIFO level greater than threshold interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="M_OT">
                    <gui_name language="en">M_OT</gui_name>
                    <description language="en">Interrupt mask for over temperature alarm interrupt</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="M_ALM">
                    <gui_name language="en">M_ALM</gui_name>
                    <description language="en">Interrupt mask for alarm signals from XADC.</description>
                </bitField>
            </register>
            <register access="Read Only" name="DEVCFG_XADCIF_MSTS" offset="0xf800710c" size="0x4">
                <gui_name language="en">XADCIF_MSTS</gui_name>
                <description language="en">XADC Interface miscellaneous Status Register : This register contains miscellaneous status of the XADC Interface</description>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="CFIFO_LVL">
                    <gui_name language="en">CFIFO_LVL</gui_name>
                    <description language="en">Command FIFO level.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="12" name="DFIFO_LVL">
                    <gui_name language="en">DFIFO_LVL</gui_name>
                    <description language="en">Data FIFO level.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="CFIFOF">
                    <gui_name language="en">CFIFOF</gui_name>
                    <description language="en">Command FIFO full.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="CFIFOE">
                    <gui_name language="en">CFIFOE</gui_name>
                    <description language="en">Command FIFO empty.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="DFIFOF">
                    <gui_name language="en">DFIFOF</gui_name>
                    <description language="en">Data FIFO full.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="DFIFOE">
                    <gui_name language="en">DFIFOE</gui_name>
                    <description language="en">Data FIFO empty.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="OT">
                    <gui_name language="en">OT</gui_name>
                    <description language="en">Raw over temperature alarm from the XADC.
Latched version of the signal is available in the interrupt status register.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="0" name="ALM">
                    <gui_name language="en">ALM</gui_name>
                    <description language="en">Raw alarm signals from the XADC.
Latched version of the signals are available in the interrupt status register.</description>
                </bitField>
            </register>
            <register access="Write Only" name="DEVCFG_XADCIF_CMDFIFO" offset="0xf8007110" size="0x4">
                <gui_name language="en">XADCIF_CMDFIFO</gui_name>
                <description language="en">XADC Interface Command FIFO Register : This address is the entry point to the command FIFO.
Commands get push into the FIFO when there is a write to this address</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="CMD">
                    <gui_name language="en">CMD</gui_name>
                    <description language="en">32-bit command.</description>
                </bitField>
            </register>

            <register name="DEVCFG_XADCIF_MCTL" offset="0xf8007118" size="0x4">
                <gui_name language="en">XADCIF_MCTL</gui_name>
                <description language="en">XADC Interface Miscellaneous Control Register : This register provides miscellaneous control of the XADC Interface.</description>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RESET">
                    <gui_name language="en">RESET</gui_name>
                    <description language="en">This bit drives the XADC reset signal</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="FLUSH">
                    <gui_name language="en">FLUSH</gui_name>
                    <description language="en">Write to this bit location to flush the command and data FIFOs, this is a write only bit (for debugging)</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DMAC0_NS" name="DMAC0_NS" offset="0xf8004000">
            <gui_name language="en">dmac0_ns</gui_name>
            <description language="en">dmac0_ns</description>
            <register name="DMAC0_NS_DSR" offset="0xf8004000" size="0x4">
                <gui_name language="en">DSR</gui_name>
                <description language="en">DMA manager status register</description>
                <bitField access="Read Only" enumerationId="DSR_DNS_ENUM" high_bit="9" low_bit="9" name="DNS">
                    <gui_name language="en">DNS</gui_name>
                    <description language="en">Provides the security status of the DMA manager thread:
0 = DMA manager operates in the Secure state
1 = DMA manager operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DSR_Wakeup_event_ENUM" high_bit="8" low_bit="4" name="Wakeup_event">
                    <gui_name language="en">Wakeup_event</gui_name>
                    <description language="en">When the DMA manager thread executes a DMAWFE instruction, it waits for the following event to occur:
b00000 = event[0]
b00001 = event[1]
b00010 = event[2]
.
.
.
b11111 = event[31].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DSR_DMA_status_ENUM" high_bit="3" low_bit="0" name="DMA_status">
                    <gui_name language="en">DMA_status</gui_name>
                    <description language="en">The operating state of the DMA manager:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101-b1110 = reserved
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DPC" offset="0xf8004004" size="0x4">
                <gui_name language="en">DPC</gui_name>
                <description language="en">DMA Program Counter Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_mgr">
                    <gui_name language="en">pc_mgr</gui_name>
                    <description language="en">Program counter for the DMA manager thread
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_INTEN" offset="0xf8004020" size="0x4">
                <gui_name language="en">INTEN</gui_name>
                <description language="en">Interrupt enable register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="event_irq_select">
                    <gui_name language="en">event_irq_select</gui_name>
                    <description language="en">Program the appropriate bit to control how the DMAC responds when it executes DMASEV:
Bit [N] = 0 If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC signals
event N to all of the threads. Set bit [N] to 0 if your system design does not use irq[N] to
signal an interrupt request.
Bit [N] = 1 If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC sets
irq[N] HIGH. Set bit [N] to 1 if your system design requires irq[N] to signal an interrupt
request.
This bit-field has the following special access attributes:
 srw: During secure access, it is read write.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsrw: During non-secure access, if thread is non-secure, it is read write.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_INT_EVENT_RIS" offset="0xf8004024" size="0x4">
                <gui_name language="en">INT_EVENT_RIS</gui_name>
                <description language="en">Event interrupt raw status register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="DMASEV_active">
                    <gui_name language="en">DMASEV_active</gui_name>
                    <description language="en">Returns the status of the event-interrupt resources:
Bit [N] = 0 Event N is inactive or irq[N] is LOW.
Bit [N] = 1 Event N is active or irq[N] is HIGH.
Note
When the DMAC executes a DMASEV N instruction to send event N, the INTEN Register
controls whether the DMAC:
signals an interrupt using the appropriate irq
sends the event to all of the threads.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_INTMIS" offset="0xf8004028" size="0x4">
                <gui_name language="en">INTMIS</gui_name>
                <description language="en">Interrupt Status Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="irq_status">
                    <gui_name language="en">irq_status</gui_name>
                    <description language="en">Provides the status of the interrupts that are active in the DMAC:
Bit [N] = 0 Interrupt N is inactive and therefore irq[N] is LOW.
Bit [N] = 1 Interrupt N is active and therefore irq[N] is HIGH.
Note
You must use the INTCLR Register to set bit [N] to 0, see Interrupt Clear Register.
Note
Bit [N] is 0 if the INTEN Register programs DMASEV to signal an event
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_INTCLR" offset="0xf800402c" size="0x4">
                <gui_name language="en">INTCLR</gui_name>
                <description language="en">Interrupt Clear Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="irq_clr">
                    <gui_name language="en">irq_clr</gui_name>
                    <description language="en">Controls the clearing of the irq outputs:
Bit [N] = 0 The status of irq[N] does not change.
Bit [N] = 1 The DMAC sets irq[N] LOW if the INTEN Register programs the DMAC to signal an interrupt.
Otherwise, the status of irq[N] does not change.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FSRD" offset="0xf8004030" size="0x4">
                <gui_name language="en">FSRD</gui_name>
                <description language="en">Fault Status DMA Manager Register</description>
                <bitField access="Read Only" enumerationId="FSRD_fs_mgr_ENUM" high_bit="0" low_bit="0" name="fs_mgr">
                    <gui_name language="en">fs_mgr</gui_name>
                    <description language="en">Provides the fault status of the DMA manager. Read as:
0 = the DMA manager thread is not in the Faulting state
1 = the DMA manager thread is in the Faulting state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FSRC" offset="0xf8004034" size="0x4">
                <gui_name language="en">FSRC</gui_name>
                <description language="en">Fault Status DMA Channel Register</description>
                <bitField access="Read Only" enumerationId="FSRC_fault_status_ENUM" high_bit="7" low_bit="0" name="fault_status">
                    <gui_name language="en">fault_status</gui_name>
                    <description language="en">Each bit provides the fault status of the corresponding channel. Read as:
Bit [N] = 0 No fault is present on DMA channel N.
Bit [N] = 1 DMA channel N is in the Faulting or Faulting completing state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTRD" offset="0xf8004038" size="0x4">
                <gui_name language="en">FTRD</gui_name>
                <description language="en">Fault Type DMA Manager Register</description>
                <bitField access="Read Only" enumerationId="FTRD_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA manager aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA manager
performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_mgr_evnt_err_ENUM" high_bit="5" low_bit="5" name="mgr_evnt_err">
                    <gui_name language="en">mgr_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = the DMA manager has appropriate security to execute DMAWFE or DMASEV
1 = a DMA manager thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
H18DMASEV to create a secure event or secure interrupt.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_dmago_err_ENUM" high_bit="4" low_bit="4" name="dmago_err">
                    <gui_name language="en">dmago_err</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute DMAGO with inappropriate security
permissions:
0 = the DMA manager has appropriate security to execute DMAGO
1 = a DMA manager thread in the Non-secure state attempted to execute DMAGO to create a DMA channel
operating in the Secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute an instruction operand that was not valid
for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR0" offset="0xf8004040" size="0x4">
                <gui_name language="en">FTR0</gui_name>
                <description language="en">Default type for DMA channel 0</description>
                <bitField access="Read Only" enumerationId="FTR0_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR1" offset="0xf8004044" size="0x4">
                <gui_name language="en">FTR1</gui_name>
                <description language="en">Default type for DMA channel 1</description>
                <bitField access="Read Only" enumerationId="FTR1_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR2" offset="0xf8004048" size="0x4">
                <gui_name language="en">FTR2</gui_name>
                <description language="en">Default type for DMA channel 2</description>
                <bitField access="Read Only" enumerationId="FTR2_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR3" offset="0xf800404c" size="0x4">
                <gui_name language="en">FTR3</gui_name>
                <description language="en">Default type for DMA channel 3</description>
                <bitField access="Read Only" enumerationId="FTR3_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR4" offset="0xf8004050" size="0x4">
                <gui_name language="en">FTR4</gui_name>
                <description language="en">Default type for DMA channel 4</description>
                <bitField access="Read Only" enumerationId="FTR4_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR5" offset="0xf8004054" size="0x4">
                <gui_name language="en">FTR5</gui_name>
                <description language="en">Default type for DMA channel 5</description>
                <bitField access="Read Only" enumerationId="FTR5_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR6" offset="0xf8004058" size="0x4">
                <gui_name language="en">FTR6</gui_name>
                <description language="en">Default type for DMA channel 6</description>
                <bitField access="Read Only" enumerationId="FTR6_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_FTR7" offset="0xf800405c" size="0x4">
                <gui_name language="en">FTR7</gui_name>
                <description language="en">Default type for DMA channel 7</description>
                <bitField access="Read Only" enumerationId="FTR7_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR0" offset="0xf8004100" size="0x4">
                <gui_name language="en">CSR0</gui_name>
                <description language="en">Channel status for DMA channel 0</description>
                <bitField access="Read Only" enumerationId="CSR0_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC0" offset="0xf8004104" size="0x4">
                <gui_name language="en">CPC0</gui_name>
                <description language="en">Channel PC for DMA channel 0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR1" offset="0xf8004108" size="0x4">
                <gui_name language="en">CSR1</gui_name>
                <description language="en">Channel status for DMA channel 1</description>
                <bitField access="Read Only" enumerationId="CSR1_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC1" offset="0xf800410c" size="0x4">
                <gui_name language="en">CPC1</gui_name>
                <description language="en">Channel PC for DMA channel 1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR2" offset="0xf8004110" size="0x4">
                <gui_name language="en">CSR2</gui_name>
                <description language="en">Channel status for DMA channel 2</description>
                <bitField access="Read Only" enumerationId="CSR2_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC2" offset="0xf8004114" size="0x4">
                <gui_name language="en">CPC2</gui_name>
                <description language="en">Channel PC for DMA channel 2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR3" offset="0xf8004118" size="0x4">
                <gui_name language="en">CSR3</gui_name>
                <description language="en">Channel status for DMA channel 3</description>
                <bitField access="Read Only" enumerationId="CSR3_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC3" offset="0xf800411c" size="0x4">
                <gui_name language="en">CPC3</gui_name>
                <description language="en">Channel PC for DMA channel 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR4" offset="0xf8004120" size="0x4">
                <gui_name language="en">CSR4</gui_name>
                <description language="en">Channel status for DMA channel 4</description>
                <bitField access="Read Only" enumerationId="CSR4_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC4" offset="0xf8004124" size="0x4">
                <gui_name language="en">CPC4</gui_name>
                <description language="en">Channel PC for DMA channel 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR5" offset="0xf8004128" size="0x4">
                <gui_name language="en">CSR5</gui_name>
                <description language="en">Channel status for DMA channel 5</description>
                <bitField access="Read Only" enumerationId="CSR5_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC5" offset="0xf800412c" size="0x4">
                <gui_name language="en">CPC5</gui_name>
                <description language="en">Channel PC for DMA channel 5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR6" offset="0xf8004130" size="0x4">
                <gui_name language="en">CSR6</gui_name>
                <description language="en">Channel status for DMA channel 6</description>
                <bitField access="Read Only" enumerationId="CSR6_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC6" offset="0xf8004134" size="0x4">
                <gui_name language="en">CPC6</gui_name>
                <description language="en">Channel PC for DMA channel 6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CSR7" offset="0xf8004138" size="0x4">
                <gui_name language="en">CSR7</gui_name>
                <description language="en">Channel status for DMA channel 7</description>
                <bitField access="Read Only" enumerationId="CSR7_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CPC7" offset="0xf800413c" size="0x4">
                <gui_name language="en">CPC7</gui_name>
                <description language="en">Channel PC for DMA channel 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR0" offset="0xf8004400" size="0x4">
                <gui_name language="en">SAR0</gui_name>
                <description language="en">source address for DMA channel 0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR0" offset="0xf8004404" size="0x4">
                <gui_name language="en">DAR0</gui_name>
                <description language="en">destination address for DMA channel 0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR0" offset="0xf8004408" size="0x4">
                <gui_name language="en">CCR0</gui_name>
                <description language="en">channel control for DMA channel 0</description>
                <bitField access="Read Only" enumerationId="CCR0_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_0" offset="0xf800440c" size="0x4">
                <gui_name language="en">LC0_0</gui_name>
                <description language="en">loop counter 0 for DMA channel 0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_0" offset="0xf8004410" size="0x4">
                <gui_name language="en">LC1_0</gui_name>
                <description language="en">loop counter 1 for DMA channel 0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR1" offset="0xf8004420" size="0x4">
                <gui_name language="en">SAR1</gui_name>
                <description language="en">source address for DMA channel 1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR1" offset="0xf8004424" size="0x4">
                <gui_name language="en">DAR1</gui_name>
                <description language="en">destination address for DMA channel 1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR1" offset="0xf8004428" size="0x4">
                <gui_name language="en">CCR1</gui_name>
                <description language="en">channel control for DMA channel 1</description>
                <bitField access="Read Only" enumerationId="CCR1_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_1" offset="0xf800442c" size="0x4">
                <gui_name language="en">LC0_1</gui_name>
                <description language="en">loop counter 0 for DMA channel 1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_1" offset="0xf8004430" size="0x4">
                <gui_name language="en">LC1_1</gui_name>
                <description language="en">loop counter 1 for DMA channel 1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR2" offset="0xf8004440" size="0x4">
                <gui_name language="en">SAR2</gui_name>
                <description language="en">source address for DMA channel 2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR2" offset="0xf8004444" size="0x4">
                <gui_name language="en">DAR2</gui_name>
                <description language="en">destination address for DMA channel 2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR2" offset="0xf8004448" size="0x4">
                <gui_name language="en">CCR2</gui_name>
                <description language="en">channel control for DMA channel 2</description>
                <bitField access="Read Only" enumerationId="CCR2_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_2" offset="0xf800444c" size="0x4">
                <gui_name language="en">LC0_2</gui_name>
                <description language="en">loop counter 0 for DMA channel 2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_2" offset="0xf8004450" size="0x4">
                <gui_name language="en">LC1_2</gui_name>
                <description language="en">loop counter 1 for DMA channel 2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR3" offset="0xf8004460" size="0x4">
                <gui_name language="en">SAR3</gui_name>
                <description language="en">source address for DMA channel 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR3" offset="0xf8004464" size="0x4">
                <gui_name language="en">DAR3</gui_name>
                <description language="en">destination address for DMA channel 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR3" offset="0xf8004468" size="0x4">
                <gui_name language="en">CCR3</gui_name>
                <description language="en">channel control for DMA channel 3</description>
                <bitField access="Read Only" enumerationId="CCR3_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_3" offset="0xf800446c" size="0x4">
                <gui_name language="en">LC0_3</gui_name>
                <description language="en">loop counter 0 for DMA channel 3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_3" offset="0xf8004470" size="0x4">
                <gui_name language="en">LC1_3</gui_name>
                <description language="en">loop counter 1 for DMA channel 3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR4" offset="0xf8004480" size="0x4">
                <gui_name language="en">SAR4</gui_name>
                <description language="en">source address for DMA channel 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR4" offset="0xf8004484" size="0x4">
                <gui_name language="en">DAR4</gui_name>
                <description language="en">destination address for DMA channel 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR4" offset="0xf8004488" size="0x4">
                <gui_name language="en">CCR4</gui_name>
                <description language="en">channel control for DMA channel 4</description>
                <bitField access="Read Only" enumerationId="CCR4_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_4" offset="0xf800448c" size="0x4">
                <gui_name language="en">LC0_4</gui_name>
                <description language="en">loop counter 0 for DMA channel 4</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_4" offset="0xf8004490" size="0x4">
                <gui_name language="en">LC1_4</gui_name>
                <description language="en">loop counter 1 for DMA channel 4</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR5" offset="0xf80044a0" size="0x4">
                <gui_name language="en">SAR5</gui_name>
                <description language="en">source address for DMA channel 5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR5" offset="0xf80044a4" size="0x4">
                <gui_name language="en">DAR5</gui_name>
                <description language="en">destination address for DMA channel 5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR5" offset="0xf80044a8" size="0x4">
                <gui_name language="en">CCR5</gui_name>
                <description language="en">channel control for DMA channel 5</description>
                <bitField access="Read Only" enumerationId="CCR5_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_5" offset="0xf80044ac" size="0x4">
                <gui_name language="en">LC0_5</gui_name>
                <description language="en">loop counter 0 for DMA channel 5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_5" offset="0xf80044b0" size="0x4">
                <gui_name language="en">LC1_5</gui_name>
                <description language="en">loop counter 1 for DMA channel 5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR6" offset="0xf80044c0" size="0x4">
                <gui_name language="en">SAR6</gui_name>
                <description language="en">source address for DMA channel 6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR6" offset="0xf80044c4" size="0x4">
                <gui_name language="en">DAR6</gui_name>
                <description language="en">destination address for DMA channel 6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR6" offset="0xf80044c8" size="0x4">
                <gui_name language="en">CCR6</gui_name>
                <description language="en">channel control for DMA channel 6</description>
                <bitField access="Read Only" enumerationId="CCR6_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_6" offset="0xf80044cc" size="0x4">
                <gui_name language="en">LC0_6</gui_name>
                <description language="en">loop counter 0 for DMA channel 6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_6" offset="0xf80044d0" size="0x4">
                <gui_name language="en">LC1_6</gui_name>
                <description language="en">loop counter 1 for DMA channel 6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_SAR7" offset="0xf80044e0" size="0x4">
                <gui_name language="en">SAR7</gui_name>
                <description language="en">source address for DMA channel 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DAR7" offset="0xf80044e4" size="0x4">
                <gui_name language="en">DAR7</gui_name>
                <description language="en">destination address for DMA channel 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CCR7" offset="0xf80044e8" size="0x4">
                <gui_name language="en">CCR7</gui_name>
                <description language="en">channel control for DMA channel 7</description>
                <bitField access="Read Only" enumerationId="CCR7_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC0_7" offset="0xf80044ec" size="0x4">
                <gui_name language="en">LC0_7</gui_name>
                <description language="en">loop counter 0 for DMA channel 7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_LC1_7" offset="0xf80044f0" size="0x4">
                <gui_name language="en">LC1_7</gui_name>
                <description language="en">loop counter 1 for DMA channel 7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DBGSTATUS" offset="0xf8004d00" size="0x4">
                <gui_name language="en">DBGSTATUS</gui_name>
                <description language="en">Debug Status Register</description>
                <bitField access="Read Only" enumerationId="DBGSTATUS_dbgstatus_ENUM" high_bit="0" low_bit="0" name="dbgstatus">
                    <gui_name language="en">dbgstatus</gui_name>
                    <description language="en">The debug status encoding is:
0 = Idle
1 = Busy.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DBGCMD" offset="0xf8004d04" size="0x4">
                <gui_name language="en">DBGCMD</gui_name>
                <description language="en">Debug Command Register</description>
                <bitField access="Write Only" enumerationId="DBGCMD_dbgcmd_ENUM" high_bit="1" low_bit="0" name="dbgcmd">
                    <gui_name language="en">dbgcmd</gui_name>
                    <description language="en">The debug encoding is as follows:
b00 = execute the instruction that the DBGINST [1:0] Registers contain
b01 = reserved
b10 = reserved
b11 = reserved.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DBGINST0" offset="0xf8004d08" size="0x4">
                <gui_name language="en">DBGINST0</gui_name>
                <description language="en">debug instruction 0 register, Controls the debug instruction, channel, and thread information for the
DMAC.</description>
                <bitField access="Write Only" high_bit="31" low_bit="24" name="instruction_byte1">
                    <gui_name language="en">instruction_byte1</gui_name>
                    <description language="en">instruction byte 1
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="16" name="instruction_byte0">
                    <gui_name language="en">instruction_byte0</gui_name>
                    <description language="en">instruction byte 0
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" enumerationId="DBGINST0_channel_num_ENUM" high_bit="10" low_bit="8" name="channel_num">
                    <gui_name language="en">channel_num</gui_name>
                    <description language="en">DMA channel number:
b000 = DMA channel 0
b001 = DMA channel 1
b010 = DMA channel 2
.
.
.
b111 = DMA channel 7.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" enumerationId="DBGINST0_debug_thread_ENUM" high_bit="0" low_bit="0" name="debug_thread">
                    <gui_name language="en">debug_thread</gui_name>
                    <description language="en">The debug thread encoding is as follows:
0 = DMA manager thread
1 = DMA channel.
Note
When set to 1, the Channel number field selects the DMA channel to debug.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_DBGINST1" offset="0xf8004d0c" size="0x4">
                <gui_name language="en">DBGINST1</gui_name>
                <description language="en">debug instruction 0 register, Controls the upper bytes of the debug instruction for the DMAC</description>
                <bitField access="Write Only" high_bit="31" low_bit="24" name="instruction_byte5">
                    <gui_name language="en">instruction_byte5</gui_name>
                    <description language="en">instruction byte 5
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="16" name="instruction_byte4">
                    <gui_name language="en">instruction_byte4</gui_name>
                    <description language="en">instruction byte 4
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="15" low_bit="8" name="instruction_byte3">
                    <gui_name language="en">instruction_byte3</gui_name>
                    <description language="en">instruction byte 3
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="instruction_byte2">
                    <gui_name language="en">instruction_byte2</gui_name>
                    <description language="en">instruction byte 2
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CR0" offset="0xf8004e00" size="0x4">
                <gui_name language="en">CR0</gui_name>
                <description language="en">Configuration Register 0, Provides the status of the tie-off control signals.</description>
                <bitField access="Read Only" enumerationId="CR0_num_events_ENUM" high_bit="21" low_bit="17" name="num_events">
                    <gui_name language="en">num_events</gui_name>
                    <description language="en">Number of interrupt outputs that the DMAC provides:
b00000 = 1 interrupt output, irq[0]
b00001 = 2 interrupt outputs, irq[1:0]
b00010 = 3 interrupt outputs, irq[2:0]
.
.
.
b11111 = 32 interrupt outputs, irq[31:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_num_periph_req_ENUM" high_bit="16" low_bit="12" name="num_periph_req">
                    <gui_name language="en">num_periph_req</gui_name>
                    <description language="en">Number of peripheral request interfaces that the DMAC provides:
b00000 = 1 peripheral request interface
b00001 = 2 peripheral request interfaces
b00010 = 3 peripheral request interfaces
.
.
.
b11111 = 32 peripheral request interfaces.
Note
This field is only valid when the periph_req bit is set to 1.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_num_chnls_ENUM" high_bit="6" low_bit="4" name="num_chnls">
                    <gui_name language="en">num_chnls</gui_name>
                    <description language="en">Number of DMA channels that the DMAC supports:
b000 = 1 DMA channel
b001 = 2 DMA channels
b010 = 3 DMA channels
.
.
.
b111 = 8 DMA channels.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_mgr_ns_at_rst_ENUM" high_bit="2" low_bit="2" name="mgr_ns_at_rst">
                    <gui_name language="en">mgr_ns_at_rst</gui_name>
                    <description language="en">Indicates the status of the boot_manager_ns signal when the DMAC exited from reset:
0 = boot_manager_ns was LOW
1 = boot_manager_ns was HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_boot_en_ENUM" high_bit="1" low_bit="1" name="boot_en">
                    <gui_name language="en">boot_en</gui_name>
                    <description language="en">Indicates the status of the boot_from_pc signal when the DMAC exited from reset:
0 = boot_from_pc was LOW
1 = boot_from_pc was HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_periph_req_ENUM" high_bit="0" low_bit="0" name="periph_req">
                    <gui_name language="en">periph_req</gui_name>
                    <description language="en">Supports peripheral requests:
0 = the DMAC does not provide a peripheral request interface
1 = the DMAC provides the number of peripheral request interfaces that the num_periph_req field
specifies.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CR1" offset="0xf8004e04" size="0x4">
                <gui_name language="en">CR1</gui_name>
                <description language="en">Configuration Register 1, Provides information about the instruction cache configuration.</description>
                <bitField access="Read Only" enumerationId="CR1_num_icache_lines_ENUM" high_bit="7" low_bit="4" name="num_icache_lines">
                    <gui_name language="en">num_icache_lines</gui_name>
                    <description language="en">Number of i-cache lines:
b0000 = 1 i-cache line
b0001 = 2 i-cache lines
b0010 = 3 i-cache lines
.
.
.
b1111 = 16 i-cache lines
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR1_icache_len_ENUM" high_bit="2" low_bit="0" name="icache_len">
                    <gui_name language="en">icache_len</gui_name>
                    <description language="en">The length of an i-cache line:
b000-b001 = reserved
b010 = 4 bytes
b011 = 8 bytes
b100 = 16 bytes
b101 = 32 bytes
b110-b111 = reserved.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CR2" offset="0xf8004e08" size="0x4">
                <gui_name language="en">CR2</gui_name>
                <description language="en">Configuration Register 2, Provides the value of the boot address that boot_addr[31:0] configures.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="boot_addr">
                    <gui_name language="en">boot_addr</gui_name>
                    <description language="en">Provides the value of boot_addr[31:0] when the DMAC exited from reset
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CR3" offset="0xf8004e0c" size="0x4">
                <gui_name language="en">CR3</gui_name>
                <description language="en">Configuration Register 3, Provides the security state of the event-interrupt resources that are
initialized when the DMAC exits from reset.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="INS">
                    <gui_name language="en">INS</gui_name>
                    <description language="en">Provides the security state of an event-interrupt resource:
Bit [N] = 0 Event&lt;N&gt; or irq[N] is in the Secure state.
Bit [N] = 1 Event&lt;N&gt; or irq[N] is in the Non-secure state.
Note
The boot_irq_ns[x:0] signals initialize the bits in this register when the DMAC exits from reset.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CR4" offset="0xf8004e10" size="0x4">
                <gui_name language="en">CR4</gui_name>
                <description language="en">Configuration Register 4, Provides the security state of the peripheral request interfaces that is
initialized when the DMAC exits from reset.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="PNS">
                    <gui_name language="en">PNS</gui_name>
                    <description language="en">Provides the security state of the peripheral request interfaces:
Bit [N] = 0 Peripheral request interface N is in the Secure state.
Bit [N] = 1 Peripheral request interface N is in the Non-secure state.
Note
The boot_periph_ns tie-off signals initialize the bits in this register when the DMAC exits from reset. See
Table A-12 on page A-9 for more information.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_CRD" offset="0xf8004e14" size="0x4">
                <gui_name language="en">CRD</gui_name>
                <description language="en">DMA configuration register, Provides information about the configuration of the data buffer, data
width, and read and write issuing capability of the DMAC.</description>
                <bitField access="Read Only" enumerationId="CRD_data_buffer_dep_ENUM" high_bit="29" low_bit="20" name="data_buffer_dep">
                    <gui_name language="en">data_buffer_dep</gui_name>
                    <description language="en">The number of lines that the data buffer contains:
b000000000 = 1 line
b000000001 = 2 lines
.
.
.
b111111111 = 1024 lines.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_rd_q_dep_ENUM" high_bit="19" low_bit="16" name="rd_q_dep">
                    <gui_name language="en">rd_q_dep</gui_name>
                    <description language="en">The depth of the read queue:
b0000 = 1 line
b0001 = 2 lines
.
.
.
b1111 = 16 lines.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_rd_cap_ENUM" high_bit="14" low_bit="12" name="rd_cap">
                    <gui_name language="en">rd_cap</gui_name>
                    <description language="en">Read issuing capability that programs the number of outstanding read transactions:
b000 = 1
b001 = 2
.
.
.
b111 = 8.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_wr_q_dep_ENUM" high_bit="11" low_bit="8" name="wr_q_dep">
                    <gui_name language="en">wr_q_dep</gui_name>
                    <description language="en">The depth of the write queue:
b0000 = 1 line
b0001 = 2 lines
.
.
.
b1111 = 16 lines.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_wr_cap_ENUM" high_bit="6" low_bit="4" name="wr_cap">
                    <gui_name language="en">wr_cap</gui_name>
                    <description language="en">Write issuing capability that programs the number of outstanding write transactions:
b000 = 1
b001 = 2
.
.
.
b111 = 8.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_data_width_ENUM" high_bit="2" low_bit="0" name="data_width">
                    <gui_name language="en">data_width</gui_name>
                    <description language="en">The data bus width of the AXI master interface:
b000 = reserved
b001 = reserved
b010 = 32-bit
b011 = 64-bit
b100 = 128-bit
b101-b111 = reserved.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_WD" offset="0xf8004e80" size="0x4">
                <gui_name language="en">WD</gui_name>
                <description language="en">watch dog register, control the watch dog behavior</description>
                <bitField access="Read Only" enumerationId="WD_wd_irq_only_ENUM" high_bit="0" low_bit="0" name="wd_irq_only">
                    <gui_name language="en">wd_irq_only</gui_name>
                    <description language="en">Controls how the DMAC responds when it detects a lock-up condition:
0 = the DMAC aborts all of the contributing DMA channels and sets irq_abort HIGH
1 = the DMAC sets irq_abort HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PERIPH_ID_0" offset="0xf8004fe0" size="0x4">
                <gui_name language="en">periph_id_0</gui_name>
                <description language="en">peripheral idenfication register 0, Provides information about the configuration and version of the peripheral</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="part_number_0">
                    <gui_name language="en">part_number_0</gui_name>
                    <description language="en">returns 0x30
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PERIPH_ID_1" offset="0xf8004fe4" size="0x4">
                <gui_name language="en">periph_id_1</gui_name>
                <description language="en">peripheral idenfication register 1, The periph_id_1 Register is hard-coded and the fields in the register control the reset value.</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="designer_0">
                    <gui_name language="en">designer_0</gui_name>
                    <description language="en">returns 0x1
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="part_number_1">
                    <gui_name language="en">part_number_1</gui_name>
                    <description language="en">returns 0x3
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PERIPH_ID_2" offset="0xf8004fe8" size="0x4">
                <gui_name language="en">periph_id_2</gui_name>
                <description language="en">peripheral idenfication register 2, The periph_id_2 Register is hard-coded and the fields in the register control the reset value.</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="revision">
                    <gui_name language="en">revision</gui_name>
                    <description language="en">Identifies the revision:
0x0 for r0p0
0x1 for r1p0
0x2 for r1p1.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="designer_1">
                    <gui_name language="en">designer_1</gui_name>
                    <description language="en">returns 0x4
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PERIPH_ID_3" offset="0xf8004fec" size="0x4">
                <gui_name language="en">periph_id_3</gui_name>
                <description language="en">peripheral idenfication register 3, Provides information about the configuration and version of the peripheral</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="integration_cfg">
                    <gui_name language="en">integration_cfg</gui_name>
                    <description language="en">Returns 0 to indicate that the DMAC does not contain integration test logic
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PCELL_ID_0" offset="0xf8004ff0" size="0x4">
                <gui_name language="en">pcell_id_0</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_0">
                    <gui_name language="en">pcell_id_0</gui_name>
                    <description language="en">returnx 0x0d
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PCELL_ID_1" offset="0xf8004ff4" size="0x4">
                <gui_name language="en">pcell_id_1</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_1">
                    <gui_name language="en">pcell_id_1</gui_name>
                    <description language="en">returns 0xf0
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PCELL_ID_2" offset="0xf8004ff8" size="0x4">
                <gui_name language="en">pcell_id_2</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_2">
                    <gui_name language="en">pcell_id_2</gui_name>
                    <description language="en">returns 0x05
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_NS_PCELL_ID_3" offset="0xf8004ffc" size="0x4">
                <gui_name language="en">pcell_id_3</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_3">
                    <gui_name language="en">pcell_id_3</gui_name>
                    <description language="en">returns 0xb1
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_DMAC0_S" name="DMAC0_S" offset="0xf8003000">
            <gui_name language="en">dmac0_s</gui_name>
            <description language="en">dmac0_s</description>
            <register name="DMAC0_S_DSR" offset="0xf8003000" size="0x4">
                <gui_name language="en">DSR</gui_name>
                <description language="en">DMA manager status register</description>
                <bitField access="Read Only" enumerationId="DSR_DNS_ENUM" high_bit="9" low_bit="9" name="DNS">
                    <gui_name language="en">DNS</gui_name>
                    <description language="en">Provides the security status of the DMA manager thread:
0 = DMA manager operates in the Secure state
1 = DMA manager operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DSR_Wakeup_event_ENUM" high_bit="8" low_bit="4" name="Wakeup_event">
                    <gui_name language="en">Wakeup_event</gui_name>
                    <description language="en">When the DMA manager thread executes a DMAWFE instruction, it waits for the following event to occur:
b00000 = event[0]
b00001 = event[1]
b00010 = event[2]
.
.
.
b11111 = event[31].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DSR_DMA_status_ENUM" high_bit="3" low_bit="0" name="DMA_status">
                    <gui_name language="en">DMA_status</gui_name>
                    <description language="en">The operating state of the DMA manager:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101-b1110 = reserved
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DPC" offset="0xf8003004" size="0x4">
                <gui_name language="en">DPC</gui_name>
                <description language="en">DMA Program Counter Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_mgr">
                    <gui_name language="en">pc_mgr</gui_name>
                    <description language="en">Program counter for the DMA manager thread
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_INTEN" offset="0xf8003020" size="0x4">
                <gui_name language="en">INTEN</gui_name>
                <description language="en">Interrupt enable register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="event_irq_select">
                    <gui_name language="en">event_irq_select</gui_name>
                    <description language="en">Program the appropriate bit to control how the DMAC responds when it executes DMASEV:
Bit [N] = 0 If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC signals
event N to all of the threads. Set bit [N] to 0 if your system design does not use irq[N] to
signal an interrupt request.
Bit [N] = 1 If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC sets
irq[N] HIGH. Set bit [N] to 1 if your system design requires irq[N] to signal an interrupt
request.
This bit-field has the following special access attributes:
 srw: During secure access, it is read write.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsrw: During non-secure access, if thread is non-secure, it is read write.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_INT_EVENT_RIS" offset="0xf8003024" size="0x4">
                <gui_name language="en">INT_EVENT_RIS</gui_name>
                <description language="en">Event interrupt raw status register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="DMASEV_active">
                    <gui_name language="en">DMASEV_active</gui_name>
                    <description language="en">Returns the status of the event-interrupt resources:
Bit [N] = 0 Event N is inactive or irq[N] is LOW.
Bit [N] = 1 Event N is active or irq[N] is HIGH.
Note
When the DMAC executes a DMASEV N instruction to send event N, the INTEN Register
controls whether the DMAC:
signals an interrupt using the appropriate irq
sends the event to all of the threads.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_INTMIS" offset="0xf8003028" size="0x4">
                <gui_name language="en">INTMIS</gui_name>
                <description language="en">Interrupt Status Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="irq_status">
                    <gui_name language="en">irq_status</gui_name>
                    <description language="en">Provides the status of the interrupts that are active in the DMAC:
Bit [N] = 0 Interrupt N is inactive and therefore irq[N] is LOW.
Bit [N] = 1 Interrupt N is active and therefore irq[N] is HIGH.
Note
You must use the INTCLR Register to set bit [N] to 0, see Interrupt Clear Register.
Note
Bit [N] is 0 if the INTEN Register programs DMASEV to signal an event
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_INTCLR" offset="0xf800302c" size="0x4">
                <gui_name language="en">INTCLR</gui_name>
                <description language="en">Interrupt Clear Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="irq_clr">
                    <gui_name language="en">irq_clr</gui_name>
                    <description language="en">Controls the clearing of the irq outputs:
Bit [N] = 0 The status of irq[N] does not change.
Bit [N] = 1 The DMAC sets irq[N] LOW if the INTEN Register programs the DMAC to signal an interrupt.
Otherwise, the status of irq[N] does not change.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FSRD" offset="0xf8003030" size="0x4">
                <gui_name language="en">FSRD</gui_name>
                <description language="en">Fault Status DMA Manager Register</description>
                <bitField access="Read Only" enumerationId="FSRD_fs_mgr_ENUM" high_bit="0" low_bit="0" name="fs_mgr">
                    <gui_name language="en">fs_mgr</gui_name>
                    <description language="en">Provides the fault status of the DMA manager. Read as:
0 = the DMA manager thread is not in the Faulting state
1 = the DMA manager thread is in the Faulting state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FSRC" offset="0xf8003034" size="0x4">
                <gui_name language="en">FSRC</gui_name>
                <description language="en">Fault Status DMA Channel Register</description>
                <bitField access="Read Only" enumerationId="FSRC_fault_status_ENUM" high_bit="7" low_bit="0" name="fault_status">
                    <gui_name language="en">fault_status</gui_name>
                    <description language="en">Each bit provides the fault status of the corresponding channel. Read as:
Bit [N] = 0 No fault is present on DMA channel N.
Bit [N] = 1 DMA channel N is in the Faulting or Faulting completing state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTRD" offset="0xf8003038" size="0x4">
                <gui_name language="en">FTRD</gui_name>
                <description language="en">Fault Type DMA Manager Register</description>
                <bitField access="Read Only" enumerationId="FTRD_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA manager aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA manager
performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_mgr_evnt_err_ENUM" high_bit="5" low_bit="5" name="mgr_evnt_err">
                    <gui_name language="en">mgr_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = the DMA manager has appropriate security to execute DMAWFE or DMASEV
1 = a DMA manager thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
H18DMASEV to create a secure event or secure interrupt.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_dmago_err_ENUM" high_bit="4" low_bit="4" name="dmago_err">
                    <gui_name language="en">dmago_err</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute DMAGO with inappropriate security
permissions:
0 = the DMA manager has appropriate security to execute DMAGO
1 = a DMA manager thread in the Non-secure state attempted to execute DMAGO to create a DMA channel
operating in the Secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute an instruction operand that was not valid
for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTRD_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA manager was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR0" offset="0xf8003040" size="0x4">
                <gui_name language="en">FTR0</gui_name>
                <description language="en">Default type for DMA channel 0</description>
                <bitField access="Read Only" enumerationId="FTR0_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR0_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR1" offset="0xf8003044" size="0x4">
                <gui_name language="en">FTR1</gui_name>
                <description language="en">Default type for DMA channel 1</description>
                <bitField access="Read Only" enumerationId="FTR1_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR1_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR2" offset="0xf8003048" size="0x4">
                <gui_name language="en">FTR2</gui_name>
                <description language="en">Default type for DMA channel 2</description>
                <bitField access="Read Only" enumerationId="FTR2_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR2_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR3" offset="0xf800304c" size="0x4">
                <gui_name language="en">FTR3</gui_name>
                <description language="en">Default type for DMA channel 3</description>
                <bitField access="Read Only" enumerationId="FTR3_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR3_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR4" offset="0xf8003050" size="0x4">
                <gui_name language="en">FTR4</gui_name>
                <description language="en">Default type for DMA channel 4</description>
                <bitField access="Read Only" enumerationId="FTR4_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR4_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR5" offset="0xf8003054" size="0x4">
                <gui_name language="en">FTR5</gui_name>
                <description language="en">Default type for DMA channel 5</description>
                <bitField access="Read Only" enumerationId="FTR5_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR5_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR6" offset="0xf8003058" size="0x4">
                <gui_name language="en">FTR6</gui_name>
                <description language="en">Default type for DMA channel 6</description>
                <bitField access="Read Only" enumerationId="FTR6_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR6_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_FTR7" offset="0xf800305c" size="0x4">
                <gui_name language="en">FTR7</gui_name>
                <description language="en">Default type for DMA channel 7</description>
                <bitField access="Read Only" enumerationId="FTR7_lockup_err_ENUM" high_bit="31" low_bit="31" name="lockup_err">
                    <gui_name language="en">lockup_err</gui_name>
                    <description language="en">Indicates whether the DMA channel has locked-up because of resource starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_dbg_instr_ENUM" high_bit="30" low_bit="30" name="dbg_instr">
                    <gui_name language="en">dbg_instr</gui_name>
                    <description language="en">If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the
system memory or from the debug interface:
0 = instruction that generated an abort was read from system memory
1 = instruction that generated an abort was read from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_data_read_err_ENUM" high_bit="18" low_bit="18" name="data_read_err">
                    <gui_name language="en">data_read_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_data_write_err_ENUM" high_bit="17" low_bit="17" name="data_write_err">
                    <gui_name language="en">data_write_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_instr_fetch_err_ENUM" high_bit="16" low_bit="16" name="instr_fetch_err">
                    <gui_name language="en">instr_fetch_err</gui_name>
                    <description language="en">Indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_st_data_unavailable_ENUM" high_bit="13" low_bit="13" name="st_data_unavailable">
                    <gui_name language="en">st_data_unavailable</gui_name>
                    <description language="en">Indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="mfifo_err">
                    <gui_name language="en">mfifo_err</gui_name>
                    <description language="en">Indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST.
Depending on the instruction:
DMALD 0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST 0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_ch_rdwr_err_ENUM" high_bit="7" low_bit="7" name="ch_rdwr_err">
                    <gui_name language="en">ch_rdwr_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to program the CCRn
Register to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to perform a secure read or secure write.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_ch_periph_err_ENUM" high_bit="6" low_bit="6" name="ch_periph_err">
                    <gui_name language="en">ch_periph_err</gui_name>
                    <description language="en">Indicates whether a DMA channel thread, in the Non-secure state, attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFP to wait for a secure peripheral
DMALDP or DMASTP to notify a secure peripheral
DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_ch_evnt_err_ENUM" high_bit="5" low_bit="5" name="ch_evnt_err">
                    <gui_name language="en">ch_evnt_err</gui_name>
                    <description language="en">Indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate
security permissions:
0 = a DMA channel thread in the Non-secure state is not violating the security permissions
1 = a DMA channel thread in the Non-secure state attempted to execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_operand_invalid_ENUM" high_bit="1" low_bit="1" name="operand_invalid">
                    <gui_name language="en">operand_invalid</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an instruction operand that was
not valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="FTR7_undef_instr_ENUM" high_bit="0" low_bit="0" name="undef_instr">
                    <gui_name language="en">undef_instr</gui_name>
                    <description language="en">Indicates whether the DMA channel thread was attempting to execute an undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR0" offset="0xf8003100" size="0x4">
                <gui_name language="en">CSR0</gui_name>
                <description language="en">Channel status for DMA channel 0</description>
                <bitField access="Read Only" enumerationId="CSR0_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR0_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC0" offset="0xf8003104" size="0x4">
                <gui_name language="en">CPC0</gui_name>
                <description language="en">Channel PC for DMA channel 0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR1" offset="0xf8003108" size="0x4">
                <gui_name language="en">CSR1</gui_name>
                <description language="en">Channel status for DMA channel 1</description>
                <bitField access="Read Only" enumerationId="CSR1_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR1_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC1" offset="0xf800310c" size="0x4">
                <gui_name language="en">CPC1</gui_name>
                <description language="en">Channel PC for DMA channel 1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR2" offset="0xf8003110" size="0x4">
                <gui_name language="en">CSR2</gui_name>
                <description language="en">Channel status for DMA channel 2</description>
                <bitField access="Read Only" enumerationId="CSR2_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR2_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC2" offset="0xf8003114" size="0x4">
                <gui_name language="en">CPC2</gui_name>
                <description language="en">Channel PC for DMA channel 2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR3" offset="0xf8003118" size="0x4">
                <gui_name language="en">CSR3</gui_name>
                <description language="en">Channel status for DMA channel 3</description>
                <bitField access="Read Only" enumerationId="CSR3_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR3_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC3" offset="0xf800311c" size="0x4">
                <gui_name language="en">CPC3</gui_name>
                <description language="en">Channel PC for DMA channel 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR4" offset="0xf8003120" size="0x4">
                <gui_name language="en">CSR4</gui_name>
                <description language="en">Channel status for DMA channel 4</description>
                <bitField access="Read Only" enumerationId="CSR4_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR4_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC4" offset="0xf8003124" size="0x4">
                <gui_name language="en">CPC4</gui_name>
                <description language="en">Channel PC for DMA channel 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR5" offset="0xf8003128" size="0x4">
                <gui_name language="en">CSR5</gui_name>
                <description language="en">Channel status for DMA channel 5</description>
                <bitField access="Read Only" enumerationId="CSR5_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR5_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC5" offset="0xf800312c" size="0x4">
                <gui_name language="en">CPC5</gui_name>
                <description language="en">Channel PC for DMA channel 5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR6" offset="0xf8003130" size="0x4">
                <gui_name language="en">CSR6</gui_name>
                <description language="en">Channel status for DMA channel 6</description>
                <bitField access="Read Only" enumerationId="CSR6_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR6_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC6" offset="0xf8003134" size="0x4">
                <gui_name language="en">CPC6</gui_name>
                <description language="en">Channel PC for DMA channel 6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CSR7" offset="0xf8003138" size="0x4">
                <gui_name language="en">CSR7</gui_name>
                <description language="en">Channel status for DMA channel 7</description>
                <bitField access="Read Only" enumerationId="CSR7_CNS_ENUM" high_bit="21" low_bit="21" name="CNS">
                    <gui_name language="en">CNS</gui_name>
                    <description language="en">The channel non-secure bit provides the security of the DMA channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_dmawfp_periph_ENUM" high_bit="15" low_bit="15" name="dmawfp_periph">
                    <gui_name language="en">dmawfp_periph</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_dmawfp_b_ns_ENUM" high_bit="14" low_bit="14" name="dmawfp_b_ns">
                    <gui_name language="en">dmawfp_b_ns</gui_name>
                    <description language="en">When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand
were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_wakeup_num_ENUM" high_bit="8" low_bit="4" name="wakeup_num">
                    <gui_name language="en">wakeup_num</gui_name>
                    <description language="en">If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits
indicate the event or peripheral number that the channel is waiting for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
.
.
.
b11111 = DMA channel is waiting for event, or peripheral, 31.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CSR7_channel_status_ENUM" high_bit="3" low_bit="0" name="channel_status">
                    <gui_name language="en">channel_status</gui_name>
                    <description language="en">The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CPC7" offset="0xf800313c" size="0x4">
                <gui_name language="en">CPC7</gui_name>
                <description language="en">Channel PC for DMA channel 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="pc_chnl">
                    <gui_name language="en">pc_chnl</gui_name>
                    <description language="en">Program counter for the DMA channel n thread, where n depends on the address
of the register
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR0" offset="0xf8003400" size="0x4">
                <gui_name language="en">SAR0</gui_name>
                <description language="en">source address for DMA channel 0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR0" offset="0xf8003404" size="0x4">
                <gui_name language="en">DAR0</gui_name>
                <description language="en">destination address for DMA channel 0</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR0" offset="0xf8003408" size="0x4">
                <gui_name language="en">CCR0</gui_name>
                <description language="en">channel control for DMA channel 0</description>
                <bitField access="Read Only" enumerationId="CCR0_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR0_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_0" offset="0xf800340c" size="0x4">
                <gui_name language="en">LC0_0</gui_name>
                <description language="en">loop counter 0 for DMA channel 0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_0" offset="0xf8003410" size="0x4">
                <gui_name language="en">LC1_0</gui_name>
                <description language="en">loop counter 1 for DMA channel 0</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR1" offset="0xf8003420" size="0x4">
                <gui_name language="en">SAR1</gui_name>
                <description language="en">source address for DMA channel 1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR1" offset="0xf8003424" size="0x4">
                <gui_name language="en">DAR1</gui_name>
                <description language="en">destination address for DMA channel 1</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR1" offset="0xf8003428" size="0x4">
                <gui_name language="en">CCR1</gui_name>
                <description language="en">channel control for DMA channel 1</description>
                <bitField access="Read Only" enumerationId="CCR1_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR1_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_1" offset="0xf800342c" size="0x4">
                <gui_name language="en">LC0_1</gui_name>
                <description language="en">loop counter 0 for DMA channel 1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_1" offset="0xf8003430" size="0x4">
                <gui_name language="en">LC1_1</gui_name>
                <description language="en">loop counter 1 for DMA channel 1</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR2" offset="0xf8003440" size="0x4">
                <gui_name language="en">SAR2</gui_name>
                <description language="en">source address for DMA channel 2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR2" offset="0xf8003444" size="0x4">
                <gui_name language="en">DAR2</gui_name>
                <description language="en">destination address for DMA channel 2</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR2" offset="0xf8003448" size="0x4">
                <gui_name language="en">CCR2</gui_name>
                <description language="en">channel control for DMA channel 2</description>
                <bitField access="Read Only" enumerationId="CCR2_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR2_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_2" offset="0xf800344c" size="0x4">
                <gui_name language="en">LC0_2</gui_name>
                <description language="en">loop counter 0 for DMA channel 2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_2" offset="0xf8003450" size="0x4">
                <gui_name language="en">LC1_2</gui_name>
                <description language="en">loop counter 1 for DMA channel 2</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR3" offset="0xf8003460" size="0x4">
                <gui_name language="en">SAR3</gui_name>
                <description language="en">source address for DMA channel 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR3" offset="0xf8003464" size="0x4">
                <gui_name language="en">DAR3</gui_name>
                <description language="en">destination address for DMA channel 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR3" offset="0xf8003468" size="0x4">
                <gui_name language="en">CCR3</gui_name>
                <description language="en">channel control for DMA channel 3</description>
                <bitField access="Read Only" enumerationId="CCR3_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR3_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_3" offset="0xf800346c" size="0x4">
                <gui_name language="en">LC0_3</gui_name>
                <description language="en">loop counter 0 for DMA channel 3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_3" offset="0xf8003470" size="0x4">
                <gui_name language="en">LC1_3</gui_name>
                <description language="en">loop counter 1 for DMA channel 3</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR4" offset="0xf8003480" size="0x4">
                <gui_name language="en">SAR4</gui_name>
                <description language="en">source address for DMA channel 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR4" offset="0xf8003484" size="0x4">
                <gui_name language="en">DAR4</gui_name>
                <description language="en">destination address for DMA channel 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR4" offset="0xf8003488" size="0x4">
                <gui_name language="en">CCR4</gui_name>
                <description language="en">channel control for DMA channel 4</description>
                <bitField access="Read Only" enumerationId="CCR4_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR4_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_4" offset="0xf800348c" size="0x4">
                <gui_name language="en">LC0_4</gui_name>
                <description language="en">loop counter 0 for DMA channel 4</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_4" offset="0xf8003490" size="0x4">
                <gui_name language="en">LC1_4</gui_name>
                <description language="en">loop counter 1 for DMA channel 4</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR5" offset="0xf80034a0" size="0x4">
                <gui_name language="en">SAR5</gui_name>
                <description language="en">source address for DMA channel 5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR5" offset="0xf80034a4" size="0x4">
                <gui_name language="en">DAR5</gui_name>
                <description language="en">destination address for DMA channel 5</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR5" offset="0xf80034a8" size="0x4">
                <gui_name language="en">CCR5</gui_name>
                <description language="en">channel control for DMA channel 5</description>
                <bitField access="Read Only" enumerationId="CCR5_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR5_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_5" offset="0xf80034ac" size="0x4">
                <gui_name language="en">LC0_5</gui_name>
                <description language="en">loop counter 0 for DMA channel 5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_5" offset="0xf80034b0" size="0x4">
                <gui_name language="en">LC1_5</gui_name>
                <description language="en">loop counter 1 for DMA channel 5</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR6" offset="0xf80034c0" size="0x4">
                <gui_name language="en">SAR6</gui_name>
                <description language="en">source address for DMA channel 6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR6" offset="0xf80034c4" size="0x4">
                <gui_name language="en">DAR6</gui_name>
                <description language="en">destination address for DMA channel 6</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR6" offset="0xf80034c8" size="0x4">
                <gui_name language="en">CCR6</gui_name>
                <description language="en">channel control for DMA channel 6</description>
                <bitField access="Read Only" enumerationId="CCR6_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR6_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_6" offset="0xf80034cc" size="0x4">
                <gui_name language="en">LC0_6</gui_name>
                <description language="en">loop counter 0 for DMA channel 6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_6" offset="0xf80034d0" size="0x4">
                <gui_name language="en">LC1_6</gui_name>
                <description language="en">loop counter 1 for DMA channel 6</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_SAR7" offset="0xf80034e0" size="0x4">
                <gui_name language="en">SAR7</gui_name>
                <description language="en">source address for DMA channel 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="src_addr">
                    <gui_name language="en">src_addr</gui_name>
                    <description language="en">Address of the source data for DMA channel n, where n depends on the address
of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DAR7" offset="0xf80034e4" size="0x4">
                <gui_name language="en">DAR7</gui_name>
                <description language="en">destination address for DMA channel 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="dest_addr">
                    <gui_name language="en">dest_addr</gui_name>
                    <description language="en">Address for the destination data for DMA channel n, where n depends on the
address of the register.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CCR7" offset="0xf80034e8" size="0x4">
                <gui_name language="en">CCR7</gui_name>
                <description language="en">channel control for DMA channel 7</description>
                <bitField access="Read Only" enumerationId="CCR7_endian_swap_size_ENUM" high_bit="30" low_bit="28" name="endian_swap_size">
                    <gui_name language="en">endian_swap_size</gui_name>
                    <description language="en">Table 3-22 on page 3-29 defines whether data can be swapped between little-endian (LE) and
byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data
independently of the source and destination transaction sizes. This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that b000 indicates that no swap must occur.
Endian swap size Description
b000 No swap, 8-bit data
b001 Swap bytes within 16-bit data
b010 Swap bytes within 32-bit data
b011 Swap bytes within 64-bit data
b100 Swap bytes within 128-bit data
b101 Reserved
b110 Reserved
b111 Reserved
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="25" name="dst_cache_ctrl">
                    <gui_name language="en">dst_cache_ctrl</gui_name>
                    <description language="en">Programs the state of AWCACHE[3,1:0]a when the DMAC writes the destination data.
Bit [27] 0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26] 0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25] 0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH.
Note
AWCACHE[2] is tied LOW by the DMAC.
Setting AWCACHE[3,1]=b10 violates the AXI protocol. See the AMBA AXI Protocol Specification.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="22" name="dst_prot_ctrl">
                    <gui_name language="en">dst_prot_ctrl</gui_name>
                    <description language="en">Programs the state of AWPROT[2:0]a when the DMAC writes the destination data.
Bit [24] 0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23] 0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22] 0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program AWPROT[1] LOW, that is, a secure access. If
a DMA channel in the Non-secure state attempts to set AWPROT[1] LOW, then the DMA channel
aborts
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_dst_burst_len_ENUM" high_bit="21" low_bit="18" name="dst_burst_len">
                    <gui_name language="en">dst_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_dst_burst_size_ENUM" high_bit="17" low_bit="15" name="dst_burst_size">
                    <gui_name language="en">dst_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.
Note
These bits control the state of AWSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_dst_inc_ENUM" high_bit="14" low_bit="14" name="dst_inc">
                    <gui_name language="en">dst_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it writes the destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="src_cache_ctrl">
                    <gui_name language="en">src_cache_ctrl</gui_name>
                    <description language="en">Set the bits to control the state of ARCACHE[2:0]a when the DMAC reads the source data.
Bit [13] 0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12] 0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11] 0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.
Note
The DMAC ties ARCACHE[3] LOW.
Setting ARCACHE[2:1]=b10 violates the AXI protocol.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="src_prot_ctrl">
                    <gui_name language="en">src_prot_ctrl</gui_name>
                    <description language="en">Programs the state of ARPROT[2:0]a when the DMAC reads the source data.
Bit [10] 0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9] 0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8] 0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.
Note
Only DMA channels in the Secure state can program ARPROT[1] LOW, that is, a secure access. If a
DMA channel in the Non-secure state attempts to set ARPROT[1] LOW, the DMA channel aborts.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_src_burst_len_ENUM" high_bit="7" low_bit="4" name="src_burst_len">
                    <gui_name language="en">src_burst_len</gui_name>
                    <description language="en">For each burst, these bits program the number of data transfers that the DMAC performs when it reads
the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
.
.
.
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARLEN[3:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_src_burst_size_ENUM" high_bit="3" low_bit="1" name="src_burst_size">
                    <gui_name language="en">src_burst_size</gui_name>
                    <description language="en">For each beat within a burst, it programs the number of bytes that the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size.
Note
These bits control the state of ARSIZE[2:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CCR7_src_inc_ENUM" high_bit="0" low_bit="0" name="src_inc">
                    <gui_name language="en">src_inc</gui_name>
                    <description language="en">Programs the burst type that the DMAC performs when it reads the source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0] HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC0_7" offset="0xf80034ec" size="0x4">
                <gui_name language="en">LC0_7</gui_name>
                <description language="en">loop counter 0 for DMA channel 7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter zero for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter zero
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_LC1_7" offset="0xf80034f0" size="0x4">
                <gui_name language="en">LC1_7</gui_name>
                <description language="en">loop counter 1 for DMA channel 7</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="loop_counter_iteration">
                    <gui_name language="en">loop_counter_iteration</gui_name>
                    <description language="en">Provides the status of loop counter one for the DMA channel. The DMAC
updates this register when it executes DMALPEND[S|B], and the DMA
channel thread is programmed to use loop counter one.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DBGSTATUS" offset="0xf8003d00" size="0x4">
                <gui_name language="en">DBGSTATUS</gui_name>
                <description language="en">Debug Status Register</description>
                <bitField access="Read Only" enumerationId="DBGSTATUS_dbgstatus_ENUM" high_bit="0" low_bit="0" name="dbgstatus">
                    <gui_name language="en">dbgstatus</gui_name>
                    <description language="en">The debug status encoding is:
0 = Idle
1 = Busy.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DBGCMD" offset="0xf8003d04" size="0x4">
                <gui_name language="en">DBGCMD</gui_name>
                <description language="en">Debug Command Register</description>
                <bitField access="Write Only" enumerationId="DBGCMD_dbgcmd_ENUM" high_bit="1" low_bit="0" name="dbgcmd">
                    <gui_name language="en">dbgcmd</gui_name>
                    <description language="en">The debug encoding is as follows:
b00 = execute the instruction that the DBGINST [1:0] Registers contain
b01 = reserved
b10 = reserved
b11 = reserved.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DBGINST0" offset="0xf8003d08" size="0x4">
                <gui_name language="en">DBGINST0</gui_name>
                <description language="en">debug instruction 0 register, Controls the debug instruction, channel, and thread information for the
DMAC.</description>
                <bitField access="Write Only" high_bit="31" low_bit="24" name="instruction_byte1">
                    <gui_name language="en">instruction_byte1</gui_name>
                    <description language="en">instruction byte 1
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="16" name="instruction_byte0">
                    <gui_name language="en">instruction_byte0</gui_name>
                    <description language="en">instruction byte 0
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" enumerationId="DBGINST0_channel_num_ENUM" high_bit="10" low_bit="8" name="channel_num">
                    <gui_name language="en">channel_num</gui_name>
                    <description language="en">DMA channel number:
b000 = DMA channel 0
b001 = DMA channel 1
b010 = DMA channel 2
.
.
.
b111 = DMA channel 7.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" enumerationId="DBGINST0_debug_thread_ENUM" high_bit="0" low_bit="0" name="debug_thread">
                    <gui_name language="en">debug_thread</gui_name>
                    <description language="en">The debug thread encoding is as follows:
0 = DMA manager thread
1 = DMA channel.
Note
When set to 1, the Channel number field selects the DMA channel to debug.
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_DBGINST1" offset="0xf8003d0c" size="0x4">
                <gui_name language="en">DBGINST1</gui_name>
                <description language="en">debug instruction 0 register, Controls the upper bytes of the debug instruction for the DMAC</description>
                <bitField access="Write Only" high_bit="31" low_bit="24" name="instruction_byte5">
                    <gui_name language="en">instruction_byte5</gui_name>
                    <description language="en">instruction byte 5
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="16" name="instruction_byte4">
                    <gui_name language="en">instruction_byte4</gui_name>
                    <description language="en">instruction byte 4
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="15" low_bit="8" name="instruction_byte3">
                    <gui_name language="en">instruction_byte3</gui_name>
                    <description language="en">instruction byte 3
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="instruction_byte2">
                    <gui_name language="en">instruction_byte2</gui_name>
                    <description language="en">instruction byte 2
This bit-field has the following special access attributes:
 swo: During secure access, it is  write only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnswo: During non-secure access, if thread is non-secure, it is write only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CR0" offset="0xf8003e00" size="0x4">
                <gui_name language="en">CR0</gui_name>
                <description language="en">Configuration Register 0, Provides the status of the tie-off control signals.</description>
                <bitField access="Read Only" enumerationId="CR0_num_events_ENUM" high_bit="21" low_bit="17" name="num_events">
                    <gui_name language="en">num_events</gui_name>
                    <description language="en">Number of interrupt outputs that the DMAC provides:
b00000 = 1 interrupt output, irq[0]
b00001 = 2 interrupt outputs, irq[1:0]
b00010 = 3 interrupt outputs, irq[2:0]
.
.
.
b11111 = 32 interrupt outputs, irq[31:0].
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_num_periph_req_ENUM" high_bit="16" low_bit="12" name="num_periph_req">
                    <gui_name language="en">num_periph_req</gui_name>
                    <description language="en">Number of peripheral request interfaces that the DMAC provides:
b00000 = 1 peripheral request interface
b00001 = 2 peripheral request interfaces
b00010 = 3 peripheral request interfaces
.
.
.
b11111 = 32 peripheral request interfaces.
Note
This field is only valid when the periph_req bit is set to 1.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_num_chnls_ENUM" high_bit="6" low_bit="4" name="num_chnls">
                    <gui_name language="en">num_chnls</gui_name>
                    <description language="en">Number of DMA channels that the DMAC supports:
b000 = 1 DMA channel
b001 = 2 DMA channels
b010 = 3 DMA channels
.
.
.
b111 = 8 DMA channels.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_mgr_ns_at_rst_ENUM" high_bit="2" low_bit="2" name="mgr_ns_at_rst">
                    <gui_name language="en">mgr_ns_at_rst</gui_name>
                    <description language="en">Indicates the status of the boot_manager_ns signal when the DMAC exited from reset:
0 = boot_manager_ns was LOW
1 = boot_manager_ns was HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_boot_en_ENUM" high_bit="1" low_bit="1" name="boot_en">
                    <gui_name language="en">boot_en</gui_name>
                    <description language="en">Indicates the status of the boot_from_pc signal when the DMAC exited from reset:
0 = boot_from_pc was LOW
1 = boot_from_pc was HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR0_periph_req_ENUM" high_bit="0" low_bit="0" name="periph_req">
                    <gui_name language="en">periph_req</gui_name>
                    <description language="en">Supports peripheral requests:
0 = the DMAC does not provide a peripheral request interface
1 = the DMAC provides the number of peripheral request interfaces that the num_periph_req field
specifies.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CR1" offset="0xf8003e04" size="0x4">
                <gui_name language="en">CR1</gui_name>
                <description language="en">Configuration Register 1, Provides information about the instruction cache configuration.</description>
                <bitField access="Read Only" enumerationId="CR1_num_icache_lines_ENUM" high_bit="7" low_bit="4" name="num_icache_lines">
                    <gui_name language="en">num_icache_lines</gui_name>
                    <description language="en">Number of i-cache lines:
b0000 = 1 i-cache line
b0001 = 2 i-cache lines
b0010 = 3 i-cache lines
.
.
.
b1111 = 16 i-cache lines
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CR1_icache_len_ENUM" high_bit="2" low_bit="0" name="icache_len">
                    <gui_name language="en">icache_len</gui_name>
                    <description language="en">The length of an i-cache line:
b000-b001 = reserved
b010 = 4 bytes
b011 = 8 bytes
b100 = 16 bytes
b101 = 32 bytes
b110-b111 = reserved.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CR2" offset="0xf8003e08" size="0x4">
                <gui_name language="en">CR2</gui_name>
                <description language="en">Configuration Register 2, Provides the value of the boot address that boot_addr[31:0] configures.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="boot_addr">
                    <gui_name language="en">boot_addr</gui_name>
                    <description language="en">Provides the value of boot_addr[31:0] when the DMAC exited from reset
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CR3" offset="0xf8003e0c" size="0x4">
                <gui_name language="en">CR3</gui_name>
                <description language="en">Configuration Register 3, Provides the security state of the event-interrupt resources that are
initialized when the DMAC exits from reset.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="INS">
                    <gui_name language="en">INS</gui_name>
                    <description language="en">Provides the security state of an event-interrupt resource:
Bit [N] = 0 Event&lt;N&gt; or irq[N] is in the Secure state.
Bit [N] = 1 Event&lt;N&gt; or irq[N] is in the Non-secure state.
Note
The boot_irq_ns[x:0] signals initialize the bits in this register when the DMAC exits from reset.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CR4" offset="0xf8003e10" size="0x4">
                <gui_name language="en">CR4</gui_name>
                <description language="en">Configuration Register 4, Provides the security state of the peripheral request interfaces that is
initialized when the DMAC exits from reset.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="PNS">
                    <gui_name language="en">PNS</gui_name>
                    <description language="en">Provides the security state of the peripheral request interfaces:
Bit [N] = 0 Peripheral request interface N is in the Secure state.
Bit [N] = 1 Peripheral request interface N is in the Non-secure state.
Note
The boot_periph_ns tie-off signals initialize the bits in this register when the DMAC exits from reset. See
Table A-12 on page A-9 for more information.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_CRD" offset="0xf8003e14" size="0x4">
                <gui_name language="en">CRD</gui_name>
                <description language="en">DMA configuration register, Provides information about the configuration of the data buffer, data
width, and read and write issuing capability of the DMAC.</description>
                <bitField access="Read Only" enumerationId="CRD_data_buffer_dep_ENUM" high_bit="29" low_bit="20" name="data_buffer_dep">
                    <gui_name language="en">data_buffer_dep</gui_name>
                    <description language="en">The number of lines that the data buffer contains:
b000000000 = 1 line
b000000001 = 2 lines
.
.
.
b111111111 = 1024 lines.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_rd_q_dep_ENUM" high_bit="19" low_bit="16" name="rd_q_dep">
                    <gui_name language="en">rd_q_dep</gui_name>
                    <description language="en">The depth of the read queue:
b0000 = 1 line
b0001 = 2 lines
.
.
.
b1111 = 16 lines.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_rd_cap_ENUM" high_bit="14" low_bit="12" name="rd_cap">
                    <gui_name language="en">rd_cap</gui_name>
                    <description language="en">Read issuing capability that programs the number of outstanding read transactions:
b000 = 1
b001 = 2
.
.
.
b111 = 8.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_wr_q_dep_ENUM" high_bit="11" low_bit="8" name="wr_q_dep">
                    <gui_name language="en">wr_q_dep</gui_name>
                    <description language="en">The depth of the write queue:
b0000 = 1 line
b0001 = 2 lines
.
.
.
b1111 = 16 lines.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_wr_cap_ENUM" high_bit="6" low_bit="4" name="wr_cap">
                    <gui_name language="en">wr_cap</gui_name>
                    <description language="en">Write issuing capability that programs the number of outstanding write transactions:
b000 = 1
b001 = 2
.
.
.
b111 = 8.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" enumerationId="CRD_data_width_ENUM" high_bit="2" low_bit="0" name="data_width">
                    <gui_name language="en">data_width</gui_name>
                    <description language="en">The data bus width of the AXI master interface:
b000 = reserved
b001 = reserved
b010 = 32-bit
b011 = 64-bit
b100 = 128-bit
b101-b111 = reserved.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_WD" offset="0xf8003e80" size="0x4">
                <gui_name language="en">WD</gui_name>
                <description language="en">watch dog register, control the watch dog behavior</description>
                <bitField access="Read Only" enumerationId="WD_wd_irq_only_ENUM" high_bit="0" low_bit="0" name="wd_irq_only">
                    <gui_name language="en">wd_irq_only</gui_name>
                    <description language="en">Controls how the DMAC responds when it detects a lock-up condition:
0 = the DMAC aborts all of the contributing DMA channels and sets irq_abort HIGH
1 = the DMAC sets irq_abort HIGH.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PERIPH_ID_0" offset="0xf8003fe0" size="0x4">
                <gui_name language="en">periph_id_0</gui_name>
                <description language="en">peripheral idenfication register 0, Provides information about the configuration and version of the peripheral</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="part_number_0">
                    <gui_name language="en">part_number_0</gui_name>
                    <description language="en">returns 0x30
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PERIPH_ID_1" offset="0xf8003fe4" size="0x4">
                <gui_name language="en">periph_id_1</gui_name>
                <description language="en">peripheral idenfication register 1, The periph_id_1 Register is hard-coded and the fields in the register control the reset value.</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="designer_0">
                    <gui_name language="en">designer_0</gui_name>
                    <description language="en">returns 0x1
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="part_number_1">
                    <gui_name language="en">part_number_1</gui_name>
                    <description language="en">returns 0x3
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PERIPH_ID_2" offset="0xf8003fe8" size="0x4">
                <gui_name language="en">periph_id_2</gui_name>
                <description language="en">peripheral idenfication register 2, The periph_id_2 Register is hard-coded and the fields in the register control the reset value.</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="revision">
                    <gui_name language="en">revision</gui_name>
                    <description language="en">Identifies the revision:
0x0 for r0p0
0x1 for r1p0
0x2 for r1p1.
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="designer_1">
                    <gui_name language="en">designer_1</gui_name>
                    <description language="en">returns 0x4
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PERIPH_ID_3" offset="0xf8003fec" size="0x4">
                <gui_name language="en">periph_id_3</gui_name>
                <description language="en">peripheral idenfication register 3, Provides information about the configuration and version of the peripheral</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="integration_cfg">
                    <gui_name language="en">integration_cfg</gui_name>
                    <description language="en">Returns 0 to indicate that the DMAC does not contain integration test logic
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PCELL_ID_0" offset="0xf8003ff0" size="0x4">
                <gui_name language="en">pcell_id_0</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_0">
                    <gui_name language="en">pcell_id_0</gui_name>
                    <description language="en">returnx 0x0d
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PCELL_ID_1" offset="0xf8003ff4" size="0x4">
                <gui_name language="en">pcell_id_1</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_1">
                    <gui_name language="en">pcell_id_1</gui_name>
                    <description language="en">returns 0xf0
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PCELL_ID_2" offset="0xf8003ff8" size="0x4">
                <gui_name language="en">pcell_id_2</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_2">
                    <gui_name language="en">pcell_id_2</gui_name>
                    <description language="en">returns 0x05
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
            <register name="DMAC0_S_PCELL_ID_3" offset="0xf8003ffc" size="0x4">
                <gui_name language="en">pcell_id_3</gui_name>
                <description language="en">component idenfication register 0, When concatenated, these four registers return 0xB105F00D.</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_3">
                    <gui_name language="en">pcell_id_3</gui_name>
                    <description language="en">returns 0xb1
This bit-field has the following special access attributes:
 sro: During secure access, it is read only.
 nssraz: During non-secure access, if thread is secure, it is read as zero.
 nsnsro: During non-secure access, if thread is non-secure, it is read only.
</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_GEM0" name="GEM0" offset="0xe000b000">
            <gui_name language="en">gem0</gui_name>
            <description language="en">gem0</description>
            <register name="GEM0_NET_CTRL" offset="0xe000b000" size="0x4">
                <gui_name language="en">net_ctrl</gui_name>
                <description language="en">The network control register contains general MAC control functions for both receiver and transmitter.</description>
                <bitField access="Write Only" high_bit="18" low_bit="18" name="flush_next_rx_dpram_pkt">
                    <gui_name language="en">flush_next_rx_dpram_pkt</gui_name>
                    <description language="en">Flush the next packet from the external RX DPRAM.
Writing one to this bit will only have an effect if the DMA is not currently writing a packet already stored in the DPRAM to memory.</description>
                </bitField>
                <bitField access="Write Only" high_bit="17" low_bit="17" name="tx_pfc_pri_pri_pause_frame">
                    <gui_name language="en">tx_pfc_pri_pri_pause_frame</gui_name>
                    <description language="en">Transmit PFC Priority Based Pause Frame. Takes the values stored in the Transmit PFC Pause Register</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="16" name="en_pfc_pri_pause_rx">
                    <gui_name language="en">en_pfc_pri_pause_rx</gui_name>
                    <description language="en">Enable PFC Priority Based Pause Reception capabilities.
Setting this bit will enable PFC negotiation and recognition of priority based pause frames.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="str_rx_timestamp">
                    <gui_name language="en">str_rx_timestamp</gui_name>
                    <description language="en">Store receive time stamp to memory. Setting this bit to one will cause the CRC of every received frame to be replaced with the value of the nanoseconds field of the 1588 timer that was captured as the receive frame passed the message time stamp point. Set to zero for normal operation.</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="tx_zeroq_pause_frame">
                    <gui_name language="en">tx_zeroq_pause_frame</gui_name>
                    <description language="en">Transmit zero quantum pause frame - writing one to this bit causes a pause frame with zero quantum to be transmitted.</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="tx_pause_frame">
                    <gui_name language="en">tx_pause_frame</gui_name>
                    <description language="en">Transmit pause frame - writing one to this bit causes a pause frame to be transmitted.</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="tx_halt">
                    <gui_name language="en">tx_halt</gui_name>
                    <description language="en">Transmit halt - writing one to this bit halts transmission as soon as any ongoing frame transmission ends.</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="start_tx">
                    <gui_name language="en">start_tx</gui_name>
                    <description language="en">Start transmission - writing one to this bit starts transmission.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="back_pressure">
                    <gui_name language="en">back_pressure</gui_name>
                    <description language="en">Back pressure - if set in 10M or 100M half duplex mode will force collisions on all received frames.
Ignored in gigabit half duplex mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="wren_stat_regs">
                    <gui_name language="en">wren_stat_regs</gui_name>
                    <description language="en">Write enable for statistics registers - setting this bit to one means the statistics registers can be written for functional test purposes.</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="incr_stat_regs">
                    <gui_name language="en">incr_stat_regs</gui_name>
                    <description language="en">Incremental statistics registers - this bit is write only.
Writing a one increments all the statistics registers by one for test purposes.</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="clear_stat_regs">
                    <gui_name language="en">clear_stat_regs</gui_name>
                    <description language="en">Clear statistics registers - this bit is write only.
Writing a one clears the statistics registers.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="mgmt_port_en">
                    <gui_name language="en">mgmt_port_en</gui_name>
                    <description language="en">Management port enable - set to one to enable the management port. When zero forces mdio to high impedance state and mdc low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="tx_en">
                    <gui_name language="en">tx_en</gui_name>
                    <description language="en">Transmit enable - when set, it enables the GEM transmitter to send data. When reset transmission will stop immediately, the transmit pipeline and control registers will be cleared and the transmit queue pointer register will reset to point to the start of the transmit descriptor list.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="rx_en">
                    <gui_name language="en">rx_en</gui_name>
                    <description language="en">Receive enable - when set, it enables the GEM to receive data. When reset frame reception will stop immediately and the receive pipeline will be cleared.
The receive queue pointer register is unaffected.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="loopback_local">
                    <gui_name language="en">loopback_local</gui_name>
                    <description language="en">Loop back local - asserts the loopback_local signal to the system clock generator. Also connects txd to rxd, tx_en to rx_dv and forces full duplex mode. Bit 11 of the network configuration register must be set low to disable TBI mode when in internal loopback. rx_clk and tx_clk may malfunction as the GEM is switched into and out of internal loop back. It is important that receive and transmit circuits have already been disabled when making the switch into and out of internal loop back. Local loopback functionality isn't available in the EP107 Pele Emulation Platform, because the clocking doesn't map well into an FPGA.</description>
                </bitField>
            </register>
            <register name="GEM0_NET_CFG" offset="0xe000b004" size="0x4">
                <gui_name language="en">net_cfg</gui_name>
                <description language="en">The network configuration register contains functions for setting the mode of operation for the Gigabit Ethernet MAC</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="unidir_en">
                    <gui_name language="en">unidir_en</gui_name>
                    <description language="en">Uni-direction-enable. When low the PCS will transmit idle symbols if the link goes down. When high the PCS can transmit frame data when the link is down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="ignore_ipg_rx_er">
                    <gui_name language="en">ignore_ipg_rx_er</gui_name>
                    <description language="en">Ignore IPG rx_er. When set rx_er has no effect on the GEM's operation when rx_dv is low. Set this when using the RGMII wrapper in half-duplex mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="rx_bad_preamble">
                    <gui_name language="en">rx_bad_preamble</gui_name>
                    <description language="en">Receive bad preamble. When set frames with non-standard preamble are not rejected.</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="ipg_stretch_en">
                    <gui_name language="en">ipg_stretch_en</gui_name>
                    <description language="en">IPG stretch enable - when set the transmit IPG can be increased above 96 bit times depending on the previous frame length using the IPG stretch register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="sgmii_en">
                    <gui_name language="en">sgmii_en</gui_name>
                    <description language="en">SGMII mode enable - changes behaviour of the auto-negotiation advertisement and link partner ability registers to meet the requirements of SGMII and reduces the duration of the link timer from 10 ms to 1.6 ms</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="ignore_rx_fcs">
                    <gui_name language="en">ignore_rx_fcs</gui_name>
                    <description language="en">Ignore RX FCS - when set frames with FCS/CRC errors will not be rejected. FCS error statistics will still be collected for frames with bad FCS and FCS status will be recorded in frame's DMA descriptor.
For normal operation this bit must be set to zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="rx_hd_while_tx">
                    <gui_name language="en">rx_hd_while_tx</gui_name>
                    <description language="en">Enable frames to be received in half-duplex mode while transmitting.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="rx_chksum_offld_en">
                    <gui_name language="en">rx_chksum_offld_en</gui_name>
                    <description language="en">Receive checksum offload enable - when set, the receive checksum engine is enabled. Frames with bad IP, TCP or UDP checksums are discarded.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="dis_cp_pause_frame">
                    <gui_name language="en">dis_cp_pause_frame</gui_name>
                    <description language="en">Disable copy of pause frames - set to one to prevent valid pause frames being copied to memory. When set, pause frames are not copied to memory regardless of the state of the copy all frames bit; whether a hash match is found or whether a type ID match is identified. If a destination address match is found the pause frame will be copied to memory.
Note that valid pause frames received will still increment pause statistics and pause the transmission of frames as required.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_dbus_width_ENUM" high_bit="22" low_bit="21" name="dbus_width">
                    <gui_name language="en">dbus_width</gui_name>
                    <description language="en">Data bus width - set according to AMBA AHB or external FIFO data bus width. The reset value for this can be changed by defining a new value for gem_dma_bus_width_def in gem_defs.v Only valid bus widths may be written if the system is configured to a maximum width less than 128-bits. Pele defines gem_dma_bus_width_def as 2'b00.
00: 32 bit AMBA AHB data bus width
01: 64 bit AMBA AHB data bus width
10: 128 bit AMBA AHB data bus width
11: 128 bit AMBA AHB data bus width</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_mdc_clk_div_ENUM" high_bit="20" low_bit="18" name="mdc_clk_div">
                    <gui_name language="en">mdc_clk_div</gui_name>
                    <description language="en">MDC clock division - set according to pclk speed.
These three bits determine the number pclk will be divided by to generate MDC. For conformance with the 802.3 specification, MDC must not exceed 2.5 MHz (MDC is only active during MDIO read and write operations). The reset value for this can be changed by defining a new value for gem_mdc_clock_div in gem_defs.v. Pele defines gem_mdc_clock_div as 3'b010.
000: divide pclk by 8 (pclk up to 20 MHz)
001: divide pclk by 16 (pclk up to 40 MHz)
010: divide pclk by 32 (pclk up to 80 MHz)
011: divide pclk by 48 (pclk up to 120MHz)
100: divide pclk by 64 (pclk up to 160 MHz)
101: divide pclk by 96 (pclk up to 240 MHz)
110: divide pclk by 128 (pclk up to 320 MHz)
111: divide pclk by 224 (pclk up to 540 MHz)</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="fcs_remove">
                    <gui_name language="en">fcs_remove</gui_name>
                    <description language="en">FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). The frame length indicated will be reduced by four bytes in this mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="len_err_frame_disc">
                    <gui_name language="en">len_err_frame_disc</gui_name>
                    <description language="en">Length field error frame discard - setting this bit causes frames with a measured length shorter than the extracted length field (as indicated by bytes 13 and 14 in a non-VLAN tagged frame) to be discarded. This only applies to frames with a length field less than 0x0600.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="14" name="rx_buf_offset">
                    <gui_name language="en">rx_buf_offset</gui_name>
                    <description language="en">Receive buffer offset - indicates the number of bytes by which the received data is offset from the start of the receive buffer.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="pause_en">
                    <gui_name language="en">pause_en</gui_name>
                    <description language="en">Pause enable - when set, transmission will pause if a non zero 802.3 classic pause frame is received and PFC has not been negotiated.</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="retry_test">
                    <gui_name language="en">retry_test</gui_name>
                    <description language="en">Retry test - must be set to zero for normal operation.
If set to one the backoff between collisions will always be one slot time. Setting this bit to one helps test the too many retries condition. Also used in the pause frame tests to reduce the pause counter's decrement time from 512 bit times, to every rx_clk cycle.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_pcs_sel_ENUM" high_bit="11" low_bit="11" name="pcs_sel">
                    <gui_name language="en">pcs_sel</gui_name>
                    <description language="en">PCS select - selects between MII/GMII and TBI.
Must be set for SGMII operation.
0: GMII/MII interface enabled, TBI disabled
1: TBI enabled, GMII/MII disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_gige_en_ENUM" high_bit="10" low_bit="10" name="gige_en">
                    <gui_name language="en">gige_en</gui_name>
                    <description language="en">Gigabit mode enable - setting this bit configures the GEM for 1000 Mbps operation.
0: 10/100 operation using MII or TBI interface
1: Gigabit operation using GMII or TBI interface</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="ext_addr_match_en">
                    <gui_name language="en">ext_addr_match_en</gui_name>
                    <description language="en">External address match enable - when set the external address match interface can be used to copy frames to memory.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="uni_hash_en">
                    <gui_name language="en">uni_hash_en</gui_name>
                    <description language="en">Unicast hash enable - when set, unicast frames will be accepted when the 6 bit hash function of the destination address points to a bit that is set in the hash register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="multi_hash_en">
                    <gui_name language="en">multi_hash_en</gui_name>
                    <description language="en">Multicast hash enable - when set, multicast frames will be accepted when the 6 bit hash function of the destination address points to a bit that is set in the hash register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="no_broadcast">
                    <gui_name language="en">no_broadcast</gui_name>
                    <description language="en">No broadcast - when set to logic one, frames addressed to the broadcast address of all ones will not be accepted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="copy_all">
                    <gui_name language="en">copy_all</gui_name>
                    <description language="en">Copy all frames - when set to logic one, all valid frames will be accepted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="disc_non_vlan">
                    <gui_name language="en">disc_non_vlan</gui_name>
                    <description language="en">Discard non-VLAN frames - when set only VLAN tagged frames will be passed to the address matching logic.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="full_duplex">
                    <gui_name language="en">full_duplex</gui_name>
                    <description language="en">Full duplex - if set to logic one, the transmit block ignores the state of collision and carrier sense and allows receive while transmitting. Also controls the half_duplex pin.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="speed">
                    <gui_name language="en">speed</gui_name>
                    <description language="en">Speed - set to logic one to indicate 100Mbps operation, logic zero for 10Mbps. The value of this pin is reflected on the speed_mode[0] output pin.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_NET_STATUS" offset="0xe000b008" size="0x4">
                <gui_name language="en">net_status</gui_name>
                <description language="en">The network status register returns status information with respect to the PHY management
interface.</description>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="pfc_pri_pause_neg">
                    <gui_name language="en">pfc_pri_pause_neg</gui_name>
                    <description language="en">Set when PFC Priority Based Pause has been negotiated.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="pcs_autoneg_pause_tx_res">
                    <gui_name language="en">pcs_autoneg_pause_tx_res</gui_name>
                    <description language="en">PCS auto-negotiation pause transmit resolution.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="pcs_autoneg_pause_rx_res">
                    <gui_name language="en">pcs_autoneg_pause_rx_res</gui_name>
                    <description language="en">PCS auto-negotiation pause receive resolution</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="pcs_autoneg_dup_res">
                    <gui_name language="en">pcs_autoneg_dup_res</gui_name>
                    <description language="en">PCS auto-negotiation duplex resolution. Set to one if the resolution function determines that both devices are capable of full duplex operation. If zero half-duplex operation is possible as long as bit 0 (PCS link state) is also one.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="phy_mgmt_idle">
                    <gui_name language="en">phy_mgmt_idle</gui_name>
                    <description language="en">The PHY management logic is idle (i.e. has completed).</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="mdio_in_pin_status">
                    <gui_name language="en">mdio_in_pin_status</gui_name>
                    <description language="en">Returns status of the mdio_in pin</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="pcs_link_state">
                    <gui_name language="en">pcs_link_state</gui_name>
                    <description language="en">Returns status of PCS link state. If auto-negotiation is disabled this returns the synchronisation status. If auto-negotiation is enabled it is set in the LINK_OK state as long as a compatible duplex mode is resolved, it is always set in the LINK_OK state in SGMII mode.</description>
                </bitField>
            </register>
            <register name="GEM0_USER_IO" offset="0xe000b00c" size="0x4">
                <gui_name language="en">user_io</gui_name>
                <description language="en">User Input/Output.
The GEM design provides up to 16 inputs and 16 outputs so that the I/O may be read or set under the control of the processor interface.
If the user I/O is disabled as a configuration option, this address space is defined as reserved, and hence will be a read-only register of the value 0x0.
If enabled, the number of inputs and outputs can be configured separately. The first output will be represented in bit 0 of the user I/O register, the second output will use bit 1 and so on.
The first input will be represented in bit 16 of the user I/O register, the second input will use bit 17 and so on.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="user_in">
                    <gui_name language="en">user_in</gui_name>
                    <description language="en">User programmable inputs - the upper 16 bits of this register are used to monitor the state of the user inputs. A logic one read from a bit in this range will correspond to the input being in a high state. A logic zero read from a bit in this range will correspond to the input being in a low state. Any unused bits will be read as zero. Writing to any bits in this range will have no functional effect.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="user_out">
                    <gui_name language="en">user_out</gui_name>
                    <description language="en">User programmable outputs - the lower 16 bits of this register are used to control the state of the user outputs. A logic one written to a bit in this range will cause the corresponding output to be set high. A logic zero written to a bit in this range shall cause the corresponding output to be forced low. Any unused bits will be read as logic zero. Writing to any unused bits in this range will have no functional effect.</description>
                </bitField>
            </register>
            <register name="GEM0_DMA_CFG" offset="0xe000b010" size="0x4">
                <gui_name language="en">dma_cfg</gui_name>
                <description language="en">DMA Configuration Register</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="disc_when_no_ahb">
                    <gui_name language="en">disc_when_no_ahb</gui_name>
                    <description language="en">When set, the GEM DMA will automatically discard receive packets from the receiver packet buffer memory when no AHB resource is available.
When low, then received packets will remain to be stored in the SRAM based packet buffer until AHB buffer resource next becomes available.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ahb_mem_rx_buf_size">
                    <gui_name language="en">ahb_mem_rx_buf_size</gui_name>
                    <description language="en">DMA receive buffer size in AHB system memory.
The value defined by these bits determines the size of buffer to use in main AHB system memory when writing received data.
The value is defined in multiples of 64 bytes such that a value of 0x01 corresponds to buffers of 64 bytes, 0x02 corresponds to 128 bytes etc.
For example:-
0x02: 128 byte
0x18: 1536 byte (1*max length frame/buffer)
0xA0: 10240 byte (1*10K jumbo frame/buffer)
Note that this value should never be written as zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="csum_gen_offload_en">
                    <gui_name language="en">csum_gen_offload_en</gui_name>
                    <description language="en">Transmitter IP, TCP and UDP checksum generation offload enable. When set, the transmitter checksum generation engine is enabled, to calculate and substitute checksums for transmit frames. When clear, frame data is unaffected.
If the GEM is not configured to use the DMA packet buffer, this bit is not implemented and will be treated as reserved, read as zero, ignored on write.
Pele uses packet buffer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="dma_cfg_tx_pktbuf_memsz_sel_ENUM" high_bit="10" low_bit="10" name="tx_pktbuf_memsz_sel">
                    <gui_name language="en">tx_pktbuf_memsz_sel</gui_name>
                    <description language="en">Transmitter packet buffer memory size select - Having this bit at zero halves the amount of memory used for the transmit packet buffer. This reduces the amount of memory used by the GEM. It is important to set this bit to one if the full configured physical memory is available. The value in brackets below represents the size that would result for the default maximum configured memory size of 4 Kbytes.
1: Use full configured addressable space (4 Kb)
0: Do not use top address bit (2 Kb)
If the GEM is not configured to use the DMA packet buffer, this bit is not implemented and will be treated as reserved, read as zero, ignored on write. Pele uses packet buffer</description>
                </bitField>
                <bitField access="Read Write" enumerationId="dma_cfg_rx_pktbuf_memsz_sel_ENUM" high_bit="9" low_bit="8" name="rx_pktbuf_memsz_sel">
                    <gui_name language="en">rx_pktbuf_memsz_sel</gui_name>
                    <description language="en">Receiver packet buffer memory size select - Having these bits at less than 11 reduces the amount of memory used for the receive packet buffer. This reduces the amount of memory used by the GEM. It is important to set these bits both to one if the full configured physical memory is available. The value in brackets below represents the size that would result for the default maximum configured memory size of 8 Kbytes.
11: Use full configured addressable space (8 Kb)
10: Do not use top address bit (4 Kb)
01: Do not use top two address bits (2 Kb)
00: Do not use top three address bits (1 Kb)
If the GEM is not configured to use the DMA packet buffer, these bits are not implemented and will be treated as reserved, read as zero, ignored on write. Pele uses packet buffer.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="ahb_endian_swp_pkt_en">
                    <gui_name language="en">ahb_endian_swp_pkt_en</gui_name>
                    <description language="en">AHB endian swap mode enable for packet data accesses - When set, selects swapped endianism for AHB transfers. When clear, selects little endian mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="ahb_endian_swp_mgmt_en">
                    <gui_name language="en">ahb_endian_swp_mgmt_en</gui_name>
                    <description language="en">AHB endian swap mode enable for management descriptor accesses - When set, selects swapped endianism for AHB transfers. When clear, selects little endian mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="dma_cfg_ahb_fixed_burst_len_ENUM" high_bit="4" low_bit="0" name="ahb_fixed_burst_len">
                    <gui_name language="en">ahb_fixed_burst_len</gui_name>
                    <description language="en">AHB fixed burst length for DMA data operations - Selects the burst length to attempt to use on the AHB when transferring frame data. Not used for DMA management operations and only used where space and data size allow. Otherwise SINGLE type AHB transfers are used.
Upper bits become non-writeable if the configured DMA TX and RX FIFO sizes are smaller than required to support the selected burst size.
One-hot priority encoding enforced automatically on register writes as follows, where 'x' represents don't care:-
1xxxx: Attempt to use INCR16 AHB bursts
01xxx: Attempt to use INCR8 AHB bursts
001xx: Attempt to use INCR4 AHB bursts
0001x: Always use SINGLE AHB bursts
00001: Always use SINGLE AHB bursts
default: Attempt to use INCR4 AHB bursts</description>
                </bitField>
            </register>
            <register name="GEM0_TX_STATUS" offset="0xe000b014" size="0x4">
                <gui_name language="en">tx_status</gui_name>
                <description language="en">Transmit Status Register. This register, when read, provides details of the status of a transmit. Once read, individual bits may be cleared by writing 1 to them. It is not possible to set a bit to 1 by writing to the
register.</description>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK - set when the DMA block sees hresp not OK. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="late_collision">
                    <gui_name language="en">late_collision</gui_name>
                    <description language="en">Late collision occurred - only set if the condition occurs in gigabit mode, as retry is not attempted.
Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="tx_under_run">
                    <gui_name language="en">tx_under_run</gui_name>
                    <description language="en">Transmit under run - this bit is set if the transmitter was forced to terminate a frame that it had already began transmitting due to further data being unavailable.
This bit is set if a transmitter status write back has not completed when another status write back is attempted.
When using the DMA interface configured for internal FIFO mode, this bit is also set when the transmit DMA has written the SOP data into the FIFO and either the AHB bus was not granted in time for further data, or because an AHB not OK response was returned, or because a used bit was read.
When using the DMA interface configured for packet buffer mode, this bit will never be set.
When using the external FIFO interface, this bit is also set when the tx_r_underflow input is asserted during a frame transfer. Cleared by writing a 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Transmit complete - set when a frame has been transmitted. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="tx_corr_ahb_err">
                    <gui_name language="en">tx_corr_ahb_err</gui_name>
                    <description language="en">Transmit frame corruption due to AHB error - set if an error occurs whilst midway through reading transmit frame from the AHB, including HRESP errors and buffers exhausted mid frame (if the buffers run out during transmission of a frame then transmission stops, FCS shall be bad and tx_er asserted).
Also set in DMA packet buffer mode if single frame is too large for configured packet buffer memory size.
Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="tx_go">
                    <gui_name language="en">tx_go</gui_name>
                    <description language="en">Transmit go - if high transmit is active.
When using the exposed FIFO interface, this bit represents bit 3 of the network control register.
When using the DMA interface this bit represents the tx_go variable as specified in the transmit buffer description.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="retry_limit_exceeded">
                    <gui_name language="en">retry_limit_exceeded</gui_name>
                    <description language="en">Retry limit exceeded - cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="collision">
                    <gui_name language="en">collision</gui_name>
                    <description language="en">Collision occurred - set by the assertion of collision.
Cleared by writing a one to this bit. When operating in 10/100 mode, this status indicates either a collision or a late collision. In gigabit mode, this status is not set for a late collision.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="used_bit_read">
                    <gui_name language="en">used_bit_read</gui_name>
                    <description language="en">Used bit read - set when a transmit buffer descriptor is read with its used bit set. Cleared by writing a one to this bit.</description>
                </bitField>
            </register>
            <register name="GEM0_RX_QBAR" offset="0xe000b018" size="0x4">
                <gui_name language="en">rx_qbar</gui_name>
                <description language="en">Receive Buffer Queue Base Address.
This register holds the start address of the receive buffer queue (receive buffers descriptor list). The receive buffer queue base address must be initialized before receive is enabled through bit 2 of the network control register. Once reception is enabled, any write to the receive buffer queue base address register is ignored. Reading this register returns the location of the descriptor currently being accessed. This value increments as buffers are used. Software should not use this register for determining where to remove received frames from the queue as it constantly changes as new frames are received. Software should instead work its way through the buffer descriptor queue checking the 'used' bits.
In terms of AMBA AHB operation, the descriptors are read from memory using a single 32bit AHB access. When the datapath is configured at 64bit, the descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is written to using a single AHB access.
For 32bit datapaths, the descriptors should be aligned at 32-bit boundaries and the descriptors are written to using two individual non sequential accesses.</description>
                <bitField access="Read Write" high_bit="31" low_bit="2" name="rx_q_baseaddr">
                    <gui_name language="en">rx_q_baseaddr</gui_name>
                    <description language="en">Receive buffer queue base address - written with the
address of the start of the receive queue.</description>
                </bitField>
            </register>
            <register name="GEM0_TX_QBAR" offset="0xe000b01c" size="0x4">
                <gui_name language="en">tx_qbar</gui_name>
                <description language="en">Transmit Buffer Queue Base Address.
This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored.
Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results.
Reading this register returns the location of the descriptor currently being accessed. Since the DMA handles two frames at once, this may not necessarily be pointing to the current frame being transmitted.
In terms of AMBA AHB operation, the descriptors are written to memory using a single 32bit AHB access. When the datapath is configured at 64bit, the descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AHB access. For 32bit datapaths, the descriptors should be aligned at 32-bit boundaries and the descriptors are read from memory using two individual non sequential accesses.</description>
                <bitField access="Read Write" high_bit="31" low_bit="2" name="tx_q_base_addr">
                    <gui_name language="en">tx_q_base_addr</gui_name>
                    <description language="en">Transmit buffer queue base address - written with the address of the start of the transmit queue.</description>
                </bitField>
            </register>
            <register name="GEM0_RX_STATUS" offset="0xe000b020" size="0x4">
                <gui_name language="en">rx_status</gui_name>
                <description language="en">When read provides details of the status of a receive. Once read, individual bits may be cleared by writing 1 to them. It is not possible to set a bit to 1 by writing to the register.</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK - set when the DMA block sees hresp not OK. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Receive overrun - this bit is set if either the gem_dma RX FIFO or external RX FIFO were unable to store the receive frame due to a FIFO overflow, or if the receive status, reported by the gem_rx module to the gem_dma was not taken at end of frame. This bit is also set in DMA packet buffer mode if the packet buffer overflows. For DMA operation the buffer will be recovered if an overrun occurs. This bit is cleared by writing a one to it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="frame_recd">
                    <gui_name language="en">frame_recd</gui_name>
                    <description language="en">Frame received - one or more frames have been received and placed in memory. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="buffer_not_avail">
                    <gui_name language="en">buffer_not_avail</gui_name>
                    <description language="en">Buffer not available - an attempt was made to get a new buffer and the pointer indicated that it was owned by the processor. The DMA will reread the pointer each time an end of frame is received until a valid pointer is found. This bit is set following each descriptor read attempt that fails, even if consecutive pointers are unsuccessful and software has in the mean time cleared the status flag. Cleared by writing a one to this bit.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_INTR_STATUS" offset="0xe000b024" size="0x4">
                <gui_name language="en">intr_status</gui_name>
                <description language="en">If not configured for priority queueing, the GEM generates a single interrupt; Pele does not support priority queueing. This register indicates the source of this interrupt. The corresponding bit in the mask register must be clear for a bit to be set. If any bit is set in this register the ethernet_int signal will be asserted.
For test purposes each bit can be set or reset by writing to the interrupt mask register.
The `gem_irq_read_clear define determines if a one must be written to the appropriate bit in order to clear it; in this mode reading has no affect on the status of the bit.
Pele leaves gem_irq_read_clear undefined, so that this register is write-one-to-clear instead of clear on read.</description>
                <bitField access="Read Only" high_bit="26" low_bit="26" name="tsu_sec_incr">
                    <gui_name language="en">tsu_sec_incr</gui_name>
                    <description language="en">TSU seconds register increment - indicates the register has incremented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">PTP pdelay_resp frame transmitted - indicates a PTP pdelay_resp frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">PTP pdelay_req frame transmitted - indicates a PTP pdelay_req frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">PTP pdelay_resp frame received - indicates a PTP pdelay_resp frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">PTP pdelay_req frame received - indicates a PTP pdelay_req frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">PTP sync frame transmitted - indicates a PTP sync frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">PTP delay_req frame transmitted - indicates a PTP delay_req frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">PTP sync frame received - indicates a PTP sync frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">PTP delay_req frame received - indicates a PTP delay_req frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">PCS link partner page received - set when a new base page or next page is received from the link partner. The first time this interrupt is received, it will indicate base page received and subsequent reads will indicate next pages. The next page and base page registers should only be read when this interrupt is signalled. For next pages, the link partner next page register should be read first to avoid the register being over written. This interrupt also indicates when the host should write a new page into the next page register. If further next page exchange is only required by the link partner, this register should be written with a null message page (0x2001).</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">PCS auto-negotiation complete - set once the internal PCS layer has completed auto-negotiation.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">External interrupt - set when a rising edge has been detected on the ext_interrupt_in input pin.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Pause frame transmitted - indicates a pause frame has been successfully transmitted after being initiated from the network control register or from the tx_pause control pin.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Pause time zero - set when either the pause time register at address 0x38 decrements to zero, or when a valid pause frame is received with a zero pause quantum field.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="pause_nonzeroq_rx">
                    <gui_name language="en">pause_nonzeroq_rx</gui_name>
                    <description language="en">Pause frame with non-zero pause quantum received - indicates a valid pause has been received that has a non-zero pause quantum field.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK - set when the DMA block sees hresp not OK.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Receive overrun - set when the receive overrun status bit gets set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Link change - set when the state of the link detected by the internal PCS changes state.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Transmit complete - set when a frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Transmit frame corruption due to AHB error - set if an error occurs whilst midway through reading transmit frame from the AHB, including HRESP errors and buffers exhausted mid frame (if the buffers run out during transmission of a frame then transmission stops, FCS shall be bad and tx_er asserted).
Also set in DMA packet buffer mode if single frame is too large for configured packet buffer memory size.
Cleared on a read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Retry limit exceeded or late collision - transmit error.
Late collision will only cause this status bit to be set in gigabit mode (as a retry is not attempted).</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">TX used bit read - set when a transmit buffer descriptor is read with its used bit set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">RX used bit read - set when a receive buffer descriptor is read with its used bit set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Receive complete - a frame has been stored in memory.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="mgmt_sent">
                    <gui_name language="en">mgmt_sent</gui_name>
                    <description language="en">Management frame sent - the PHY maintenance register has completed its operation.</description>
                </bitField>
            </register>
            <register access="Write Only" name="GEM0_INTR_EN" offset="0xe000b028" size="0x4">
                <gui_name language="en">intr_en</gui_name>
                <description language="en">Interrupt Enable Register. At reset all interrupts are disabled. Writing a one to the relevant bit location enables the required interrupt. This register is write only and when read will return zero.</description>
                <bitField access="Write Only" high_bit="26" low_bit="26" name="tsu_sec_incr">
                    <gui_name language="en">tsu_sec_incr</gui_name>
                    <description language="en">Enable TSU seconds register increment interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">Enable PTP pdelay_resp frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">Enable PTP pdelay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">Enable PTP pdelay_resp frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">Enable PTP pdelay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">Enable PTP sync frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">Enable PTP delay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">Enable PTP sync frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">Enable PTP delay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">Enable PCS link partner page received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">Enable PCS auto-negotiation complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">Enable external interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Enable pause frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Enable pause time zero interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="pause_nonzeroq">
                    <gui_name language="en">pause_nonzeroq</gui_name>
                    <description language="en">Enable pause frame with non-zero pause quantum interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Enable hresp not OK interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Enable receive overrun interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Enable link change interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Enable transmit complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Enable transmit frame corruption due to AHB error interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Enable retry limit exceeded or late collision interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="tx_underrun">
                    <gui_name language="en">tx_underrun</gui_name>
                    <description language="en">Enable transmit buffer under run interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">Enable transmit used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">Enable receive used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Enable receive complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="mgmt_done">
                    <gui_name language="en">mgmt_done</gui_name>
                    <description language="en">Enable management done interrupt</description>
                </bitField>
            </register>
            <register access="Write Only" name="GEM0_INTR_DIS" offset="0xe000b02c" size="0x4">
                <gui_name language="en">intr_dis</gui_name>
                <description language="en">Interrupt Disable Register.
Writing a 1 to the relevant bit location disables that particular interrupt. This register is write only and when read will return zero</description>
                <bitField access="Write Only" high_bit="26" low_bit="26" name="tsu_sec_incr">
                    <gui_name language="en">tsu_sec_incr</gui_name>
                    <description language="en">Disable TSU seconds register increment interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">Disable PTP pdelay_resp frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">Disable PTP pdelay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">Disable PTP pdelay_resp frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">Disable PTP pdelay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">Disable PTP sync frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">Disable PTP delay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">Disable PTP sync frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">Disable PTP delay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">Disable PCS link partner page received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">Disable PCS auto-negotiation complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">Disable external interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Disable pause frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Disable pause time zero interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="pause_nonzeroq">
                    <gui_name language="en">pause_nonzeroq</gui_name>
                    <description language="en">Disable pause frame with non-zero pause quantum interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Disable hresp not OK interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Disable receive overrun interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Disable link change interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Disable transmit complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Disable transmit frame corruption due to AHB error interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Disable retry limit exceeded or late collision interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="tx_underrun">
                    <gui_name language="en">tx_underrun</gui_name>
                    <description language="en">Disable transmit buffer under run interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">Disable transmit used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">Disable receive used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Disable receive complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="mgmt_done">
                    <gui_name language="en">mgmt_done</gui_name>
                    <description language="en">Disable management done interrupt</description>
                </bitField>
            </register>
            <register name="GEM0_INTR_MASK" offset="0xe000b030" size="0x4">
                <gui_name language="en">intr_mask</gui_name>
                <description language="en">Interrupt Mask Register.
The interrupt mask register is a read only register indicating which interrupts are masked. All bits are set at reset and can be reset individually by writing to the interrupt enable register or set individually by writing to the interrupt disable register. Having separate address locations for enable and disable saves the need for performing a read modify write when updating the interrupt mask register.
For test purposes there is a write-only function to this register that allows the bits in the interrupt status register to be set or cleared, regardless of the state of the mask register.</description>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">PTP pdelay_resp frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">PTP pdelay_req frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">PTP pdelay_resp frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">PTP pdelay_req frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">PTP sync frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">PTP delay_req frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">PTP sync frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">PTP delay_req frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">PCS link partner page mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">PCS auto-negotiation complete interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">External interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Pause frame transmitted interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Pause time zero interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="pause_nonzeroq">
                    <gui_name language="en">pause_nonzeroq</gui_name>
                    <description language="en">Pause frame with non-zero pause quantum interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Receive overrun interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Link change interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Transmit complete interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Transmit frame corruption due to AHB error interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Retry limit exceeded or late collision (gigabit mode only)</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="tx_underrun">
                    <gui_name language="en">tx_underrun</gui_name>
                    <description language="en">Transmit buffer under run interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">Transmit used bit read interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">Receive used bit read interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Receive complete interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="mgmt_done">
                    <gui_name language="en">mgmt_done</gui_name>
                    <description language="en">Management done interrupt mask.</description>
                </bitField>
            </register>
            <register name="GEM0_PHY_MAINT" offset="0xe000b034" size="0x4">
                <gui_name language="en">phy_maint</gui_name>
                <description language="en">PHY Maintenance Register
The PHY maintenance register is implemented as a shift register. Writing to the register starts a shift operation which is signalled as complete when bit-2 is set in the network status register. It takes about 2000 pclk cycles to complete, when MDC is set for pclk divide by 32 in the network configuration register. An interrupt is generated upon completion.
During this time, the MSB of the register is output on the MDIO pin and the LSB updated from the MDIO pin with each MDC cycle. This causes transmission of a PHY management frame on MDIO. See Section 22.2.4.5 of the IEEE 802.3 standard.
Reading during the shift operation will return the current contents of the shift register. At the end of management operation, the bits will have shifted back to their original locations. For a read operation, the data bits will be updated with data read from the PHY. It is important to write the correct values to the register to ensure a valid PHY management frame is produced.
The MDIO interface can read IEEE 802.3 clause 45 PHYs as well as clause 22 PHYs. To read clause 45 PHYs, bit 30 should be written with a 0 rather than a 1.
For a description of MDC generation, see Network Configuration Register</description>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="clause_22">
                    <gui_name language="en">clause_22</gui_name>
                    <description language="en">Must be written to 1 for Clause 22 operation.
Check you PHY's spec to see if it is clause 22 or clause 45 compliant.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="28" name="operation">
                    <gui_name language="en">operation</gui_name>
                    <description language="en">Operation. 10 is read. 01 is write.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="23" name="phy_addr">
                    <gui_name language="en">phy_addr</gui_name>
                    <description language="en">PHY address.</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="18" name="reg_addr">
                    <gui_name language="en">reg_addr</gui_name>
                    <description language="en">Register address - specifies the register in the PHY to access.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="16" name="must_10">
                    <gui_name language="en">must_10</gui_name>
                    <description language="en">Must be written to 10.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="data">
                    <gui_name language="en">data</gui_name>
                    <description language="en">For a write operation this is written with the data to be written to the PHY. After a read operation this contains the data read from the PHY.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_RX_PAUSEQ" offset="0xe000b038" size="0x4">
                <gui_name language="en">rx_pauseq</gui_name>
                <description language="en">Received Pause Quantum Register</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="rx_pauseq">
                    <gui_name language="en">rx_pauseq</gui_name>
                    <description language="en">Received pause quantum - stores the current value of the received pause quantum register which is decremented every 512 bit times.</description>
                </bitField>
            </register>
            <register name="GEM0_TX_PAUSEQ" offset="0xe000b03c" size="0x4">
                <gui_name language="en">tx_pauseq</gui_name>
                <description language="en">Transmit Pause Quantum Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="tx_pauseq">
                    <gui_name language="en">tx_pauseq</gui_name>
                    <description language="en">Transmit pause quantum - written with the pause quantum value for pause frame transmission</description>
                </bitField>
            </register>
            <register name="GEM0_HASH_BOT" offset="0xe000b080" size="0x4">
                <gui_name language="en">hash_bot</gui_name>
                <description language="en">Hash Register Bottom [31:0]. The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames.</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The first 32 bits of the hash address register.</description>
                </bitField>
            </register>
            <register name="GEM0_HASH_TOP" offset="0xe000b084" size="0x4">
                <gui_name language="en">hash_top</gui_name>
                <description language="en">Hash Register Top [63:32]. The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames.</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The remaining 32 bits of the hash address register.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR1_BOT" offset="0xe000b088" size="0x4">
                <gui_name language="en">spec_addr1_bot</gui_name>
                <description language="en">Specific Address 1 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR1_TOP" offset="0xe000b08c" size="0x4">
                <gui_name language="en">spec_addr1_top</gui_name>
                <description language="en">Specific Address 1 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 1. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR2_BOT" offset="0xe000b090" size="0x4">
                <gui_name language="en">spec_addr2_bot</gui_name>
                <description language="en">Specific Address 2 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR2_TOP" offset="0xe000b094" size="0x4">
                <gui_name language="en">spec_addr2_top</gui_name>
                <description language="en">Specific Address 2 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 2. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR3_BOT" offset="0xe000b098" size="0x4">
                <gui_name language="en">spec_addr3_bot</gui_name>
                <description language="en">Specific Address 3 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR3_TOP" offset="0xe000b09c" size="0x4">
                <gui_name language="en">spec_addr3_top</gui_name>
                <description language="en">Specific Address 3 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 3. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR4_BOT" offset="0xe000b0a0" size="0x4">
                <gui_name language="en">spec_addr4_bot</gui_name>
                <description language="en">Specific Address 4 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR4_TOP" offset="0xe000b0a4" size="0x4">
                <gui_name language="en">spec_addr4_top</gui_name>
                <description language="en">Specific Address 4 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 4. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM0_TYPE_ID_MATCH1" offset="0xe000b0a8" size="0x4">
                <gui_name language="en">type_id_match1</gui_name>
                <description language="en">Type ID Match 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 1 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match1">
                    <gui_name language="en">type_id_match1</gui_name>
                    <description language="en">Type ID match 1. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM0_TYPE_ID_MATCH2" offset="0xe000b0ac" size="0x4">
                <gui_name language="en">type_id_match2</gui_name>
                <description language="en">Type ID Match 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 2 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match2">
                    <gui_name language="en">type_id_match2</gui_name>
                    <description language="en">Type ID match 2. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM0_TYPE_ID_MATCH3" offset="0xe000b0b0" size="0x4">
                <gui_name language="en">type_id_match3</gui_name>
                <description language="en">Type ID Match 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 3 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match3">
                    <gui_name language="en">type_id_match3</gui_name>
                    <description language="en">Type ID match 3. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM0_TYPE_ID_MATCH4" offset="0xe000b0b4" size="0x4">
                <gui_name language="en">type_id_match4</gui_name>
                <description language="en">Type ID Match 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 4 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match4">
                    <gui_name language="en">type_id_match4</gui_name>
                    <description language="en">Type ID match 4. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM0_WAKE_ON_LAN" offset="0xe000b0b8" size="0x4">
                <gui_name language="en">wake_on_lan</gui_name>
                <description language="en">Wake on LAN Register</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="multi_hash_en">
                    <gui_name language="en">multi_hash_en</gui_name>
                    <description language="en">Wake on LAN multicast hash event enable. When set multicast hash events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="spec_addr_reg1_en">
                    <gui_name language="en">spec_addr_reg1_en</gui_name>
                    <description language="en">Wake on LAN specific address register 1 event enable. When set specific address 1 events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="arp_req_en">
                    <gui_name language="en">arp_req_en</gui_name>
                    <description language="en">Wake on LAN ARP request event enable. When set ARP request events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="magic_pkt_en">
                    <gui_name language="en">magic_pkt_en</gui_name>
                    <description language="en">Wake on LAN magic packet event enable. When set magic packet events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="arp_req_ip_addr">
                    <gui_name language="en">arp_req_ip_addr</gui_name>
                    <description language="en">Wake on LAN ARP request IP address. Written to define the least significant 16 bits of the target IP address that is matched to generate a Wake on LAN event. A value of zero will not generate an event, even if this is matched by the received frame.</description>
                </bitField>
            </register>
            <register name="GEM0_IPG_STRETCH" offset="0xe000b0bc" size="0x4">
                <gui_name language="en">ipg_stretch</gui_name>
                <description language="en">IPG stretch register</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="ipg_stretch">
                    <gui_name language="en">ipg_stretch</gui_name>
                    <description language="en">Bits 7:0 are multiplied with the previously transmitted frame length (including preamble) bits 15:8 +1 divide the frame length. If the resulting number is greater than 96 and bit 28 is set in the network configuration register then the resulting number is used for the transmit inter-packet-gap. 1 is added to bits 15:8 to prevent a divide by zero.</description>
                </bitField>
            </register>
            <register name="GEM0_STACKED_VLAN" offset="0xe000b0c0" size="0x4">
                <gui_name language="en">stacked_vlan</gui_name>
                <description language="en">Stacked VLAN Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="stacked_vlan_en">
                    <gui_name language="en">stacked_vlan_en</gui_name>
                    <description language="en">Enable Stacked VLAN processing mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="user_def_vlan_type">
                    <gui_name language="en">user_def_vlan_type</gui_name>
                    <description language="en">User defined VLAN_TYPE field. When Stacked VLAN is enabled, the first VLAN tag in a received frame will only be accepted if the VLAN type field is equal to this user defined VLAN_TYPE OR equal to the standard VLAN type (0x8100). Note that the second VLAN tag of a Stacked VLAN packet will only be matched correctly if its VLAN_TYPE field equals 0x8100.</description>
                </bitField>
            </register>
            <register name="GEM0_TX_PFC_PAUSE" offset="0xe000b0c4" size="0x4">
                <gui_name language="en">tx_pfc_pause</gui_name>
                <description language="en">Transmit PFC Pause Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="pauseq_sel">
                    <gui_name language="en">pauseq_sel</gui_name>
                    <description language="en">If bit 17 of the network control register is written with a one then for each entry equal to zero in the Transmit PFC Pause Register[15:8], the PFC pause frame's pause quantum field associated with that entry will be taken from the transmit pause quantum register. For each entry equal to one in the Transmit PFC Pause Register [15:8], the pause quantum associated with that entry will be zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="pri_en_vec_val">
                    <gui_name language="en">pri_en_vec_val</gui_name>
                    <description language="en">If bit 17 of the network control register is written with a one then the priority enable vector of the PFC priority based pause frame will be set equal to the value stored in this register [7:0].</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR1_MASK_BOT" offset="0xe000b0c8" size="0x4">
                <gui_name language="en">spec_addr1_mask_bot</gui_name>
                <description language="en">Specific Address Mask 1 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="mask_bits_bot">
                    <gui_name language="en">mask_bits_bot</gui_name>
                    <description language="en">Setting a bit to one masks the corresponding bit in the specific address 1 register</description>
                </bitField>
            </register>
            <register name="GEM0_SPEC_ADDR1_MASK_TOP" offset="0xe000b0cc" size="0x4">
                <gui_name language="en">spec_addr1_mask_top</gui_name>
                <description language="en">Specific Address Mask 1 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="mask_bits_top">
                    <gui_name language="en">mask_bits_top</gui_name>
                    <description language="en">Setting a bit to one masks the corresponding bit in the specific address 1 register</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_MODULE_ID" offset="0xe000b0fc" size="0x4">
                <gui_name language="en">module_id</gui_name>
                <description language="en">Module ID Register. This register indicates a Cadence module identification number and module revision. The value of this register is read only as defined by `gem_revision_reg_value. In Pele with GEM p23, it is 0x00020118.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="module_id">
                    <gui_name language="en">module_id</gui_name>
                    <description language="en">Module identification number - for the GEM, this value is fixed at 0x0002.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="module_rev">
                    <gui_name language="en">module_rev</gui_name>
                    <description language="en">Module revision - fixed byte value specific to the revision of the design which is incremented after each release of the IP. Corresponds to Pele having GEM p23.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_OCTETS_TX_BOT" offset="0xe000b100" size="0x4">
                <gui_name language="en">octets_tx_bot</gui_name>
                <description language="en">Octets transmitted [31:0] (in frames without error). Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="octets_tx_bot">
                    <gui_name language="en">octets_tx_bot</gui_name>
                    <description language="en">Transmitted octets in frame without errors [31:0].
The number of octets transmitted in valid frames of any type. This counter is 48-bits, and is read through two registers. This count does not include octets from automatically generated pause frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_OCTETS_TX_TOP" offset="0xe000b104" size="0x4">
                <gui_name language="en">octets_tx_top</gui_name>
                <description language="en">Octets transmitted [47:32] (in frames without error). Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="octets_tx_top">
                    <gui_name language="en">octets_tx_top</gui_name>
                    <description language="en">Transmitted octets in frame without errors [47:32].
The number of octets transmitted in valid frames of
any type. This counter is 48-bits, and is read through
two registers. This count does not include octets
from automatically generated pause frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_TX" offset="0xe000b108" size="0x4">
                <gui_name language="en">frames_tx</gui_name>
                <description language="en">Frames transmitted without error, excluding pause
frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Frames transmitted without error. A 32 bit register
counting the number of frames successfully
transmitted, i.e. no under run and not too many
retries. Excludes pause frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_BROADCAST_FRAMES_TX" offset="0xe000b10c" size="0x4">
                <gui_name language="en">broadcast_frames_tx</gui_name>
                <description language="en">Broadcast frames transmitted without error,
excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Broadcast frames transmitted without error. A 32 bit
register counting the number of broadcast frames
successfully transmitted without error, i.e. no under
run and not too many retries. Excludes pause
frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_MULTI_FRAMES_TX" offset="0xe000b110" size="0x4">
                <gui_name language="en">multi_frames_tx</gui_name>
                <description language="en">Multicast frames transmitted without error,
excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Multicast frames transmitted without error. A 32 bit
register counting the number of multicast frames
successfully transmitted without error, i.e. no under
run and not too many retries. Excludes pause
frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PAUSE_FRAMES_TX" offset="0xe000b114" size="0x4">
                <gui_name language="en">pause_frames_tx</gui_name>
                <description language="en">Transmitted pause frames (unless sent through
external FIFO interface). In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="pause_frames_tx">
                    <gui_name language="en">pause_frames_tx</gui_name>
                    <description language="en">Transmitted pause frames - a 16 bit register
counting the number of pause frames transmitted.
Only pause frames triggered by the register interface
or through the external pause pins are counted as
pause frames. Pause frames received through the
external FIFO interface are counted in the frames
transmitted counter.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_64B_TX" offset="0xe000b118" size="0x4">
                <gui_name language="en">frames_64b_tx</gui_name>
                <description language="en">64 byte frames transmitted without error, excluding
pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">64 byte frames transmitted without error. A 32 bit
register counting the number of 64 byte frames
successfully transmitted without error, i.e. no under
run and not too many retries. Excludes pause
frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_65TO127B_TX" offset="0xe000b11c" size="0x4">
                <gui_name language="en">frames_65to127b_tx</gui_name>
                <description language="en">65 to 127 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">65 to127 byte frames transmitted without error. A 32
bit register counting the number of 65 to127 byte
frames successfully transmitted without error, i.e. no
under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_128TO255B_TX" offset="0xe000b120" size="0x4">
                <gui_name language="en">frames_128to255b_tx</gui_name>
                <description language="en">128 to 255 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">128 to 255 byte frames transmitted without error. A
32 bit register counting the number of 128 to 255
byte frames successfully transmitted without error,
i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_256TO511B_TX" offset="0xe000b124" size="0x4">
                <gui_name language="en">frames_256to511b_tx</gui_name>
                <description language="en">256 to 511 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">256 to 511 byte frames transmitted without error. A
32 bit register counting the number of 256 to 511
byte frames successfully transmitted without error,
i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_512TO1023B_TX" offset="0xe000b128" size="0x4">
                <gui_name language="en">frames_512to1023b_tx</gui_name>
                <description language="en">512 to 1023 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">512 to 1023 byte frames transmitted without error. A
32 bit register counting the number of 512 to 1023
byte frames successfully transmitted without error,
i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_1024TO1518B_TX" offset="0xe000b12c" size="0x4">
                <gui_name language="en">frames_1024to1518b_tx</gui_name>
                <description language="en">1024 to 1518 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">1024 to 1518 byte frames transmitted without error.
A 32 bit register counting the number of 1024 to
1518 byte frames successfully transmitted without
error, i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_TX_UNDER_RUNS" offset="0xe000b134" size="0x4">
                <gui_name language="en">tx_under_runs</gui_name>
                <description language="en">Transmit under runs. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="tx_under_runs">
                    <gui_name language="en">tx_under_runs</gui_name>
                    <description language="en">Transmit under runs - a 10 bit register counting the
number of frames not transmitted due to a transmit
under run. If this register is incremented then no
other statistics register is incremented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_SINGLE_COLLISN_FRAMES" offset="0xe000b138" size="0x4">
                <gui_name language="en">single_collisn_frames</gui_name>
                <description language="en">Single Collision Frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="single_collisn">
                    <gui_name language="en">single_collisn</gui_name>
                    <description language="en">Single collision frames - an 18 bit register counting
the number of frames experiencing a single collision
before being successfully transmitted, i.e. no under
run.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_MULTI_COLLISN_FRAMES" offset="0xe000b13c" size="0x4">
                <gui_name language="en">multi_collisn_frames</gui_name>
                <description language="en">Multiple Collision Frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="multi_collisn">
                    <gui_name language="en">multi_collisn</gui_name>
                    <description language="en">Multiple collision frames - an 18 bit register counting
the number of frames experiencing between two and
fifteen collisions prior to being successfully
transmitted, i.e. no under run and not too many
retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_EXCESSIVE_COLLISNS" offset="0xe000b140" size="0x4">
                <gui_name language="en">excessive_collisns</gui_name>
                <description language="en">Excessive Collisions. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="excessive_collisns">
                    <gui_name language="en">excessive_collisns</gui_name>
                    <description language="en">Excessive collisions - a 10 bit register counting the
number of frames that failed to be transmitted
because they experienced 16 collisions.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_LATE_COLLISNS" offset="0xe000b144" size="0x4">
                <gui_name language="en">late_collisns</gui_name>
                <description language="en">Late Collisions. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="late_collisns">
                    <gui_name language="en">late_collisns</gui_name>
                    <description language="en">Late collisions - a 10 bit register counting the number
of late collision occurring after the slot time (512 bits)
has expired. In 10/100 mode, late collisions are
counted twice i.e. both as a collision and a late
collision. In gigabit mode, a late collision causes the
transmission to be aborted, thus the single and multi
collision registers are not updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DEFERRED_TX_FRAMES" offset="0xe000b148" size="0x4">
                <gui_name language="en">deferred_tx_frames</gui_name>
                <description language="en">Deferred Transmission Frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="deferred_tx">
                    <gui_name language="en">deferred_tx</gui_name>
                    <description language="en">Deferred transmission frames - an 18 bit register
counting the number of frames experiencing deferral
due to carrier sense being active on their first
attempt at transmission. Frames involved in any
collision are not counted nor are frames that
experienced a transmit under run.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_CARRIER_SENSE_ERRS" offset="0xe000b14c" size="0x4">
                <gui_name language="en">carrier_sense_errs</gui_name>
                <description language="en">Carrier Sense Errors. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="carrier_sense_errs">
                    <gui_name language="en">carrier_sense_errs</gui_name>
                    <description language="en">Carrier sense errors - a 10 bit register counting the
number of frames transmitted where carrier sense
was not seen during transmission or where carrier
sense was deasserted after being asserted in a
transmit frame without collision (no under run). Only
incremented in half duplex mode. The only effect of
a carrier sense error is to increment this register.
The behaviour of the other statistics registers is
unaffected by the detection of a carrier sense error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_OCTETS_RX_BOT" offset="0xe000b150" size="0x4">
                <gui_name language="en">octets_rx_bot</gui_name>
                <description language="en">Octets Received [31:0]. Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="octets_rx_bot">
                    <gui_name language="en">octets_rx_bot</gui_name>
                    <description language="en">Received octets in frame without errors [31:0]. The
number of octets received in valid frames of any
type. This counter is 48-bits and is read through two
registers. This count does not include octets from
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_OCTETS_RX_TOP" offset="0xe000b154" size="0x4">
                <gui_name language="en">octets_rx_top</gui_name>
                <description language="en">Octets Received [47:32]. Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="octets_rx_top">
                    <gui_name language="en">octets_rx_top</gui_name>
                    <description language="en">Received octets in frame without errors [47:32]. The
number of octets received in valid frames of any
type. This counter is 48-bits and is read through two
registers. This count does not include octets from
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_RX" offset="0xe000b158" size="0x4">
                <gui_name language="en">frames_rx</gui_name>
                <description language="en">Frames received without error, excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Frames received without error. A 32 bit register
counting the number of frames successfully
received. Excludes pause frames, and is only
incremented if the frame is successfully filtered and
copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_BDCAST_FAMES_RX" offset="0xe000b15c" size="0x4">
                <gui_name language="en">bdcast_fames_rx</gui_name>
                <description language="en">Broadcast frames received without error, excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Broadcast frames received without error. A 32 bit
register counting the number of broadcast frames
successfully received without error. Excludes pause
frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_MULTI_FRAMES_RX" offset="0xe000b160" size="0x4">
                <gui_name language="en">multi_frames_rx</gui_name>
                <description language="en">Multicast frames received without error, excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Multicast frames received without error. A 32 bit
register counting the number of multicast frames
successfully received without error. Excludes pause
frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PAUSE_RX" offset="0xe000b164" size="0x4">
                <gui_name language="en">pause_rx</gui_name>
                <description language="en">Pause frames received. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="pause_rx">
                    <gui_name language="en">pause_rx</gui_name>
                    <description language="en">Received pause frames - a 16 bit register counting
the number of pause frames received without error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_64B_RX" offset="0xe000b168" size="0x4">
                <gui_name language="en">frames_64b_rx</gui_name>
                <description language="en">64 byte frames received without error, excluding
pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">64 byte frames received without error. A 32 bit
register counting the number of 64 byte frames
successfully received without error. Excludes pause
frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_65TO127B_RX" offset="0xe000b16c" size="0x4">
                <gui_name language="en">frames_65to127b_rx</gui_name>
                <description language="en">65 to 127 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">65 to 127 byte frames received without error. A 32 bit
register counting the number of 65 to 127 byte
frames successfully received without error. Excludes
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_128TO255B_RX" offset="0xe000b170" size="0x4">
                <gui_name language="en">frames_128to255b_rx</gui_name>
                <description language="en">128 to 255 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">128 to 255 byte frames received without error. A 32
bit register counting the number of 128 to 255 byte
frames successfully received without error. Excludes
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_256TO511B_RX" offset="0xe000b174" size="0x4">
                <gui_name language="en">frames_256to511b_rx</gui_name>
                <description language="en">256 to 511 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">256 to 511 byte frames received without error. A 32
bit register counting the number of 256 to 511 byte
frames successfully transmitted without error.
Excludes pause frames, and is only incremented if
the frame is successfully filtered and copied to
memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_512TO1023B_RX" offset="0xe000b178" size="0x4">
                <gui_name language="en">frames_512to1023b_rx</gui_name>
                <description language="en">512 to 1023 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">512 to 1023 byte frames received without error. A 32
bit register counting the number of 512 to 1023 byte
frames successfully received without error. Excludes
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FRAMES_1024TO1518B_RX" offset="0xe000b17c" size="0x4">
                <gui_name language="en">frames_1024to1518b_rx</gui_name>
                <description language="en">1024 to 1518 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">1024 to 1518 byte frames received without error. A
32 bit register counting the number of 1024 to 1518
byte frames successfully received without error.
Excludes pause frames, and is only incremented if
the frame is successfully filtered and copied to
memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_UNDERSZ_RX" offset="0xe000b184" size="0x4">
                <gui_name language="en">undersz_rx</gui_name>
                <description language="en">Undersize frames received</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="undersz_rx">
                    <gui_name language="en">undersz_rx</gui_name>
                    <description language="en">Undersize frames received - a 10 bit register
counting the number of frames received less than 64
bytes in length (10/100 mode or gigabit mode, full
duplex) that do not have either a CRC error or an
alignment error. In gigabit mode, half duplex, this
register counts either frames not conforming to the
minimum slot time of 512 bytes or frames not
conforming to the minimum frame size once bursting
is active.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_FCS_ERRORS" offset="0xe000b190" size="0x4">
                <gui_name language="en">fcs_errors</gui_name>
                <description language="en">Frame check sequence errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="fcs_errors">
                    <gui_name language="en">fcs_errors</gui_name>
                    <description language="en">Frame check sequence errors - a 10 bit register
counting frames that are an integral number of
bytes, have bad CRC and are between 64 and 1518
bytes in length. This register is
also incremented if a symbol error is detected and
the frame is of valid length and has an integral
number of bytes.
This register is incremented for a frame with bad
FCS, regardless of whether it is copied to memory
due to ignore FCS mode being enabled in bit 26 of
the network configuration register.H524</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_LENGTH_FIELD_ERRORS" offset="0xe000b194" size="0x4">
                <gui_name language="en">length_field_errors</gui_name>
                <description language="en">Length field frame errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="length_field_errors">
                    <gui_name language="en">length_field_errors</gui_name>
                    <description language="en">Length field frame errors - this 10-bit register counts
the number of frames received that have a
measured length shorter than that extracted from the
length field (bytes 13 and 14). This condition is only
counted if the value of the length field is less than
0x0600, the frame is not of excessive length and
checking is enabled through bit 16 of the network
configuration register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_RX_SYMBOL_ERRORS" offset="0xe000b198" size="0x4">
                <gui_name language="en">rx_symbol_errors</gui_name>
                <description language="en">Receive symbol errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="rx_symbol_errors">
                    <gui_name language="en">rx_symbol_errors</gui_name>
                    <description language="en">Receive symbol errors - a 10-bit register counting
the number of frames that had rx_er asserted
during reception. For 10/100 mode symbol errors
are counted regardless of frame length checks. For
gigabit mode the frame must satisfy slot time
requirements in order to count a symbol error.
Additionally, in gigabit half duplex mode, carrier
extension errors are also recorded. Receive symbol
errors will also be counted as an FCS or alignment
error if the frame is between 64 and 1518 bytes. If the frame is larger it will be
recorded as a jabber error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_ALIGN_ERRORS" offset="0xe000b19c" size="0x4">
                <gui_name language="en">align_errors</gui_name>
                <description language="en">Alignment errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="align_errors">
                    <gui_name language="en">align_errors</gui_name>
                    <description language="en">Alignment errors - a 10 bit register counting frames
that are not an integral number of bytes long and
have bad CRC when their length is truncated to an
integral number of bytes and are between 64 and
1518 bytes in length. This register is
also incremented if a symbol error is detected and
the frame is of valid length and does not have an
integral number of bytes.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_RX_RESOURCE_ERRORS" offset="0xe000b1a0" size="0x4">
                <gui_name language="en">rx_resource_errors</gui_name>
                <description language="en">Receive resource errors</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="rx_resource_errors">
                    <gui_name language="en">rx_resource_errors</gui_name>
                    <description language="en">Receive resource errors - an 18 bit register counting
the number of frames that were successfully
received by the MAC (correct address matched
frame and adequate slot time) but could not be
copied to memory because no receive buffer was
available. This will be either because the AHB bus
was not granted in time or because a hresp not OK
was returned.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_RX_OVERRUN_ERRORS" offset="0xe000b1a4" size="0x4">
                <gui_name language="en">rx_overrun_errors</gui_name>
                <description language="en">Receive overrun errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="rx_overrun_errors">
                    <gui_name language="en">rx_overrun_errors</gui_name>
                    <description language="en">Receive overruns - a 10 bit register counting the
number of frames that are address recognized but
were not copied to memory due to a receive overrun.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_IP_HDR_CSUM_ERRORS" offset="0xe000b1a8" size="0x4">
                <gui_name language="en">ip_hdr_csum_errors</gui_name>
                <description language="en">IP header checksum errors</description>
                <bitField access="Read Only" enumerationId="ip_hdr_csum_errors_ip_hdr_csum_errors_ENUM" high_bit="7" low_bit="0" name="ip_hdr_csum_errors">
                    <gui_name language="en">ip_hdr_csum_errors</gui_name>
                    <description language="en">0 IP header checksum errors - an 8-bit register
counting the number of frames discarded due to an
incorrect IP header checksum, but are between 64
and 1518 bytes and do not
have a CRC error, an alignment error, nor a symbol
error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_TCP_CSUM_ERRORS" offset="0xe000b1ac" size="0x4">
                <gui_name language="en">tcp_csum_errors</gui_name>
                <description language="en">TCP checksum errors</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="tcp_csum_errors">
                    <gui_name language="en">tcp_csum_errors</gui_name>
                    <description language="en">TCP checksum errors - an 8-bit register counting the
number of frames discarded due to an incorrect TCP
checksum, but are between 64 and 1518 bytes and do not have a CRC error,
an alignment error, nor a symbol error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_UDP_CSUM_ERRORS" offset="0xe000b1b0" size="0x4">
                <gui_name language="en">udp_csum_errors</gui_name>
                <description language="en">UDP checksum error</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="udp_csum_errors">
                    <gui_name language="en">udp_csum_errors</gui_name>
                    <description language="en">UDP checksum errors - an 8-bit register counting the
number of frames discarded due to an incorrect UDP
checksum, but are between 64 and 1518 bytes and do not have a CRC error,
an alignment error, nor a symbol error.</description>
                </bitField>
            </register>
            <register name="GEM0_TIMER_STROBE_S" offset="0xe000b1c8" size="0x4">
                <gui_name language="en">timer_strobe_s</gui_name>
                <description language="en">1588 timer sync strobe seconds</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The value of the Timer Seconds register captured
when gem_tsu_ms and gem_tsu_inc_ctrl are zero</description>
                </bitField>
            </register>
            <register name="GEM0_TIMER_STROBE_NS" offset="0xe000b1cc" size="0x4">
                <gui_name language="en">timer_strobe_ns</gui_name>
                <description language="en">1588 timer sync strobe nanoseconds</description>
                <bitField access="Read Write" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The value of the Timer Nanoseconds register
captured when gem_tsu_ms and gem_tsu_inc_ctrl
are zero.</description>
                </bitField>
            </register>
            <register name="GEM0_TIMER_S" offset="0xe000b1d0" size="0x4">
                <gui_name language="en">timer_s</gui_name>
                <description language="en">1588 timer seconds</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Timer count in seconds. This register is writeable. It
increments by one when the 1588 nanoseconds
counter counts to one second. It may also be
incremented when the timer adjust register is
written.</description>
                </bitField>
            </register>
            <register name="GEM0_TIMER_NS" offset="0xe000b1d4" size="0x4">
                <gui_name language="en">timer_ns</gui_name>
                <description language="en">1588 timer nanoseconds</description>
                <bitField access="Read Write" high_bit="29" low_bit="0" name="timer_ct_ns">
                    <gui_name language="en">timer_ct_ns</gui_name>
                    <description language="en">Timer count in nanoseconds. This register is
writeable. It can also be adjusted by writes to the
1588 timer adjust register. It increments by the value
of the 1588 timer increment register each clock
cycle.</description>
                </bitField>
            </register>
            <register name="GEM0_TIMER_ADJUST" offset="0xe000b1d8" size="0x4">
                <gui_name language="en">timer_adjust</gui_name>
                <description language="en">1588 timer adjust</description>
                <bitField access="Write Only" high_bit="31" low_bit="31" name="add_subn">
                    <gui_name language="en">add_subn</gui_name>
                    <description language="en">Write as one to subtract from the 1588 timer. Write
as zero to add to it.</description>
                </bitField>
                <bitField access="Write Only" high_bit="29" low_bit="0" name="ns_delta">
                    <gui_name language="en">ns_delta</gui_name>
                    <description language="en">The number of nanoseconds to increment or
decrement the 1588 timer nanoseconds register. If
necessary the 1588 seconds register will be
incremented or decremented.</description>
                </bitField>
            </register>
            <register name="GEM0_TIMER_INCR" offset="0xe000b1dc" size="0x4">
                <gui_name language="en">timer_incr</gui_name>
                <description language="en">1588 timer increment</description>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="incr_b4_alt">
                    <gui_name language="en">incr_b4_alt</gui_name>
                    <description language="en">The number of increments after which the alternative
increment is used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="timer_incr_alt_ct_ns_delta_ENUM" high_bit="15" low_bit="8" name="alt_ct_ns_delta">
                    <gui_name language="en">alt_ct_ns_delta</gui_name>
                    <description language="en">Alternative count of nanoseconds by which the 1588
timer nanoseconds register will be incremented
each clock cycle.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ns_delta">
                    <gui_name language="en">ns_delta</gui_name>
                    <description language="en">A count of nanoseconds by which the 1588 timer
nanoseconds register will be incremented each
clock cycle.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_TX_S" offset="0xe000b1e0" size="0x4">
                <gui_name language="en">ptp_tx_s</gui_name>
                <description language="en">PTP event frame transmitted seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
transmit primary event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP sync or delay_req frame. An
interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_TX_NS" offset="0xe000b1e4" size="0x4">
                <gui_name language="en">ptp_tx_ns</gui_name>
                <description language="en">PTP event frame transmitted nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP transmit primary event crosses the MII
interface. The actual update occurs when the GEM
recognizes the frame as a PTP sync or delay_req
frame. An interrupt is issued when the register is
updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_RX_S" offset="0xe000b1e8" size="0x4">
                <gui_name language="en">ptp_rx_s</gui_name>
                <description language="en">PTP event frame received seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
receive primary event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP sync or delay_req frame. An
interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_RX_NS" offset="0xe000b1ec" size="0x4">
                <gui_name language="en">ptp_rx_ns</gui_name>
                <description language="en">PTP event frame received nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP receive primary event crosses the MII interface.
The actual update occurs when the GEM recognizes
the frame as a PTP sync or delay_req frame. An
interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_PEER_TX_S" offset="0xe000b1f0" size="0x4">
                <gui_name language="en">ptp_peer_tx_s</gui_name>
                <description language="en">PTP peer event frame transmitted seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
transmit peer event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP pdealy_req or pdelay_resp frame.
An interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_PEER_TX_NS" offset="0xe000b1f4" size="0x4">
                <gui_name language="en">ptp_peer_tx_ns</gui_name>
                <description language="en">PTP peer event frame transmitted nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP transmit peer event crosses the MII interface.
The actual update occurs when the GEM recognizes
the frame as a PTP pdelay_req or pdelay_resp
frame. An interrupt is issued when the register is
updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_PEER_RX_S" offset="0xe000b1f8" size="0x4">
                <gui_name language="en">ptp_peer_rx_s</gui_name>
                <description language="en">PTP peer event frame received seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
receive peer event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP pdelay_req or pdelay_resp frame.
An interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_PTP_PEER_RX_NS" offset="0xe000b1fc" size="0x4">
                <gui_name language="en">ptp_peer_rx_ns</gui_name>
                <description language="en">PTP peer event frame received nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP receive peer event crosses the MII interface.
The actual update occurs when the GEM recognizes
the frame as a PTP pdelay_req or pdelay_resp
frame. An interrupt is issued when the register is
updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG1" offset="0xe000b280" size="0x4">
                <gui_name language="en">design_cfg1</gui_name>
                <description language="en">Design Configuration Register 1</description>
                <bitField access="Read Only" enumerationId="design_cfg1_gem_dma_bus_width_ENUM" high_bit="27" low_bit="25" name="gem_dma_bus_width">
                    <gui_name language="en">gem_dma_bus_width</gui_name>
                    <description language="en">Takes the value of the `gem_dma_bus_width DEFINE
3'b001 : 32-bit
3'b010 : 64-bit
3'b100 : 128-bit</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="extra_spec_add">
                    <gui_name language="en">extra_spec_add</gui_name>
                    <description language="en">Takes the value of the `extra_spec_add DEFINE. Undefined in Pele</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="gem_irq_read_clear">
                    <gui_name language="en">gem_irq_read_clear</gui_name>
                    <description language="en">Takes the value of the `gem_irq_read_clear DEFINE. Undefined in Pele. Keeping undefined means interrupt status registers are write-one-to-clear rather than clearing when read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="gem_no_snapshot">
                    <gui_name language="en">gem_no_snapshot</gui_name>
                    <description language="en">Takes the value of the `gem_no_snapshot DEFINE. Defined for Pele. Remove statistics snapshot
(not supported by driver)</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="gem_no_stats">
                    <gui_name language="en">gem_no_stats</gui_name>
                    <description language="en">Takes the value of the `gem_no_stats DEFINE. Undefined for Pele.
Include statistics registers.</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="gem_no_scan_pins">
                    <gui_name language="en">gem_no_scan_pins</gui_name>
                    <description language="en">Takes the value of the `gem_no_scan_pins DEFINE. Defined for Pele. Remove placeholder scan pins from module.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="15" name="gem_user_in_width">
                    <gui_name language="en">gem_user_in_width</gui_name>
                    <description language="en">Takes the value of the `gem_user_in_width DEFINE. Undefined for Pele. No requirement for user I/O.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="10" name="gem_user_out_width">
                    <gui_name language="en">gem_user_out_width</gui_name>
                    <description language="en">Takes the value of the `gem_user_out_width DEFINE. Undefined for Pele. No requirement for user I/O.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="gem_user_io">
                    <gui_name language="en">gem_user_io</gui_name>
                    <description language="en">Takes the value of the `gem_user_io DEFINE. Undefined for Pele. No requirement for user I/O.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="gem_apb_rev2">
                    <gui_name language="en">gem_apb_rev2</gui_name>
                    <description language="en">Takes the value of the `gem_apb_rev2 DEFINE. Defined for Pele. Use AMBA 2.0 APB.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="gem_apb_rev1">
                    <gui_name language="en">gem_apb_rev1</gui_name>
                    <description language="en">Takes the value of the `gem_apb_rev1 DEFINE. Undefined for Pele. Use AMBA 2.0 APB.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="gem_ext_fifo_interface">
                    <gui_name language="en">gem_ext_fifo_interface</gui_name>
                    <description language="en">Takes the value of the `gem_ext_fifo_interface. Undefined for Pele. Use AHB DMA; External FIFO interface not implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="gem_no_int_loopback">
                    <gui_name language="en">gem_no_int_loopback</gui_name>
                    <description language="en">Takes the value of the `gem_no_int_loopback DEFINE. Undefined for Pele. Include loopback test mode</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="gem_int_loopback">
                    <gui_name language="en">gem_int_loopback</gui_name>
                    <description language="en">Takes the value of the `gem_int_loopback DEFINE. Defined for Pele. Include loopback test mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="TDC_50">
                    <gui_name language="en">TDC_50</gui_name>
                    <description language="en">Takes the value of the `TDC_50 DEFINE. Undefined for Pele. Only used with PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="RDC_50">
                    <gui_name language="en">RDC_50</gui_name>
                    <description language="en">Takes the value of the `RDC_50 DEFINE. Undefined for Pele. Only used with PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="gem_serdes">
                    <gui_name language="en">gem_serdes</gui_name>
                    <description language="en">Takes the value of the `gem_serdes DEFINE. Undefined for Pele. Only used with PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="gem_no_pcs">
                    <gui_name language="en">gem_no_pcs</gui_name>
                    <description language="en">Takes the value of the `gem_no_pcs DEFINE. Defined for Pele. Use GEM without 1000-BASE-X PCS sublayer and Ten Bit Interface</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG2" offset="0xe000b284" size="0x4">
                <gui_name language="en">design_cfg2</gui_name>
                <description language="en">Design Configuration Register 2</description>
                <bitField access="Read Only" high_bit="29" low_bit="26" name="gem_tx_pbuf_addr">
                    <gui_name language="en">gem_tx_pbuf_addr</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_addr DEFINE. Max address bits for Tx packet buffer (10-bits for maximum 4 kB buffer)
Buffer size for Tx packet buffer mode will be 4kB.
This will allow one standard packet to be received while another is transferred to system memory by the DMA interface.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="22" name="gem_rx_pbuf_addr">
                    <gui_name language="en">gem_rx_pbuf_addr</gui_name>
                    <description language="en">Takes the value of the `gem_rx_pbuf_addr DEFINE. Max address bits for Rx packet buffer (10-bits for maximum 4 kB buffer)
Buffer size for Rx packet buffer mode will be 4kB.
This will allow one standard packet to be received while another is transferred to system memory by the DMA interface.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="gem_tx_pkt_buffer">
                    <gui_name language="en">gem_tx_pkt_buffer</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pkt_buffer DEFINE. Defined for Pele. Includes the transmitter packet buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="gem_rx_pkt_buffer">
                    <gui_name language="en">gem_rx_pkt_buffer</gui_name>
                    <description language="en">Takes the value of the `gem_rx_pkt_buffer DEFINE. Defined for Pele. Includes the receiver packet buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="gem_hprot_value">
                    <gui_name language="en">gem_hprot_value</gui_name>
                    <description language="en">Takes the value of the `gem_hprot_value DEFINE. For Pele set the fixed AHB HPROT value used during transfers</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="gem_jumbo_max_length">
                    <gui_name language="en">gem_jumbo_max_length</gui_name>
                    <description language="en">Takes the value of the `gem_jumbo_max_length DEFINE. Maximum length of jumbo frames accepted by receiver.
This is set to the size of the smallest of the two packet buffer, minus a margin for packet headers. However, Pele will not support jumbo frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG3" offset="0xe000b288" size="0x4">
                <gui_name language="en">design_cfg3</gui_name>
                <description language="en">Design Configuration Register 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="gem_rx_base2_fifo_size">
                    <gui_name language="en">gem_rx_base2_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_rx_base2_fifo_size DEFINE. Base-2 equivalent of `gem_rx_fifo_size</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="gem_rx_fifo_size">
                    <gui_name language="en">gem_rx_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_rx_fifo_size DEFINE. Set the size of the small Rx FIFO for grant latency. Extended to 16 deep to allow buffering of 64 byte maximum AHB burst size in Pele.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG4" offset="0xe000b28c" size="0x4">
                <gui_name language="en">design_cfg4</gui_name>
                <description language="en">Design Configuration Register 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="gem_tx_base2_fifo_size">
                    <gui_name language="en">gem_tx_base2_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_tx_base2_fifo_size DEFINE. Base-2 equivalent of `gem_tx_fifo_size</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="gem_tx_fifo_size">
                    <gui_name language="en">gem_tx_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_tx_fifo_size DEFINE. Set the size of the small TX FIFO for grant latency</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG5" offset="0xe000b290" size="0x4">
                <gui_name language="en">design_cfg5</gui_name>
                <description language="en">Design Configuration Register 5</description>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="gem_tsu_clk">
                    <gui_name language="en">gem_tsu_clk</gui_name>
                    <description language="en">Takes the value of the `gem_tsu_clk DEFINE. Undefined in Pele. 1588 Time Stamp Unit clock sourced from pclk rather than independent tsu_clk.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="20" name="gem_rx_buffer_length_def">
                    <gui_name language="en">gem_rx_buffer_length_def</gui_name>
                    <description language="en">Takes the value of the `gem_rx_buffer_length_def DEFINE. Set the default buffer length used by Rx DMA to 128 bytes in Pele</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="gem_tx_pbuf_size_def">
                    <gui_name language="en">gem_tx_pbuf_size_def</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_size_def DEFINE. Full 4 kB Tx packet buffer size - dedicated memory resource in Pele.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="design_cfg5_gem_rx_pbuf_size_def_ENUM" high_bit="18" low_bit="17" name="gem_rx_pbuf_size_def">
                    <gui_name language="en">gem_rx_pbuf_size_def</gui_name>
                    <description language="en">Takes the value of the `gem_rx_pbuf_size_def DEFINE. Full
4 kB Rx packet buffer size - dedicated memory resource in Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="15" name="gem_endian_swap_def">
                    <gui_name language="en">gem_endian_swap_def</gui_name>
                    <description language="en">Takes the value of the `gem_endian_swap_def DEFINE. Set to big endian data, little endian management descriptors in Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="gem_mdc_clock_div">
                    <gui_name language="en">gem_mdc_clock_div</gui_name>
                    <description language="en">Takes the value of the `gem_mdc_clock_div DEFINE. Set default MDC clock divisor (can still be programmed) in Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="10" name="gem_dma_bus_width">
                    <gui_name language="en">gem_dma_bus_width</gui_name>
                    <description language="en">Takes the value of the `gem_dma_bus_width_def DEFINE. Limit to 32-bit AHB bus in Pele</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="gem_phy_ident">
                    <gui_name language="en">gem_phy_ident</gui_name>
                    <description language="en">Takes the value of the `gem_phy_ident DEFINE. Undefined in Pele. Only used in PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="gem_tsu">
                    <gui_name language="en">gem_tsu</gui_name>
                    <description language="en">Takes the value of the `gem_tsu DEFINE. Defined in Pele. Include support for 1588 Time Stamp Unit</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="gem_tx_fifo_cnt_width">
                    <gui_name language="en">gem_tx_fifo_cnt_width</gui_name>
                    <description language="en">Takes the value of the `gem_tx_fifo_cnt_width DEFINE. Width for `gem_tx_fifo_size</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="gem_rx_fifo_cnt_width">
                    <gui_name language="en">gem_rx_fifo_cnt_width</gui_name>
                    <description language="en">Takes the value of the `gem_rx_fifo_cnt_width DEFINE. Width for `gem_rx_fifo_size.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG6" offset="0xe000b294" size="0x4">
                <gui_name language="en">design_cfg6</gui_name>
                <description language="en">Design Configuration Register 6</description>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="gem_tx_pbufq_seg_sz">
                    <gui_name language="en">gem_tx_pbufq_seg_sz</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_queue_segment_size DEFINE. Uses default GEM value in Pele. Ignored, no priority dma.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="dma_priority_queue7">
                    <gui_name language="en">dma_priority_queue7</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue7 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="dma_priority_queue6">
                    <gui_name language="en">dma_priority_queue6</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue6 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="dma_priority_queue5">
                    <gui_name language="en">dma_priority_queue5</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue5 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="dma_priority_queue4">
                    <gui_name language="en">dma_priority_queue4</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue4 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="dma_priority_queue3">
                    <gui_name language="en">dma_priority_queue3</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue3 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="dma_priority_queue2">
                    <gui_name language="en">dma_priority_queue2</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue2 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="dma_priority_queue1">
                    <gui_name language="en">dma_priority_queue1</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue1 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM0_DESIGN_CFG7" offset="0xe000b298" size="0x4">
                <gui_name language="en">design_cfg7</gui_name>
                <description language="en">Design Configuration Register 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="28" name="tx_pbuf_numseg_q7">
                    <gui_name language="en">tx_pbuf_numseg_q7</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q7 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="24" name="tx_pbuf_numseg_q6">
                    <gui_name language="en">tx_pbuf_numseg_q6</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q6 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="tx_pbuf_numseg_q5">
                    <gui_name language="en">tx_pbuf_numseg_q5</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q5 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="tx_pbuf_numseg_q4">
                    <gui_name language="en">tx_pbuf_numseg_q4</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q4 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="12" name="tx_pbuf_numseg_q3">
                    <gui_name language="en">tx_pbuf_numseg_q3</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q3 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="tx_pbuf_numseg_q2">
                    <gui_name language="en">tx_pbuf_numseg_q2</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q2 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="tx_pbuf_numseg_q1">
                    <gui_name language="en">tx_pbuf_numseg_q1</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q1 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="tx_pbuf_numseg_q0">
                    <gui_name language="en">tx_pbuf_numseg_q0</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q0 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_GEM1" name="GEM1" offset="0xe000c000">
            <gui_name language="en">gem1</gui_name>
            <description language="en">gem1</description>
            <register name="GEM1_NET_CTRL" offset="0xe000c000" size="0x4">
                <gui_name language="en">net_ctrl</gui_name>
                <description language="en">The network control register contains general MAC control functions for both receiver and transmitter.</description>
                <bitField access="Write Only" high_bit="18" low_bit="18" name="flush_next_rx_dpram_pkt">
                    <gui_name language="en">flush_next_rx_dpram_pkt</gui_name>
                    <description language="en">Flush the next packet from the external RX DPRAM.
Writing one to this bit will only have an effect if the DMA is not currently writing a packet already stored in the DPRAM to memory.</description>
                </bitField>
                <bitField access="Write Only" high_bit="17" low_bit="17" name="tx_pfc_pri_pri_pause_frame">
                    <gui_name language="en">tx_pfc_pri_pri_pause_frame</gui_name>
                    <description language="en">Transmit PFC Priority Based Pause Frame. Takes the values stored in the Transmit PFC Pause Register</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="16" name="en_pfc_pri_pause_rx">
                    <gui_name language="en">en_pfc_pri_pause_rx</gui_name>
                    <description language="en">Enable PFC Priority Based Pause Reception capabilities.
Setting this bit will enable PFC negotiation and recognition of priority based pause frames.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="str_rx_timestamp">
                    <gui_name language="en">str_rx_timestamp</gui_name>
                    <description language="en">Store receive time stamp to memory. Setting this bit to one will cause the CRC of every received frame to be replaced with the value of the nanoseconds field of the 1588 timer that was captured as the receive frame passed the message time stamp point. Set to zero for normal operation.</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="tx_zeroq_pause_frame">
                    <gui_name language="en">tx_zeroq_pause_frame</gui_name>
                    <description language="en">Transmit zero quantum pause frame - writing one to this bit causes a pause frame with zero quantum to be transmitted.</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="tx_pause_frame">
                    <gui_name language="en">tx_pause_frame</gui_name>
                    <description language="en">Transmit pause frame - writing one to this bit causes a pause frame to be transmitted.</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="tx_halt">
                    <gui_name language="en">tx_halt</gui_name>
                    <description language="en">Transmit halt - writing one to this bit halts transmission as soon as any ongoing frame transmission ends.</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="start_tx">
                    <gui_name language="en">start_tx</gui_name>
                    <description language="en">Start transmission - writing one to this bit starts transmission.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="back_pressure">
                    <gui_name language="en">back_pressure</gui_name>
                    <description language="en">Back pressure - if set in 10M or 100M half duplex mode will force collisions on all received frames.
Ignored in gigabit half duplex mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="wren_stat_regs">
                    <gui_name language="en">wren_stat_regs</gui_name>
                    <description language="en">Write enable for statistics registers - setting this bit to one means the statistics registers can be written for functional test purposes.</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="incr_stat_regs">
                    <gui_name language="en">incr_stat_regs</gui_name>
                    <description language="en">Incremental statistics registers - this bit is write only.
Writing a one increments all the statistics registers by one for test purposes.</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="clear_stat_regs">
                    <gui_name language="en">clear_stat_regs</gui_name>
                    <description language="en">Clear statistics registers - this bit is write only.
Writing a one clears the statistics registers.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="mgmt_port_en">
                    <gui_name language="en">mgmt_port_en</gui_name>
                    <description language="en">Management port enable - set to one to enable the management port. When zero forces mdio to high impedance state and mdc low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="tx_en">
                    <gui_name language="en">tx_en</gui_name>
                    <description language="en">Transmit enable - when set, it enables the GEM transmitter to send data. When reset transmission will stop immediately, the transmit pipeline and control registers will be cleared and the transmit queue pointer register will reset to point to the start of the transmit descriptor list.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="rx_en">
                    <gui_name language="en">rx_en</gui_name>
                    <description language="en">Receive enable - when set, it enables the GEM to receive data. When reset frame reception will stop immediately and the receive pipeline will be cleared.
The receive queue pointer register is unaffected.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="loopback_local">
                    <gui_name language="en">loopback_local</gui_name>
                    <description language="en">Loop back local - asserts the loopback_local signal to the system clock generator. Also connects txd to rxd, tx_en to rx_dv and forces full duplex mode. Bit 11 of the network configuration register must be set low to disable TBI mode when in internal loopback. rx_clk and tx_clk may malfunction as the GEM is switched into and out of internal loop back. It is important that receive and transmit circuits have already been disabled when making the switch into and out of internal loop back. Local loopback functionality isn't available in the EP107 Pele Emulation Platform, because the clocking doesn't map well into an FPGA.</description>
                </bitField>
            </register>
            <register name="GEM1_NET_CFG" offset="0xe000c004" size="0x4">
                <gui_name language="en">net_cfg</gui_name>
                <description language="en">The network configuration register contains functions for setting the mode of operation for the Gigabit Ethernet MAC</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="unidir_en">
                    <gui_name language="en">unidir_en</gui_name>
                    <description language="en">Uni-direction-enable. When low the PCS will transmit idle symbols if the link goes down. When high the PCS can transmit frame data when the link is down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="ignore_ipg_rx_er">
                    <gui_name language="en">ignore_ipg_rx_er</gui_name>
                    <description language="en">Ignore IPG rx_er. When set rx_er has no effect on the GEM's operation when rx_dv is low. Set this when using the RGMII wrapper in half-duplex mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="rx_bad_preamble">
                    <gui_name language="en">rx_bad_preamble</gui_name>
                    <description language="en">Receive bad preamble. When set frames with non-standard preamble are not rejected.</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="ipg_stretch_en">
                    <gui_name language="en">ipg_stretch_en</gui_name>
                    <description language="en">IPG stretch enable - when set the transmit IPG can be increased above 96 bit times depending on the previous frame length using the IPG stretch register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="sgmii_en">
                    <gui_name language="en">sgmii_en</gui_name>
                    <description language="en">SGMII mode enable - changes behaviour of the auto-negotiation advertisement and link partner ability registers to meet the requirements of SGMII and reduces the duration of the link timer from 10 ms to 1.6 ms</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="ignore_rx_fcs">
                    <gui_name language="en">ignore_rx_fcs</gui_name>
                    <description language="en">Ignore RX FCS - when set frames with FCS/CRC errors will not be rejected. FCS error statistics will still be collected for frames with bad FCS and FCS status will be recorded in frame's DMA descriptor.
For normal operation this bit must be set to zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="rx_hd_while_tx">
                    <gui_name language="en">rx_hd_while_tx</gui_name>
                    <description language="en">Enable frames to be received in half-duplex mode while transmitting.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="rx_chksum_offld_en">
                    <gui_name language="en">rx_chksum_offld_en</gui_name>
                    <description language="en">Receive checksum offload enable - when set, the receive checksum engine is enabled. Frames with bad IP, TCP or UDP checksums are discarded.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="dis_cp_pause_frame">
                    <gui_name language="en">dis_cp_pause_frame</gui_name>
                    <description language="en">Disable copy of pause frames - set to one to prevent valid pause frames being copied to memory. When set, pause frames are not copied to memory regardless of the state of the copy all frames bit; whether a hash match is found or whether a type ID match is identified. If a destination address match is found the pause frame will be copied to memory.
Note that valid pause frames received will still increment pause statistics and pause the transmission of frames as required.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_dbus_width_ENUM" high_bit="22" low_bit="21" name="dbus_width">
                    <gui_name language="en">dbus_width</gui_name>
                    <description language="en">Data bus width - set according to AMBA AHB or external FIFO data bus width. The reset value for this can be changed by defining a new value for gem_dma_bus_width_def in gem_defs.v Only valid bus widths may be written if the system is configured to a maximum width less than 128-bits. Pele defines gem_dma_bus_width_def as 2'b00.
00: 32 bit AMBA AHB data bus width
01: 64 bit AMBA AHB data bus width
10: 128 bit AMBA AHB data bus width
11: 128 bit AMBA AHB data bus width</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_mdc_clk_div_ENUM" high_bit="20" low_bit="18" name="mdc_clk_div">
                    <gui_name language="en">mdc_clk_div</gui_name>
                    <description language="en">MDC clock division - set according to pclk speed.
These three bits determine the number pclk will be divided by to generate MDC. For conformance with the 802.3 specification, MDC must not exceed 2.5 MHz (MDC is only active during MDIO read and write operations). The reset value for this can be changed by defining a new value for gem_mdc_clock_div in gem_defs.v. Pele defines gem_mdc_clock_div as 3'b010.
000: divide pclk by 8 (pclk up to 20 MHz)
001: divide pclk by 16 (pclk up to 40 MHz)
010: divide pclk by 32 (pclk up to 80 MHz)
011: divide pclk by 48 (pclk up to 120MHz)
100: divide pclk by 64 (pclk up to 160 MHz)
101: divide pclk by 96 (pclk up to 240 MHz)
110: divide pclk by 128 (pclk up to 320 MHz)
111: divide pclk by 224 (pclk up to 540 MHz)</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="fcs_remove">
                    <gui_name language="en">fcs_remove</gui_name>
                    <description language="en">FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). The frame length indicated will be reduced by four bytes in this mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="len_err_frame_disc">
                    <gui_name language="en">len_err_frame_disc</gui_name>
                    <description language="en">Length field error frame discard - setting this bit causes frames with a measured length shorter than the extracted length field (as indicated by bytes 13 and 14 in a non-VLAN tagged frame) to be discarded. This only applies to frames with a length field less than 0x0600.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="14" name="rx_buf_offset">
                    <gui_name language="en">rx_buf_offset</gui_name>
                    <description language="en">Receive buffer offset - indicates the number of bytes by which the received data is offset from the start of the receive buffer.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="pause_en">
                    <gui_name language="en">pause_en</gui_name>
                    <description language="en">Pause enable - when set, transmission will pause if a non zero 802.3 classic pause frame is received and PFC has not been negotiated.</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="retry_test">
                    <gui_name language="en">retry_test</gui_name>
                    <description language="en">Retry test - must be set to zero for normal operation.
If set to one the backoff between collisions will always be one slot time. Setting this bit to one helps test the too many retries condition. Also used in the pause frame tests to reduce the pause counter's decrement time from 512 bit times, to every rx_clk cycle.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_pcs_sel_ENUM" high_bit="11" low_bit="11" name="pcs_sel">
                    <gui_name language="en">pcs_sel</gui_name>
                    <description language="en">PCS select - selects between MII/GMII and TBI.
Must be set for SGMII operation.
0: GMII/MII interface enabled, TBI disabled
1: TBI enabled, GMII/MII disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="net_cfg_gige_en_ENUM" high_bit="10" low_bit="10" name="gige_en">
                    <gui_name language="en">gige_en</gui_name>
                    <description language="en">Gigabit mode enable - setting this bit configures the GEM for 1000 Mbps operation.
0: 10/100 operation using MII or TBI interface
1: Gigabit operation using GMII or TBI interface</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="ext_addr_match_en">
                    <gui_name language="en">ext_addr_match_en</gui_name>
                    <description language="en">External address match enable - when set the external address match interface can be used to copy frames to memory.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="uni_hash_en">
                    <gui_name language="en">uni_hash_en</gui_name>
                    <description language="en">Unicast hash enable - when set, unicast frames will be accepted when the 6 bit hash function of the destination address points to a bit that is set in the hash register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="multi_hash_en">
                    <gui_name language="en">multi_hash_en</gui_name>
                    <description language="en">Multicast hash enable - when set, multicast frames will be accepted when the 6 bit hash function of the destination address points to a bit that is set in the hash register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="no_broadcast">
                    <gui_name language="en">no_broadcast</gui_name>
                    <description language="en">No broadcast - when set to logic one, frames addressed to the broadcast address of all ones will not be accepted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="copy_all">
                    <gui_name language="en">copy_all</gui_name>
                    <description language="en">Copy all frames - when set to logic one, all valid frames will be accepted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="disc_non_vlan">
                    <gui_name language="en">disc_non_vlan</gui_name>
                    <description language="en">Discard non-VLAN frames - when set only VLAN tagged frames will be passed to the address matching logic.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="full_duplex">
                    <gui_name language="en">full_duplex</gui_name>
                    <description language="en">Full duplex - if set to logic one, the transmit block ignores the state of collision and carrier sense and allows receive while transmitting. Also controls the half_duplex pin.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="speed">
                    <gui_name language="en">speed</gui_name>
                    <description language="en">Speed - set to logic one to indicate 100Mbps operation, logic zero for 10Mbps. The value of this pin is reflected on the speed_mode[0] output pin.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_NET_STATUS" offset="0xe000c008" size="0x4">
                <gui_name language="en">net_status</gui_name>
                <description language="en">The network status register returns status information with respect to the PHY management
interface.</description>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="pfc_pri_pause_neg">
                    <gui_name language="en">pfc_pri_pause_neg</gui_name>
                    <description language="en">Set when PFC Priority Based Pause has been negotiated.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="pcs_autoneg_pause_tx_res">
                    <gui_name language="en">pcs_autoneg_pause_tx_res</gui_name>
                    <description language="en">PCS auto-negotiation pause transmit resolution.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="pcs_autoneg_pause_rx_res">
                    <gui_name language="en">pcs_autoneg_pause_rx_res</gui_name>
                    <description language="en">PCS auto-negotiation pause receive resolution</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="pcs_autoneg_dup_res">
                    <gui_name language="en">pcs_autoneg_dup_res</gui_name>
                    <description language="en">PCS auto-negotiation duplex resolution. Set to one if the resolution function determines that both devices are capable of full duplex operation. If zero half-duplex operation is possible as long as bit 0 (PCS link state) is also one.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="phy_mgmt_idle">
                    <gui_name language="en">phy_mgmt_idle</gui_name>
                    <description language="en">The PHY management logic is idle (i.e. has completed).</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="mdio_in_pin_status">
                    <gui_name language="en">mdio_in_pin_status</gui_name>
                    <description language="en">Returns status of the mdio_in pin</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="pcs_link_state">
                    <gui_name language="en">pcs_link_state</gui_name>
                    <description language="en">Returns status of PCS link state. If auto-negotiation is disabled this returns the synchronisation status. If auto-negotiation is enabled it is set in the LINK_OK state as long as a compatible duplex mode is resolved, it is always set in the LINK_OK state in SGMII mode.</description>
                </bitField>
            </register>
            <register name="GEM1_USER_IO" offset="0xe000c00c" size="0x4">
                <gui_name language="en">user_io</gui_name>
                <description language="en">User Input/Output.
The GEM design provides up to 16 inputs and 16 outputs so that the I/O may be read or set under the control of the processor interface.
If the user I/O is disabled as a configuration option, this address space is defined as reserved, and hence will be a read-only register of the value 0x0.
If enabled, the number of inputs and outputs can be configured separately. The first output will be represented in bit 0 of the user I/O register, the second output will use bit 1 and so on.
The first input will be represented in bit 16 of the user I/O register, the second input will use bit 17 and so on.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="user_in">
                    <gui_name language="en">user_in</gui_name>
                    <description language="en">User programmable inputs - the upper 16 bits of this register are used to monitor the state of the user inputs. A logic one read from a bit in this range will correspond to the input being in a high state. A logic zero read from a bit in this range will correspond to the input being in a low state. Any unused bits will be read as zero. Writing to any bits in this range will have no functional effect.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="user_out">
                    <gui_name language="en">user_out</gui_name>
                    <description language="en">User programmable outputs - the lower 16 bits of this register are used to control the state of the user outputs. A logic one written to a bit in this range will cause the corresponding output to be set high. A logic zero written to a bit in this range shall cause the corresponding output to be forced low. Any unused bits will be read as logic zero. Writing to any unused bits in this range will have no functional effect.</description>
                </bitField>
            </register>
            <register name="GEM1_DMA_CFG" offset="0xe000c010" size="0x4">
                <gui_name language="en">dma_cfg</gui_name>
                <description language="en">DMA Configuration Register</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="disc_when_no_ahb">
                    <gui_name language="en">disc_when_no_ahb</gui_name>
                    <description language="en">When set, the GEM DMA will automatically discard receive packets from the receiver packet buffer memory when no AHB resource is available.
When low, then received packets will remain to be stored in the SRAM based packet buffer until AHB buffer resource next becomes available.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ahb_mem_rx_buf_size">
                    <gui_name language="en">ahb_mem_rx_buf_size</gui_name>
                    <description language="en">DMA receive buffer size in AHB system memory.
The value defined by these bits determines the size of buffer to use in main AHB system memory when writing received data.
The value is defined in multiples of 64 bytes such that a value of 0x01 corresponds to buffers of 64 bytes, 0x02 corresponds to 128 bytes etc.
For example:-
0x02: 128 byte
0x18: 1536 byte (1*max length frame/buffer)
0xA0: 10240 byte (1*10K jumbo frame/buffer)
Note that this value should never be written as zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="csum_gen_offload_en">
                    <gui_name language="en">csum_gen_offload_en</gui_name>
                    <description language="en">Transmitter IP, TCP and UDP checksum generation offload enable. When set, the transmitter checksum generation engine is enabled, to calculate and substitute checksums for transmit frames. When clear, frame data is unaffected.
If the GEM is not configured to use the DMA packet buffer, this bit is not implemented and will be treated as reserved, read as zero, ignored on write.
Pele uses packet buffer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="dma_cfg_tx_pktbuf_memsz_sel_ENUM" high_bit="10" low_bit="10" name="tx_pktbuf_memsz_sel">
                    <gui_name language="en">tx_pktbuf_memsz_sel</gui_name>
                    <description language="en">Transmitter packet buffer memory size select - Having this bit at zero halves the amount of memory used for the transmit packet buffer. This reduces the amount of memory used by the GEM. It is important to set this bit to one if the full configured physical memory is available. The value in brackets below represents the size that would result for the default maximum configured memory size of 4 Kbytes.
1: Use full configured addressable space (4 Kb)
0: Do not use top address bit (2 Kb)
If the GEM is not configured to use the DMA packet buffer, this bit is not implemented and will be treated as reserved, read as zero, ignored on write. Pele uses packet buffer</description>
                </bitField>
                <bitField access="Read Write" enumerationId="dma_cfg_rx_pktbuf_memsz_sel_ENUM" high_bit="9" low_bit="8" name="rx_pktbuf_memsz_sel">
                    <gui_name language="en">rx_pktbuf_memsz_sel</gui_name>
                    <description language="en">Receiver packet buffer memory size select - Having these bits at less than 11 reduces the amount of memory used for the receive packet buffer. This reduces the amount of memory used by the GEM. It is important to set these bits both to one if the full configured physical memory is available. The value in brackets below represents the size that would result for the default maximum configured memory size of 8 Kbytes.
11: Use full configured addressable space (8 Kb)
10: Do not use top address bit (4 Kb)
01: Do not use top two address bits (2 Kb)
00: Do not use top three address bits (1 Kb)
If the GEM is not configured to use the DMA packet buffer, these bits are not implemented and will be treated as reserved, read as zero, ignored on write. Pele uses packet buffer.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="ahb_endian_swp_pkt_en">
                    <gui_name language="en">ahb_endian_swp_pkt_en</gui_name>
                    <description language="en">AHB endian swap mode enable for packet data accesses - When set, selects swapped endianism for AHB transfers. When clear, selects little endian mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="ahb_endian_swp_mgmt_en">
                    <gui_name language="en">ahb_endian_swp_mgmt_en</gui_name>
                    <description language="en">AHB endian swap mode enable for management descriptor accesses - When set, selects swapped endianism for AHB transfers. When clear, selects little endian mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="dma_cfg_ahb_fixed_burst_len_ENUM" high_bit="4" low_bit="0" name="ahb_fixed_burst_len">
                    <gui_name language="en">ahb_fixed_burst_len</gui_name>
                    <description language="en">AHB fixed burst length for DMA data operations - Selects the burst length to attempt to use on the AHB when transferring frame data. Not used for DMA management operations and only used where space and data size allow. Otherwise SINGLE type AHB transfers are used.
Upper bits become non-writeable if the configured DMA TX and RX FIFO sizes are smaller than required to support the selected burst size.
One-hot priority encoding enforced automatically on register writes as follows, where 'x' represents don't care:-
1xxxx: Attempt to use INCR16 AHB bursts
01xxx: Attempt to use INCR8 AHB bursts
001xx: Attempt to use INCR4 AHB bursts
0001x: Always use SINGLE AHB bursts
00001: Always use SINGLE AHB bursts
default: Attempt to use INCR4 AHB bursts</description>
                </bitField>
            </register>
            <register name="GEM1_TX_STATUS" offset="0xe000c014" size="0x4">
                <gui_name language="en">tx_status</gui_name>
                <description language="en">Transmit Status Register. This register, when read, provides details of the status of a transmit. Once read, individual bits may be cleared by writing 1 to them. It is not possible to set a bit to 1 by writing to the
register.</description>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK - set when the DMA block sees hresp not OK. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="late_collision">
                    <gui_name language="en">late_collision</gui_name>
                    <description language="en">Late collision occurred - only set if the condition occurs in gigabit mode, as retry is not attempted.
Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="tx_under_run">
                    <gui_name language="en">tx_under_run</gui_name>
                    <description language="en">Transmit under run - this bit is set if the transmitter was forced to terminate a frame that it had already began transmitting due to further data being unavailable.
This bit is set if a transmitter status write back has not completed when another status write back is attempted.
When using the DMA interface configured for internal FIFO mode, this bit is also set when the transmit DMA has written the SOP data into the FIFO and either the AHB bus was not granted in time for further data, or because an AHB not OK response was returned, or because a used bit was read.
When using the DMA interface configured for packet buffer mode, this bit will never be set.
When using the external FIFO interface, this bit is also set when the tx_r_underflow input is asserted during a frame transfer. Cleared by writing a 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Transmit complete - set when a frame has been transmitted. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="tx_corr_ahb_err">
                    <gui_name language="en">tx_corr_ahb_err</gui_name>
                    <description language="en">Transmit frame corruption due to AHB error - set if an error occurs whilst midway through reading transmit frame from the AHB, including HRESP errors and buffers exhausted mid frame (if the buffers run out during transmission of a frame then transmission stops, FCS shall be bad and tx_er asserted).
Also set in DMA packet buffer mode if single frame is too large for configured packet buffer memory size.
Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="tx_go">
                    <gui_name language="en">tx_go</gui_name>
                    <description language="en">Transmit go - if high transmit is active.
When using the exposed FIFO interface, this bit represents bit 3 of the network control register.
When using the DMA interface this bit represents the tx_go variable as specified in the transmit buffer description.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="retry_limit_exceeded">
                    <gui_name language="en">retry_limit_exceeded</gui_name>
                    <description language="en">Retry limit exceeded - cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="collision">
                    <gui_name language="en">collision</gui_name>
                    <description language="en">Collision occurred - set by the assertion of collision.
Cleared by writing a one to this bit. When operating in 10/100 mode, this status indicates either a collision or a late collision. In gigabit mode, this status is not set for a late collision.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="used_bit_read">
                    <gui_name language="en">used_bit_read</gui_name>
                    <description language="en">Used bit read - set when a transmit buffer descriptor is read with its used bit set. Cleared by writing a one to this bit.</description>
                </bitField>
            </register>
            <register name="GEM1_RX_QBAR" offset="0xe000c018" size="0x4">
                <gui_name language="en">rx_qbar</gui_name>
                <description language="en">Receive Buffer Queue Base Address.
This register holds the start address of the receive buffer queue (receive buffers descriptor list). The receive buffer queue base address must be initialized before receive is enabled through bit 2 of the network control register. Once reception is enabled, any write to the receive buffer queue base address register is ignored. Reading this register returns the location of the descriptor currently being accessed. This value increments as buffers are used. Software should not use this register for determining where to remove received frames from the queue as it constantly changes as new frames are received. Software should instead work its way through the buffer descriptor queue checking the 'used' bits.
In terms of AMBA AHB operation, the descriptors are read from memory using a single 32bit AHB access. When the datapath is configured at 64bit, the descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is written to using a single AHB access.
For 32bit datapaths, the descriptors should be aligned at 32-bit boundaries and the descriptors are written to using two individual non sequential accesses.</description>
                <bitField access="Read Write" high_bit="31" low_bit="2" name="rx_q_baseaddr">
                    <gui_name language="en">rx_q_baseaddr</gui_name>
                    <description language="en">Receive buffer queue base address - written with the
address of the start of the receive queue.</description>
                </bitField>
            </register>
            <register name="GEM1_TX_QBAR" offset="0xe000c01c" size="0x4">
                <gui_name language="en">tx_qbar</gui_name>
                <description language="en">Transmit Buffer Queue Base Address.
This register holds the start address of the transmit buffer queue (transmit buffers descriptor list). The transmit buffer queue base address register must be initialized before transmit is started through bit 9 of the network control register. Once transmission has started, any write to the transmit buffer queue base address register is illegal and therefore ignored.
Note that due to clock boundary synchronization, it takes a maximum of four pclk cycles from the writing of the transmit start bit before the transmitter is active. Writing to the transmit buffer queue base address register during this time may produce unpredictable results.
Reading this register returns the location of the descriptor currently being accessed. Since the DMA handles two frames at once, this may not necessarily be pointing to the current frame being transmitted.
In terms of AMBA AHB operation, the descriptors are written to memory using a single 32bit AHB access. When the datapath is configured at 64bit, the descriptors should be aligned at 64-bit boundaries and each pair of 32-bit descriptors is read from memory using a single AHB access. For 32bit datapaths, the descriptors should be aligned at 32-bit boundaries and the descriptors are read from memory using two individual non sequential accesses.</description>
                <bitField access="Read Write" high_bit="31" low_bit="2" name="tx_q_base_addr">
                    <gui_name language="en">tx_q_base_addr</gui_name>
                    <description language="en">Transmit buffer queue base address - written with the address of the start of the transmit queue.</description>
                </bitField>
            </register>
            <register name="GEM1_RX_STATUS" offset="0xe000c020" size="0x4">
                <gui_name language="en">rx_status</gui_name>
                <description language="en">When read provides details of the status of a receive. Once read, individual bits may be cleared by writing 1 to them. It is not possible to set a bit to 1 by writing to the register.</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK - set when the DMA block sees hresp not OK. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Receive overrun - this bit is set if either the gem_dma RX FIFO or external RX FIFO were unable to store the receive frame due to a FIFO overflow, or if the receive status, reported by the gem_rx module to the gem_dma was not taken at end of frame. This bit is also set in DMA packet buffer mode if the packet buffer overflows. For DMA operation the buffer will be recovered if an overrun occurs. This bit is cleared by writing a one to it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="frame_recd">
                    <gui_name language="en">frame_recd</gui_name>
                    <description language="en">Frame received - one or more frames have been received and placed in memory. Cleared by writing a one to this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="buffer_not_avail">
                    <gui_name language="en">buffer_not_avail</gui_name>
                    <description language="en">Buffer not available - an attempt was made to get a new buffer and the pointer indicated that it was owned by the processor. The DMA will reread the pointer each time an end of frame is received until a valid pointer is found. This bit is set following each descriptor read attempt that fails, even if consecutive pointers are unsuccessful and software has in the mean time cleared the status flag. Cleared by writing a one to this bit.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_INTR_STATUS" offset="0xe000c024" size="0x4">
                <gui_name language="en">intr_status</gui_name>
                <description language="en">If not configured for priority queueing, the GEM generates a single interrupt; Pele does not support priority queueing. This register indicates the source of this interrupt. The corresponding bit in the mask register must be clear for a bit to be set. If any bit is set in this register the ethernet_int signal will be asserted.
For test purposes each bit can be set or reset by writing to the interrupt mask register.
The `gem_irq_read_clear define determines if a one must be written to the appropriate bit in order to clear it; in this mode reading has no affect on the status of the bit.
Pele leaves gem_irq_read_clear undefined, so that this register is write-one-to-clear instead of clear on read.</description>
                <bitField access="Read Only" high_bit="26" low_bit="26" name="tsu_sec_incr">
                    <gui_name language="en">tsu_sec_incr</gui_name>
                    <description language="en">TSU seconds register increment - indicates the register has incremented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">PTP pdelay_resp frame transmitted - indicates a PTP pdelay_resp frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">PTP pdelay_req frame transmitted - indicates a PTP pdelay_req frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">PTP pdelay_resp frame received - indicates a PTP pdelay_resp frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">PTP pdelay_req frame received - indicates a PTP pdelay_req frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">PTP sync frame transmitted - indicates a PTP sync frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">PTP delay_req frame transmitted - indicates a PTP delay_req frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">PTP sync frame received - indicates a PTP sync frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">PTP delay_req frame received - indicates a PTP delay_req frame has been received.</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">PCS link partner page received - set when a new base page or next page is received from the link partner. The first time this interrupt is received, it will indicate base page received and subsequent reads will indicate next pages. The next page and base page registers should only be read when this interrupt is signalled. For next pages, the link partner next page register should be read first to avoid the register being over written. This interrupt also indicates when the host should write a new page into the next page register. If further next page exchange is only required by the link partner, this register should be written with a null message page (0x2001).</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">PCS auto-negotiation complete - set once the internal PCS layer has completed auto-negotiation.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">External interrupt - set when a rising edge has been detected on the ext_interrupt_in input pin.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Pause frame transmitted - indicates a pause frame has been successfully transmitted after being initiated from the network control register or from the tx_pause control pin.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Pause time zero - set when either the pause time register at address 0x38 decrements to zero, or when a valid pause frame is received with a zero pause quantum field.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="pause_nonzeroq_rx">
                    <gui_name language="en">pause_nonzeroq_rx</gui_name>
                    <description language="en">Pause frame with non-zero pause quantum received - indicates a valid pause has been received that has a non-zero pause quantum field.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK - set when the DMA block sees hresp not OK.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Receive overrun - set when the receive overrun status bit gets set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Link change - set when the state of the link detected by the internal PCS changes state.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Transmit complete - set when a frame has been transmitted.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Transmit frame corruption due to AHB error - set if an error occurs whilst midway through reading transmit frame from the AHB, including HRESP errors and buffers exhausted mid frame (if the buffers run out during transmission of a frame then transmission stops, FCS shall be bad and tx_er asserted).
Also set in DMA packet buffer mode if single frame is too large for configured packet buffer memory size.
Cleared on a read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Retry limit exceeded or late collision - transmit error.
Late collision will only cause this status bit to be set in gigabit mode (as a retry is not attempted).</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">TX used bit read - set when a transmit buffer descriptor is read with its used bit set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">RX used bit read - set when a receive buffer descriptor is read with its used bit set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Receive complete - a frame has been stored in memory.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="mgmt_sent">
                    <gui_name language="en">mgmt_sent</gui_name>
                    <description language="en">Management frame sent - the PHY maintenance register has completed its operation.</description>
                </bitField>
            </register>
            <register access="Write Only" name="GEM1_INTR_EN" offset="0xe000c028" size="0x4">
                <gui_name language="en">intr_en</gui_name>
                <description language="en">Interrupt Enable Register. At reset all interrupts are disabled. Writing a one to the relevant bit location enables the required interrupt. This register is write only and when read will return zero.</description>
                <bitField access="Write Only" high_bit="26" low_bit="26" name="tsu_sec_incr">
                    <gui_name language="en">tsu_sec_incr</gui_name>
                    <description language="en">Enable TSU seconds register increment interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">Enable PTP pdelay_resp frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">Enable PTP pdelay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">Enable PTP pdelay_resp frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">Enable PTP pdelay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">Enable PTP sync frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">Enable PTP delay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">Enable PTP sync frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">Enable PTP delay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">Enable PCS link partner page received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">Enable PCS auto-negotiation complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">Enable external interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Enable pause frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Enable pause time zero interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="pause_nonzeroq">
                    <gui_name language="en">pause_nonzeroq</gui_name>
                    <description language="en">Enable pause frame with non-zero pause quantum interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Enable hresp not OK interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Enable receive overrun interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Enable link change interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Enable transmit complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Enable transmit frame corruption due to AHB error interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Enable retry limit exceeded or late collision interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="tx_underrun">
                    <gui_name language="en">tx_underrun</gui_name>
                    <description language="en">Enable transmit buffer under run interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">Enable transmit used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">Enable receive used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Enable receive complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="mgmt_done">
                    <gui_name language="en">mgmt_done</gui_name>
                    <description language="en">Enable management done interrupt</description>
                </bitField>
            </register>
            <register access="Write Only" name="GEM1_INTR_DIS" offset="0xe000c02c" size="0x4">
                <gui_name language="en">intr_dis</gui_name>
                <description language="en">Interrupt Disable Register.
Writing a 1 to the relevant bit location disables that particular interrupt. This register is write only and when read will return zero</description>
                <bitField access="Write Only" high_bit="26" low_bit="26" name="tsu_sec_incr">
                    <gui_name language="en">tsu_sec_incr</gui_name>
                    <description language="en">Disable TSU seconds register increment interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">Disable PTP pdelay_resp frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">Disable PTP pdelay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">Disable PTP pdelay_resp frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">Disable PTP pdelay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">Disable PTP sync frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">Disable PTP delay_req frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">Disable PTP sync frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">Disable PTP delay_req frame received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">Disable PCS link partner page received interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">Disable PCS auto-negotiation complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">Disable external interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Disable pause frame transmitted interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Disable pause time zero interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="12" low_bit="12" name="pause_nonzeroq">
                    <gui_name language="en">pause_nonzeroq</gui_name>
                    <description language="en">Disable pause frame with non-zero pause quantum interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Disable hresp not OK interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Disable receive overrun interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Disable link change interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Disable transmit complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Disable transmit frame corruption due to AHB error interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Disable retry limit exceeded or late collision interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="4" low_bit="4" name="tx_underrun">
                    <gui_name language="en">tx_underrun</gui_name>
                    <description language="en">Disable transmit buffer under run interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">Disable transmit used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">Disable receive used bit read interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Disable receive complete interrupt</description>
                </bitField>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="mgmt_done">
                    <gui_name language="en">mgmt_done</gui_name>
                    <description language="en">Disable management done interrupt</description>
                </bitField>
            </register>
            <register name="GEM1_INTR_MASK" offset="0xe000c030" size="0x4">
                <gui_name language="en">intr_mask</gui_name>
                <description language="en">Interrupt Mask Register.
The interrupt mask register is a read only register indicating which interrupts are masked. All bits are set at reset and can be reset individually by writing to the interrupt enable register or set individually by writing to the interrupt disable register. Having separate address locations for enable and disable saves the need for performing a read modify write when updating the interrupt mask register.
For test purposes there is a write-only function to this register that allows the bits in the interrupt status register to be set or cleared, regardless of the state of the mask register.</description>
                <bitField access="Read Only" high_bit="25" low_bit="25" name="pdelay_resp_tx">
                    <gui_name language="en">pdelay_resp_tx</gui_name>
                    <description language="en">PTP pdelay_resp frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="pdelay_req_tx">
                    <gui_name language="en">pdelay_req_tx</gui_name>
                    <description language="en">PTP pdelay_req frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="pdelay_resp_rx">
                    <gui_name language="en">pdelay_resp_rx</gui_name>
                    <description language="en">PTP pdelay_resp frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="pdelay_req_rx">
                    <gui_name language="en">pdelay_req_rx</gui_name>
                    <description language="en">PTP pdelay_req frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="sync_tx">
                    <gui_name language="en">sync_tx</gui_name>
                    <description language="en">PTP sync frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="delay_req_tx">
                    <gui_name language="en">delay_req_tx</gui_name>
                    <description language="en">PTP delay_req frame transmitted mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="sync_rx">
                    <gui_name language="en">sync_rx</gui_name>
                    <description language="en">PTP sync frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="18" name="delay_req_rx">
                    <gui_name language="en">delay_req_rx</gui_name>
                    <description language="en">PTP delay_req frame received mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="17" low_bit="17" name="partner_pg_rx">
                    <gui_name language="en">partner_pg_rx</gui_name>
                    <description language="en">PCS link partner page mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="autoneg_complete">
                    <gui_name language="en">autoneg_complete</gui_name>
                    <description language="en">PCS auto-negotiation complete interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="ext_intr">
                    <gui_name language="en">ext_intr</gui_name>
                    <description language="en">External interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="pause_tx">
                    <gui_name language="en">pause_tx</gui_name>
                    <description language="en">Pause frame transmitted interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="pause_zero">
                    <gui_name language="en">pause_zero</gui_name>
                    <description language="en">Pause time zero interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="pause_nonzeroq">
                    <gui_name language="en">pause_nonzeroq</gui_name>
                    <description language="en">Pause frame with non-zero pause quantum interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="hresp_not_ok">
                    <gui_name language="en">hresp_not_ok</gui_name>
                    <description language="en">Hresp not OK interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="rx_overrun">
                    <gui_name language="en">rx_overrun</gui_name>
                    <description language="en">Receive overrun interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="link_chng">
                    <gui_name language="en">link_chng</gui_name>
                    <description language="en">Link change interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="tx_complete">
                    <gui_name language="en">tx_complete</gui_name>
                    <description language="en">Transmit complete interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="tx_corrupt_ahb_err">
                    <gui_name language="en">tx_corrupt_ahb_err</gui_name>
                    <description language="en">Transmit frame corruption due to AHB error interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="retry_ex_late_collisn">
                    <gui_name language="en">retry_ex_late_collisn</gui_name>
                    <description language="en">Retry limit exceeded or late collision (gigabit mode only)</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="tx_underrun">
                    <gui_name language="en">tx_underrun</gui_name>
                    <description language="en">Transmit buffer under run interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="tx_used_read">
                    <gui_name language="en">tx_used_read</gui_name>
                    <description language="en">Transmit used bit read interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rx_used_read">
                    <gui_name language="en">rx_used_read</gui_name>
                    <description language="en">Receive used bit read interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="rx_complete">
                    <gui_name language="en">rx_complete</gui_name>
                    <description language="en">Receive complete interrupt mask.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="mgmt_done">
                    <gui_name language="en">mgmt_done</gui_name>
                    <description language="en">Management done interrupt mask.</description>
                </bitField>
            </register>
            <register name="GEM1_PHY_MAINT" offset="0xe000c034" size="0x4">
                <gui_name language="en">phy_maint</gui_name>
                <description language="en">PHY Maintenance Register
The PHY maintenance register is implemented as a shift register. Writing to the register starts a shift operation which is signalled as complete when bit-2 is set in the network status register. It takes about 2000 pclk cycles to complete, when MDC is set for pclk divide by 32 in the network configuration register. An interrupt is generated upon completion.
During this time, the MSB of the register is output on the MDIO pin and the LSB updated from the MDIO pin with each MDC cycle. This causes transmission of a PHY management frame on MDIO. See Section 22.2.4.5 of the IEEE 802.3 standard.
Reading during the shift operation will return the current contents of the shift register. At the end of management operation, the bits will have shifted back to their original locations. For a read operation, the data bits will be updated with data read from the PHY. It is important to write the correct values to the register to ensure a valid PHY management frame is produced.
The MDIO interface can read IEEE 802.3 clause 45 PHYs as well as clause 22 PHYs. To read clause 45 PHYs, bit 30 should be written with a 0 rather than a 1.
For a description of MDC generation, see Network Configuration Register</description>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="clause_22">
                    <gui_name language="en">clause_22</gui_name>
                    <description language="en">Must be written to 1 for Clause 22 operation.
Check you PHY's spec to see if it is clause 22 or clause 45 compliant.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="28" name="operation">
                    <gui_name language="en">operation</gui_name>
                    <description language="en">Operation. 10 is read. 01 is write.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="23" name="phy_addr">
                    <gui_name language="en">phy_addr</gui_name>
                    <description language="en">PHY address.</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="18" name="reg_addr">
                    <gui_name language="en">reg_addr</gui_name>
                    <description language="en">Register address - specifies the register in the PHY to access.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="16" name="must_10">
                    <gui_name language="en">must_10</gui_name>
                    <description language="en">Must be written to 10.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="data">
                    <gui_name language="en">data</gui_name>
                    <description language="en">For a write operation this is written with the data to be written to the PHY. After a read operation this contains the data read from the PHY.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_RX_PAUSEQ" offset="0xe000c038" size="0x4">
                <gui_name language="en">rx_pauseq</gui_name>
                <description language="en">Received Pause Quantum Register</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="rx_pauseq">
                    <gui_name language="en">rx_pauseq</gui_name>
                    <description language="en">Received pause quantum - stores the current value of the received pause quantum register which is decremented every 512 bit times.</description>
                </bitField>
            </register>
            <register name="GEM1_TX_PAUSEQ" offset="0xe000c03c" size="0x4">
                <gui_name language="en">tx_pauseq</gui_name>
                <description language="en">Transmit Pause Quantum Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="tx_pauseq">
                    <gui_name language="en">tx_pauseq</gui_name>
                    <description language="en">Transmit pause quantum - written with the pause quantum value for pause frame transmission</description>
                </bitField>
            </register>
            <register name="GEM1_HASH_BOT" offset="0xe000c080" size="0x4">
                <gui_name language="en">hash_bot</gui_name>
                <description language="en">Hash Register Bottom [31:0]. The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames.</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The first 32 bits of the hash address register.</description>
                </bitField>
            </register>
            <register name="GEM1_HASH_TOP" offset="0xe000c084" size="0x4">
                <gui_name language="en">hash_top</gui_name>
                <description language="en">Hash Register Top [63:32]. The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames.</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The remaining 32 bits of the hash address register.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR1_BOT" offset="0xe000c088" size="0x4">
                <gui_name language="en">spec_addr1_bot</gui_name>
                <description language="en">Specific Address 1 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR1_TOP" offset="0xe000c08c" size="0x4">
                <gui_name language="en">spec_addr1_top</gui_name>
                <description language="en">Specific Address 1 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 1. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR2_BOT" offset="0xe000c090" size="0x4">
                <gui_name language="en">spec_addr2_bot</gui_name>
                <description language="en">Specific Address 2 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR2_TOP" offset="0xe000c094" size="0x4">
                <gui_name language="en">spec_addr2_top</gui_name>
                <description language="en">Specific Address 2 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 2. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR3_BOT" offset="0xe000c098" size="0x4">
                <gui_name language="en">spec_addr3_bot</gui_name>
                <description language="en">Specific Address 3 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR3_TOP" offset="0xe000c09c" size="0x4">
                <gui_name language="en">spec_addr3_top</gui_name>
                <description language="en">Specific Address 3 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 3. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR4_BOT" offset="0xe000c0a0" size="0x4">
                <gui_name language="en">spec_addr4_bot</gui_name>
                <description language="en">Specific Address 4 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Least significant 32 bits of the destination address, that is bits 31:0. Bit zero indicates whether the address is multicast or unicast and corresponds to the least significant bit of the first byte received.</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR4_TOP" offset="0xe000c0a4" size="0x4">
                <gui_name language="en">spec_addr4_top</gui_name>
                <description language="en">Specific Address 4 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="addr_msbs">
                    <gui_name language="en">addr_msbs</gui_name>
                    <description language="en">Specific address 4. The most significant bits of the destination address, that is bits 47:32.</description>
                </bitField>
            </register>
            <register name="GEM1_TYPE_ID_MATCH1" offset="0xe000c0a8" size="0x4">
                <gui_name language="en">type_id_match1</gui_name>
                <description language="en">Type ID Match 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 1 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match1">
                    <gui_name language="en">type_id_match1</gui_name>
                    <description language="en">Type ID match 1. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM1_TYPE_ID_MATCH2" offset="0xe000c0ac" size="0x4">
                <gui_name language="en">type_id_match2</gui_name>
                <description language="en">Type ID Match 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 2 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match2">
                    <gui_name language="en">type_id_match2</gui_name>
                    <description language="en">Type ID match 2. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM1_TYPE_ID_MATCH3" offset="0xe000c0b0" size="0x4">
                <gui_name language="en">type_id_match3</gui_name>
                <description language="en">Type ID Match 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 3 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match3">
                    <gui_name language="en">type_id_match3</gui_name>
                    <description language="en">Type ID match 3. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM1_TYPE_ID_MATCH4" offset="0xe000c0b4" size="0x4">
                <gui_name language="en">type_id_match4</gui_name>
                <description language="en">Type ID Match 4</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="copy_en">
                    <gui_name language="en">copy_en</gui_name>
                    <description language="en">Enable copying of type ID match 4 matched frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="type_id_match4">
                    <gui_name language="en">type_id_match4</gui_name>
                    <description language="en">Type ID match 4. For use in comparisons with received frames type ID/length field.</description>
                </bitField>
            </register>
            <register name="GEM1_WAKE_ON_LAN" offset="0xe000c0b8" size="0x4">
                <gui_name language="en">wake_on_lan</gui_name>
                <description language="en">Wake on LAN Register</description>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="multi_hash_en">
                    <gui_name language="en">multi_hash_en</gui_name>
                    <description language="en">Wake on LAN multicast hash event enable. When set multicast hash events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="spec_addr_reg1_en">
                    <gui_name language="en">spec_addr_reg1_en</gui_name>
                    <description language="en">Wake on LAN specific address register 1 event enable. When set specific address 1 events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="arp_req_en">
                    <gui_name language="en">arp_req_en</gui_name>
                    <description language="en">Wake on LAN ARP request event enable. When set ARP request events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="magic_pkt_en">
                    <gui_name language="en">magic_pkt_en</gui_name>
                    <description language="en">Wake on LAN magic packet event enable. When set magic packet events will cause the wol output to be asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="arp_req_ip_addr">
                    <gui_name language="en">arp_req_ip_addr</gui_name>
                    <description language="en">Wake on LAN ARP request IP address. Written to define the least significant 16 bits of the target IP address that is matched to generate a Wake on LAN event. A value of zero will not generate an event, even if this is matched by the received frame.</description>
                </bitField>
            </register>
            <register name="GEM1_IPG_STRETCH" offset="0xe000c0bc" size="0x4">
                <gui_name language="en">ipg_stretch</gui_name>
                <description language="en">IPG stretch register</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="ipg_stretch">
                    <gui_name language="en">ipg_stretch</gui_name>
                    <description language="en">Bits 7:0 are multiplied with the previously transmitted frame length (including preamble) bits 15:8 +1 divide the frame length. If the resulting number is greater than 96 and bit 28 is set in the network configuration register then the resulting number is used for the transmit inter-packet-gap. 1 is added to bits 15:8 to prevent a divide by zero.</description>
                </bitField>
            </register>
            <register name="GEM1_STACKED_VLAN" offset="0xe000c0c0" size="0x4">
                <gui_name language="en">stacked_vlan</gui_name>
                <description language="en">Stacked VLAN Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="stacked_vlan_en">
                    <gui_name language="en">stacked_vlan_en</gui_name>
                    <description language="en">Enable Stacked VLAN processing mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="user_def_vlan_type">
                    <gui_name language="en">user_def_vlan_type</gui_name>
                    <description language="en">User defined VLAN_TYPE field. When Stacked VLAN is enabled, the first VLAN tag in a received frame will only be accepted if the VLAN type field is equal to this user defined VLAN_TYPE OR equal to the standard VLAN type (0x8100). Note that the second VLAN tag of a Stacked VLAN packet will only be matched correctly if its VLAN_TYPE field equals 0x8100.</description>
                </bitField>
            </register>
            <register name="GEM1_TX_PFC_PAUSE" offset="0xe000c0c4" size="0x4">
                <gui_name language="en">tx_pfc_pause</gui_name>
                <description language="en">Transmit PFC Pause Register</description>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="pauseq_sel">
                    <gui_name language="en">pauseq_sel</gui_name>
                    <description language="en">If bit 17 of the network control register is written with a one then for each entry equal to zero in the Transmit PFC Pause Register[15:8], the PFC pause frame's pause quantum field associated with that entry will be taken from the transmit pause quantum register. For each entry equal to one in the Transmit PFC Pause Register [15:8], the pause quantum associated with that entry will be zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="pri_en_vec_val">
                    <gui_name language="en">pri_en_vec_val</gui_name>
                    <description language="en">If bit 17 of the network control register is written with a one then the priority enable vector of the PFC priority based pause frame will be set equal to the value stored in this register [7:0].</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR1_MASK_BOT" offset="0xe000c0c8" size="0x4">
                <gui_name language="en">spec_addr1_mask_bot</gui_name>
                <description language="en">Specific Address Mask 1 Bottom [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="mask_bits_bot">
                    <gui_name language="en">mask_bits_bot</gui_name>
                    <description language="en">Setting a bit to one masks the corresponding bit in the specific address 1 register</description>
                </bitField>
            </register>
            <register name="GEM1_SPEC_ADDR1_MASK_TOP" offset="0xe000c0cc" size="0x4">
                <gui_name language="en">spec_addr1_mask_top</gui_name>
                <description language="en">Specific Address Mask 1 Top [47:32]</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="mask_bits_top">
                    <gui_name language="en">mask_bits_top</gui_name>
                    <description language="en">Setting a bit to one masks the corresponding bit in the specific address 1 register</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_MODULE_ID" offset="0xe000c0fc" size="0x4">
                <gui_name language="en">module_id</gui_name>
                <description language="en">Module ID Register. This register indicates a Cadence module identification number and module revision. The value of this register is read only as defined by `gem_revision_reg_value. In Pele with GEM p23, it is 0x00020118.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="module_id">
                    <gui_name language="en">module_id</gui_name>
                    <description language="en">Module identification number - for the GEM, this value is fixed at 0x0002.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="module_rev">
                    <gui_name language="en">module_rev</gui_name>
                    <description language="en">Module revision - fixed byte value specific to the revision of the design which is incremented after each release of the IP. Corresponds to Pele having GEM p23.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_OCTETS_TX_BOT" offset="0xe000c100" size="0x4">
                <gui_name language="en">octets_tx_bot</gui_name>
                <description language="en">Octets transmitted [31:0] (in frames without error). Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="octets_tx_bot">
                    <gui_name language="en">octets_tx_bot</gui_name>
                    <description language="en">Transmitted octets in frame without errors [31:0].
The number of octets transmitted in valid frames of any type. This counter is 48-bits, and is read through two registers. This count does not include octets from automatically generated pause frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_OCTETS_TX_TOP" offset="0xe000c104" size="0x4">
                <gui_name language="en">octets_tx_top</gui_name>
                <description language="en">Octets transmitted [47:32] (in frames without error). Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="octets_tx_top">
                    <gui_name language="en">octets_tx_top</gui_name>
                    <description language="en">Transmitted octets in frame without errors [47:32].
The number of octets transmitted in valid frames of
any type. This counter is 48-bits, and is read through
two registers. This count does not include octets
from automatically generated pause frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_TX" offset="0xe000c108" size="0x4">
                <gui_name language="en">frames_tx</gui_name>
                <description language="en">Frames transmitted without error, excluding pause
frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Frames transmitted without error. A 32 bit register
counting the number of frames successfully
transmitted, i.e. no under run and not too many
retries. Excludes pause frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_BROADCAST_FRAMES_TX" offset="0xe000c10c" size="0x4">
                <gui_name language="en">broadcast_frames_tx</gui_name>
                <description language="en">Broadcast frames transmitted without error,
excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Broadcast frames transmitted without error. A 32 bit
register counting the number of broadcast frames
successfully transmitted without error, i.e. no under
run and not too many retries. Excludes pause
frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_MULTI_FRAMES_TX" offset="0xe000c110" size="0x4">
                <gui_name language="en">multi_frames_tx</gui_name>
                <description language="en">Multicast frames transmitted without error,
excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Multicast frames transmitted without error. A 32 bit
register counting the number of multicast frames
successfully transmitted without error, i.e. no under
run and not too many retries. Excludes pause
frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PAUSE_FRAMES_TX" offset="0xe000c114" size="0x4">
                <gui_name language="en">pause_frames_tx</gui_name>
                <description language="en">Transmitted pause frames (unless sent through
external FIFO interface). In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="pause_frames_tx">
                    <gui_name language="en">pause_frames_tx</gui_name>
                    <description language="en">Transmitted pause frames - a 16 bit register
counting the number of pause frames transmitted.
Only pause frames triggered by the register interface
or through the external pause pins are counted as
pause frames. Pause frames received through the
external FIFO interface are counted in the frames
transmitted counter.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_64B_TX" offset="0xe000c118" size="0x4">
                <gui_name language="en">frames_64b_tx</gui_name>
                <description language="en">64 byte frames transmitted without error, excluding
pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">64 byte frames transmitted without error. A 32 bit
register counting the number of 64 byte frames
successfully transmitted without error, i.e. no under
run and not too many retries. Excludes pause
frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_65TO127B_TX" offset="0xe000c11c" size="0x4">
                <gui_name language="en">frames_65to127b_tx</gui_name>
                <description language="en">65 to 127 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">65 to127 byte frames transmitted without error. A 32
bit register counting the number of 65 to127 byte
frames successfully transmitted without error, i.e. no
under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_128TO255B_TX" offset="0xe000c120" size="0x4">
                <gui_name language="en">frames_128to255b_tx</gui_name>
                <description language="en">128 to 255 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">128 to 255 byte frames transmitted without error. A
32 bit register counting the number of 128 to 255
byte frames successfully transmitted without error,
i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_256TO511B_TX" offset="0xe000c124" size="0x4">
                <gui_name language="en">frames_256to511b_tx</gui_name>
                <description language="en">256 to 511 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">256 to 511 byte frames transmitted without error. A
32 bit register counting the number of 256 to 511
byte frames successfully transmitted without error,
i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_512TO1023B_TX" offset="0xe000c128" size="0x4">
                <gui_name language="en">frames_512to1023b_tx</gui_name>
                <description language="en">512 to 1023 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">512 to 1023 byte frames transmitted without error. A
32 bit register counting the number of 512 to 1023
byte frames successfully transmitted without error,
i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_1024TO1518B_TX" offset="0xe000c12c" size="0x4">
                <gui_name language="en">frames_1024to1518b_tx</gui_name>
                <description language="en">1024 to 1518 byte frames transmitted without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">1024 to 1518 byte frames transmitted without error.
A 32 bit register counting the number of 1024 to
1518 byte frames successfully transmitted without
error, i.e. no under run and not too many retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_TX_UNDER_RUNS" offset="0xe000c134" size="0x4">
                <gui_name language="en">tx_under_runs</gui_name>
                <description language="en">Transmit under runs. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="tx_under_runs">
                    <gui_name language="en">tx_under_runs</gui_name>
                    <description language="en">Transmit under runs - a 10 bit register counting the
number of frames not transmitted due to a transmit
under run. If this register is incremented then no
other statistics register is incremented.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_SINGLE_COLLISN_FRAMES" offset="0xe000c138" size="0x4">
                <gui_name language="en">single_collisn_frames</gui_name>
                <description language="en">Single Collision Frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="single_collisn">
                    <gui_name language="en">single_collisn</gui_name>
                    <description language="en">Single collision frames - an 18 bit register counting
the number of frames experiencing a single collision
before being successfully transmitted, i.e. no under
run.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_MULTI_COLLISN_FRAMES" offset="0xe000c13c" size="0x4">
                <gui_name language="en">multi_collisn_frames</gui_name>
                <description language="en">Multiple Collision Frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="multi_collisn">
                    <gui_name language="en">multi_collisn</gui_name>
                    <description language="en">Multiple collision frames - an 18 bit register counting
the number of frames experiencing between two and
fifteen collisions prior to being successfully
transmitted, i.e. no under run and not too many
retries.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_EXCESSIVE_COLLISNS" offset="0xe000c140" size="0x4">
                <gui_name language="en">excessive_collisns</gui_name>
                <description language="en">Excessive Collisions. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="excessive_collisns">
                    <gui_name language="en">excessive_collisns</gui_name>
                    <description language="en">Excessive collisions - a 10 bit register counting the
number of frames that failed to be transmitted
because they experienced 16 collisions.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_LATE_COLLISNS" offset="0xe000c144" size="0x4">
                <gui_name language="en">late_collisns</gui_name>
                <description language="en">Late Collisions. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="late_collisns">
                    <gui_name language="en">late_collisns</gui_name>
                    <description language="en">Late collisions - a 10 bit register counting the number
of late collision occurring after the slot time (512 bits)
has expired. In 10/100 mode, late collisions are
counted twice i.e. both as a collision and a late
collision. In gigabit mode, a late collision causes the
transmission to be aborted, thus the single and multi
collision registers are not updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DEFERRED_TX_FRAMES" offset="0xe000c148" size="0x4">
                <gui_name language="en">deferred_tx_frames</gui_name>
                <description language="en">Deferred Transmission Frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="deferred_tx">
                    <gui_name language="en">deferred_tx</gui_name>
                    <description language="en">Deferred transmission frames - an 18 bit register
counting the number of frames experiencing deferral
due to carrier sense being active on their first
attempt at transmission. Frames involved in any
collision are not counted nor are frames that
experienced a transmit under run.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_CARRIER_SENSE_ERRS" offset="0xe000c14c" size="0x4">
                <gui_name language="en">carrier_sense_errs</gui_name>
                <description language="en">Carrier Sense Errors. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="carrier_sense_errs">
                    <gui_name language="en">carrier_sense_errs</gui_name>
                    <description language="en">Carrier sense errors - a 10 bit register counting the
number of frames transmitted where carrier sense
was not seen during transmission or where carrier
sense was deasserted after being asserted in a
transmit frame without collision (no under run). Only
incremented in half duplex mode. The only effect of
a carrier sense error is to increment this register.
The behaviour of the other statistics registers is
unaffected by the detection of a carrier sense error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_OCTETS_RX_BOT" offset="0xe000c150" size="0x4">
                <gui_name language="en">octets_rx_bot</gui_name>
                <description language="en">Octets Received [31:0]. Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="octets_rx_bot">
                    <gui_name language="en">octets_rx_bot</gui_name>
                    <description language="en">Received octets in frame without errors [31:0]. The
number of octets received in valid frames of any
type. This counter is 48-bits and is read through two
registers. This count does not include octets from
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_OCTETS_RX_TOP" offset="0xe000c154" size="0x4">
                <gui_name language="en">octets_rx_top</gui_name>
                <description language="en">Octets Received [47:32]. Bits 31:0 should be read prior to bits 47:32 to ensure reliable operation. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="octets_rx_top">
                    <gui_name language="en">octets_rx_top</gui_name>
                    <description language="en">Received octets in frame without errors [47:32]. The
number of octets received in valid frames of any
type. This counter is 48-bits and is read through two
registers. This count does not include octets from
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_RX" offset="0xe000c158" size="0x4">
                <gui_name language="en">frames_rx</gui_name>
                <description language="en">Frames received without error, excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Frames received without error. A 32 bit register
counting the number of frames successfully
received. Excludes pause frames, and is only
incremented if the frame is successfully filtered and
copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_BDCAST_FAMES_RX" offset="0xe000c15c" size="0x4">
                <gui_name language="en">bdcast_fames_rx</gui_name>
                <description language="en">Broadcast frames received without error, excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Broadcast frames received without error. A 32 bit
register counting the number of broadcast frames
successfully received without error. Excludes pause
frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_MULTI_FRAMES_RX" offset="0xe000c160" size="0x4">
                <gui_name language="en">multi_frames_rx</gui_name>
                <description language="en">Multicast frames received without error, excluding pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Multicast frames received without error. A 32 bit
register counting the number of multicast frames
successfully received without error. Excludes pause
frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PAUSE_RX" offset="0xe000c164" size="0x4">
                <gui_name language="en">pause_rx</gui_name>
                <description language="en">Pause frames received. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="pause_rx">
                    <gui_name language="en">pause_rx</gui_name>
                    <description language="en">Received pause frames - a 16 bit register counting
the number of pause frames received without error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_64B_RX" offset="0xe000c168" size="0x4">
                <gui_name language="en">frames_64b_rx</gui_name>
                <description language="en">64 byte frames received without error, excluding
pause frames. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">64 byte frames received without error. A 32 bit
register counting the number of 64 byte frames
successfully received without error. Excludes pause
frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_65TO127B_RX" offset="0xe000c16c" size="0x4">
                <gui_name language="en">frames_65to127b_rx</gui_name>
                <description language="en">65 to 127 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">65 to 127 byte frames received without error. A 32 bit
register counting the number of 65 to 127 byte
frames successfully received without error. Excludes
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_128TO255B_RX" offset="0xe000c170" size="0x4">
                <gui_name language="en">frames_128to255b_rx</gui_name>
                <description language="en">128 to 255 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">128 to 255 byte frames received without error. A 32
bit register counting the number of 128 to 255 byte
frames successfully received without error. Excludes
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_256TO511B_RX" offset="0xe000c174" size="0x4">
                <gui_name language="en">frames_256to511b_rx</gui_name>
                <description language="en">256 to 511 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">256 to 511 byte frames received without error. A 32
bit register counting the number of 256 to 511 byte
frames successfully transmitted without error.
Excludes pause frames, and is only incremented if
the frame is successfully filtered and copied to
memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_512TO1023B_RX" offset="0xe000c178" size="0x4">
                <gui_name language="en">frames_512to1023b_rx</gui_name>
                <description language="en">512 to 1023 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">512 to 1023 byte frames received without error. A 32
bit register counting the number of 512 to 1023 byte
frames successfully received without error. Excludes
pause frames, and is only incremented if the frame is
successfully filtered and copied to memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FRAMES_1024TO1518B_RX" offset="0xe000c17c" size="0x4">
                <gui_name language="en">frames_1024to1518b_rx</gui_name>
                <description language="en">1024 to 1518 byte frames received without error. In statistics register block. Is reset to zero on a read and stick at all ones when it counts to its maximum value. It should be read frequently enough to prevent loss of data.
For test purposes it may be written by setting bit 7 (Write Enable) in the network control register. Setting bit 6 (increment statistics) in the network control register causes all the statistics registers to increment by one, again for test purposes.
Once a statistics register has been read, it is automatically cleared.</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">1024 to 1518 byte frames received without error. A
32 bit register counting the number of 1024 to 1518
byte frames successfully received without error.
Excludes pause frames, and is only incremented if
the frame is successfully filtered and copied to
memory.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_UNDERSZ_RX" offset="0xe000c184" size="0x4">
                <gui_name language="en">undersz_rx</gui_name>
                <description language="en">Undersize frames received</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="undersz_rx">
                    <gui_name language="en">undersz_rx</gui_name>
                    <description language="en">Undersize frames received - a 10 bit register
counting the number of frames received less than 64
bytes in length (10/100 mode or gigabit mode, full
duplex) that do not have either a CRC error or an
alignment error. In gigabit mode, half duplex, this
register counts either frames not conforming to the
minimum slot time of 512 bytes or frames not
conforming to the minimum frame size once bursting
is active.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_FCS_ERRORS" offset="0xe000c190" size="0x4">
                <gui_name language="en">fcs_errors</gui_name>
                <description language="en">Frame check sequence errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="fcs_errors">
                    <gui_name language="en">fcs_errors</gui_name>
                    <description language="en">Frame check sequence errors - a 10 bit register
counting frames that are an integral number of
bytes, have bad CRC and are between 64 and 1518
bytes in length. This register is
also incremented if a symbol error is detected and
the frame is of valid length and has an integral
number of bytes.
This register is incremented for a frame with bad
FCS, regardless of whether it is copied to memory
due to ignore FCS mode being enabled in bit 26 of
the network configuration register.H524</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_LENGTH_FIELD_ERRORS" offset="0xe000c194" size="0x4">
                <gui_name language="en">length_field_errors</gui_name>
                <description language="en">Length field frame errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="length_field_errors">
                    <gui_name language="en">length_field_errors</gui_name>
                    <description language="en">Length field frame errors - this 10-bit register counts
the number of frames received that have a
measured length shorter than that extracted from the
length field (bytes 13 and 14). This condition is only
counted if the value of the length field is less than
0x0600, the frame is not of excessive length and
checking is enabled through bit 16 of the network
configuration register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_RX_SYMBOL_ERRORS" offset="0xe000c198" size="0x4">
                <gui_name language="en">rx_symbol_errors</gui_name>
                <description language="en">Receive symbol errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="rx_symbol_errors">
                    <gui_name language="en">rx_symbol_errors</gui_name>
                    <description language="en">Receive symbol errors - a 10-bit register counting
the number of frames that had rx_er asserted
during reception. For 10/100 mode symbol errors
are counted regardless of frame length checks. For
gigabit mode the frame must satisfy slot time
requirements in order to count a symbol error.
Additionally, in gigabit half duplex mode, carrier
extension errors are also recorded. Receive symbol
errors will also be counted as an FCS or alignment
error if the frame is between 64 and 1518 bytes. If the frame is larger it will be
recorded as a jabber error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_ALIGN_ERRORS" offset="0xe000c19c" size="0x4">
                <gui_name language="en">align_errors</gui_name>
                <description language="en">Alignment errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="align_errors">
                    <gui_name language="en">align_errors</gui_name>
                    <description language="en">Alignment errors - a 10 bit register counting frames
that are not an integral number of bytes long and
have bad CRC when their length is truncated to an
integral number of bytes and are between 64 and
1518 bytes in length. This register is
also incremented if a symbol error is detected and
the frame is of valid length and does not have an
integral number of bytes.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_RX_RESOURCE_ERRORS" offset="0xe000c1a0" size="0x4">
                <gui_name language="en">rx_resource_errors</gui_name>
                <description language="en">Receive resource errors</description>
                <bitField access="Read Only" high_bit="17" low_bit="0" name="rx_resource_errors">
                    <gui_name language="en">rx_resource_errors</gui_name>
                    <description language="en">Receive resource errors - an 18 bit register counting
the number of frames that were successfully
received by the MAC (correct address matched
frame and adequate slot time) but could not be
copied to memory because no receive buffer was
available. This will be either because the AHB bus
was not granted in time or because a hresp not OK
was returned.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_RX_OVERRUN_ERRORS" offset="0xe000c1a4" size="0x4">
                <gui_name language="en">rx_overrun_errors</gui_name>
                <description language="en">Receive overrun errors</description>
                <bitField access="Read Only" high_bit="9" low_bit="0" name="rx_overrun_errors">
                    <gui_name language="en">rx_overrun_errors</gui_name>
                    <description language="en">Receive overruns - a 10 bit register counting the
number of frames that are address recognized but
were not copied to memory due to a receive overrun.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_IP_HDR_CSUM_ERRORS" offset="0xe000c1a8" size="0x4">
                <gui_name language="en">ip_hdr_csum_errors</gui_name>
                <description language="en">IP header checksum errors</description>
                <bitField access="Read Only" enumerationId="ip_hdr_csum_errors_ip_hdr_csum_errors_ENUM" high_bit="7" low_bit="0" name="ip_hdr_csum_errors">
                    <gui_name language="en">ip_hdr_csum_errors</gui_name>
                    <description language="en">0 IP header checksum errors - an 8-bit register
counting the number of frames discarded due to an
incorrect IP header checksum, but are between 64
and 1518 bytes and do not
have a CRC error, an alignment error, nor a symbol
error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_TCP_CSUM_ERRORS" offset="0xe000c1ac" size="0x4">
                <gui_name language="en">tcp_csum_errors</gui_name>
                <description language="en">TCP checksum errors</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="tcp_csum_errors">
                    <gui_name language="en">tcp_csum_errors</gui_name>
                    <description language="en">TCP checksum errors - an 8-bit register counting the
number of frames discarded due to an incorrect TCP
checksum, but are between 64 and 1518 bytes and do not have a CRC error,
an alignment error, nor a symbol error.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_UDP_CSUM_ERRORS" offset="0xe000c1b0" size="0x4">
                <gui_name language="en">udp_csum_errors</gui_name>
                <description language="en">UDP checksum error</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="udp_csum_errors">
                    <gui_name language="en">udp_csum_errors</gui_name>
                    <description language="en">UDP checksum errors - an 8-bit register counting the
number of frames discarded due to an incorrect UDP
checksum, but are between 64 and 1518 bytes and do not have a CRC error,
an alignment error, nor a symbol error.</description>
                </bitField>
            </register>
            <register name="GEM1_TIMER_STROBE_S" offset="0xe000c1c8" size="0x4">
                <gui_name language="en">timer_strobe_s</gui_name>
                <description language="en">1588 timer sync strobe seconds</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The value of the Timer Seconds register captured
when gem_tsu_ms and gem_tsu_inc_ctrl are zero</description>
                </bitField>
            </register>
            <register name="GEM1_TIMER_STROBE_NS" offset="0xe000c1cc" size="0x4">
                <gui_name language="en">timer_strobe_ns</gui_name>
                <description language="en">1588 timer sync strobe nanoseconds</description>
                <bitField access="Read Write" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The value of the Timer Nanoseconds register
captured when gem_tsu_ms and gem_tsu_inc_ctrl
are zero.</description>
                </bitField>
            </register>
            <register name="GEM1_TIMER_S" offset="0xe000c1d0" size="0x4">
                <gui_name language="en">timer_s</gui_name>
                <description language="en">1588 timer seconds</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Timer count in seconds. This register is writeable. It
increments by one when the 1588 nanoseconds
counter counts to one second. It may also be
incremented when the timer adjust register is
written.</description>
                </bitField>
            </register>
            <register name="GEM1_TIMER_NS" offset="0xe000c1d4" size="0x4">
                <gui_name language="en">timer_ns</gui_name>
                <description language="en">1588 timer nanoseconds</description>
                <bitField access="Read Write" high_bit="29" low_bit="0" name="timer_ct_ns">
                    <gui_name language="en">timer_ct_ns</gui_name>
                    <description language="en">Timer count in nanoseconds. This register is
writeable. It can also be adjusted by writes to the
1588 timer adjust register. It increments by the value
of the 1588 timer increment register each clock
cycle.</description>
                </bitField>
            </register>
            <register name="GEM1_TIMER_ADJUST" offset="0xe000c1d8" size="0x4">
                <gui_name language="en">timer_adjust</gui_name>
                <description language="en">1588 timer adjust</description>
                <bitField access="Write Only" high_bit="31" low_bit="31" name="add_subn">
                    <gui_name language="en">add_subn</gui_name>
                    <description language="en">Write as one to subtract from the 1588 timer. Write
as zero to add to it.</description>
                </bitField>
                <bitField access="Write Only" high_bit="29" low_bit="0" name="ns_delta">
                    <gui_name language="en">ns_delta</gui_name>
                    <description language="en">The number of nanoseconds to increment or
decrement the 1588 timer nanoseconds register. If
necessary the 1588 seconds register will be
incremented or decremented.</description>
                </bitField>
            </register>
            <register name="GEM1_TIMER_INCR" offset="0xe000c1dc" size="0x4">
                <gui_name language="en">timer_incr</gui_name>
                <description language="en">1588 timer increment</description>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="incr_b4_alt">
                    <gui_name language="en">incr_b4_alt</gui_name>
                    <description language="en">The number of increments after which the alternative
increment is used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="timer_incr_alt_ct_ns_delta_ENUM" high_bit="15" low_bit="8" name="alt_ct_ns_delta">
                    <gui_name language="en">alt_ct_ns_delta</gui_name>
                    <description language="en">Alternative count of nanoseconds by which the 1588
timer nanoseconds register will be incremented
each clock cycle.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ns_delta">
                    <gui_name language="en">ns_delta</gui_name>
                    <description language="en">A count of nanoseconds by which the 1588 timer
nanoseconds register will be incremented each
clock cycle.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_TX_S" offset="0xe000c1e0" size="0x4">
                <gui_name language="en">ptp_tx_s</gui_name>
                <description language="en">PTP event frame transmitted seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
transmit primary event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP sync or delay_req frame. An
interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_TX_NS" offset="0xe000c1e4" size="0x4">
                <gui_name language="en">ptp_tx_ns</gui_name>
                <description language="en">PTP event frame transmitted nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP transmit primary event crosses the MII
interface. The actual update occurs when the GEM
recognizes the frame as a PTP sync or delay_req
frame. An interrupt is issued when the register is
updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_RX_S" offset="0xe000c1e8" size="0x4">
                <gui_name language="en">ptp_rx_s</gui_name>
                <description language="en">PTP event frame received seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
receive primary event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP sync or delay_req frame. An
interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_RX_NS" offset="0xe000c1ec" size="0x4">
                <gui_name language="en">ptp_rx_ns</gui_name>
                <description language="en">PTP event frame received nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP receive primary event crosses the MII interface.
The actual update occurs when the GEM recognizes
the frame as a PTP sync or delay_req frame. An
interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_PEER_TX_S" offset="0xe000c1f0" size="0x4">
                <gui_name language="en">ptp_peer_tx_s</gui_name>
                <description language="en">PTP peer event frame transmitted seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
transmit peer event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP pdealy_req or pdelay_resp frame.
An interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_PEER_TX_NS" offset="0xe000c1f4" size="0x4">
                <gui_name language="en">ptp_peer_tx_ns</gui_name>
                <description language="en">PTP peer event frame transmitted nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP transmit peer event crosses the MII interface.
The actual update occurs when the GEM recognizes
the frame as a PTP pdelay_req or pdelay_resp
frame. An interrupt is issued when the register is
updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_PEER_RX_S" offset="0xe000c1f8" size="0x4">
                <gui_name language="en">ptp_peer_rx_s</gui_name>
                <description language="en">PTP peer event frame received seconds</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer seconds register held when the SFD of a PTP
receive peer event crosses the MII interface. The
actual update occurs when the GEM recognizes the
frame as a PTP pdelay_req or pdelay_resp frame.
An interrupt is issued when the register is updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_PTP_PEER_RX_NS" offset="0xe000c1fc" size="0x4">
                <gui_name language="en">ptp_peer_rx_ns</gui_name>
                <description language="en">PTP peer event frame received nanoseconds</description>
                <bitField access="Read Only" high_bit="29" low_bit="0" name="ns_reg_val">
                    <gui_name language="en">ns_reg_val</gui_name>
                    <description language="en">The register is updated with the value that the 1588
timer nanoseconds register held when the SFD of a
PTP receive peer event crosses the MII interface.
The actual update occurs when the GEM recognizes
the frame as a PTP pdelay_req or pdelay_resp
frame. An interrupt is issued when the register is
updated.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG1" offset="0xe000c280" size="0x4">
                <gui_name language="en">design_cfg1</gui_name>
                <description language="en">Design Configuration Register 1</description>
                <bitField access="Read Only" enumerationId="design_cfg1_gem_dma_bus_width_ENUM" high_bit="27" low_bit="25" name="gem_dma_bus_width">
                    <gui_name language="en">gem_dma_bus_width</gui_name>
                    <description language="en">Takes the value of the `gem_dma_bus_width DEFINE
3'b001 : 32-bit
3'b010 : 64-bit
3'b100 : 128-bit</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="extra_spec_add">
                    <gui_name language="en">extra_spec_add</gui_name>
                    <description language="en">Takes the value of the `extra_spec_add DEFINE. Undefined in Pele</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="gem_irq_read_clear">
                    <gui_name language="en">gem_irq_read_clear</gui_name>
                    <description language="en">Takes the value of the `gem_irq_read_clear DEFINE. Undefined in Pele. Keeping undefined means interrupt status registers are write-one-to-clear rather than clearing when read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="gem_no_snapshot">
                    <gui_name language="en">gem_no_snapshot</gui_name>
                    <description language="en">Takes the value of the `gem_no_snapshot DEFINE. Defined for Pele. Remove statistics snapshot
(not supported by driver)</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="gem_no_stats">
                    <gui_name language="en">gem_no_stats</gui_name>
                    <description language="en">Takes the value of the `gem_no_stats DEFINE. Undefined for Pele.
Include statistics registers.</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="gem_no_scan_pins">
                    <gui_name language="en">gem_no_scan_pins</gui_name>
                    <description language="en">Takes the value of the `gem_no_scan_pins DEFINE. Defined for Pele. Remove placeholder scan pins from module.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="15" name="gem_user_in_width">
                    <gui_name language="en">gem_user_in_width</gui_name>
                    <description language="en">Takes the value of the `gem_user_in_width DEFINE. Undefined for Pele. No requirement for user I/O.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="10" name="gem_user_out_width">
                    <gui_name language="en">gem_user_out_width</gui_name>
                    <description language="en">Takes the value of the `gem_user_out_width DEFINE. Undefined for Pele. No requirement for user I/O.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="gem_user_io">
                    <gui_name language="en">gem_user_io</gui_name>
                    <description language="en">Takes the value of the `gem_user_io DEFINE. Undefined for Pele. No requirement for user I/O.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="gem_apb_rev2">
                    <gui_name language="en">gem_apb_rev2</gui_name>
                    <description language="en">Takes the value of the `gem_apb_rev2 DEFINE. Defined for Pele. Use AMBA 2.0 APB.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="gem_apb_rev1">
                    <gui_name language="en">gem_apb_rev1</gui_name>
                    <description language="en">Takes the value of the `gem_apb_rev1 DEFINE. Undefined for Pele. Use AMBA 2.0 APB.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="gem_ext_fifo_interface">
                    <gui_name language="en">gem_ext_fifo_interface</gui_name>
                    <description language="en">Takes the value of the `gem_ext_fifo_interface. Undefined for Pele. Use AHB DMA; External FIFO interface not implemented.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="gem_no_int_loopback">
                    <gui_name language="en">gem_no_int_loopback</gui_name>
                    <description language="en">Takes the value of the `gem_no_int_loopback DEFINE. Undefined for Pele. Include loopback test mode</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="gem_int_loopback">
                    <gui_name language="en">gem_int_loopback</gui_name>
                    <description language="en">Takes the value of the `gem_int_loopback DEFINE. Defined for Pele. Include loopback test mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="TDC_50">
                    <gui_name language="en">TDC_50</gui_name>
                    <description language="en">Takes the value of the `TDC_50 DEFINE. Undefined for Pele. Only used with PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="RDC_50">
                    <gui_name language="en">RDC_50</gui_name>
                    <description language="en">Takes the value of the `RDC_50 DEFINE. Undefined for Pele. Only used with PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="gem_serdes">
                    <gui_name language="en">gem_serdes</gui_name>
                    <description language="en">Takes the value of the `gem_serdes DEFINE. Undefined for Pele. Only used with PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="gem_no_pcs">
                    <gui_name language="en">gem_no_pcs</gui_name>
                    <description language="en">Takes the value of the `gem_no_pcs DEFINE. Defined for Pele. Use GEM without 1000-BASE-X PCS sublayer and Ten Bit Interface</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG2" offset="0xe000c284" size="0x4">
                <gui_name language="en">design_cfg2</gui_name>
                <description language="en">Design Configuration Register 2</description>
                <bitField access="Read Only" high_bit="29" low_bit="26" name="gem_tx_pbuf_addr">
                    <gui_name language="en">gem_tx_pbuf_addr</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_addr DEFINE. Max address bits for Tx packet buffer (10-bits for maximum 4 kB buffer)
Buffer size for Tx packet buffer mode will be 4kB.
This will allow one standard packet to be received while another is transferred to system memory by the DMA interface.</description>
                </bitField>
                <bitField access="Read Only" high_bit="25" low_bit="22" name="gem_rx_pbuf_addr">
                    <gui_name language="en">gem_rx_pbuf_addr</gui_name>
                    <description language="en">Takes the value of the `gem_rx_pbuf_addr DEFINE. Max address bits for Rx packet buffer (10-bits for maximum 4 kB buffer)
Buffer size for Rx packet buffer mode will be 4kB.
This will allow one standard packet to be received while another is transferred to system memory by the DMA interface.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="gem_tx_pkt_buffer">
                    <gui_name language="en">gem_tx_pkt_buffer</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pkt_buffer DEFINE. Defined for Pele. Includes the transmitter packet buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="20" name="gem_rx_pkt_buffer">
                    <gui_name language="en">gem_rx_pkt_buffer</gui_name>
                    <description language="en">Takes the value of the `gem_rx_pkt_buffer DEFINE. Defined for Pele. Includes the receiver packet buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="gem_hprot_value">
                    <gui_name language="en">gem_hprot_value</gui_name>
                    <description language="en">Takes the value of the `gem_hprot_value DEFINE. For Pele set the fixed AHB HPROT value used during transfers</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="gem_jumbo_max_length">
                    <gui_name language="en">gem_jumbo_max_length</gui_name>
                    <description language="en">Takes the value of the `gem_jumbo_max_length DEFINE. Maximum length of jumbo frames accepted by receiver.
This is set to the size of the smallest of the two packet buffer, minus a margin for packet headers. However, Pele will not support jumbo frames.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG3" offset="0xe000c288" size="0x4">
                <gui_name language="en">design_cfg3</gui_name>
                <description language="en">Design Configuration Register 3</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="gem_rx_base2_fifo_size">
                    <gui_name language="en">gem_rx_base2_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_rx_base2_fifo_size DEFINE. Base-2 equivalent of `gem_rx_fifo_size</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="gem_rx_fifo_size">
                    <gui_name language="en">gem_rx_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_rx_fifo_size DEFINE. Set the size of the small Rx FIFO for grant latency. Extended to 16 deep to allow buffering of 64 byte maximum AHB burst size in Pele.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG4" offset="0xe000c28c" size="0x4">
                <gui_name language="en">design_cfg4</gui_name>
                <description language="en">Design Configuration Register 4</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="gem_tx_base2_fifo_size">
                    <gui_name language="en">gem_tx_base2_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_tx_base2_fifo_size DEFINE. Base-2 equivalent of `gem_tx_fifo_size</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="gem_tx_fifo_size">
                    <gui_name language="en">gem_tx_fifo_size</gui_name>
                    <description language="en">Takes the value of the `gem_tx_fifo_size DEFINE. Set the size of the small TX FIFO for grant latency</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG5" offset="0xe000c290" size="0x4">
                <gui_name language="en">design_cfg5</gui_name>
                <description language="en">Design Configuration Register 5</description>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="gem_tsu_clk">
                    <gui_name language="en">gem_tsu_clk</gui_name>
                    <description language="en">Takes the value of the `gem_tsu_clk DEFINE. Undefined in Pele. 1588 Time Stamp Unit clock sourced from pclk rather than independent tsu_clk.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="20" name="gem_rx_buffer_length_def">
                    <gui_name language="en">gem_rx_buffer_length_def</gui_name>
                    <description language="en">Takes the value of the `gem_rx_buffer_length_def DEFINE. Set the default buffer length used by Rx DMA to 128 bytes in Pele</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="gem_tx_pbuf_size_def">
                    <gui_name language="en">gem_tx_pbuf_size_def</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_size_def DEFINE. Full 4 kB Tx packet buffer size - dedicated memory resource in Pele.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="design_cfg5_gem_rx_pbuf_size_def_ENUM" high_bit="18" low_bit="17" name="gem_rx_pbuf_size_def">
                    <gui_name language="en">gem_rx_pbuf_size_def</gui_name>
                    <description language="en">Takes the value of the `gem_rx_pbuf_size_def DEFINE. Full
4 kB Rx packet buffer size - dedicated memory resource in Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="15" name="gem_endian_swap_def">
                    <gui_name language="en">gem_endian_swap_def</gui_name>
                    <description language="en">Takes the value of the `gem_endian_swap_def DEFINE. Set to big endian data, little endian management descriptors in Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="gem_mdc_clock_div">
                    <gui_name language="en">gem_mdc_clock_div</gui_name>
                    <description language="en">Takes the value of the `gem_mdc_clock_div DEFINE. Set default MDC clock divisor (can still be programmed) in Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="10" name="gem_dma_bus_width">
                    <gui_name language="en">gem_dma_bus_width</gui_name>
                    <description language="en">Takes the value of the `gem_dma_bus_width_def DEFINE. Limit to 32-bit AHB bus in Pele</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="gem_phy_ident">
                    <gui_name language="en">gem_phy_ident</gui_name>
                    <description language="en">Takes the value of the `gem_phy_ident DEFINE. Undefined in Pele. Only used in PCS.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="gem_tsu">
                    <gui_name language="en">gem_tsu</gui_name>
                    <description language="en">Takes the value of the `gem_tsu DEFINE. Defined in Pele. Include support for 1588 Time Stamp Unit</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="gem_tx_fifo_cnt_width">
                    <gui_name language="en">gem_tx_fifo_cnt_width</gui_name>
                    <description language="en">Takes the value of the `gem_tx_fifo_cnt_width DEFINE. Width for `gem_tx_fifo_size</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="gem_rx_fifo_cnt_width">
                    <gui_name language="en">gem_rx_fifo_cnt_width</gui_name>
                    <description language="en">Takes the value of the `gem_rx_fifo_cnt_width DEFINE. Width for `gem_rx_fifo_size.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG6" offset="0xe000c294" size="0x4">
                <gui_name language="en">design_cfg6</gui_name>
                <description language="en">Design Configuration Register 6</description>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="gem_tx_pbufq_seg_sz">
                    <gui_name language="en">gem_tx_pbufq_seg_sz</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_queue_segment_size DEFINE. Uses default GEM value in Pele. Ignored, no priority dma.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="dma_priority_queue7">
                    <gui_name language="en">dma_priority_queue7</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue7 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="dma_priority_queue6">
                    <gui_name language="en">dma_priority_queue6</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue6 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="dma_priority_queue5">
                    <gui_name language="en">dma_priority_queue5</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue5 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="dma_priority_queue4">
                    <gui_name language="en">dma_priority_queue4</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue4 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="dma_priority_queue3">
                    <gui_name language="en">dma_priority_queue3</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue3 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="dma_priority_queue2">
                    <gui_name language="en">dma_priority_queue2</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue2 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="dma_priority_queue1">
                    <gui_name language="en">dma_priority_queue1</gui_name>
                    <description language="en">Takes the value of the `dma_priority_queue1 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
            </register>
            <register access="Read Only" name="GEM1_DESIGN_CFG7" offset="0xe000c298" size="0x4">
                <gui_name language="en">design_cfg7</gui_name>
                <description language="en">Design Configuration Register 7</description>
                <bitField access="Read Only" high_bit="31" low_bit="28" name="tx_pbuf_numseg_q7">
                    <gui_name language="en">tx_pbuf_numseg_q7</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q7 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="24" name="tx_pbuf_numseg_q6">
                    <gui_name language="en">tx_pbuf_numseg_q6</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q6 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="tx_pbuf_numseg_q5">
                    <gui_name language="en">tx_pbuf_numseg_q5</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q5 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="16" name="tx_pbuf_numseg_q4">
                    <gui_name language="en">tx_pbuf_numseg_q4</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q4 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="12" name="tx_pbuf_numseg_q3">
                    <gui_name language="en">tx_pbuf_numseg_q3</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q3 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="tx_pbuf_numseg_q2">
                    <gui_name language="en">tx_pbuf_numseg_q2</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q2 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="tx_pbuf_numseg_q1">
                    <gui_name language="en">tx_pbuf_numseg_q1</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q1 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="tx_pbuf_numseg_q0">
                    <gui_name language="en">tx_pbuf_numseg_q0</gui_name>
                    <description language="en">Takes the value of the `gem_tx_pbuf_num_segments_q0 DEFINE. Undefined. No priority DMA In Pele.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_GPIO" name="GPIO" offset="0xe000a000">
            <gui_name language="en">gpio</gui_name>
            <description language="en">gpio</description>
            <register name="GPIO_MASK_DATA_0_LSW" offset="0xe000a000" size="0x4">
                <gui_name language="en">MASK_DATA_0_LSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the least significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_0_LSW_MASK_0_LSW_ENUM" high_bit="31" low_bit="16" name="MASK_0_LSW">
                    <gui_name language="en">MASK_0_LSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_0_LSW_DATA_0_LSW_ENUM" high_bit="15" low_bit="0" name="DATA_0_LSW">
                    <gui_name language="en">DATA_0_LSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank Note: Bit[6], bit[7] default value = 0</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_0_MSW" offset="0xe000a004" size="0x4">
                <gui_name language="en">MASK_DATA_0_MSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the most significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_0_MSW_MASK_0_MSW_ENUM" high_bit="31" low_bit="16" name="MASK_0_MSW">
                    <gui_name language="en">MASK_0_MSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_0_MSW_DATA_0_MSW_ENUM" high_bit="15" low_bit="0" name="DATA_0_MSW">
                    <gui_name language="en">DATA_0_MSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_1_LSW" offset="0xe000a008" size="0x4">
                <gui_name language="en">MASK_DATA_1_LSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the least significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_1_LSW_MASK_1_LSW_ENUM" high_bit="31" low_bit="16" name="MASK_1_LSW">
                    <gui_name language="en">MASK_1_LSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_1_LSW_DATA_1_LSW_ENUM" high_bit="15" low_bit="0" name="DATA_1_LSW">
                    <gui_name language="en">DATA_1_LSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_1_MSW" offset="0xe000a00c" size="0x4">
                <gui_name language="en">MASK_DATA_1_MSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the most significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_1_MSW_MASK_1_MSW_ENUM" high_bit="21" low_bit="16" name="MASK_1_MSW">
                    <gui_name language="en">MASK_1_MSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_1_MSW_DATA_1_MSW_ENUM" high_bit="5" low_bit="0" name="DATA_1_MSW">
                    <gui_name language="en">DATA_1_MSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_2_LSW" offset="0xe000a010" size="0x4">
                <gui_name language="en">MASK_DATA_2_LSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the least significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_2_LSW_MASK_2_LSW_ENUM" high_bit="31" low_bit="16" name="MASK_2_LSW">
                    <gui_name language="en">MASK_2_LSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_2_LSW_DATA_2_LSW_ENUM" high_bit="15" low_bit="0" name="DATA_2_LSW">
                    <gui_name language="en">DATA_2_LSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_2_MSW" offset="0xe000a014" size="0x4">
                <gui_name language="en">MASK_DATA_2_MSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the most significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_2_MSW_MASK_2_MSW_ENUM" high_bit="31" low_bit="16" name="MASK_2_MSW">
                    <gui_name language="en">MASK_2_MSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_2_MSW_DATA_2_MSW_ENUM" high_bit="15" low_bit="0" name="DATA_2_MSW">
                    <gui_name language="en">DATA_2_MSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_3_LSW" offset="0xe000a018" size="0x4">
                <gui_name language="en">MASK_DATA_3_LSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the least significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_3_LSW_MASK_3_LSW_ENUM" high_bit="31" low_bit="16" name="MASK_3_LSW">
                    <gui_name language="en">MASK_3_LSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_3_LSW_DATA_3_LSW_ENUM" high_bit="15" low_bit="0" name="DATA_3_LSW">
                    <gui_name language="en">DATA_3_LSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_MASK_DATA_3_MSW" offset="0xe000a01c" size="0x4">
                <gui_name language="en">MASK_DATA_3_MSW</gui_name>
                <description language="en">Maskable single-word-based data access register: Mask and data access for the most significant word of this bank of GPIO pins</description>
                <bitField access="Write Only" enumerationId="MASK_DATA_3_MSW_MASK_3_MSW_ENUM" high_bit="31" low_bit="16" name="MASK_3_MSW">
                    <gui_name language="en">MASK_3_MSW</gui_name>
                    <description language="en">Mask values to be applied on writes to the corresponding GPIO pins
0 = pin value is updated
1 = pin is masked
Each bit controls the corresponding pin within the 16-bit half-bank
Write Only, Read back as zero</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MASK_DATA_3_MSW_DATA_3_MSW_ENUM" high_bit="15" low_bit="0" name="DATA_3_MSW">
                    <gui_name language="en">DATA_3_MSW</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 16-bit half-bank</description>
                </bitField>
            </register>
            <register name="GPIO_DATA_0" offset="0xe000a040" size="0x4">
                <gui_name language="en">DATA_0</gui_name>
                <description language="en">Unmasked double-word-based data access register: data access for this bank of GPIO pins</description>
                <bitField access="Read Write" enumerationId="DATA_0_DATA_0_ENUM" high_bit="31" low_bit="0" name="DATA_0">
                    <gui_name language="en">DATA_0</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 32-bit bank. Note: Bit[6], bit[7] default value = 0</description>
                </bitField>
            </register>
            <register name="GPIO_DATA_1" offset="0xe000a044" size="0x4">
                <gui_name language="en">DATA_1</gui_name>
                <description language="en">Unmasked double-word-based data access register: data access for this bank of GPIO pins</description>
                <bitField access="Read Write" enumerationId="DATA_1_DATA_1_ENUM" high_bit="21" low_bit="0" name="DATA_1">
                    <gui_name language="en">DATA_1</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_DATA_2" offset="0xe000a048" size="0x4">
                <gui_name language="en">DATA_2</gui_name>
                <description language="en">Unmasked double-word-based data access register: data access for this bank of GPIO pins</description>
                <bitField access="Read Write" enumerationId="DATA_2_DATA_2_ENUM" high_bit="31" low_bit="0" name="DATA_2">
                    <gui_name language="en">DATA_2</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_DATA_3" offset="0xe000a04c" size="0x4">
                <gui_name language="en">DATA_3</gui_name>
                <description language="en">Unmasked double-word-based data access register: data access for this bank of GPIO pins</description>
                <bitField access="Read Write" enumerationId="DATA_3_DATA_3_ENUM" high_bit="31" low_bit="0" name="DATA_3">
                    <gui_name language="en">DATA_3</gui_name>
                    <description language="en">Data values read from or written to the corresponding GPIO pins
Each bit controls the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_DATA_0_RO" offset="0xe000a060" size="0x4">
                <gui_name language="en">DATA_0_RO</gui_name>
                <description language="en">Read only pin value register: read only pin values for this bank of GPIO pins</description>
                <bitField access="Read Only" enumerationId="DATA_0_RO_DATA_0_RO_ENUM" high_bit="31" low_bit="0" name="DATA_0_RO">
                    <gui_name language="en">DATA_0_RO</gui_name>
                    <description language="en">GPIO pin values, independent of the read, write, and direction settings.
Each bit provides a pin value within the 32-bit bank Note :Bit[6], bit[7] default value = 0</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_DATA_1_RO" offset="0xe000a064" size="0x4">
                <gui_name language="en">DATA_1_RO</gui_name>
                <description language="en">Read only pin value register: read only pin values for this bank of GPIO pins</description>
                <bitField access="Read Only" enumerationId="DATA_1_RO_DATA_1_RO_ENUM" high_bit="21" low_bit="0" name="DATA_1_RO">
                    <gui_name language="en">DATA_1_RO</gui_name>
                    <description language="en">GPIO pin values, independent of the read, write, and direction settings.
Each bit provides a pin value within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_DATA_2_RO" offset="0xe000a068" size="0x4">
                <gui_name language="en">DATA_2_RO</gui_name>
                <description language="en">Read only pin value register: read only pin values for this bank of GPIO pins</description>
                <bitField access="Read Only" enumerationId="DATA_2_RO_DATA_2_RO_ENUM" high_bit="31" low_bit="0" name="DATA_2_RO">
                    <gui_name language="en">DATA_2_RO</gui_name>
                    <description language="en">GPIO pin values, independent of the read, write, and direction settings.
Each bit provides a pin value within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_DATA_3_RO" offset="0xe000a06c" size="0x4">
                <gui_name language="en">DATA_3_RO</gui_name>
                <description language="en">Read only pin value register: read only pin values for this bank of GPIO pins</description>
                <bitField access="Read Only" enumerationId="DATA_3_RO_DATA_3_RO_ENUM" high_bit="31" low_bit="0" name="DATA_3_RO">
                    <gui_name language="en">DATA_3_RO</gui_name>
                    <description language="en">GPIO pin values, independent of the read, write, and direction settings.
Each bit provides a pin value within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_BYPM_0" offset="0xe000a200" size="0x4">
                <gui_name language="en">BYPM_0</gui_name>
                <description language="en">Bypass configuration register: Configures bank 0 for bypass mode or software control mode</description>
                <bitField access="Read Write" enumerationId="BYPM_0_BYPASS_MODE_0_ENUM" high_bit="31" low_bit="0" name="BYPASS_MODE_0">
                    <gui_name language="en">BYPASS_MODE_0</gui_name>
                    <description language="en">Bypass configuration for bank 0
0 = software controlled mode
1 = bypass mode
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_DIRM_0" offset="0xe000a204" size="0x4">
                <gui_name language="en">DIRM_0</gui_name>
                <description language="en">Direction mode configuration register: Configures bank 0 for direction mode, either input or output</description>
                <bitField access="Read Write" enumerationId="DIRM_0_DIRECTION_0_ENUM" high_bit="31" low_bit="0" name="DIRECTION_0">
                    <gui_name language="en">DIRECTION_0</gui_name>
                    <description language="en">Direction mode for bank 0
0 = input
1 = output
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_OEN_0" offset="0xe000a208" size="0x4">
                <gui_name language="en">OEN_0</gui_name>
                <description language="en">Output enable register: Configures the output enables of bank 0</description>
                <bitField access="Read Write" enumerationId="OEN_0_OP_ENABLE_0_ENUM" high_bit="31" low_bit="0" name="OP_ENABLE_0">
                    <gui_name language="en">OP_ENABLE_0</gui_name>
                    <description language="en">Output enables for bank 0
0 = disabled
1 = enabled
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_INT_MASK_0" offset="0xe000a20c" size="0x4">
                <gui_name language="en">INT_MASK_0</gui_name>
                <description language="en">Interrupt Mask status register: Reports the interrupt mask state for bank 0</description>
                <bitField access="Read Only" enumerationId="INT_MASK_0_INT_MASK_0_ENUM" high_bit="31" low_bit="0" name="INT_MASK_0">
                    <gui_name language="en">INT_MASK_0</gui_name>
                    <description language="en">Interrupt mask for bank 0
0 = interrupt source enabled
1 = interrupt source masked
Each bit reports the status for the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_EN_0" offset="0xe000a210" size="0x4">
                <gui_name language="en">INT_EN_0</gui_name>
                <description language="en">Interrupt Enable configuration register: Clears the interrupt mask for bank 0</description>
                <bitField access="Write Only" enumerationId="INT_EN_0_INT_ENABLE_0_ENUM" high_bit="31" low_bit="0" name="INT_ENABLE_0">
                    <gui_name language="en">INT_ENABLE_0</gui_name>
                    <description language="en">Interrupt enable for bank 0
0 = no change
1 = clear interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_DIS_0" offset="0xe000a214" size="0x4">
                <gui_name language="en">INT_DIS_0</gui_name>
                <description language="en">Interrupt Disable configuration register: Sets the interrupt mask for bank 0</description>
                <bitField access="Write Only" enumerationId="INT_DIS_0_INT_DISABLE_0_ENUM" high_bit="31" low_bit="0" name="INT_DISABLE_0">
                    <gui_name language="en">INT_DISABLE_0</gui_name>
                    <description language="en">Interrupt disable for bank 0
0 = no change
1 = set interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_STAT_0" offset="0xe000a218" size="0x4">
                <gui_name language="en">INT_STAT_0</gui_name>
                <description language="en">Interrupt Status register: Reports the interrupt status for bank 0</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="INT_STATUS_0">
                    <gui_name language="en">INT_STATUS_0</gui_name>
                    <description language="en">Interrupt status for bank 0
Upon read:
0 = no interrupt
1 = interrupt event has occurred
Upon write:
0 = no action
1 = clear interrupt status bit
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_TYPE_0" offset="0xe000a21c" size="0x4">
                <gui_name language="en">INT_TYPE_0</gui_name>
                <description language="en">Interrupt Type configuration register: Configures the interrupt type for bank 0</description>
                <bitField access="Read Write" enumerationId="INT_TYPE_0_INT_TYPE_0_ENUM" high_bit="31" low_bit="0" name="INT_TYPE_0">
                    <gui_name language="en">INT_TYPE_0</gui_name>
                    <description language="en">Interrupt type for bank 0
0 = level-sensitive
1 = edge-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_POLARITY_0" offset="0xe000a220" size="0x4">
                <gui_name language="en">INT_POLARITY_0</gui_name>
                <description language="en">Interrupt polarity configuration register: Configures the interrupt polarity for bank 0</description>
                <bitField access="Read Write" enumerationId="INT_POLARITY_0_INT_POL_0_ENUM" high_bit="31" low_bit="0" name="INT_POL_0">
                    <gui_name language="en">INT_POL_0</gui_name>
                    <description language="en">Interrupt polarity for bank 0
0 = active low or falling edge
1 = active high or rising edge
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_ANY_0" offset="0xe000a224" size="0x4">
                <gui_name language="en">INT_ANY_0</gui_name>
                <description language="en">Interrupt On Any configuration register: Configures the interrupt to trigger on any edge for bank 0</description>
                <bitField access="Read Write" enumerationId="INT_ANY_0_INT_ON_ANY_0_ENUM" high_bit="31" low_bit="0" name="INT_ON_ANY_0">
                    <gui_name language="en">INT_ON_ANY_0</gui_name>
                    <description language="en">Interrupt edge triggering mode for bank 0
0 = trigger on single edge, using configured interrupt polarity
1 = trigger on both edges
This value is ignored if corresponding interrupt source is configured to be level-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_BYPM_1" offset="0xe000a240" size="0x4">
                <gui_name language="en">BYPM_1</gui_name>
                <description language="en">Bypass configuration register: Configures bank 1 for bypass mode or software control mode</description>
                <bitField access="Read Write" enumerationId="BYPM_1_BYPASS_MODE_1_ENUM" high_bit="21" low_bit="0" name="BYPASS_MODE_1">
                    <gui_name language="en">BYPASS_MODE_1</gui_name>
                    <description language="en">Bypass configuration for bank 1
0 = software controlled mode
1 = bypass mode
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_DIRM_1" offset="0xe000a244" size="0x4">
                <gui_name language="en">DIRM_1</gui_name>
                <description language="en">Direction mode configuration register: Configures bank 1 for direction mode, either input or output</description>
                <bitField access="Read Write" enumerationId="DIRM_1_DIRECTION_1_ENUM" high_bit="21" low_bit="0" name="DIRECTION_1">
                    <gui_name language="en">DIRECTION_1</gui_name>
                    <description language="en">Direction mode for bank 1
0 = input
1 = output
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_OEN_1" offset="0xe000a248" size="0x4">
                <gui_name language="en">OEN_1</gui_name>
                <description language="en">Output enable register: Configures the output enables of bank 1</description>
                <bitField access="Read Write" enumerationId="OEN_1_OP_ENABLE_1_ENUM" high_bit="21" low_bit="0" name="OP_ENABLE_1">
                    <gui_name language="en">OP_ENABLE_1</gui_name>
                    <description language="en">Output enables for bank 1
0 = disabled
1 = enabled
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_INT_MASK_1" offset="0xe000a24c" size="0x4">
                <gui_name language="en">INT_MASK_1</gui_name>
                <description language="en">Interrupt Mask status register: Reports the interrupt mask state for bank 1</description>
                <bitField access="Read Only" enumerationId="INT_MASK_1_INT_MASK_1_ENUM" high_bit="21" low_bit="0" name="INT_MASK_1">
                    <gui_name language="en">INT_MASK_1</gui_name>
                    <description language="en">Interrupt mask for bank 1
0 = interrupt source enabled
1 = interrupt source masked
Each bit reports the status for the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_EN_1" offset="0xe000a250" size="0x4">
                <gui_name language="en">INT_EN_1</gui_name>
                <description language="en">Interrupt Enable configuration register: Clears the interrupt mask for bank 1</description>
                <bitField access="Write Only" enumerationId="INT_EN_1_INT_ENABLE_1_ENUM" high_bit="21" low_bit="0" name="INT_ENABLE_1">
                    <gui_name language="en">INT_ENABLE_1</gui_name>
                    <description language="en">Interrupt enable for bank 1
0 = no change
1 = clear interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_DIS_1" offset="0xe000a254" size="0x4">
                <gui_name language="en">INT_DIS_1</gui_name>
                <description language="en">Interrupt Disable configuration register: Sets the interrupt mask for bank 1</description>
                <bitField access="Write Only" enumerationId="INT_DIS_1_INT_DISABLE_1_ENUM" high_bit="21" low_bit="0" name="INT_DISABLE_1">
                    <gui_name language="en">INT_DISABLE_1</gui_name>
                    <description language="en">Interrupt disable for bank 1
0 = no change
1 = set interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_STAT_1" offset="0xe000a258" size="0x4">
                <gui_name language="en">INT_STAT_1</gui_name>
                <description language="en">Interrupt Status register: Reports the interrupt status for bank 1</description>
                <bitField access="Read Write" high_bit="21" low_bit="0" name="INT_STATUS_1">
                    <gui_name language="en">INT_STATUS_1</gui_name>
                    <description language="en">Interrupt status for bank 1
Upon read:
0 = no interrupt
1 = interrupt event has occurred
Upon write:
0 = no action
1 = clear interrupt status bit
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_TYPE_1" offset="0xe000a25c" size="0x4">
                <gui_name language="en">INT_TYPE_1</gui_name>
                <description language="en">Interrupt Type configuration register: Configures the interrupt type for bank 1</description>
                <bitField access="Read Write" enumerationId="INT_TYPE_1_INT_TYPE_1_ENUM" high_bit="21" low_bit="0" name="INT_TYPE_1">
                    <gui_name language="en">INT_TYPE_1</gui_name>
                    <description language="en">Interrupt type for bank 1
0 = level-sensitive
1 = edge-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_POLARITY_1" offset="0xe000a260" size="0x4">
                <gui_name language="en">INT_POLARITY_1</gui_name>
                <description language="en">Interrupt polarity configuration register: Configures the interrupt polarity for bank 1</description>
                <bitField access="Read Write" enumerationId="INT_POLARITY_1_INT_POL_1_ENUM" high_bit="21" low_bit="0" name="INT_POL_1">
                    <gui_name language="en">INT_POL_1</gui_name>
                    <description language="en">Interrupt polarity for bank 1
0 = active low or falling edge
1 = active high or rising edge
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_ANY_1" offset="0xe000a264" size="0x4">
                <gui_name language="en">INT_ANY_1</gui_name>
                <description language="en">Interrupt On Any configuration register: Configures the interrupt to trigger on any edge for bank 1</description>
                <bitField access="Read Write" enumerationId="INT_ANY_1_INT_ON_ANY_1_ENUM" high_bit="21" low_bit="0" name="INT_ON_ANY_1">
                    <gui_name language="en">INT_ON_ANY_1</gui_name>
                    <description language="en">Interrupt edge triggering mode for bank 1
0 = trigger on single edge, using configured interrupt polarity
1 = trigger on both edges
This value is ignored if corresponding interrupt source is configured to be level-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_BYPM_2" offset="0xe000a280" size="0x4">
                <gui_name language="en">BYPM_2</gui_name>
                <description language="en">Bypass configuration register: Configures bank 2 for bypass mode or software control mode</description>
                <bitField access="Read Write" enumerationId="BYPM_2_BYPASS_MODE_2_ENUM" high_bit="31" low_bit="0" name="BYPASS_MODE_2">
                    <gui_name language="en">BYPASS_MODE_2</gui_name>
                    <description language="en">Bypass configuration for bank 2
0 = software controlled mode
1 = bypass mode
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_DIRM_2" offset="0xe000a284" size="0x4">
                <gui_name language="en">DIRM_2</gui_name>
                <description language="en">Direction mode configuration register: Configures bank 2 for direction mode, either input or output</description>
                <bitField access="Read Write" enumerationId="DIRM_2_DIRECTION_2_ENUM" high_bit="31" low_bit="0" name="DIRECTION_2">
                    <gui_name language="en">DIRECTION_2</gui_name>
                    <description language="en">Direction mode for bank 2
0 = input
1 = output
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_OEN_2" offset="0xe000a288" size="0x4">
                <gui_name language="en">OEN_2</gui_name>
                <description language="en">Output enable register: Configures the output enables of bank 2</description>
                <bitField access="Read Write" enumerationId="OEN_2_OP_ENABLE_2_ENUM" high_bit="31" low_bit="0" name="OP_ENABLE_2">
                    <gui_name language="en">OP_ENABLE_2</gui_name>
                    <description language="en">Output enables for bank 2
0 = disabled
1 = enabled
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_INT_MASK_2" offset="0xe000a28c" size="0x4">
                <gui_name language="en">INT_MASK_2</gui_name>
                <description language="en">Interrupt Mask status register: Reports the interrupt mask state for bank 2</description>
                <bitField access="Read Only" enumerationId="INT_MASK_2_INT_MASK_2_ENUM" high_bit="31" low_bit="0" name="INT_MASK_2">
                    <gui_name language="en">INT_MASK_2</gui_name>
                    <description language="en">Interrupt mask for bank 2
0 = interrupt source enabled
1 = interrupt source masked
Each bit reports the status for the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_EN_2" offset="0xe000a290" size="0x4">
                <gui_name language="en">INT_EN_2</gui_name>
                <description language="en">Interrupt Enable configuration register: Clears the interrupt mask for bank 2</description>
                <bitField access="Write Only" enumerationId="INT_EN_2_INT_ENABLE_2_ENUM" high_bit="31" low_bit="0" name="INT_ENABLE_2">
                    <gui_name language="en">INT_ENABLE_2</gui_name>
                    <description language="en">Interrupt enable for bank 2
0 = no change
1 = clear interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_DIS_2" offset="0xe000a294" size="0x4">
                <gui_name language="en">INT_DIS_2</gui_name>
                <description language="en">Interrupt Disable configuration register: Sets the interrupt mask for bank 2</description>
                <bitField access="Write Only" enumerationId="INT_DIS_2_INT_DISABLE_2_ENUM" high_bit="31" low_bit="0" name="INT_DISABLE_2">
                    <gui_name language="en">INT_DISABLE_2</gui_name>
                    <description language="en">Interrupt disable for bank 2
0 = no change
1 = set interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_STAT_2" offset="0xe000a298" size="0x4">
                <gui_name language="en">INT_STAT_2</gui_name>
                <description language="en">Interrupt Status register: Reports the interrupt status for bank 2</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="INT_STATUS_2">
                    <gui_name language="en">INT_STATUS_2</gui_name>
                    <description language="en">Interrupt status for bank 2
Upon read:
0 = no interrupt
1 = interrupt event has occurred
Upon write:
0 = no action
1 = clear interrupt status bit
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_TYPE_2" offset="0xe000a29c" size="0x4">
                <gui_name language="en">INT_TYPE_2</gui_name>
                <description language="en">Interrupt Type configuration register: Configures the interrupt type for bank 2</description>
                <bitField access="Read Write" enumerationId="INT_TYPE_2_INT_TYPE_2_ENUM" high_bit="31" low_bit="0" name="INT_TYPE_2">
                    <gui_name language="en">INT_TYPE_2</gui_name>
                    <description language="en">Interrupt type for bank 2
0 = level-sensitive
1 = edge-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_POLARITY_2" offset="0xe000a2a0" size="0x4">
                <gui_name language="en">INT_POLARITY_2</gui_name>
                <description language="en">Interrupt polarity configuration register: Configures the interrupt polarity for bank 2</description>
                <bitField access="Read Write" enumerationId="INT_POLARITY_2_INT_POL_2_ENUM" high_bit="31" low_bit="0" name="INT_POL_2">
                    <gui_name language="en">INT_POL_2</gui_name>
                    <description language="en">Interrupt polarity for bank 2
0 = active low or falling edge
1 = active high or rising edge
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_ANY_2" offset="0xe000a2a4" size="0x4">
                <gui_name language="en">INT_ANY_2</gui_name>
                <description language="en">Interrupt On Any configuration register: Configures the interrupt to trigger on any edge for bank 2</description>
                <bitField access="Read Write" enumerationId="INT_ANY_2_INT_ON_ANY_2_ENUM" high_bit="31" low_bit="0" name="INT_ON_ANY_2">
                    <gui_name language="en">INT_ON_ANY_2</gui_name>
                    <description language="en">Interrupt edge triggering mode for bank 2
0 = trigger on single edge, using configured interrupt polarity
1 = trigger on both edges
This value is ignored if corresponding interrupt source is configured to be level-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_BYPM_3" offset="0xe000a2c0" size="0x4">
                <gui_name language="en">BYPM_3</gui_name>
                <description language="en">Bypass configuration register: Configures bank 3 for bypass mode or software control mode</description>
                <bitField access="Read Write" enumerationId="BYPM_3_BYPASS_MODE_3_ENUM" high_bit="31" low_bit="0" name="BYPASS_MODE_3">
                    <gui_name language="en">BYPASS_MODE_3</gui_name>
                    <description language="en">Bypass configuration for bank 3
0 = software controlled mode
1 = bypass mode
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_DIRM_3" offset="0xe000a2c4" size="0x4">
                <gui_name language="en">DIRM_3</gui_name>
                <description language="en">Direction mode configuration register: Configures bank 3 for direction mode, either input or output</description>
                <bitField access="Read Write" enumerationId="DIRM_3_DIRECTION_3_ENUM" high_bit="31" low_bit="0" name="DIRECTION_3">
                    <gui_name language="en">DIRECTION_3</gui_name>
                    <description language="en">Direction mode for bank 3
0 = input
1 = output
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_OEN_3" offset="0xe000a2c8" size="0x4">
                <gui_name language="en">OEN_3</gui_name>
                <description language="en">Output enable register: Configures the output enables of bank 3</description>
                <bitField access="Read Write" enumerationId="OEN_3_OP_ENABLE_3_ENUM" high_bit="31" low_bit="0" name="OP_ENABLE_3">
                    <gui_name language="en">OP_ENABLE_3</gui_name>
                    <description language="en">Output enables for bank 3
0 = disabled
1 = enabled
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Read Only" name="GPIO_INT_MASK_3" offset="0xe000a2cc" size="0x4">
                <gui_name language="en">INT_MASK_3</gui_name>
                <description language="en">Interrupt Mask status register: Reports the interrupt mask state for bank 3</description>
                <bitField access="Read Only" enumerationId="INT_MASK_3_INT_MASK_3_ENUM" high_bit="31" low_bit="0" name="INT_MASK_3">
                    <gui_name language="en">INT_MASK_3</gui_name>
                    <description language="en">Interrupt mask for bank 3
0 = interrupt source enabled
1 = interrupt source masked
Each bit reports the status for the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_EN_3" offset="0xe000a2d0" size="0x4">
                <gui_name language="en">INT_EN_3</gui_name>
                <description language="en">Interrupt Enable configuration register: Clears the interrupt mask for bank 3</description>
                <bitField access="Write Only" enumerationId="INT_EN_3_INT_ENABLE_3_ENUM" high_bit="31" low_bit="0" name="INT_ENABLE_3">
                    <gui_name language="en">INT_ENABLE_3</gui_name>
                    <description language="en">Interrupt enable for bank 3
0 = no change
1 = clear interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register access="Write Only" name="GPIO_INT_DIS_3" offset="0xe000a2d4" size="0x4">
                <gui_name language="en">INT_DIS_3</gui_name>
                <description language="en">Interrupt Disable configuration register: Sets the interrupt mask for bank 3</description>
                <bitField access="Write Only" enumerationId="INT_DIS_3_INT_DISABLE_3_ENUM" high_bit="31" low_bit="0" name="INT_DISABLE_3">
                    <gui_name language="en">INT_DISABLE_3</gui_name>
                    <description language="en">Interrupt disable for bank 3
0 = no change
1 = set interrupt mask
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_STAT_3" offset="0xe000a2d8" size="0x4">
                <gui_name language="en">INT_STAT_3</gui_name>
                <description language="en">Interrupt Status register: Reports the interrupt status for bank 3</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="INT_STATUS_3">
                    <gui_name language="en">INT_STATUS_3</gui_name>
                    <description language="en">Interrupt status for bank 3
Upon read:
0 = no interrupt
1 = interrupt event has occurred
Upon write:
0 = no action
1 = clear interrupt status bit
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_TYPE_3" offset="0xe000a2dc" size="0x4">
                <gui_name language="en">INT_TYPE_3</gui_name>
                <description language="en">Interrupt Type configuration register: Configures the interrupt type for bank 3</description>
                <bitField access="Read Write" enumerationId="INT_TYPE_3_INT_TYPE_3_ENUM" high_bit="31" low_bit="0" name="INT_TYPE_3">
                    <gui_name language="en">INT_TYPE_3</gui_name>
                    <description language="en">Interrupt type for bank 3
0 = level-sensitive
1 = edge-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_POLARITY_3" offset="0xe000a2e0" size="0x4">
                <gui_name language="en">INT_POLARITY_3</gui_name>
                <description language="en">Interrupt polarity configuration register: Configures the interrupt polarity for bank 3</description>
                <bitField access="Read Write" enumerationId="INT_POLARITY_3_INT_POL_3_ENUM" high_bit="31" low_bit="0" name="INT_POL_3">
                    <gui_name language="en">INT_POL_3</gui_name>
                    <description language="en">Interrupt polarity for bank 3
0 = active low or falling edge
1 = active high or rising edge
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
            <register name="GPIO_INT_ANY_3" offset="0xe000a2e4" size="0x4">
                <gui_name language="en">INT_ANY_3</gui_name>
                <description language="en">Interrupt On Any configuration register: Configures the interrupt to trigger on any edge for bank 3</description>
                <bitField access="Read Write" enumerationId="INT_ANY_3_INT_ON_ANY_3_ENUM" high_bit="31" low_bit="0" name="INT_ON_ANY_3">
                    <gui_name language="en">INT_ON_ANY_3</gui_name>
                    <description language="en">Interrupt edge triggering mode for bank 3
0 = trigger on single edge, using configured interrupt polarity
1 = trigger on both edges
This value is ignored if corresponding interrupt source is configured to be level-sensitive
Each bit configures the corresponding pin within the 32-bit bank</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_GPV_QOS301_CPU" name="GPV_QOS301_CPU" offset="0xf8946000">
            <gui_name language="en">gpv_qos301_cpu</gui_name>
            <description language="en">gpv_qos301_cpu</description>
            <register name="GPV_QOS301_CPU_QOS_CNTL" offset="0xf894610c" size="0x4">
                <gui_name language="en">qos_cntl</gui_name>
                <description language="en">The QoS control register contains the enable bits for all the regulators.</description>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="en_awar_ot">
                    <gui_name language="en">en_awar_ot</gui_name>
                    <description language="en">Enable combined regulation of outstanding transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="en_ar_ot">
                    <gui_name language="en">en_ar_ot</gui_name>
                    <description language="en">Enable regulation of outstanding read transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="en_aw_ot">
                    <gui_name language="en">en_aw_ot</gui_name>
                    <description language="en">Enable regulation of outstanding write transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="en_awar_rate">
                    <gui_name language="en">en_awar_rate</gui_name>
                    <description language="en">Enable combined AW/AR rate regulation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="en_ar_rate">
                    <gui_name language="en">en_ar_rate</gui_name>
                    <description language="en">Enable AR rate regulation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="en_aw_rate">
                    <gui_name language="en">en_aw_rate</gui_name>
                    <description language="en">Enable AW rate regulation.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_MAX_OT" offset="0xf8946110" size="0x4">
                <gui_name language="en">max_ot</gui_name>
                <description language="en">Maximum number of outstanding transactions</description>
                <bitField access="Read Write" high_bit="29" low_bit="24" name="ar_max_oti">
                    <gui_name language="en">ar_max_oti</gui_name>
                    <description language="en">Integer part of max outstanding AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ar_max_otf">
                    <gui_name language="en">ar_max_otf</gui_name>
                    <description language="en">Fraction part of max outstanding AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="aw_max_oti">
                    <gui_name language="en">aw_max_oti</gui_name>
                    <description language="en">Integer part of max outstanding AW addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="aw_max_otf">
                    <gui_name language="en">aw_max_otf</gui_name>
                    <description language="en">Fraction part of max outstanding AW addresses.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_MAX_COMB_OT" offset="0xf8946114" size="0x4">
                <gui_name language="en">max_comb_ot</gui_name>
                <description language="en">Maximum number of combined outstanding transactions</description>
                <bitField access="Read Write" high_bit="14" low_bit="8" name="awar_max_oti">
                    <gui_name language="en">awar_max_oti</gui_name>
                    <description language="en">Integer part of max combined outstanding AW/AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="awar_max_otf">
                    <gui_name language="en">awar_max_otf</gui_name>
                    <description language="en">Fraction part of max combined outstanding AW/AR addresses.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_AW_P" offset="0xf8946118" size="0x4">
                <gui_name language="en">aw_p</gui_name>
                <description language="en">AW channel peak rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel peak rate. 8-bit fraction of the number of transfers per cycle. A value of 0x80 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x40 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_AW_B" offset="0xf894611c" size="0x4">
                <gui_name language="en">aw_b</gui_name>
                <description language="en">AW channel burstiness allowance</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel burstiness (integer number of transfers)</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_AW_R" offset="0xf8946120" size="0x4">
                <gui_name language="en">aw_r</gui_name>
                <description language="en">AW channel average rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="20" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel average rate. 12-bit fraction of the number of transfers per cycle. A value of 0x800 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x400 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_AR_P" offset="0xf8946124" size="0x4">
                <gui_name language="en">ar_p</gui_name>
                <description language="en">AR channel peak rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel peak rate. 8-bit fraction of the number of transfers per cycle. A value of 0x80 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x40 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_AR_B" offset="0xf8946128" size="0x4">
                <gui_name language="en">ar_b</gui_name>
                <description language="en">AR channel burstiness allowance</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel burstiness (integer number of transfers)</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_CPU_AR_R" offset="0xf894612c" size="0x4">
                <gui_name language="en">ar_r</gui_name>
                <description language="en">AR channel average rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="20" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel average rate. 12-bit fraction of the number of transfers per cycle. A value of 0x800 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x400 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_GPV_QOS301_DMAC" name="GPV_QOS301_DMAC" offset="0xf8947000">
            <gui_name language="en">gpv_qos301_dmac</gui_name>
            <description language="en">gpv_qos301_dmac</description>
            <register name="GPV_QOS301_DMAC_QOS_CNTL" offset="0xf894710c" size="0x4">
                <gui_name language="en">qos_cntl</gui_name>
                <description language="en">The QoS control register contains the enable bits for all the regulators.</description>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="en_awar_ot">
                    <gui_name language="en">en_awar_ot</gui_name>
                    <description language="en">Enable combined regulation of outstanding transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="en_ar_ot">
                    <gui_name language="en">en_ar_ot</gui_name>
                    <description language="en">Enable regulation of outstanding read transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="en_aw_ot">
                    <gui_name language="en">en_aw_ot</gui_name>
                    <description language="en">Enable regulation of outstanding write transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="en_awar_rate">
                    <gui_name language="en">en_awar_rate</gui_name>
                    <description language="en">Enable combined AW/AR rate regulation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="en_ar_rate">
                    <gui_name language="en">en_ar_rate</gui_name>
                    <description language="en">Enable AR rate regulation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="en_aw_rate">
                    <gui_name language="en">en_aw_rate</gui_name>
                    <description language="en">Enable AW rate regulation.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_MAX_OT" offset="0xf8947110" size="0x4">
                <gui_name language="en">max_ot</gui_name>
                <description language="en">Maximum number of outstanding transactions</description>
                <bitField access="Read Write" high_bit="29" low_bit="24" name="ar_max_oti">
                    <gui_name language="en">ar_max_oti</gui_name>
                    <description language="en">Integer part of max outstanding AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ar_max_otf">
                    <gui_name language="en">ar_max_otf</gui_name>
                    <description language="en">Fraction part of max outstanding AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="aw_max_oti">
                    <gui_name language="en">aw_max_oti</gui_name>
                    <description language="en">Integer part of max outstanding AW addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="aw_max_otf">
                    <gui_name language="en">aw_max_otf</gui_name>
                    <description language="en">Fraction part of max outstanding AW addresses.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_MAX_COMB_OT" offset="0xf8947114" size="0x4">
                <gui_name language="en">max_comb_ot</gui_name>
                <description language="en">Maximum number of combined outstanding transactions</description>
                <bitField access="Read Write" high_bit="14" low_bit="8" name="awar_max_oti">
                    <gui_name language="en">awar_max_oti</gui_name>
                    <description language="en">Integer part of max combined outstanding AW/AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="awar_max_otf">
                    <gui_name language="en">awar_max_otf</gui_name>
                    <description language="en">Fraction part of max combined outstanding AW/AR addresses.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_AW_P" offset="0xf8947118" size="0x4">
                <gui_name language="en">aw_p</gui_name>
                <description language="en">AW channel peak rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel peak rate. 8-bit fraction of the number of transfers per cycle. A value of 0x80 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x40 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_AW_B" offset="0xf894711c" size="0x4">
                <gui_name language="en">aw_b</gui_name>
                <description language="en">AW channel burstiness allowance</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel burstiness (integer number of transfers)</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_AW_R" offset="0xf8947120" size="0x4">
                <gui_name language="en">aw_r</gui_name>
                <description language="en">AW channel average rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="20" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel average rate. 12-bit fraction of the number of transfers per cycle. A value of 0x800 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x400 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_AR_P" offset="0xf8947124" size="0x4">
                <gui_name language="en">ar_p</gui_name>
                <description language="en">AR channel peak rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel peak rate. 8-bit fraction of the number of transfers per cycle. A value of 0x80 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x40 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_AR_B" offset="0xf8947128" size="0x4">
                <gui_name language="en">ar_b</gui_name>
                <description language="en">AR channel burstiness allowance</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel burstiness (integer number of transfers)</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_DMAC_AR_R" offset="0xf894712c" size="0x4">
                <gui_name language="en">ar_r</gui_name>
                <description language="en">AR channel average rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="20" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel average rate. 12-bit fraction of the number of transfers per cycle. A value of 0x800 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x400 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_GPV_QOS301_IOU" name="GPV_QOS301_IOU" offset="0xf8948000">
            <gui_name language="en">gpv_qos301_iou</gui_name>
            <description language="en">gpv_qos301_iou</description>
            <register name="GPV_QOS301_IOU_QOS_CNTL" offset="0xf894810c" size="0x4">
                <gui_name language="en">qos_cntl</gui_name>
                <description language="en">The QoS control register contains the enable bits for all the regulators.</description>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="en_awar_ot">
                    <gui_name language="en">en_awar_ot</gui_name>
                    <description language="en">Enable combined regulation of outstanding transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="en_ar_ot">
                    <gui_name language="en">en_ar_ot</gui_name>
                    <description language="en">Enable regulation of outstanding read transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="en_aw_ot">
                    <gui_name language="en">en_aw_ot</gui_name>
                    <description language="en">Enable regulation of outstanding write transactions.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="en_awar_rate">
                    <gui_name language="en">en_awar_rate</gui_name>
                    <description language="en">Enable combined AW/AR rate regulation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="en_ar_rate">
                    <gui_name language="en">en_ar_rate</gui_name>
                    <description language="en">Enable AR rate regulation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="en_aw_rate">
                    <gui_name language="en">en_aw_rate</gui_name>
                    <description language="en">Enable AW rate regulation.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_MAX_OT" offset="0xf8948110" size="0x4">
                <gui_name language="en">max_ot</gui_name>
                <description language="en">Maximum number of outstanding transactions</description>
                <bitField access="Read Write" high_bit="29" low_bit="24" name="ar_max_oti">
                    <gui_name language="en">ar_max_oti</gui_name>
                    <description language="en">Integer part of max outstanding AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ar_max_otf">
                    <gui_name language="en">ar_max_otf</gui_name>
                    <description language="en">Fraction part of max outstanding AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="aw_max_oti">
                    <gui_name language="en">aw_max_oti</gui_name>
                    <description language="en">Integer part of max outstanding AW addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="aw_max_otf">
                    <gui_name language="en">aw_max_otf</gui_name>
                    <description language="en">Fraction part of max outstanding AW addresses.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_MAX_COMB_OT" offset="0xf8948114" size="0x4">
                <gui_name language="en">max_comb_ot</gui_name>
                <description language="en">Maximum number of combined outstanding transactions</description>
                <bitField access="Read Write" high_bit="14" low_bit="8" name="awar_max_oti">
                    <gui_name language="en">awar_max_oti</gui_name>
                    <description language="en">Integer part of max combined outstanding AW/AR addresses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="awar_max_otf">
                    <gui_name language="en">awar_max_otf</gui_name>
                    <description language="en">Fraction part of max combined outstanding AW/AR addresses.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_AW_P" offset="0xf8948118" size="0x4">
                <gui_name language="en">aw_p</gui_name>
                <description language="en">AW channel peak rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel peak rate. 8-bit fraction of the number of transfers per cycle. A value of 0x80 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x40 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_AW_B" offset="0xf894811c" size="0x4">
                <gui_name language="en">aw_b</gui_name>
                <description language="en">AW channel burstiness allowance</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel burstiness (integer number of transfers)</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_AW_R" offset="0xf8948120" size="0x4">
                <gui_name language="en">aw_r</gui_name>
                <description language="en">AW channel average rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="20" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel average rate. 12-bit fraction of the number of transfers per cycle. A value of 0x800 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x400 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_AR_P" offset="0xf8948124" size="0x4">
                <gui_name language="en">ar_p</gui_name>
                <description language="en">AR channel peak rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel peak rate. 8-bit fraction of the number of transfers per cycle. A value of 0x80 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x40 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_AR_B" offset="0xf8948128" size="0x4">
                <gui_name language="en">ar_b</gui_name>
                <description language="en">AR channel burstiness allowance</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel burstiness (integer number of transfers)</description>
                </bitField>
            </register>
            <register name="GPV_QOS301_IOU_AR_R" offset="0xf894812c" size="0x4">
                <gui_name language="en">ar_r</gui_name>
                <description language="en">AR channel average rate</description>
                <bitField access="Read Write" high_bit="31" low_bit="20" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">channel average rate. 12-bit fraction of the number of transfers per cycle. A value of 0x800 (decimal 0.5) sets a rate of one transaction every 2 cycles. A value of 0x400 sets a rate of one transaction every 4 cycles, etc.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_I2C0" name="I2C0" offset="0xe0004000">
            <gui_name language="en">i2c0</gui_name>
            <description language="en">i2c0</description>
            <register name="I2C0_CONTROL_REG0" offset="0xe0004000" size="0x2">
                <gui_name language="en">Control_reg0</gui_name>
                <description language="en">Control Register</description>
                <bitField access="Read Write" enumerationId="Control_reg0_divisor_a_ENUM" high_bit="15" low_bit="14" name="divisor_a">
                    <gui_name language="en">divisor_a</gui_name>
                    <description language="en">Divisor for stage A clock divider.
0 - 3: Divides the input pclk frequency by divisor_a + 1.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_divisor_b_ENUM" high_bit="13" low_bit="8" name="divisor_b">
                    <gui_name language="en">divisor_b</gui_name>
                    <description language="en">Divisor for stage B clock divider.
0 -31 : Divides the output frequency from divisor_a by divisor_b + 1.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_CLR_FIFO_ENUM" high_bit="6" low_bit="6" name="CLR_FIFO">
                    <gui_name language="en">CLR_FIFO</gui_name>
                    <description language="en">clear_fifo:This bit is implemented only if FIFO is implemented.
1 - initializes the FIFO to all zeros and clears the transfer size register. Automatically gets cleared on the next APB clock after
being set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_SLVMON_ENUM" high_bit="5" low_bit="5" name="SLVMON">
                    <gui_name language="en">SLVMON</gui_name>
                    <description language="en">Slave monitor mode
1 - monitor mode.
0 - normal operation.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_HOLD_ENUM" high_bit="4" low_bit="4" name="HOLD">
                    <gui_name language="en">HOLD</gui_name>
                    <description language="en">hold_bus
1 - when no more data is available for transmit or no more data can be received, hold the sclk line low until serviced by the host.
0 - allow the transfer to terminate as soon as all the data has been transmitted or received.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_ACKEN_ENUM" high_bit="3" low_bit="3" name="ACKEN">
                    <gui_name language="en">ACKEN</gui_name>
                    <description language="en">ackn_enabled: This bit must always be set if FIFO is implemented.
1 - acknowledge enabled, ACK transmitted
0 - acknowledge disabled, NACK transmitted.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_NEA_ENUM" high_bit="2" low_bit="2" name="NEA">
                    <gui_name language="en">NEA</gui_name>
                    <description language="en">Addressing mode: This bit is used in master
mode only.
1 - normal (7-bit) address
0 - reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_MS_ENUM" high_bit="1" low_bit="1" name="MS">
                    <gui_name language="en">MS</gui_name>
                    <description language="en">Overall interface mode:
1 - master
0 - slave</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_RW_ENUM" high_bit="0" low_bit="0" name="RW">
                    <gui_name language="en">RW</gui_name>
                    <description language="en">Direction of transfer:
This bit is used in master mode only.
1 - master receiver
0 - master transmitter.</description>
                </bitField>
            </register>
            <register access="Read Only" name="I2C0_STATUS_REG0" offset="0xe0004004" size="0x2">
                <gui_name language="en">Status_reg0</gui_name>
                <description language="en">Stauts register</description>
                <bitField access="Read Only" enumerationId="Status_reg0_BA_ENUM" high_bit="8" low_bit="8" name="BA">
                    <gui_name language="en">BA</gui_name>
                    <description language="en">Bus Active
1 - ongoing transfer on the I2C bus.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_RXOVF_ENUM" high_bit="7" low_bit="7" name="RXOVF">
                    <gui_name language="en">RXOVF</gui_name>
                    <description language="en">Receiver Overflow
1 - when the receiver receives a byte of data before the previous byte has been read by the host.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_TXDV_ENUM" high_bit="6" low_bit="6" name="TXDV">
                    <gui_name language="en">TXDV</gui_name>
                    <description language="en">Transmit Data Valid - SW should not use this to determine data completion, it is the RAW value on the interface.
Please use COMP in the ISR.
1 - still a byte of data to be transmitted by the interface.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_RXDV_ENUM" high_bit="5" low_bit="5" name="RXDV">
                    <gui_name language="en">RXDV</gui_name>
                    <description language="en">Receiver Data Valid
1 -valid, new data to be read from the interface.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_RXRW_ENUM" high_bit="3" low_bit="3" name="RXRW">
                    <gui_name language="en">RXRW</gui_name>
                    <description language="en">RX read_write
1 - mode of the transmission received from a master.</description>
                </bitField>
            </register>
            <register name="I2C0_I2C_ADDRESS_REG0" offset="0xe0004008" size="0x2">
                <gui_name language="en">I2C_address_reg0</gui_name>
                <description language="en">IIC Address register</description>
                <bitField access="Read Write" enumerationId="I2C_address_reg0_ADD_ENUM" high_bit="9" low_bit="0" name="ADD">
                    <gui_name language="en">ADD</gui_name>
                    <description language="en">Address
0 - 1024: Normal addressing mode uses add[6:0]. Extended addressing mode uses add[9:0].</description>
                </bitField>
            </register>
            <register name="I2C0_I2C_DATA_REG0" offset="0xe000400c" size="0x2">
                <gui_name language="en">I2C_data_reg0</gui_name>
                <description language="en">IIC data register</description>
                <bitField access="Read Write" enumerationId="I2C_data_reg0_DATA_ENUM" high_bit="7" low_bit="0" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">data
0 -255: When written to, the data register sets data to transmit. When read from, the data register</description>
                </bitField>
            </register>
            <register name="I2C0_INTERRUPT_STATUS_REG0" offset="0xe0004010" size="0x2">
                <gui_name language="en">Interrupt_status_reg0</gui_name>
                <description language="en">IIC interrupt status register</description>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = master loses bus ownership during a transfer due to ongoing arbitration</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = host attempts to read from the I2C data register more times than the value of the transfer size register plus one</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = host attempts to write to the I2C data register more times than the FIFO depth</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 =
transfer is complete</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 =
addressed slave returns ACK.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 =
I2C sclk line is kept low for longer time</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = slave responds with a NACK or master terminates the transfer before all data is supplied</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">More data
1 =
Data being sent or received</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
1 =
transfer is complete</description>
                </bitField>
            </register>
            <register name="I2C0_TRANSFER_SIZE_REG0" offset="0xe0004014" size="0x2">
                <gui_name language="en">Transfer_size_reg0</gui_name>
                <description language="en">Transfer Size Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="Transfer_Size">
                    <gui_name language="en">Transfer_Size</gui_name>
                    <description language="en">Transfer Size
0-255: Master transmitter mode, Master receiver mode,
Slave transmitter mode, Slave receiver mode.</description>
                </bitField>
            </register>
            <register name="I2C0_SLAVE_MON_PAUSE_REG0" offset="0xe0004018" size="0x2">
                <gui_name language="en">Slave_mon_pause_reg0</gui_name>
                <description language="en">Slave Monitor Pause Register</description>
                <bitField access="Read Write" enumerationId="Slave_mon_pause_reg0_Pause_ENUM" high_bit="3" low_bit="0" name="Pause">
                    <gui_name language="en">Pause</gui_name>
                    <description language="en">pause interval
0 - 7: pause interval</description>
                </bitField>
            </register>
            <register name="I2C0_TIME_OUT_REG0" offset="0xe000401c" size="0x2">
                <gui_name language="en">Time_out_reg0</gui_name>
                <description language="en">Time out register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Time Out
127 - 32 : value of time out register</description>
                </bitField>
            </register>
            <register access="Read Only" name="I2C0_INTRPT_MASK_REG0" offset="0xe0004020" size="0x2">
                <gui_name language="en">Intrpt_mask_reg0</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">More data
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
            </register>
            <register name="I2C0_INTRPT_ENABLE_REG0" offset="0xe0004024" size="0x2">
                <gui_name language="en">Intrpt_enable_reg0</gui_name>
                <description language="en">Interrupt Enable Register</description>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">More data
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
Will be set when transfer is complete
1 = enable this interrupt</description>
                </bitField>
            </register>
            <register name="I2C0_INTRPT_DISABLE_REG0" offset="0xe0004028" size="0x2">
                <gui_name language="en">Intrpt_disable_reg0</gui_name>
                <description language="en">Interrupt Disable Register</description>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">Master Write or Slave Transmitter
Master Read or Slave Receiver
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
Will be set when transfer is complete
1 = disable this interrupt</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_I2C1" name="I2C1" offset="0xe0005000">
            <gui_name language="en">i2c1</gui_name>
            <description language="en">i2c1</description>
            <register name="I2C1_CONTROL_REG0" offset="0xe0005000" size="0x2">
                <gui_name language="en">Control_reg0</gui_name>
                <description language="en">Control Register</description>
                <bitField access="Read Write" enumerationId="Control_reg0_divisor_a_ENUM" high_bit="15" low_bit="14" name="divisor_a">
                    <gui_name language="en">divisor_a</gui_name>
                    <description language="en">Divisor for stage A clock divider.
0 - 3: Divides the input pclk frequency by divisor_a + 1.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_divisor_b_ENUM" high_bit="13" low_bit="8" name="divisor_b">
                    <gui_name language="en">divisor_b</gui_name>
                    <description language="en">Divisor for stage B clock divider.
0 -31 : Divides the output frequency from divisor_a by divisor_b + 1.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_CLR_FIFO_ENUM" high_bit="6" low_bit="6" name="CLR_FIFO">
                    <gui_name language="en">CLR_FIFO</gui_name>
                    <description language="en">clear_fifo:This bit is implemented only if FIFO is implemented.
1 - initializes the FIFO to all zeros and clears the transfer size register. Automatically gets cleared on the next APB clock after
being set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_SLVMON_ENUM" high_bit="5" low_bit="5" name="SLVMON">
                    <gui_name language="en">SLVMON</gui_name>
                    <description language="en">Slave monitor mode
1 - monitor mode.
0 - normal operation.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_HOLD_ENUM" high_bit="4" low_bit="4" name="HOLD">
                    <gui_name language="en">HOLD</gui_name>
                    <description language="en">hold_bus
1 - when no more data is available for transmit or no more data can be received, hold the sclk line low until serviced by the host.
0 - allow the transfer to terminate as soon as all the data has been transmitted or received.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_ACKEN_ENUM" high_bit="3" low_bit="3" name="ACKEN">
                    <gui_name language="en">ACKEN</gui_name>
                    <description language="en">ackn_enabled: This bit must always be set if FIFO is implemented.
1 - acknowledge enabled, ACK transmitted
0 - acknowledge disabled, NACK transmitted.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_NEA_ENUM" high_bit="2" low_bit="2" name="NEA">
                    <gui_name language="en">NEA</gui_name>
                    <description language="en">Addressing mode: This bit is used in master
mode only.
1 - normal (7-bit) address
0 - reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_MS_ENUM" high_bit="1" low_bit="1" name="MS">
                    <gui_name language="en">MS</gui_name>
                    <description language="en">Overall interface mode:
1 - master
0 - slave</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_RW_ENUM" high_bit="0" low_bit="0" name="RW">
                    <gui_name language="en">RW</gui_name>
                    <description language="en">Direction of transfer:
This bit is used in master mode only.
1 - master receiver
0 - master transmitter.</description>
                </bitField>
            </register>
            <register access="Read Only" name="I2C1_STATUS_REG0" offset="0xe0005004" size="0x2">
                <gui_name language="en">Status_reg0</gui_name>
                <description language="en">Stauts register</description>
                <bitField access="Read Only" enumerationId="Status_reg0_BA_ENUM" high_bit="8" low_bit="8" name="BA">
                    <gui_name language="en">BA</gui_name>
                    <description language="en">Bus Active
1 - ongoing transfer on the I2C bus.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_RXOVF_ENUM" high_bit="7" low_bit="7" name="RXOVF">
                    <gui_name language="en">RXOVF</gui_name>
                    <description language="en">Receiver Overflow
1 - when the receiver receives a byte of data before the previous byte has been read by the host.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_TXDV_ENUM" high_bit="6" low_bit="6" name="TXDV">
                    <gui_name language="en">TXDV</gui_name>
                    <description language="en">Transmit Data Valid - SW should not use this to determine data completion, it is the RAW value on the interface.
Please use COMP in the ISR.
1 - still a byte of data to be transmitted by the interface.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_RXDV_ENUM" high_bit="5" low_bit="5" name="RXDV">
                    <gui_name language="en">RXDV</gui_name>
                    <description language="en">Receiver Data Valid
1 -valid, new data to be read from the interface.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Status_reg0_RXRW_ENUM" high_bit="3" low_bit="3" name="RXRW">
                    <gui_name language="en">RXRW</gui_name>
                    <description language="en">RX read_write
1 - mode of the transmission received from a master.</description>
                </bitField>
            </register>
            <register name="I2C1_I2C_ADDRESS_REG0" offset="0xe0005008" size="0x2">
                <gui_name language="en">I2C_address_reg0</gui_name>
                <description language="en">IIC Address register</description>
                <bitField access="Read Write" enumerationId="I2C_address_reg0_ADD_ENUM" high_bit="9" low_bit="0" name="ADD">
                    <gui_name language="en">ADD</gui_name>
                    <description language="en">Address
0 - 1024: Normal addressing mode uses add[6:0]. Extended addressing mode uses add[9:0].</description>
                </bitField>
            </register>
            <register name="I2C1_I2C_DATA_REG0" offset="0xe000500c" size="0x2">
                <gui_name language="en">I2C_data_reg0</gui_name>
                <description language="en">IIC data register</description>
                <bitField access="Read Write" enumerationId="I2C_data_reg0_DATA_ENUM" high_bit="7" low_bit="0" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">data
0 -255: When written to, the data register sets data to transmit. When read from, the data register</description>
                </bitField>
            </register>
            <register name="I2C1_INTERRUPT_STATUS_REG0" offset="0xe0005010" size="0x2">
                <gui_name language="en">Interrupt_status_reg0</gui_name>
                <description language="en">IIC interrupt status register</description>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = master loses bus ownership during a transfer due to ongoing arbitration</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = host attempts to read from the I2C data register more times than the value of the transfer size register plus one</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = host attempts to write to the I2C data register more times than the FIFO depth</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 =
transfer is complete</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 =
addressed slave returns ACK.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 =
I2C sclk line is kept low for longer time</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = slave responds with a NACK or master terminates the transfer before all data is supplied</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">More data
1 =
Data being sent or received</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Interrupt_status_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
1 =
transfer is complete</description>
                </bitField>
            </register>
            <register name="I2C1_TRANSFER_SIZE_REG0" offset="0xe0005014" size="0x2">
                <gui_name language="en">Transfer_size_reg0</gui_name>
                <description language="en">Transfer Size Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="Transfer_Size">
                    <gui_name language="en">Transfer_Size</gui_name>
                    <description language="en">Transfer Size
0-255: Master transmitter mode, Master receiver mode,
Slave transmitter mode, Slave receiver mode.</description>
                </bitField>
            </register>
            <register name="I2C1_SLAVE_MON_PAUSE_REG0" offset="0xe0005018" size="0x2">
                <gui_name language="en">Slave_mon_pause_reg0</gui_name>
                <description language="en">Slave Monitor Pause Register</description>
                <bitField access="Read Write" enumerationId="Slave_mon_pause_reg0_Pause_ENUM" high_bit="3" low_bit="0" name="Pause">
                    <gui_name language="en">Pause</gui_name>
                    <description language="en">pause interval
0 - 7: pause interval</description>
                </bitField>
            </register>
            <register name="I2C1_TIME_OUT_REG0" offset="0xe000501c" size="0x2">
                <gui_name language="en">Time_out_reg0</gui_name>
                <description language="en">Time out register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Time Out
127 - 32 : value of time out register</description>
                </bitField>
            </register>
            <register access="Read Only" name="I2C1_INTRPT_MASK_REG0" offset="0xe0005020" size="0x2">
                <gui_name language="en">Intrpt_mask_reg0</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">More data
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
1 = Mask this interrupt
0 = unmask this interrupt</description>
                </bitField>
            </register>
            <register name="I2C1_INTRPT_ENABLE_REG0" offset="0xe0005024" size="0x2">
                <gui_name language="en">Intrpt_enable_reg0</gui_name>
                <description language="en">Interrupt Enable Register</description>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">More data
1 = enable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_enable_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
Will be set when transfer is complete
1 = enable this interrupt</description>
                </bitField>
            </register>
            <register name="I2C1_INTRPT_DISABLE_REG0" offset="0xe0005028" size="0x2">
                <gui_name language="en">Intrpt_disable_reg0</gui_name>
                <description language="en">Interrupt Disable Register</description>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_ARB_LOST_ENUM" high_bit="9" low_bit="9" name="ARB_LOST">
                    <gui_name language="en">ARB_LOST</gui_name>
                    <description language="en">arbitration lost
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_RX_UNF_ENUM" high_bit="7" low_bit="7" name="RX_UNF">
                    <gui_name language="en">RX_UNF</gui_name>
                    <description language="en">FIFO receive underflow
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_TX_OVF_ENUM" high_bit="6" low_bit="6" name="TX_OVF">
                    <gui_name language="en">TX_OVF</gui_name>
                    <description language="en">FIFO transmit overflow
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_RX_OVF_ENUM" high_bit="5" low_bit="5" name="RX_OVF">
                    <gui_name language="en">RX_OVF</gui_name>
                    <description language="en">Receive overflow
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_SLV_RDY_ENUM" high_bit="4" low_bit="4" name="SLV_RDY">
                    <gui_name language="en">SLV_RDY</gui_name>
                    <description language="en">Monitored slave ready
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_TO_ENUM" high_bit="3" low_bit="3" name="TO">
                    <gui_name language="en">TO</gui_name>
                    <description language="en">Transfer time out
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_NACK_ENUM" high_bit="2" low_bit="2" name="NACK">
                    <gui_name language="en">NACK</gui_name>
                    <description language="en">Transfer not acknowledged
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_DATA_ENUM" high_bit="1" low_bit="1" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">Master Write or Slave Transmitter
Master Read or Slave Receiver
1 = disable this interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_disable_reg0_COMP_ENUM" high_bit="0" low_bit="0" name="COMP">
                    <gui_name language="en">COMP</gui_name>
                    <description language="en">Transfer complete
Will be set when transfer is complete
1 = disable this interrupt</description>
                </bitField>
            </register>
        </peripheral>

        <peripheral address_type="Non-Secure" base_addr="M_OCM" name="OCM" offset="0xf800c000">
            <gui_name language="en">ocm</gui_name>
            <description language="en">ocm</description>
            <register name="OCM_OCM_PARITY_CTRL" offset="0xf800c000" size="0x4">
                <gui_name language="en">OCM_PARITY_CTRL</gui_name>
                <description language="en">Control fields for RAM parity operation</description>
                <bitField access="Read Write" enumerationId="OCM_PARITY_CTRL_OddParityEn_ENUM" high_bit="20" low_bit="5" name="OddParityEn">
                    <gui_name language="en">OddParityEn</gui_name>
                    <description language="en">Enable RAM Odd Parity Generation. One control bit per data byte (OddParity[0] controls Data[7:0] e.t.c)
0 - Even Parity generated
1 - Odd
Parity generated</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="LockFailErrIrqEn">
                    <gui_name language="en">LockFailErrIrqEn</gui_name>
                    <description language="en">Enable interrupt when
an AXI LOCK ("locked access") command is detected.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OCM_PARITY_CTRL_MultipleParityErrIrqEn_ENUM" high_bit="3" low_bit="3" name="MultipleParityErrIrqEn">
                    <gui_name language="en">MultipleParityErrIrqEn</gui_name>
                    <description language="en">Same as SingleParityErrIrqEn, but enables IRQ on multiple parity errors detected.
0 - IRQ is not generated when parity error detected and ParityCheckDis=0
1 - IRQ is generated when parity error detected and ParityCheckDis=0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OCM_PARITY_CTRL_SingleParityErrIrqEn_ENUM" high_bit="2" low_bit="2" name="SingleParityErrIrqEn">
                    <gui_name language="en">SingleParityErrIrqEn</gui_name>
                    <description language="en">Enable interrupt when a single parity error is detected. Note that even if this field is 0, the OCM_IRQ_STS register will still log the error if 
ParityCheckDis=0. This allows software the option of polling if an error occurred.
0 - IRQ is not generated when parity error detected and ParityCheckDis=0
1 - IRQ is generated when parity error detected and ParityCheckDis=0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OCM_PARITY_CTRL_RdRespParityErrEn_ENUM" high_bit="1" low_bit="1" name="RdRespParityErrEn">
                    <gui_name language="en">RdRespParityErrEn</gui_name>
                    <description language="en">Enable AXI read 'SLVERR' response for parity error detection.
0 - Error will not be sent on AXI read channel when parity error detected
1 - Error will be sent on AXI read channel when parity error detected and ParityCheckDis=0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OCM_PARITY_CTRL_ParityCheckDis_ENUM" high_bit="0" low_bit="0" name="ParityCheckDis">
                    <gui_name language="en">ParityCheckDis</gui_name>
                    <description language="en">Disable RAM Parity Checking. No checking or logging of status will occur when 1.
0 - RAM Parity checking is enabled
1 - RAM Parity checking is disabled</description>
                </bitField>
            </register>
            <register name="OCM_OCM_PARITY_ERRADDRESS" offset="0xf800c004" size="0x4">
                <gui_name language="en">OCM_PARITY_ERRADDRESS</gui_name>
                <description language="en">Stores the first parity error access address. This register is sticky and will retain its value unless explicitly cleared (written with 1's) with an APB 
write access. The physical RAM address is logged.</description>
                <bitField access="Read Write" high_bit="13" low_bit="0" name="ParityErrAddress">
                    <gui_name language="en">ParityErrAddress</gui_name>
                    <description language="en">When a parity Error occurs, the access address associated with the error is logged here. The first error address will be held if multiple parity errors 
occur. Need an explicit write of all '1's' to reset/clear this field.</description>
                </bitField>
            </register>
            <register name="OCM_OCM_IRQ_STS" offset="0xf800c008" size="0x4">
                <gui_name language="en">OCM_IRQ_STS</gui_name>
                <description language="en">Status of OCM Interrupt</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="LockFailErr">
                    <gui_name language="en">LockFailErr</gui_name>
                    <description language="en">When set (1), indicates that an AXI LOCK has been attempted (not supported by OCM). This is a sticky bit. Once set it can only be cleared by explicitly 
writing a 1 to this field. This field drives the interrupt pin. (Associated irq enable bit must be set)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OCM_IRQ_STS_MultipleParityErr_ENUM" high_bit="1" low_bit="1" name="MultipleParityErr">
                    <gui_name language="en">MultipleParityErr</gui_name>
                    <description language="en">Status of OCM multiple parity error. This is a sticky bit. Once set it can only be cleared by explicitly writing a 1 to this field. This field drives the 
interrupt pin. (Associated irq enable bit must be set)
0 - Multiple OCM parity Errors have not occurred
1 - Multiple OCM parity Errors have occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OCM_IRQ_STS_SingleParityErr_ENUM" high_bit="0" low_bit="0" name="SingleParityErr">
                    <gui_name language="en">SingleParityErr</gui_name>
                    <description language="en">Status of OCM single parity error. This is a sticky bit. Once set it can only be cleared by explicitly writing a 1 to this field. This field drives the 
interrupt pin (Associated irq enable bit must be set)
0 - Single OCM parity Error has not occurred
1 - Single OCM parity Error has occurred</description>
                </bitField>
            </register>
            <register name="OCM_OCM_CONTROL" offset="0xf800c00c" size="0x4">
                <gui_name language="en">OCM_CONTROL</gui_name>
                <description language="en">Control fields for OCM</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="DisableRom">
                    <gui_name language="en">DisableRom</gui_name>
                    <description language="en">When set (1), disables the ROM CEN signal. This is useful when the 2:1 clock ratio is used and the ROM clk exceeds its specifications</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="ScuWrPriorityLo">
                    <gui_name language="en">ScuWrPriorityLo</gui_name>
                    <description language="en">When set (1), changes the priority of the SCU write port to LOW from Medium</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_QSPI" name="QSPI" offset="0xe000d000">
            <gui_name language="en">qspi</gui_name>
            <description language="en">qspi</description>
            <register name="QSPI_CONFIG_REG" offset="0xe000d000" size="0x4">
                <gui_name language="en">Config_reg</gui_name>
                <description language="en">SPI configuration register</description>
                <bitField access="Read Write" enumerationId="Config_reg_leg_flsh_ENUM" high_bit="31" low_bit="31" name="leg_flsh">
                    <gui_name language="en">leg_flsh</gui_name>
                    <description language="en">Flash memory interface mode control:
0 = legacy SPI mode
1 = Flash memory interface mode
This control is required to enable or disable automatic recognition of instruction bytes in the first byte of a transfer.
If this mode is disabled, the core will operate in standard SPI mode, with no dual- or quad-bit input or output capability; the extended bits will be configured as inputs to prevent any driver contention on these pins.
If enabled, flash memory interface instructions are automatically recognized and the I/O configured accordingly.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_endian_ENUM" high_bit="26" low_bit="26" name="endian">
                    <gui_name language="en">endian</gui_name>
                    <description language="en">0 for little endian format when writing to the transmit data register 0x1C or reading from the receive data register 0x20.
1 for big endian format when writing to the transmit data register 0x1C or reading from the receive data register 0x20.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Config_reg_Man_start_com_ENUM" high_bit="16" low_bit="16" name="Man_start_com">
                    <gui_name language="en">Man_start_com</gui_name>
                    <description language="en">Manual Start Command
1 = start transmission of data
0 = don't care</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_Man_start_en_ENUM" high_bit="15" low_bit="15" name="Man_start_en">
                    <gui_name language="en">Man_start_en</gui_name>
                    <description language="en">Manual Start Enable
1 = enables maual start
0 = auto mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_Manual_CS_ENUM" high_bit="14" low_bit="14" name="Manual_CS">
                    <gui_name language="en">Manual_CS</gui_name>
                    <description language="en">Manual CS
1 = manual CS mode
0 = auto mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="PCS">
                    <gui_name language="en">PCS</gui_name>
                    <description language="en">Peripheral chip select line, directly drive n_ss_out if Manual_C is set</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_REF_CLK_ENUM" high_bit="8" low_bit="8" name="REF_CLK">
                    <gui_name language="en">REF_CLK</gui_name>
                    <description language="en">Master reference clock select
1 = use ext_clk
0 = use SPI REFERENCE CLOCK</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_FIFO_WIDTH_ENUM" high_bit="7" low_bit="6" name="FIFO_WIDTH">
                    <gui_name language="en">FIFO_WIDTH</gui_name>
                    <description language="en">FIFO width
00 = 8bits
01 = 16bits
10 = 24bits
11 = 32bits</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_BAUD_RATE_DIV_ENUM" high_bit="5" low_bit="3" name="BAUD_RATE_DIV">
                    <gui_name language="en">BAUD_RATE_DIV</gui_name>
                    <description language="en">Master mode baud rate divisor
000 = divide by 2
001 = divide by 4
010 = divide by 8
011 = divide by 16
100 = divide by 32
101 = divide by 64
110 = divide by 128
111 = divide by 256</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_CLK_PH_ENUM" high_bit="2" low_bit="2" name="CLK_PH">
                    <gui_name language="en">CLK_PH</gui_name>
                    <description language="en">Clock phase
1 = the SPI clock is inactive outside the word
0 = the SPI clock is active outside the word</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_CLK_POL_ENUM" high_bit="1" low_bit="1" name="CLK_POL">
                    <gui_name language="en">CLK_POL</gui_name>
                    <description language="en">Clock polarity outside SPI word
1 = the SPI clock is quiescent high
0 = the SPI clock is quiescent low</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg_MODE_SEL_ENUM" high_bit="0" low_bit="0" name="MODE_SEL">
                    <gui_name language="en">MODE_SEL</gui_name>
                    <description language="en">Mode select
1 = the SPI is in master mode
0 = the SPI is in slave mode</description>
                </bitField>
            </register>
            <register access="Read Only" name="QSPI_INTR_STATUS_REG" offset="0xe000d004" size="0x4">
                <gui_name language="en">Intr_status_REG</gui_name>
                <description language="en">SPI interrupt status register</description>
                <bitField access="Read Only" enumerationId="Intr_status_REG_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
1 = underflow is detected
0 = no underflow has been detected</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_REG_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
1 = FIFO is full
0 = FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_REG_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
1 = FIFO has more than or equal to THRESHOLD entries
0 = FIFO has less than RX THRESHOLD entries</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_REG_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
1 = FIFO is full
0 = FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_REG_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
1 = FIFO has less than THRESHOLD entries
0 = FIFO has more than or equal toTHRESHOLD entries</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_REG_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt
1 = overflow occured
0 = no overflow occurred</description>
                </bitField>
            </register>
            <register name="QSPI_INTRPT_EN_REG" offset="0xe000d008" size="0x4">
                <gui_name language="en">Intrpt_en_REG</gui_name>
                <description language="en">Interrupt Enable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_en_REG_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_REG_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_REG_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_REG_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_REG_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_REG_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
            </register>
            <register name="QSPI_INTRPT_DIS_REG" offset="0xe000d00c" size="0x4">
                <gui_name language="en">Intrpt_dis_REG</gui_name>
                <description language="en">Interrupt disable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_dis_REG_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_REG_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_REG_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_REG_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_REG_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_REG_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
            </register>
            <register access="Read Only" name="QSPI_INTRPT_MASK_REG" offset="0xe000d010" size="0x4">
                <gui_name language="en">Intrpt_mask_REG</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_REG_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_REG_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_REG_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_REG_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_REG_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_REG_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
            </register>
            <register name="QSPI_EN_REG" offset="0xe000d014" size="0x4">
                <gui_name language="en">En_REG</gui_name>
                <description language="en">SPI_Enable Register</description>
                <bitField access="Read Write" enumerationId="En_REG_SPI_EN_ENUM" high_bit="0" low_bit="0" name="SPI_EN">
                    <gui_name language="en">SPI_EN</gui_name>
                    <description language="en">SPI_Enable
1 = enable the SPI
0 = disable the SPI</description>
                </bitField>
            </register>
            <register name="QSPI_DELAY_REG" offset="0xe000d018" size="0x4">
                <gui_name language="en">Delay_REG</gui_name>
                <description language="en">Delay Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="d_nss">
                    <gui_name language="en">d_nss</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles
for the length that the master mode chip select outputs are de-asserted between words when cpha=0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="d_btwn">
                    <gui_name language="en">d_btwn</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles
between one chip select being de-activated and the
activation of another</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="d_after">
                    <gui_name language="en">d_after</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles between last bit of current word and the first bit of the next word.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="d_int">
                    <gui_name language="en">d_int</gui_name>
                    <description language="en">Added delay in SPI REFERENCE CLOCK or ext_clk
cycles between setting n_ss_out low and first bit
transfer.</description>
                </bitField>
            </register>
            <register access="Write Only" name="QSPI_TXD0" offset="0xe000d01c" size="0x4">
                <gui_name language="en">TXD0</gui_name>
                <description language="en">Transmit Data Register. Keyhole addresses for the Transmit data FIFO. See also TXD1-3.</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">Data to TX FIFO, for 4-byte instruction for normal read/write data transfer.</description>
                </bitField>
            </register>
            <register access="Read Only" name="QSPI_RX_DATA_REG" offset="0xe000d020" size="0x4">
                <gui_name language="en">Rx_data_REG</gui_name>
                <description language="en">Receive Data Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="RX_FIFO_data">
                    <gui_name language="en">RX_FIFO_data</gui_name>
                    <description language="en">Data from TX FIFO</description>
                </bitField>
            </register>
            <register name="QSPI_SLAVE_IDLE_COUNT_REG" offset="0xe000d024" size="0x4">
                <gui_name language="en">Slave_Idle_count_REG</gui_name>
                <description language="en">Slave Idle Count Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="Slave_Idle_coun">
                    <gui_name language="en">Slave_Idle_coun</gui_name>
                    <description language="en">SPI in slave mode detects a start only when the
external SPI master serial clock (sclk_in) is stable
(quiescent state) for SPI REFERENCE CLOCK cycles
specified by slave idle count register or when the SPI
is deselected.</description>
                </bitField>
            </register>
            <register name="QSPI_TX_THRES_REG" offset="0xe000d028" size="0x4">
                <gui_name language="en">TX_thres_REG</gui_name>
                <description language="en">TX_FIFO Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="DEPTH_of_TX_FIFO">
                    <gui_name language="en">DEPTH_of_TX_FIFO</gui_name>
                    <description language="en">Defines the level at which the TX FIFO not full interrupt is generated</description>
                </bitField>
            </register>
            <register name="QSPI_RX_THRES_REG" offset="0xe000d02c" size="0x4">
                <gui_name language="en">RX_thres_REG</gui_name>
                <description language="en">RX FIFO Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="DEPTH_of_RX_FIFO">
                    <gui_name language="en">DEPTH_of_RX_FIFO</gui_name>
                    <description language="en">Defines the level at which the RX FIFO not empty interrupt is generated</description>
                </bitField>
            </register>
            <register name="QSPI_GPIO" offset="0xe000d030" size="0x4">
                <gui_name language="en">GPIO</gui_name>
                <description language="en">General Purpose Inputs and Outputs Register for the Quad-SPI Controller core</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="WP_N">
                    <gui_name language="en">WP_N</gui_name>
                    <description language="en">Write Protect.
Write Protect output for flash devices supporting this function.
Active low (may be inverted externally to the core if required for flash devices requiring active high write protect signal.)</description>
                </bitField>
            </register>
            <register name="QSPI_LPBK_DLY_ADJ" offset="0xe000d038" size="0x4">
                <gui_name language="en">LPBK_DLY_ADJ</gui_name>
                <description language="en">Loopback Master Clock Delay Adjustment Register</description>
                <bitField access="Read Write" enumerationId="LPBK_DLY_ADJ_LPBK_SEL_ENUM" high_bit="8" low_bit="8" name="LPBK_SEL">
                    <gui_name language="en">LPBK_SEL</gui_name>
                    <description language="en">Loopback clock select:
0 - loopback at pad
1 - loopback through external connections</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="LPBK_PH">
                    <gui_name language="en">LPBK_PH</gui_name>
                    <description language="en">Loopback clock phase selection. 0 - normal, 1 - inverted</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="USE_LPBK">
                    <gui_name language="en">USE_LPBK</gui_name>
                    <description language="en">Use external loopback master clock for read data capturing when baud rate divisor (reg 0x00) is 2.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="DLY1">
                    <gui_name language="en">DLY1</gui_name>
                    <description language="en">Delay adjustment (00, 01, 10, 11) for 0, 0.4, 0.8 or 1.2 ns, this is added to DLY0 to form the overall delay.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="DLY0">
                    <gui_name language="en">DLY0</gui_name>
                    <description language="en">Delay adjustment step, 0 to 7, each step is around 0.2 ns.</description>
                </bitField>
            </register>
            <register access="Write Only" name="QSPI_TXD1" offset="0xe000d080" size="0x4">
                <gui_name language="en">TXD1</gui_name>
                <description language="en">Transmit Data Register. Keyhole addresses for the Transmit data FIFO.</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">Data to TX FIFO, for 1-byte instruction, not for normal data transfer.
In little endian mode (default), only bits 7:0 are valid, bits 31:8 are ignored.
In big endian mode, only the 8 MS bits are valid.</description>
                </bitField>
            </register>
            <register access="Write Only" name="QSPI_TXD2" offset="0xe000d084" size="0x4">
                <gui_name language="en">TXD2</gui_name>
                <description language="en">Transmit Data Register. Keyhole addresses for the Transmit data FIFO.</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">Data to TX FIFO, for 2-byte instruction, not for normal data transfer.
In little endian mode (default), only bits 15:0 are valid, bits 31:16 are ignored.
In big endian mode, only the 16 MS bits are valid.</description>
                </bitField>
            </register>
            <register access="Write Only" name="QSPI_TXD3" offset="0xe000d088" size="0x4">
                <gui_name language="en">TXD3</gui_name>
                <description language="en">Transmit Data Register. Keyhole addresses for the Transmit data FIFO.</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">Data to TX FIFO, for 3-byte instruction, not for normal data transfer.
In little endian mode (default), only bits 23:0 are valid, bits 31:24 are ignored.
In big endian mode, only the 24 MS bits are valid.</description>
                </bitField>
            </register>
            <register name="QSPI_LQSPI_CFG" offset="0xe000d0a0" size="0x4">
                <gui_name language="en">LQSPI_CFG</gui_name>
                <description language="en">Configuration Register specifically for the Linear Quad-SPI Controller</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="LQ_MODE">
                    <gui_name language="en">LQ_MODE</gui_name>
                    <description language="en">Linear quad SPI mode, if set, else quad SPI mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="TWO_MEM">
                    <gui_name language="en">TWO_MEM</gui_name>
                    <description language="en">Both upper and lower memories are active, if set</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="SEP_BUS">
                    <gui_name language="en">SEP_BUS</gui_name>
                    <description language="en">Separate memory bus, if set.
Only has meaning if bit 30 is set</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="U_PAGE">
                    <gui_name language="en">U_PAGE</gui_name>
                    <description language="en">Upper memory page, if set.
Only has meaning if bit 30 is set AND bit 29 is clear AND bit 31 is clear.
In LQSPI mode, address bit 25 will indicate lower (0) or upper (1) page.
In IO mode, this bit is used to select the lower or upper memory for configuration or read/write operations.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="MODE_EN">
                    <gui_name language="en">MODE_EN</gui_name>
                    <description language="en">Enable MODE_BITS[23:16] to be sent, if set.
This bit MUST BE SET for dual I/O or quad I/O read (specified through [7:0]).
This bit MUST BE CLEAR for all other read modes as they do not have mode bits.
If this bit is 0, bits 24, and [23:16] are ignored.
Here is a summary of how bits 25, 24 and 23:16 are related.
Bit 25
bit 24
bits 23:16
0
x
x
1
0
not 8'bxx10xxxx
1
1
8'bxx10xxxx</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="MODE_ON">
                    <gui_name language="en">MODE_ON</gui_name>
                    <description language="en">This bit is only relevant if bit 25 is set, else it is ignored.
If this bit is set, instruction code is only sent for the very first read transfer.
If this bit is clear, instruction code will be sent for all read transfers.
This bit is configured in association with the MODE_BITS.
For Winbond devices, this bit MUST BE SET if the MODE_BITS are 8'bxx10xxxx, else this bit MUST BE CLEAR.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="MODE_BITS">
                    <gui_name language="en">MODE_BITS</gui_name>
                    <description language="en">These bits are only relevant if bit 25 is set, else it is ignored.
If bit 25 is set, this value is required for both dual I/O read and quad I/O read.
See vendor's datasheet for more information.
For Winbond's device, the continuous read mode value is 8'bxx10xxxx to skip the instruction code for the next read transfer, else instruction code is sent for all read transfers.
Bit 24 has to be configured accordingly with this value.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="DUMMY_BYTE">
                    <gui_name language="en">DUMMY_BYTE</gui_name>
                    <description language="en">Number of dummy bytes between address and return read data</description>
                </bitField>
                <bitField access="Read Write" enumerationId="LQSPI_CFG_INST_CODE_ENUM" high_bit="7" low_bit="0" name="INST_CODE">
                    <gui_name language="en">INST_CODE</gui_name>
                    <description language="en">Read instruction code.
The known read instruction codes are:
8'h03 - Read
8'h0B - Fast read
8'h3B - Fast read dual output
8'h6B - Fast read quad output
8'hBB - Fast read dual I/O
8'hEB - Fast read quad I/O</description>
                </bitField>
            </register>
            <register name="QSPI_LQSPI_STS" offset="0xe000d0a4" size="0x2">
                <gui_name language="en">LQSPI_STS</gui_name>
                <description language="en">Status Register specifically for the Linear Quad-SPI Controller</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="D_FSM_ERR">
                    <gui_name language="en">D_FSM_ERR</gui_name>
                    <description language="en">Data FSM error, if set</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="WR_RECVD">
                    <gui_name language="en">WR_RECVD</gui_name>
                    <description language="en">AXI write command received, if set</description>
                </bitField>
            </register>
            <register name="QSPI_MOD_ID" offset="0xe000d0fc" size="0x4">
                <gui_name language="en">MOD_ID</gui_name>
                <description language="en">Module Identification register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">Module ID value.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SD0" name="SD0" offset="0xe0100000">
            <gui_name language="en">sd0</gui_name>
            <description language="en">sd0</description>
            <register name="SD0_SDMA_SYSTEM_ADDRESS_REGISTER" offset="0xe0100000" size="0x4">
                <gui_name language="en">SDMA_system_address_register</gui_name>
                <description language="en">This register contains the system memory address for a DMA transfer. When the Host Controller (HC) stops a DMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing (i.e after a transaction has stopped). Read operations during transfer return an invalid value. The Host Driver (HD) shall initialize this register before starting a DMA transaction. After DMA has stopped, the next system address of the next contiguous data position can be read from this register. The DMA transfer waits at every boundary specified by the Host DMA Buffer Size in the Block Size register. The Host Controller generates DMA Interrupt to request to update this register. The HD sets the next system address of the next data position to this register. When most upper byte of this register (003h) is written, the HC restart the DMA transfer. When restarting DMA by the resume command or by setting Continue Request in the Block Gap Control register, the HC shall start at the next contiguous address stored here in the System Address register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="SDMA_System_Address">
                    <gui_name language="en">SDMA_System_Address</gui_name>
                    <description language="en">Watchdog enable - if set, the watchdog is enabled and can generate any signals that are enabled.</description>
                </bitField>
            </register>
            <register name="SD0_BLOCK_SIZE_BLOCK_COUNT" offset="0xe0100004" size="0x4">
                <gui_name language="en">Block_Size_Block_Count</gui_name>
                <description language="en">Block size register
Block count register</description>
                <bitField access="Read Write" enumerationId="Block_Size_Block_Count_Blocks_Count_for_Current_Transfer_ENUM" high_bit="31" low_bit="16" name="Blocks_Count_for_Current_Transfer">
                    <gui_name language="en">Blocks_Count_for_Current_Transfer</gui_name>
                    <description language="en">This register is enabled when Block Count Enable in the Transfer
Mode register is set to 1 and is valid only for multiple block transfers. The HC decrements the block count after each block transfer and stops when the count reaches zero. It can be accessed only if no transaction is
executing (i.e after a transaction has stopped). Read operations
during transfer return an invalid value and write operations shall
be ignored. When saving transfer context as a result of Suspend command, the number of blocks yet to be transferred can be determined
by reading this register. When restoring transfer context prior to
issuing a Resume command, the HD shall restore the previously
save block count.
0000h - Stop Count
0001h - 1 block
0002h - 2 blocks
--- ---
FFFFh - 65535 blocks</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Block_Size_Block_Count_Host_SDMA_Buffer_Size_ENUM" high_bit="14" low_bit="12" name="Host_SDMA_Buffer_Size">
                    <gui_name language="en">Host_SDMA_Buffer_Size</gui_name>
                    <description language="en">Counter clock prescale - selects the prescaler division ratio:
00 = pclk divided by 8
01 = pclk divided by 64
10 = pclk divided by 256
11 = pclk divided by 4096
Note: If a restart signal is received the prescaler should be reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Block_Size_Block_Count_Transfer_Block_Size_ENUM" high_bit="11" low_bit="0" name="Transfer_Block_Size">
                    <gui_name language="en">Transfer_Block_Size</gui_name>
                    <description language="en">This register specifies the block size for block data transfers for CMD17, CMD18, CMD24, CMD25, and CMD53. It can be accessed only if no transaction is executing (i.e after a transaction has stopped). Read operations during transfer return an invalid value and write operations shall be ignored.
0000h - No Data Transfer
0001h - 1 Byte
0002h - 2 Bytes
0003h - 3 Bytes
0004h - 4 Bytes
--- ---
01FFh - 511 Bytes
0200h - 512 Bytes
--- ---
0800h - 2048 Bytes</description>
                </bitField>
            </register>
            <register name="SD0_ARGUMENT" offset="0xe0100008" size="0x4">
                <gui_name language="en">Argument</gui_name>
                <description language="en">Argument register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Command_Argument">
                    <gui_name language="en">Command_Argument</gui_name>
                    <description language="en">The SD Command Argument is specified as bit39-8 of Command-Format.</description>
                </bitField>
            </register>
            <register name="SD0_TRANSFER_MODE_COMMAND" offset="0xe010000c" size="0x4">
                <gui_name language="en">Transfer_Mode_Command</gui_name>
                <description language="en">Transfer mode register
Command register</description>
                <bitField access="Read Write" high_bit="28" low_bit="24" name="Command_Index">
                    <gui_name language="en">Command_Index</gui_name>
                    <description language="en">This bit shall be set to the command number (CMD0-63, ACMD0-63).</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Command_Type_ENUM" high_bit="23" low_bit="22" name="Command_Type">
                    <gui_name language="en">Command_Type</gui_name>
                    <description language="en">There are three types of special commands. Suspend, Resume and Abort. These bits shall bet set to 00b for all other commands. Suspend Command If the Suspend command succeeds, the HC shall assume the SD Bus has been released and that it is possible to issue the next command which uses the DAT line. The HC shall de-assert Read Wait for read transactions and stop checking busy for write transactions. The Interrupt cycle shall start, in 4-bit mode. If the Suspend command fails, the HC shall maintain its current state. and the HD shall restart the transfer by setting Continue Request in the Block Gap Control Register. Resume Command The HD re-starts the data transfer by restoring the registers in the range of 000-00Dh. The HC shall check for busy before starting write transfers. Abort Command If this command is set when executing a read transfer, the HC shall stop reads to the buffer. If this command is set when executing a write transfer, the HC shall stop driving the DAT line. After issuing the Abort command, the HD should issue a software reset
00b - Normal
01b - Suspend
10b - Resume
11b - Abort</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Data_Present_Select_ENUM" high_bit="21" low_bit="21" name="Data_Present_Select">
                    <gui_name language="en">Data_Present_Select</gui_name>
                    <description language="en">This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. If is set to 0 for the following:
1. Commands using only CMD line (ex. CMD52)
2. Commands with no data transfer but using busy signal on DAT[0]
line (R1b or R5b ex. CMD38)
3. Resume Command
0 - No Data Present
1 - Data Present</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Command_Index_Check_Enable_ENUM" high_bit="20" low_bit="20" name="Command_Index_Check_Enable">
                    <gui_name language="en">Command_Index_Check_Enable</gui_name>
                    <description language="en">If this bit is set to 1, the HC shall check the index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Command_CRC_Check_Enable_ENUM" high_bit="19" low_bit="19" name="Command_CRC_Check_Enable">
                    <gui_name language="en">Command_CRC_Check_Enable</gui_name>
                    <description language="en">If this bit is set to 1, the HC shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Response_Type_Select_ENUM" high_bit="17" low_bit="16" name="Response_Type_Select">
                    <gui_name language="en">Response_Type_Select</gui_name>
                    <description language="en">Response Type Select
00 - No Response
01 - Response length 136
10 - Response length 48
11 - Response length 48 check
Busy after response</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Multi_Single_Block_Select_ENUM" high_bit="5" low_bit="5" name="Multi_Single_Block_Select">
                    <gui_name language="en">Multi_Single_Block_Select</gui_name>
                    <description language="en">This bit enables multiple block DAT line data transfers.
0 - Single Block
1 - Multiple Block</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Data_Transfer_Direction_Select_ENUM" high_bit="4" low_bit="4" name="Data_Transfer_Direction_Select">
                    <gui_name language="en">Data_Transfer_Direction_Select</gui_name>
                    <description language="en">This bit defines the direction of DAT line data transfers.
0 - Write (Host to Card)
1 - Read (Card to Host)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Auto_CMD12_Enable_ENUM" high_bit="2" low_bit="2" name="Auto_CMD12_Enable">
                    <gui_name language="en">Auto_CMD12_Enable</gui_name>
                    <description language="en">Multiple block transfers for memory require CMD12 to stop the ransaction. When this bit is set to 1, the HC shall issue CMD12 utomatically when last block transfer is completed. The HD shall not set this bit to issue commands that do not require CMD12 to stop data transfer.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Block_Count_Enable_ENUM" high_bit="1" low_bit="1" name="Block_Count_Enable">
                    <gui_name language="en">Block_Count_Enable</gui_name>
                    <description language="en">This bit is used to enable the Block count register, which is only relevant for multiple block transfers. When this bit is 0, the Block Count register is disabled, which is useful in executing an infinite transfer.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_DMA_Enable_ENUM" high_bit="0" low_bit="0" name="DMA_Enable">
                    <gui_name language="en">DMA_Enable</gui_name>
                    <description language="en">DMA can be enabled only if DMA Support bit in the Capabilities register is set. If this bit is set to 1, a DMA operation shall begin when the HD writes to the upper byte of Command register (00Fh).
0 - Disable
1 - Enable</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_RESPONSE0" offset="0xe0100010" size="0x4">
                <gui_name language="en">Response0</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_RESPONSE1" offset="0xe0100014" size="0x4">
                <gui_name language="en">Response1</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_RESPONSE2" offset="0xe0100018" size="0x4">
                <gui_name language="en">Response2</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_RESPONSE3" offset="0xe010001c" size="0x4">
                <gui_name language="en">Response3</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register name="SD0_BUFFER_DATA_PORT" offset="0xe0100020" size="0x4">
                <gui_name language="en">Buffer_Data_Port</gui_name>
                <description language="en">Buffer data port register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Buffer_Data">
                    <gui_name language="en">Buffer_Data</gui_name>
                    <description language="en">The Host Controller Buffer can be accessed through this 32-bit Data Port Register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_PRESENT_STATE" offset="0xe0100024" size="0x4">
                <gui_name language="en">Present_State</gui_name>
                <description language="en">Present State register</description>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="CMD_Line_Signal_Level">
                    <gui_name language="en">CMD_Line_Signal_Level</gui_name>
                    <description language="en">This status is used to check CMD line level to recover from errors, and for debugging.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="DAT_Bit3_Bit0_Line_Signal_Level">
                    <gui_name language="en">DAT_Bit3_Bit0_Line_Signal_Level</gui_name>
                    <description language="en">This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT[0].
D23 - DAT[3]
D22 - DAT[2]
D21 - DAT[1]
D20 - DAT[0]</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Write_Protect_Switch_Pin_Level_ENUM" high_bit="19" low_bit="19" name="Write_Protect_Switch_Pin_Level">
                    <gui_name language="en">Write_Protect_Switch_Pin_Level</gui_name>
                    <description language="en">The Write Protect Switch is supported for memory and combo cards. This bit reflects the SDWP# pin.
0 - Write protected (SDWP# = 1)
1 - Write enabled (SDWP# = 0)</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Card_Detect_Pin_Level_ENUM" high_bit="18" low_bit="18" name="Card_Detect_Pin_Level">
                    <gui_name language="en">Card_Detect_Pin_Level</gui_name>
                    <description language="en">This bit reflects the inverse value of the SDCD# pin.
0 - No Card present (SDCD# = 1)
1 - Card present (SDCD# = 0)</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Card_State_Stable_ENUM" high_bit="17" low_bit="17" name="Card_State_Stable">
                    <gui_name language="en">Card_State_Stable</gui_name>
                    <description language="en">This bit is used for testing. If it is 0, the Card Detect Pin Level is not stable. If this bit is set to 1, it means the Card Detect Pin Level is stable. The Software Reset For All in the Software Reset Register shall not affect this bit.
0 - Reset of Debouncing
1 - No Card or Inserted</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Card_Inserted_ENUM" high_bit="16" low_bit="16" name="Card_Inserted">
                    <gui_name language="en">Card_Inserted</gui_name>
                    <description language="en">This bit indicates whether a card has been inserted. Changing from 0 to 1 generates a Card Insertion interrupt in the Normal Interrupt Status register and changing from 1 to 0 generates a Card Removal Interrupt in the Normal Interrupt Status register. The Software Reset For All in the Software Reset register shall not affect this bit. If a Card is removed while its power is on and its clock is oscillating, the HC shall clear SD Bus Power in the Power Control register and SD Clock Enable in the Clock control register. In addition the HD should clear the HC by the Software Reset For All in Software register. The card detect is active regardless of the SD Bus Power.
0 - Reset or Debouncing or No Card
1 - Card Inserted</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Buffer_Read_Enable_ENUM" high_bit="11" low_bit="11" name="Buffer_Read_Enable">
                    <gui_name language="en">Buffer_Read_Enable</gui_name>
                    <description language="en">This status is used for non-DMA read transfers. This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt.
0 - Read Disable
1 - Read Enable.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Buffer_Write_Enable_ENUM" high_bit="10" low_bit="10" name="Buffer_Write_Enable">
                    <gui_name language="en">Buffer_Write_Enable</gui_name>
                    <description language="en">This status is used for non-DMA write transfers. This read only flag indicates if space is available for write data. If this bit is 1, data can be written to the buffer. A change of this bit from 1 to 0 occurs when all the block data is written to the buffer. A change of this bit from 0 to 1 occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt.
0 - Write Disable
1 - Write Enable.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Read_Transfer_Active_ENUM" high_bit="9" low_bit="9" name="Read_Transfer_Active">
                    <gui_name language="en">Read_Transfer_Active</gui_name>
                    <description language="en">This status is used for detecting completion of a read transfer.
This bit is set to 1 for either of the following conditions:
1. After the end bit of the read command
2. When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer
This bit is cleared to 0 for either of the following
conditions:
1. When the last data block as specified by block length is transferred to the system.
2. When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop At Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0.
1 - Transferring data
0 - No valid data</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Write_Transfer_Active_ENUM" high_bit="8" low_bit="8" name="Write_Transfer_Active">
                    <gui_name language="en">Write_Transfer_Active</gui_name>
                    <description language="en">This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the HC. This bit is set in either of the following cases:
1. After the end bit of the write command.
2. When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer.
This bit is cleared in either of the following cases:
1. After getting the CRC status of the last data block as specified by the transfer count (Single or Multiple)
2. After getting a CRC status of any block where data transmission is about to be stopped by a Stop At Block Gap Request.
During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop At Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.
1 - transferring data
0 - No valid data</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_DAT_Line_Active_ENUM" high_bit="2" low_bit="2" name="DAT_Line_Active">
                    <gui_name language="en">DAT_Line_Active</gui_name>
                    <description language="en">This bit indicates whether one of the DAT line on SD bus is in use.
1 - DAT line active
0 - DAT line inactive</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Command_Inhibit_DAT_ENUM" high_bit="1" low_bit="1" name="Command_Inhibit_DAT">
                    <gui_name language="en">Command_Inhibit_DAT</gui_name>
                    <description language="en">This status bit is generated if either the DAT Line Active or the Read transfer Active is set to 1. If this bit is 0, it indicates the HC can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). Changing from 1 to 0 generates a Transfer Complete interrupt in the Normal interrupt status register.
Note: The SD Host Driver can save registers in the range of 000-00Dh for a suspend transaction after this bit has changed from 1 to 0.
1 - cannot issue command which uses the DAT line
0 - Can issue command which uses the DAT line</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Command_Inhibit_CMD">
                    <gui_name language="en">Command_Inhibit_CMD</gui_name>
                    <description language="en">If this bit is 0, it indicates the CMD line is not in use and the HC can issue a SD command using the CMD line. This bit is set immediately after the Command register (00Fh) is written. This bit is cleared when the command response is received. Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the HC cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. Status issuing Auto CMD12 is not read from this bit.</description>
                </bitField>
            </register>
            <register name="SD0_HOST_CONTROL_POWER_CONTROL_BLOCK_GAP_CONTROL_WAKEUP_CONTROL" offset="0xe0100028" size="0x4">
                <gui_name language="en">Host_control_Power_control_Block_Gap_Control_Wakeup_control</gui_name>
                <description language="en">Host control register
Power control register
Block gap control register
Wake-up control register</description>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_SD_Card_Removal_ENUM" high_bit="26" low_bit="26" name="Wakeup_Event_Enable_On_SD_Card_Removal">
                    <gui_name language="en">Wakeup_Event_Enable_On_SD_Card_Removal</gui_name>
                    <description language="en">This bit enables wakeup event via
Card Removal assertion in the
Normal Interrupt Status register.
FN_WUS (Wake up Support) in
CIS does not affect this bit.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_SD_Card_Insertion_ENUM" high_bit="25" low_bit="25" name="Wakeup_Event_Enable_On_SD_Card_Insertion">
                    <gui_name language="en">Wakeup_Event_Enable_On_SD_Card_Insertion</gui_name>
                    <description language="en">This bit enables wakeup event via Card Insertion assertion in the Normal Interrupt Status register. FN_WUS (Wake up Support) in CIS does not affect this bit.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_Card_Interrupt_ENUM" high_bit="24" low_bit="24" name="Wakeup_Event_Enable_On_Card_Interrupt">
                    <gui_name language="en">Wakeup_Event_Enable_On_Card_Interrupt</gui_name>
                    <description language="en">This bit enables wakeup event via
Card Interrupt assertion in the
Normal Interrupt Status register.
This bit can be set to 1 if FN_WUS
(Wake Up Support) in CIS is set to
1.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="Interrupt_At_Block_Gap">
                    <gui_name language="en">Interrupt_At_Block_Gap</gui_name>
                    <description language="en">This bit is valid only in 4-bit mode of the SDIO
card and selects a sample point in the interrupt
cycle. Setting to 1 enables interrupt detection at
the block gap for a multiple block transfer. If the
SD card cannot signal an interrupt during a multiple
block transfer, this bit should be set to 0.
When the HD detects an SD card insertion, it shall
set this bit according to the CCCR of the SDIO
card.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Read_Wait_Control_ENUM" high_bit="18" low_bit="18" name="Read_Wait_Control">
                    <gui_name language="en">Read_Wait_Control</gui_name>
                    <description language="en">The read wait function is optional for SDIO cards.
If the card supports read wait, set this bit to
enable use of the read wait protocol to stop read
data using DAT[2] line. Otherwise the HC has to
stop the SD clock to hold read data, which
restricts commands generation. When the HD
detects an SD card insertion, it shall set this bit
according to the CCCR of the SDIO card. If the
card does not support read wait, this bit shall
never be set to 1 otherwise DAT line conflict may
occur. If this bit is set to 0, Suspend / Resume
cannot be supported
1 - Enable Read Wait Control
0 - Disable Read Wait Control</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Continue_Request_ENUM" high_bit="17" low_bit="17" name="Continue_Request">
                    <gui_name language="en">Continue_Request</gui_name>
                    <description language="en">This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request. To
cancel stop at the block gap, set Stop At block
Gap Request to 0 and set this bit to restart the
transfer.
The HC automatically clears this bit in either of
the following cases:
1) In the case of a read transaction, the DAT Line
Active changes from 0 to 1 as a read transaction
restarts.
2) In the case of a write transaction, the Write
transfer active changes from 0 to 1 as the write
transaction restarts.
Therefore it is not necessary for Host driver to set
this bit to 0. If Stop At Block Gap Request is set to
1, any write to this bit is ignored.
1 - Restart
0 - Ignored</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Stop_At_Block_Gap_Request_ENUM" high_bit="16" low_bit="16" name="Stop_At_Block_Gap_Request">
                    <gui_name language="en">Stop_At_Block_Gap_Request</gui_name>
                    <description language="en">This bit is used to stop executing a transaction at the next block gap for non- DMA,SDMA and ADMA transfers. Until the transfer complete is set
to 1, indicating a transfer completion the HD shall leave this bit set to 1. Clearing both the Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. Read Wait is used to stop the read transaction at the block gap. The HC shall honour Stop At Block Gap Request for write transfers, but for read transfers it requires that the SD card support Read Wait. Therefore the HD shall not set this bit during read transfers unless the SD card supports Read Wait and has set Read Wait Control to 1. In case of write transfers in which the HD writes data to the Buffer Data Port register, the HD shall set this bit after all block data is written. If this bit is set to 1, the HD shall not write data to Buffer data port register. This bit affects Read Transfer Active, Write Transfer Active, DAT line active and Command Inhibit (DAT) in the Present State register.
1 - Stop
0 - Transfer</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_SD_Bus_Voltage_Select_ENUM" high_bit="11" low_bit="9" name="SD_Bus_Voltage_Select">
                    <gui_name language="en">SD_Bus_Voltage_Select</gui_name>
                    <description language="en">By setting these bits, the HD selects the voltage level for the SD card. Before setting this register, the HD shall check the voltage support bits
in the capabilities register. If an unsupported voltage is selected, the
Host System shall not supply SD bus voltage
111b - 3.3 Flattop.)
110b - 3.0 V(Typ.)
101b - 1.8 V(Typ.)
100b - 000b - Reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_SD_Bus_Power_ENUM" high_bit="8" low_bit="8" name="SD_Bus_Power">
                    <gui_name language="en">SD_Bus_Power</gui_name>
                    <description language="en">Before setting this bit, the SD host driver shall set SD Bus Voltage Select. If the HC detects the No Card State, this bit shall be cleared.
1 - Power on
0 - Power off</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Card_detect_signal_detetction_ENUM" high_bit="7" low_bit="7" name="Card_detect_signal_detetction">
                    <gui_name language="en">Card_detect_signal_detetction</gui_name>
                    <description language="en">This bit selects source for card detection.
1- The card detect test level is selected
0 -SDCD# is selected (for normal use)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Card_Detect_Test_Level_ENUM" high_bit="6" low_bit="6" name="Card_Detect_Test_Level">
                    <gui_name language="en">Card_Detect_Test_Level</gui_name>
                    <description language="en">This bit is enabled while the Card Detect Signal Selection is set to 1 and it
indicates card inserted or not. Generates (card ins or card removal) interrupt when the normal int sts enable bit is set.
1 - Card Inserted
0 - No Card</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_DMA_Select_ENUM" high_bit="4" low_bit="3" name="DMA_Select">
                    <gui_name language="en">DMA_Select</gui_name>
                    <description language="en">One of supported DMA modes can be selected. The host driver shall check support of DMA modes by referring the Capabilities register.
00 - SDMA is selected
01 - 32-bit Address ADMA1 is selected
10 -32-bit Address ADMA2 is selected
11 - 64-bit Address ADMA2 is selected</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_High_Speed_Enable_ENUM" high_bit="2" low_bit="2" name="High_Speed_Enable">
                    <gui_name language="en">High_Speed_Enable</gui_name>
                    <description language="en">This bit is optional. Before setting this bit, the HD shall check the High Speed Support in the capabilities register. If this bit is set to 0 (default), the HC outputs CMD line and DAT lines at the falling edge of the SD clock (up to 25 MHz/20MHz for MMC). If this bit is set to 1, the HC outputs CMD line and DAT lines at the rising edge of the SD clock (up to 50 MHz for SD/52MHz for MMC)
1 - High Speed Mode
0 - Normal Speed Mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Data_Transfer_Width_SD1_or_SD4_ENUM" high_bit="1" low_bit="1" name="Data_Transfer_Width_SD1_or_SD4">
                    <gui_name language="en">Data_Transfer_Width_SD1_or_SD4</gui_name>
                    <description language="en">This bit selects the data width of the HC. The HD shall select it to match the data width of the SD card.
1 - 4 bit mode
0 - 1 bit mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_LED_Control_ENUM" high_bit="0" low_bit="0" name="LED_Control">
                    <gui_name language="en">LED_Control</gui_name>
                    <description language="en">This bit is used to caution the user not to remove the card while the SD card is being accessed. If the software is going to issue multiple SD commands, this bit can be set during all transactions. It is not necessary to change for each transaction.
1 - LED on
0 - LED off</description>
                </bitField>
            </register>
            <register name="SD0_CLOCK_CONTROL_TIMEOUT_CONTROL_SOFTWARE_RESET" offset="0xe010002c" size="0x4">
                <gui_name language="en">Clock_Control_Timeout_control_Software_reset</gui_name>
                <description language="en">Clock Control register
Timeout control register
Software reset register</description>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_DAT_Line_ENUM" high_bit="26" low_bit="26" name="Software_Reset_for_DAT_Line">
                    <gui_name language="en">Software_Reset_for_DAT_Line</gui_name>
                    <description language="en">Only part of data circuit is reset. The following registers and bits are cleared by this bit:
Buffer Data Port Register
Buffer is cleared and Initialized.
Present State register
Buffer read Enable
Buffer write Enable
Read Transfer Active
Write Transfer Active
DAT Line Active
Command Inhibit (DAT)
Block Gap Control register
Continue Request
Stop At Block Gap Request
Normal Interrupt Status register
Buffer Read Ready
Buffer Write Ready
Block Gap Event
Transfer Complete
1 - Reset
0 - Work</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_CMD_Line_ENUM" high_bit="25" low_bit="25" name="Software_Reset_for_CMD_Line">
                    <gui_name language="en">Software_Reset_for_CMD_Line</gui_name>
                    <description language="en">Only part of command circuit is reset. The following registers and bits are cleared by this bit:
Present State register
Command Inhibit (CMD)
Normal Interrupt Status register
Command Complete
1 - Reset
0 - Work</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_All_ENUM" high_bit="24" low_bit="24" name="Software_Reset_for_All">
                    <gui_name language="en">Software_Reset_for_All</gui_name>
                    <description language="en">This reset affects the entire HC except for the card detection circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when capabilities registers are valid and the HD
can read them. Additional use of Software Reset For All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be re initialized by the HD.
1 - Reset
0 - Work</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Data_Timeout_Counter_Value__ENUM" high_bit="19" low_bit="16" name="Data_Timeout_Counter_Value_">
                    <gui_name language="en">Data_Timeout_Counter_Value_</gui_name>
                    <description language="en">This value determines the interval by which DAT line time-outs are detected. Refer to the Data Time-out Error in the Error Interrupt Status register for information on factors that dictate time-out generation. Time-out clock frequency will be generated by dividing the sdclockTMCLK by this value. When setting this register, prevent inadvertent time-out events by clearing the Data
Time-out Error Status Enable (in the Error Interrupt Status Enable register)
1111 - Reserved
1110 - TMCLK * 2^27
------------------------------
------------------------------
0001 - TMCLK * 2^14
0000 - TMCLK * 2^13</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_SDCLK_Frequency_Select_ENUM" high_bit="15" low_bit="8" name="SDCLK_Frequency_Select">
                    <gui_name language="en">SDCLK_Frequency_Select</gui_name>
                    <description language="en">This register is used to select the frequency of the SDCLK pin. The frequency is not programmed directly; rather this register holds the divisor of the Base Clock Frequency For SD clock in the capabilities register. Only the following settings are allowed.
80h - base clock divided by 256
40h - base clock divided by 128
20h - base clock divided by 64
10h - base clock divided by 32
08h - base clock divided by 16
04h - base clock divided by 8
02h - base clock divided by 4
01h - base clock divided by 2
00h - base clock(10MHz-63MHz)
Setting 00h specifies the highest frequency of the SD Clock. When setting multiple bits, the most significant bit is used as the divisor. But multiple bits should not be set. The two default divider values can be calculated by the frequency that is defined by the Base Clock Frequency For SD Clock in the Capabilities register.
1) 25 MHz divider value
2) 400 KHz divider value
The frequency of the SDCLK is set by the following formula:
Clock Frequency = (Baseclock) / divisor.
Thus choose the smallest possible divisor which results in a clock frequency that is less than or equal to the target frequency.
Maximum Frequency for SD = 50Mhz (base clock)
Maximum Frequency for MMC = 52Mhz (base clock)
Minimum Frequency = 195.3125Khz (50Mhz / 256), same calc for MMC also</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_SD_Clock_Enable_ENUM" high_bit="2" low_bit="2" name="SD_Clock_Enable">
                    <gui_name language="en">SD_Clock_Enable</gui_name>
                    <description language="en">The HC shall stop SDCLK when writing this bit to 0. SDCLK frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped (Stop at SDCLK = 0). If the HC detects the No Card state, this bit shall be cleared.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Clock_Control_Timeout_control_Software_reset_Internal_Clock_Stable_ENUM" high_bit="1" low_bit="1" name="Internal_Clock_Stable">
                    <gui_name language="en">Internal_Clock_Stable</gui_name>
                    <description language="en">This bit is set to 1 when SD clock is stable after writing to Internal Clock Enable in this register to 1. The SD Host Driver shall wait to set SD Clock Enable until this bit is set to 1.
Note: This is useful when using PLL for a clock oscillator that requires setup time.
1 - Ready
0 - Not Ready</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Internal_Clock_Enable_ENUM" high_bit="0" low_bit="0" name="Internal_Clock_Enable">
                    <gui_name language="en">Internal_Clock_Enable</gui_name>
                    <description language="en">This bit is set to 0 when the HD is not using the HC or the HC awaits a wakeup event. The HC should stop its internal clock to go very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection.
1 - Oscillate
0 - Stop</description>
                </bitField>
            </register>
            <register name="SD0_NORMAL_INTERRUPT_STATUS_ERROR_INTERRUPT_STATUS" offset="0xe0100030" size="0x4">
                <gui_name language="en">Normal_interrupt_status_Error_interrupt_status</gui_name>
                <description language="en">Normal interrupt status register
Error interrupt status register</description>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Ceata_Error_Status_ENUM" high_bit="29" low_bit="29" name="Ceata_Error_Status">
                    <gui_name language="en">Ceata_Error_Status</gui_name>
                    <description language="en">Occurs when ATA command termination has occured due to an error condition the device has encountered.
0 - no error
1 - error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Target_Response_error_ENUM" high_bit="28" low_bit="28" name="Target_Response_error">
                    <gui_name language="en">Target_Response_error</gui_name>
                    <description language="en">Occurs when detecting ERROR in m_hresp(dma transaction)
0 - no error
1 - error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_ADMA_Error_ENUM" high_bit="25" low_bit="25" name="ADMA_Error">
                    <gui_name language="en">ADMA_Error</gui_name>
                    <description language="en">This bit is set when the Host Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the ADMA Error Status Register.
1- Error
0 -No error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Auto_CMD12_Error_ENUM" high_bit="24" low_bit="24" name="Auto_CMD12_Error">
                    <gui_name language="en">Auto_CMD12_Error</gui_name>
                    <description language="en">Occurs when detecting that one of the bits in Auto CMD12 Error Status register has changed from 0 to 1. This bit is set to 1 also when Auto CMD12 is not executed due to the previous command error.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Current_Limit_Error_ENUM" high_bit="23" low_bit="23" name="Current_Limit_Error">
                    <gui_name language="en">Current_Limit_Error</gui_name>
                    <description language="en">By setting the SD Bus Power bit in the Power Control Register, the HC is requested to supply power for the SD Bus. If the HC supports the Current Limit Function, it can be protected from an Illegal card by stopping power supply to the card in which case this bit indicates a failure status. Reading 1 means the HC is not supplying power to SD card due to some failure. Reading 0 means that the HC is supplying power and no error has occurred. This bit shall always set to be 0, if the HC does not support this function.
0 - No Error
1 - Power Fail</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Data_End_Bit_Error_ENUM" high_bit="22" low_bit="22" name="Data_End_Bit_Error">
                    <gui_name language="en">Data_End_Bit_Error</gui_name>
                    <description language="en">Occurs when detecting 0 at the end bit position of read data which uses the DAT line or the end bit position of the CRC status.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Data_CRC_Error_ENUM" high_bit="21" low_bit="21" name="Data_CRC_Error">
                    <gui_name language="en">Data_CRC_Error</gui_name>
                    <description language="en">Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than '010'.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Data_Timeout_Error_ENUM" high_bit="20" low_bit="20" name="Data_Timeout_Error">
                    <gui_name language="en">Data_Timeout_Error</gui_name>
                    <description language="en">Occurs when detecting one of following timeout conditions.
1. Busy Timeout for R1b, R5b type.
2. Busy Timeout after Write CRC status
3. Write CRC status Timeout
4. Read Data Timeout
0 - No Error
1 - Timeout</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_Index_Error_ENUM" high_bit="19" low_bit="19" name="Command_Index_Error">
                    <gui_name language="en">Command_Index_Error</gui_name>
                    <description language="en">Occurs if a Command Index error occurs in the Command Response.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_End_Bit_Error_ENUM" high_bit="18" low_bit="18" name="Command_End_Bit_Error">
                    <gui_name language="en">Command_End_Bit_Error</gui_name>
                    <description language="en">Occurs when detecting that the end bit of a command response is 0.
0 - No Error
1 - End Bit Error Generated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_CRC_Error_ENUM" high_bit="17" low_bit="17" name="Command_CRC_Error">
                    <gui_name language="en">Command_CRC_Error</gui_name>
                    <description language="en">Command CRC Error is generated in two cases.
1. If a response is returned and the Command Time-out Error is set to 0, this bit is set to 1 when detecting a CRT error in the command response
2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SDCLK edge, then the HC shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict.
0 - No Error
1 - CRC Error Generated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_Timeout_Error_ENUM" high_bit="16" low_bit="16" name="Command_Timeout_Error">
                    <gui_name language="en">Command_Timeout_Error</gui_name>
                    <description language="en">Occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command. If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC.
0 - No Error
1 - Timeout</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Normal_interrupt_status_Error_interrupt_status_Error_Interrupt_ENUM" high_bit="15" low_bit="15" name="Error_Interrupt">
                    <gui_name language="en">Error_Interrupt</gui_name>
                    <description language="en">If any of the bits in the Error Interrupt Status Register are set, then this bit is set. Therefore the HD can test for an error by checking this bit first.
0 - No Error.
1 - Error.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Boot_terminate_Interrupt_ENUM" high_bit="10" low_bit="10" name="Boot_terminate_Interrupt">
                    <gui_name language="en">Boot_terminate_Interrupt</gui_name>
                    <description language="en">This status is set if the boot opeartion get terminated
0 - Boot operation is not teminated.
1 - Boot operation is teminated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Boot_ack_rcv_ENUM" high_bit="9" low_bit="9" name="Boot_ack_rcv">
                    <gui_name language="en">Boot_ack_rcv</gui_name>
                    <description language="en">This status is set if the boot acknowledge is received from device.
0 - Boot ack is not received.
1 - Boot ack is received.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Normal_interrupt_status_Error_interrupt_status_Card_Interrupt_ENUM" high_bit="8" low_bit="8" name="Card_Interrupt">
                    <gui_name language="en">Card_Interrupt</gui_name>
                    <description language="en">Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor. In 1-bit mode, the HC shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the card and the interrupt to the Host system.
when this status has been set and the HD needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status register shall be set to 0 in order to clear the card interrupt statuses latched in the HC and stop driving the Host System. After completion of the card interrupt service (the reset factor in the SD card and the interrupt signal may not be asserted), set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again.
0 - No Card Interrupt
1 - Generate Card Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Card_Removal_ENUM" high_bit="7" low_bit="7" name="Card_Removal">
                    <gui_name language="en">Card_Removal</gui_name>
                    <description language="en">This status is set if the Card Inserted in the Present State register changes from 1 to 0. When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed.
Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.
0 - Card State Stable or Debouncing
1 - Card Removed</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Card_Insertion_ENUM" high_bit="6" low_bit="6" name="Card_Insertion">
                    <gui_name language="en">Card_Insertion</gui_name>
                    <description language="en">This status is set if the Card Inserted in the Present State register changes from 0 to 1. When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed.
Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.
0 - Card State Stable or Debouncing
1 - Card Inserted</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Buffer_Read_Ready_ENUM" high_bit="5" low_bit="5" name="Buffer_Read_Ready">
                    <gui_name language="en">Buffer_Read_Ready</gui_name>
                    <description language="en">This status is set if the Buffer Read Enable
changes from 0 to 1.
0 - Not Ready to read Buffer.
1 - Ready to read Buffer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Buffer_Write_Ready_ENUM" high_bit="4" low_bit="4" name="Buffer_Write_Ready">
                    <gui_name language="en">Buffer_Write_Ready</gui_name>
                    <description language="en">This status is set if the Buffer Write Enable
changes from 0 to 1.
0 - Not Ready to Write Buffer.
1 - Ready to Write Buffer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_DMA_Interrupt_ENUM" high_bit="3" low_bit="3" name="DMA_Interrupt">
                    <gui_name language="en">DMA_Interrupt</gui_name>
                    <description language="en">This status is set if the HC detects the Host
DMA Buffer Boundary in the Block Size
regiser.
0 - No DMA Interrupt
1 - DMA Interrupt is Generated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Block_Gap_Event_ENUM" high_bit="2" low_bit="2" name="Block_Gap_Event">
                    <gui_name language="en">Block_Gap_Event</gui_name>
                    <description language="en">If the Stop At Block Gap Request in the Block
Gap Control Register is set, this bit is set.
Read Transaction:
This bit is set at the falling edge of the DAT
Line Active Status (When the transaction is
stopped at SD Bus timing. The Read Wait
must be supported inorder to use this function).
Write Transaction:
This bit is set at the falling edge of Write
Transfer Active Status (After getting CRC status
at SD Bus timing).
0 - No Block Gap Event
1 - Transaction stopped at Block
Gap</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Transfer_Complete_ENUM" high_bit="1" low_bit="1" name="Transfer_Complete">
                    <gui_name language="en">Transfer_Complete</gui_name>
                    <description language="en">This bit is set when a read / write transaction is completed.
Read Transaction:
This bit is set at the falling edge of Read Transfer Active Status.
There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting the Stop At Block Gap Request in the Block Gap Control Register (After valid
data has been read to the Host System).
Write Transaction:
This bit is set at the falling edge of the DAT
Line Active Status.
There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop At Block Gap Request in the Block Gap Control Register and data transfers completed. (After valid data is written to the SD card and the busy signal is released).
Note: Transfer Complete has higher priority than Data Time-out Error. If both bits are set to 1, the data transfer can be considered complete
0 - No Data Transfer Complete
1 - Data Transfer Complete</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_Complete_ENUM" high_bit="0" low_bit="0" name="Command_Complete">
                    <gui_name language="en">Command_Complete</gui_name>
                    <description language="en">This bit is set when get the end bit of the command response (Except Auto CMD12).
Note: Command Time-out Error has higher priority than Command Complete. If both are set to 1, it can be considered that the response was not received correctly.
0 - No Command Complete
1 - Command Complete</description>
                </bitField>
            </register>
            <register name="SD0_NORMAL_INTERRUPT_STATUS_ENABLE_ERROR_INTERRUPT_STATUS_ENABLE" offset="0xe0100034" size="0x4">
                <gui_name language="en">Normal_interrupt_status_enable_Error_interrupt_status_enable</gui_name>
                <description language="en">Normal interrupt status enable register
Error interrupt status enable register</description>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Ceata_Error_Status_Enable_ENUM" high_bit="29" low_bit="29" name="Ceata_Error_Status_Enable">
                    <gui_name language="en">Ceata_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Target_Response_Error_Status_Enable_ENUM" high_bit="28" low_bit="28" name="Target_Response_Error_Status_Enable">
                    <gui_name language="en">Target_Response_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_ADMA_Error_Status_Enable_ENUM" high_bit="25" low_bit="25" name="ADMA_Error_Status_Enable">
                    <gui_name language="en">ADMA_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Auto_CMD12_Error_Status_Enable_ENUM" high_bit="24" low_bit="24" name="Auto_CMD12_Error_Status_Enable">
                    <gui_name language="en">Auto_CMD12_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Current_Limit_Error_Status_Enable_ENUM" high_bit="23" low_bit="23" name="Current_Limit_Error_Status_Enable">
                    <gui_name language="en">Current_Limit_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_End_Bit_Error_Status_Enable_ENUM" high_bit="22" low_bit="22" name="Data_End_Bit_Error_Status_Enable">
                    <gui_name language="en">Data_End_Bit_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_CRC_Error_Status_Enable_ENUM" high_bit="21" low_bit="21" name="Data_CRC_Error_Status_Enable">
                    <gui_name language="en">Data_CRC_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_Timeout_Error_Status_Enable_ENUM" high_bit="20" low_bit="20" name="Data_Timeout_Error_Status_Enable">
                    <gui_name language="en">Data_Timeout_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Index_Error_Status_Enable_ENUM" high_bit="19" low_bit="19" name="Command_Index_Error_Status_Enable">
                    <gui_name language="en">Command_Index_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_End_Bit_Error_Status_Enable_ENUM" high_bit="18" low_bit="18" name="Command_End_Bit_Error_Status_Enable">
                    <gui_name language="en">Command_End_Bit_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_CRC_Error_Status_Enable_ENUM" high_bit="17" low_bit="17" name="Command_CRC_Error_Status_Enable">
                    <gui_name language="en">Command_CRC_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Timeout_Error_Status_Enable_ENUM" high_bit="16" low_bit="16" name="Command_Timeout_Error_Status_Enable">
                    <gui_name language="en">Command_Timeout_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="Fixed_to_0">
                    <gui_name language="en">Fixed_to_0</gui_name>
                    <description language="en">The HC shall control error Interrupts using the Error Interrupt Status Enable register.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Boot_terminate_Interrupt_enable_ENUM" high_bit="10" low_bit="10" name="Boot_terminate_Interrupt_enable">
                    <gui_name language="en">Boot_terminate_Interrupt_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Boot_ack_rcv_enable_ENUM" high_bit="9" low_bit="9" name="Boot_ack_rcv_enable">
                    <gui_name language="en">Boot_ack_rcv_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Interrupt_Status_Enable_ENUM" high_bit="8" low_bit="8" name="Card_Interrupt_Status_Enable">
                    <gui_name language="en">Card_Interrupt_Status_Enable</gui_name>
                    <description language="en">If this bit is set to 0, the HC shall clear Interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The HD should clear the Card Interrupt Status Enable before servicing the Card Interrupt and should set this bit again after all Interrupt requests from the card are cleared to prevent inadvertent Interrupts.
0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Removal_Status_Enable_ENUM" high_bit="7" low_bit="7" name="Card_Removal_Status_Enable">
                    <gui_name language="en">Card_Removal_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Insertion_Status_Enable_ENUM" high_bit="6" low_bit="6" name="Card_Insertion_Status_Enable">
                    <gui_name language="en">Card_Insertion_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Buffer_Read_Ready_Status_Enable_ENUM" high_bit="5" low_bit="5" name="Buffer_Read_Ready_Status_Enable">
                    <gui_name language="en">Buffer_Read_Ready_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Buffer_Write_Ready_Status_Enable_ENUM" high_bit="4" low_bit="4" name="Buffer_Write_Ready_Status_Enable">
                    <gui_name language="en">Buffer_Write_Ready_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_DMA_Interrupt_Status_Enable_ENUM" high_bit="3" low_bit="3" name="DMA_Interrupt_Status_Enable">
                    <gui_name language="en">DMA_Interrupt_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Block_Gap_Event_Status_Enable_ENUM" high_bit="2" low_bit="2" name="Block_Gap_Event_Status_Enable">
                    <gui_name language="en">Block_Gap_Event_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Transfer_Complete_Status_Enable_ENUM" high_bit="1" low_bit="1" name="Transfer_Complete_Status_Enable">
                    <gui_name language="en">Transfer_Complete_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Complete_Status_Enable_ENUM" high_bit="0" low_bit="0" name="Command_Complete_Status_Enable">
                    <gui_name language="en">Command_Complete_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
            </register>
            <register name="SD0_NORMAL_INTERRUPT_SIGNAL_ENABLE_ERROR_INTERRUPT_SIGNAL_ENABLE" offset="0xe0100038" size="0x4">
                <gui_name language="en">Normal_interrupt_signal_enable_Error_interrupt_signal_enable</gui_name>
                <description language="en">Normal interrupt signal enable register
Error interrupt signal enable register</description>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Ceata_Error_Signal_Enable_ENUM" high_bit="29" low_bit="29" name="Ceata_Error_Signal_Enable">
                    <gui_name language="en">Ceata_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Target_Response_Error_Signal_Enable_ENUM" high_bit="28" low_bit="28" name="Target_Response_Error_Signal_Enable">
                    <gui_name language="en">Target_Response_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_ADMA_Error_Signal_Enable_ENUM" high_bit="25" low_bit="25" name="ADMA_Error_Signal_Enable">
                    <gui_name language="en">ADMA_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Auto_CMD12_Error_Signal_Enable_ENUM" high_bit="24" low_bit="24" name="Auto_CMD12_Error_Signal_Enable">
                    <gui_name language="en">Auto_CMD12_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Current_Limit_Error_Signal_Enable_ENUM" high_bit="23" low_bit="23" name="Current_Limit_Error_Signal_Enable">
                    <gui_name language="en">Current_Limit_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_End_Bit_Error_Signal_Enable_ENUM" high_bit="22" low_bit="22" name="Data_End_Bit_Error_Signal_Enable">
                    <gui_name language="en">Data_End_Bit_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_CRC_Error_Signal_Enable_ENUM" high_bit="21" low_bit="21" name="Data_CRC_Error_Signal_Enable">
                    <gui_name language="en">Data_CRC_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_Timeout_Error_Signal_Enable_ENUM" high_bit="20" low_bit="20" name="Data_Timeout_Error_Signal_Enable">
                    <gui_name language="en">Data_Timeout_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Index_Error_Signal_Enable_ENUM" high_bit="19" low_bit="19" name="Command_Index_Error_Signal_Enable">
                    <gui_name language="en">Command_Index_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_End_Bit_Error_Signal_Enable_ENUM" high_bit="18" low_bit="18" name="Command_End_Bit_Error_Signal_Enable">
                    <gui_name language="en">Command_End_Bit_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_CRC_Error_Signal_Enable_ENUM" high_bit="17" low_bit="17" name="Command_CRC_Error_Signal_Enable">
                    <gui_name language="en">Command_CRC_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Timeout_Error_Signal_Enable_ENUM" high_bit="16" low_bit="16" name="Command_Timeout_Error_Signal_Enable">
                    <gui_name language="en">Command_Timeout_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="Fixed_to_0">
                    <gui_name language="en">Fixed_to_0</gui_name>
                    <description language="en">The HD shall control error Interrupts using the Error Interrupt Signal Enable register.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Boot_terminate_Interrupt_signal_enable_ENUM" high_bit="10" low_bit="10" name="Boot_terminate_Interrupt_signal_enable">
                    <gui_name language="en">Boot_terminate_Interrupt_signal_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Boot_ack_rcv_signal_enable_ENUM" high_bit="9" low_bit="9" name="Boot_ack_rcv_signal_enable">
                    <gui_name language="en">Boot_ack_rcv_signal_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Interrupt_Signal_Enable_ENUM" high_bit="8" low_bit="8" name="Card_Interrupt_Signal_Enable">
                    <gui_name language="en">Card_Interrupt_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Removal_Signal_Enable_ENUM" high_bit="7" low_bit="7" name="Card_Removal_Signal_Enable">
                    <gui_name language="en">Card_Removal_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Insertion_Signal_Enable_ENUM" high_bit="6" low_bit="6" name="Card_Insertion_Signal_Enable">
                    <gui_name language="en">Card_Insertion_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Buffer_Read_Ready_Signal_Enable_ENUM" high_bit="5" low_bit="5" name="Buffer_Read_Ready_Signal_Enable">
                    <gui_name language="en">Buffer_Read_Ready_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Buffer_Write_Ready_Signal_Enable_ENUM" high_bit="4" low_bit="4" name="Buffer_Write_Ready_Signal_Enable">
                    <gui_name language="en">Buffer_Write_Ready_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_DMA_Interrupt_Signal_Enable_ENUM" high_bit="3" low_bit="3" name="DMA_Interrupt_Signal_Enable">
                    <gui_name language="en">DMA_Interrupt_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Block_Gap_Event_Signal_Enable_ENUM" high_bit="2" low_bit="2" name="Block_Gap_Event_Signal_Enable">
                    <gui_name language="en">Block_Gap_Event_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Transfer_Complete_Signal_Enable_ENUM" high_bit="1" low_bit="1" name="Transfer_Complete_Signal_Enable">
                    <gui_name language="en">Transfer_Complete_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Complete_Signal_Enable_ENUM" high_bit="0" low_bit="0" name="Command_Complete_Signal_Enable">
                    <gui_name language="en">Command_Complete_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_AUTO_CMD12_ERROR_STATUS" offset="0xe010003c" size="0x2">
                <gui_name language="en">Auto_CMD12_error_status</gui_name>
                <description language="en">Auto CMD12 error status register</description>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Command_Not_Issued_By_Auto_CMD12_Error_ENUM" high_bit="7" low_bit="7" name="Command_Not_Issued_By_Auto_CMD12_Error">
                    <gui_name language="en">Command_Not_Issued_By_Auto_CMD12_Error</gui_name>
                    <description language="en">Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register.
0 - No Error
1 - Not Issued</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_Index_Error_ENUM" high_bit="4" low_bit="4" name="Auto_CMD12_Index_Error">
                    <gui_name language="en">Auto_CMD12_Index_Error</gui_name>
                    <description language="en">Occurs if the Command Index error occurs in response to a command.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_End_Bit_Error_ENUM" high_bit="3" low_bit="3" name="Auto_CMD12_End_Bit_Error">
                    <gui_name language="en">Auto_CMD12_End_Bit_Error</gui_name>
                    <description language="en">Occurs when detecting that the end bit of command response is 0.
0 - No Error
1 - End Bit Error Generated</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_CRC_Error_ENUM" high_bit="2" low_bit="2" name="Auto_CMD12_CRC_Error">
                    <gui_name language="en">Auto_CMD12_CRC_Error</gui_name>
                    <description language="en">Occurs when detecting a CRC error in the command response.
0 - No Error
1 - CRC Error Generated</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_Timeout_Error_ENUM" high_bit="1" low_bit="1" name="Auto_CMD12_Timeout_Error">
                    <gui_name language="en">Auto_CMD12_Timeout_Error</gui_name>
                    <description language="en">Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless.
0 - No Error
1 - Timeout</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_not_Executed_ENUM" high_bit="0" low_bit="0" name="Auto_CMD12_not_Executed">
                    <gui_name language="en">Auto_CMD12_not_Executed</gui_name>
                    <description language="en">If memory multiple block data transfer is not started due to command
error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless.
0 - Executed
1 - Not Executed</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_CAPABILITIES" offset="0xe0100040" size="0x4">
                <gui_name language="en">Capabilities</gui_name>
                <description language="en">Capabilities register</description>
                <bitField access="Read Only" enumerationId="Capabilities_Spi_block_mode_ENUM" high_bit="30" low_bit="30" name="Spi_block_mode">
                    <gui_name language="en">Spi_block_mode</gui_name>
                    <description language="en">Spi block mode
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Spi_mode_ENUM" high_bit="29" low_bit="29" name="Spi_mode">
                    <gui_name language="en">Spi_mode</gui_name>
                    <description language="en">Spi mode
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_n64_bit_System_Bus_Support_ENUM" high_bit="28" low_bit="28" name="n64_bit_System_Bus_Support">
                    <gui_name language="en">n64_bit_System_Bus_Support</gui_name>
                    <description language="en">1 - supports 64 bit system address
0 - Does not support 64 bit system
address</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Interrupt_mode_ENUM" high_bit="27" low_bit="27" name="Interrupt_mode">
                    <gui_name language="en">Interrupt_mode</gui_name>
                    <description language="en">Interrupt mode
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Voltage_Support_1_8_V_ENUM" high_bit="26" low_bit="26" name="Voltage_Support_1_8_V">
                    <gui_name language="en">Voltage_Support_1_8_V</gui_name>
                    <description language="en">0 - 1.8 V Not Supported
1 - 1.8 V Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Voltage_Support_3_0_V_ENUM" high_bit="25" low_bit="25" name="Voltage_Support_3_0_V">
                    <gui_name language="en">Voltage_Support_3_0_V</gui_name>
                    <description language="en">0 - 3.0 V Not Supported
1 - 3.0 V Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Voltage_Support_3_3_V_ENUM" high_bit="24" low_bit="24" name="Voltage_Support_3_3_V">
                    <gui_name language="en">Voltage_Support_3_3_V</gui_name>
                    <description language="en">0 - 3.3 V Not Supported
1 - 3.3 V Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Suspend_Resume_Support_ENUM" high_bit="23" low_bit="23" name="Suspend_Resume_Support">
                    <gui_name language="en">Suspend_Resume_Support</gui_name>
                    <description language="en">This bit indicates whether the HC supports Suspend / Resume functionality. If this bit is 0, the Suspend and Resume mechanism are not supported and the HD shall not issue either Suspend / Resume commands.
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_SDMA_Support_ENUM" high_bit="22" low_bit="22" name="SDMA_Support">
                    <gui_name language="en">SDMA_Support</gui_name>
                    <description language="en">This bit indicates whether the HC is capable of using DMA to transfer data between system memory and the HC directly.
0 - SDMA Not Supported
1 - SDMA Supported.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_High_Speed_Support_ENUM" high_bit="21" low_bit="21" name="High_Speed_Support">
                    <gui_name language="en">High_Speed_Support</gui_name>
                    <description language="en">This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25Mhz to 50 Mhz (for SD)/ 20MHz to 52MHz (for MMC).
0 - High Speed Not Supported
1 - High Speed Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_ADMA2_Support_ENUM" high_bit="19" low_bit="19" name="ADMA2_Support">
                    <gui_name language="en">ADMA2_Support</gui_name>
                    <description language="en">1 - ADMA2 support.
0 - ADMA2 not support</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Extended_Media_Bus_Support_ENUM" high_bit="18" low_bit="18" name="Extended_Media_Bus_Support">
                    <gui_name language="en">Extended_Media_Bus_Support</gui_name>
                    <description language="en">This bit indicates whether the Host Controller is capable bus.
1 - Extended Media Bus Supported
0 - Extended Media Bus not Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Max_Block_Length_ENUM" high_bit="17" low_bit="16" name="Max_Block_Length">
                    <gui_name language="en">Max_Block_Length</gui_name>
                    <description language="en">This value indicates the maximum block size that the HD can read and write to the buffer in the HC. The buffer shall transfer this block size without wait cycles. Three sizes can be defined as indicated below.
00 - 512 byte
01 - 1024 byte
10 - 2048 byte
11 - 4096 byte</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Base_Clock_Frequency_for_SD_Clock_ENUM" high_bit="13" low_bit="8" name="Base_Clock_Frequency_for_SD_Clock">
                    <gui_name language="en">Base_Clock_Frequency_for_SD_Clock</gui_name>
                    <description language="en">This value indicates the base (maximum) clock frequency for the SD clock. Unit values are 1Mhz. If the real frequency is 16.5 Mhz, the larger value shall be set 010001b (17 Mhz) because the HD uses this value to calculate the clock divider value and it shall not exceed the upper limit of the SD clock frequency. The supported range is 10Mhz to 63 Mhz. If these bits are all 0, the Host System has to get information via another method. Not 0 - 1 Mhz to 63 Mhz
000000b - Get information via another method.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Timeout_Clock_Unit_ENUM" high_bit="7" low_bit="7" name="Timeout_Clock_Unit">
                    <gui_name language="en">Timeout_Clock_Unit</gui_name>
                    <description language="en">This bit shows the unit of base clock frequency used to detect Data Timeout Error.
0 - Khz
1 - Mhz</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="0" name="Timeout_Clock_Frequency">
                    <gui_name language="en">Timeout_Clock_Frequency</gui_name>
                    <description language="en">This bit shows the base clock frequency used to detect Data Timeout Error.
Not 0 - 1Khz to 63Khz or 1Mhz to 63Mhz 000000b - Get Information via another method.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_MAXIMUM_CURRENT_CAPABILITIES" offset="0xe0100048" size="0x4">
                <gui_name language="en">Maximum_current_capabilities</gui_name>
                <description language="en">Maximum current capabilities register</description>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="Maximum_Current_for_1_8V">
                    <gui_name language="en">Maximum_Current_for_1_8V</gui_name>
                    <description language="en">Maximum Current for 1.8V</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="Maximum_Current_for_3_0V">
                    <gui_name language="en">Maximum_Current_for_3_0V</gui_name>
                    <description language="en">Maximum Current for 3.0V</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Maximum_Current_for_3_3V">
                    <gui_name language="en">Maximum_Current_for_3_3V</gui_name>
                    <description language="en">Maximum Current for 3.3V</description>
                </bitField>
            </register>
            <register name="SD0_FORCE_EVENT_FOR_AUTOCMD12_ERROR_STATUS_FORCE_EVENT_REGISTER_FOR_ERROR_INTERRUPT_STATUS" offset="0xe0100050" size="0x4">
                <gui_name language="en">Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status</gui_name>
                <description language="en">Force event register for Auto CMD12 error status register
Force event register for error interrupt status</description>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Vendor_Specific_Error_Status_ENUM" high_bit="31" low_bit="30" name="Force_Event_for_Vendor_Specific_Error_Status">
                    <gui_name language="en">Force_Event_for_Vendor_Specific_Error_Status</gui_name>
                    <description language="en">Additional status bits can be defined in
this register by the vendor.
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Ceata_error_ENUM" high_bit="29" low_bit="29" name="Force_Event_for_Ceata_error">
                    <gui_name language="en">Force_Event_for_Ceata_error</gui_name>
                    <description language="en">Force Event for Ceata Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_event_for_Target_Response_error_ENUM" high_bit="28" low_bit="28" name="Force_event_for_Target_Response_error">
                    <gui_name language="en">Force_event_for_Target_Response_error</gui_name>
                    <description language="en">Force Event for Target Response Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_ADMA_Error_ENUM" high_bit="25" low_bit="25" name="Force_Event_for_ADMA_Error">
                    <gui_name language="en">Force_Event_for_ADMA_Error</gui_name>
                    <description language="en">Force Event for ADMA Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_Error_ENUM" high_bit="24" low_bit="24" name="Force_Event_for_Auto_CMD12_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_Error</gui_name>
                    <description language="en">Force Event for Auto CMD12 Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Current_Limit_Error_ENUM" high_bit="23" low_bit="23" name="Force_Event_for_Current_Limit_Error">
                    <gui_name language="en">Force_Event_for_Current_Limit_Error</gui_name>
                    <description language="en">Force Event for Current Limit Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data_End_Bit_Error_ENUM" high_bit="22" low_bit="22" name="Force_Event_for_Data_End_Bit_Error">
                    <gui_name language="en">Force_Event_for_Data_End_Bit_Error</gui_name>
                    <description language="en">Force Event for Data End Bit Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data_CRC_Error_ENUM" high_bit="21" low_bit="21" name="Force_Event_for_Data_CRC_Error">
                    <gui_name language="en">Force_Event_for_Data_CRC_Error</gui_name>
                    <description language="en">Force Event for Data CRC Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data__Timeout_Error_ENUM" high_bit="20" low_bit="20" name="Force_Event_for_Data__Timeout_Error">
                    <gui_name language="en">Force_Event_for_Data__Timeout_Error</gui_name>
                    <description language="en">Force Event for Data Timeout Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_Index_Error_ENUM" high_bit="19" low_bit="19" name="Force_Event_for_Command_Index_Error">
                    <gui_name language="en">Force_Event_for_Command_Index_Error</gui_name>
                    <description language="en">Force Event for Command Index Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_End_Bit_Error_ENUM" high_bit="18" low_bit="18" name="Force_Event_for_Command_End_Bit_Error">
                    <gui_name language="en">Force_Event_for_Command_End_Bit_Error</gui_name>
                    <description language="en">Force Event for Command End Bit Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_CRC_Error_ENUM" high_bit="17" low_bit="17" name="Force_Event_for_Command_CRC_Error">
                    <gui_name language="en">Force_Event_for_Command_CRC_Error</gui_name>
                    <description language="en">Force Event for Command CRC Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_Timeout_Error_ENUM" high_bit="16" low_bit="16" name="Force_Event_for_Command_Timeout_Error">
                    <gui_name language="en">Force_Event_for_Command_Timeout_Error</gui_name>
                    <description language="en">Force Event for Command Timeout Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_command_not_issued_by_Auto_CMD12_Error_ENUM" high_bit="7" low_bit="7" name="Force_Event_for_command_not_issued_by_Auto_CMD12_Error">
                    <gui_name language="en">Force_Event_for_command_not_issued_by_Auto_CMD12_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_Index_Error_ENUM" high_bit="4" low_bit="4" name="Force_Event_for_Auto_CMD12_Index_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_Index_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_End_bit_Error_ENUM" high_bit="3" low_bit="3" name="Force_Event_for_Auto_CMD12_End_bit_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_End_bit_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_CRC_Error_ENUM" high_bit="2" low_bit="2" name="Force_Event_for_Auto_CMD12_CRC_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_CRC_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_timeout_Error_ENUM" high_bit="1" low_bit="1" name="Force_Event_for_Auto_CMD12_timeout_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_timeout_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_NOT_Executed_ENUM" high_bit="0" low_bit="0" name="Force_Event_for_Auto_CMD12_NOT_Executed">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_NOT_Executed</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
            </register>
            <register name="SD0_ADMA_ERROR_STATUS" offset="0xe0100054" size="0x2">
                <gui_name language="en">ADMA_error_status</gui_name>
                <description language="en">ADMA error status register</description>
                <bitField access="Read Write" enumerationId="ADMA_error_status_ADMA_Length_Mismatch_Error_ENUM" high_bit="2" low_bit="2" name="ADMA_Length_Mismatch_Error">
                    <gui_name language="en">ADMA_Length_Mismatch_Error</gui_name>
                    <description language="en">This error occurs in the following 2 cases.
1. While Block Count Enable being set, the total
data length specified by the
Descriptor table is different from that specified by
the Block Count and
Block Length.
2. Total data length can not be divided by the block
length.
1 - Error
0 - No error</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ADMA_error_status_ADMA_Error_State_ENUM" high_bit="1" low_bit="0" name="ADMA_Error_State">
                    <gui_name language="en">ADMA_Error_State</gui_name>
                    <description language="en">This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates "10" because ADMA never stops in this state.
D01 - D00 : ADMA Error State when
error is occurred
Contents of SYS_SDR register
00 - ST_STOP (Stop DMA) Points next of the error
descriptor
01 - ST_FDS (Fetch Descriptor) Points the error
descriptor
10 - Never set this state (Not used)
11 - ST_TFR (Transfer Data) Points the next of the
error descriptor</description>
                </bitField>
            </register>
            <register name="SD0_ADMA_SYSTEM_ADDRESS" offset="0xe0100058" size="0x4">
                <gui_name language="en">ADMA_system_address</gui_name>
                <description language="en">ADMA system address register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ADMA_System_Address">
                    <gui_name language="en">ADMA_System_Address</gui_name>
                    <description language="en">This register holds byte address of executing
command of the Descriptor table.
32-bit Address Descriptor uses lower 32-
bit of this register. At the start of ADMA,
the Host Driver shall set start address of
the Descriptor table. The ADMA
increments this register address, which
points to next line, when every fetching a
Descriptor line. When the ADMA Error
Interrupt is generated, this register shall
hold valid Descriptor address depending
on the ADMA state. The Host Driver shall
program Descriptor Table on 32-bit
boundary and set 32-bit boundary
address to this register. ADMA2 ignores
lower 2-bit of this register and assumes it
to be 00b.
32-bit Address ADMA Register Value 32-
bit System Address
0x00000000 0x00000000
0x00000004 0x00000004
to
0xFFFFFFFC 0xFFFFFFFC</description>
                </bitField>
            </register>
            <register name="SD0_BOOT_TIMEOUT_CONTROL" offset="0xe0100060" size="0x4">
                <gui_name language="en">Boot_Timeout_control</gui_name>
                <description language="en">Boot Timeout control register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Boot_Data_Timeout_Counter_Value">
                    <gui_name language="en">Boot_Data_Timeout_Counter_Value</gui_name>
                    <description language="en">This value determines the interval by
which DAT line time-outs are detected
during boot operation for MMC3.31
card.
The value is in number of sd clock.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SD0_DEBUG_SELECTION" offset="0xe0100064" size="0x2">
                <gui_name language="en">Debug_Selection</gui_name>
                <description language="en">Debug Selection Register</description>
                <bitField access="Write Only" enumerationId="Debug_Selection_Debug_sel_ENUM" high_bit="0" low_bit="0" name="Debug_sel">
                    <gui_name language="en">Debug_sel</gui_name>
                    <description language="en">1- cmd register, Interrupt status, transmitter
module, ahb_iface module and clk
sdcard signals are probed out.
0 - receiver module and fifo_ctrl module
signals are probed out</description>
                </bitField>
            </register>
            <register name="SD0_SPI_INTERRUPT_SUPPORT" offset="0xe01000f0" size="0x2">
                <gui_name language="en">SPI_interrupt_support</gui_name>
                <description language="en">SPI interrupt support register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="SPI_INT_SUPPORT">
                    <gui_name language="en">SPI_INT_SUPPORT</gui_name>
                    <description language="en">This bit is set to indicate the assertion of interrupts in the SPI mode at any time, irrespective of the status of the card select (CS) line. If this bit is zero,
then SDIO card can only assert the interrupt line in the SPI mode when the CS line is asserted.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD0_SLOT_INTERRUPT_STATUS_HOST_CONTROLLER_VERSION" offset="0xe01000fc" size="0x4">
                <gui_name language="en">Slot_interrupt_status_Host_controller_version</gui_name>
                <description language="en">Slot interrupt status register and
Host controller version register</description>
                <bitField access="Read Only" enumerationId="Slot_interrupt_status_Host_controller_version_Specification_Version_Number_ENUM" high_bit="31" low_bit="24" name="Specification_Version_Number">
                    <gui_name language="en">Specification_Version_Number</gui_name>
                    <description language="en">This status indicates the Host Controller Spec. Version. The upper and lower 4-bits indicate the version. 00 - SD Host Specification version
1.0
01 - SD Host Specification version 2.00 including only the feature of theTest Register
others - Reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="Vendor_Version_Number">
                    <gui_name language="en">Vendor_Version_Number</gui_name>
                    <description language="en">This status is reserved for the vendor version number. The HD should not use this status.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Interrupt_Signal_for_Each_Slot">
                    <gui_name language="en">Interrupt_Signal_for_Each_Slot</gui_name>
                    <description language="en">These status bit indicate the logical OR of Interrupt signal and Wakeup
signal for each slot. A maximum of 8 slots can be defined. If one interrupt
signal is associated with multiple slots. the HD can know which interrupt
is generated by reading these status bits. By a power on reset or by Software Reset For All, the Interrupt signal shall be de asserted and this
status shall read 00h.
Bit 00 - Slot 1
Bit 01 - Slot 2
Bit 02 - Slot 3
----- -----
Bit 07 - Slot 8</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SD1" name="SD1" offset="0xe0101000">
            <gui_name language="en">sd1</gui_name>
            <description language="en">sd1</description>
            <register name="SD1_SDMA_SYSTEM_ADDRESS_REGISTER" offset="0xe0101000" size="0x4">
                <gui_name language="en">SDMA_system_address_register</gui_name>
                <description language="en">This register contains the system memory address for a DMA transfer. When the Host Controller (HC) stops a DMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing (i.e after a transaction has stopped). Read operations during transfer return an invalid value. The Host Driver (HD) shall initialize this register before starting a DMA transaction. After DMA has stopped, the next system address of the next contiguous data position can be read from this register. The DMA transfer waits at every boundary specified by the Host DMA Buffer Size in the Block Size register. The Host Controller generates DMA Interrupt to request to update this register. The HD sets the next system address of the next data position to this register. When most upper byte of this register (003h) is written, the HC restart the DMA transfer. When restarting DMA by the resume command or by setting Continue Request in the Block Gap Control register, the HC shall start at the next contiguous address stored here in the System Address register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="SDMA_System_Address">
                    <gui_name language="en">SDMA_System_Address</gui_name>
                    <description language="en">Watchdog enable - if set, the watchdog is enabled and can generate any signals that are enabled.</description>
                </bitField>
            </register>
            <register name="SD1_BLOCK_SIZE_BLOCK_COUNT" offset="0xe0101004" size="0x4">
                <gui_name language="en">Block_Size_Block_Count</gui_name>
                <description language="en">Block size register
Block count register</description>
                <bitField access="Read Write" enumerationId="Block_Size_Block_Count_Blocks_Count_for_Current_Transfer_ENUM" high_bit="31" low_bit="16" name="Blocks_Count_for_Current_Transfer">
                    <gui_name language="en">Blocks_Count_for_Current_Transfer</gui_name>
                    <description language="en">This register is enabled when Block Count Enable in the Transfer
Mode register is set to 1 and is valid only for multiple block transfers. The HC decrements the block count after each block transfer and stops when the count reaches zero. It can be accessed only if no transaction is
executing (i.e after a transaction has stopped). Read operations
during transfer return an invalid value and write operations shall
be ignored. When saving transfer context as a result of Suspend command, the number of blocks yet to be transferred can be determined
by reading this register. When restoring transfer context prior to
issuing a Resume command, the HD shall restore the previously
save block count.
0000h - Stop Count
0001h - 1 block
0002h - 2 blocks
--- ---
FFFFh - 65535 blocks</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Block_Size_Block_Count_Host_SDMA_Buffer_Size_ENUM" high_bit="14" low_bit="12" name="Host_SDMA_Buffer_Size">
                    <gui_name language="en">Host_SDMA_Buffer_Size</gui_name>
                    <description language="en">Counter clock prescale - selects the prescaler division ratio:
00 = pclk divided by 8
01 = pclk divided by 64
10 = pclk divided by 256
11 = pclk divided by 4096
Note: If a restart signal is received the prescaler should be reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Block_Size_Block_Count_Transfer_Block_Size_ENUM" high_bit="11" low_bit="0" name="Transfer_Block_Size">
                    <gui_name language="en">Transfer_Block_Size</gui_name>
                    <description language="en">This register specifies the block size for block data transfers for CMD17, CMD18, CMD24, CMD25, and CMD53. It can be accessed only if no transaction is executing (i.e after a transaction has stopped). Read operations during transfer return an invalid value and write operations shall be ignored.
0000h - No Data Transfer
0001h - 1 Byte
0002h - 2 Bytes
0003h - 3 Bytes
0004h - 4 Bytes
--- ---
01FFh - 511 Bytes
0200h - 512 Bytes
--- ---
0800h - 2048 Bytes</description>
                </bitField>
            </register>
            <register name="SD1_ARGUMENT" offset="0xe0101008" size="0x4">
                <gui_name language="en">Argument</gui_name>
                <description language="en">Argument register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Command_Argument">
                    <gui_name language="en">Command_Argument</gui_name>
                    <description language="en">The SD Command Argument is specified as bit39-8 of Command-Format.</description>
                </bitField>
            </register>
            <register name="SD1_TRANSFER_MODE_COMMAND" offset="0xe010100c" size="0x4">
                <gui_name language="en">Transfer_Mode_Command</gui_name>
                <description language="en">Transfer mode register
Command register</description>
                <bitField access="Read Write" high_bit="28" low_bit="24" name="Command_Index">
                    <gui_name language="en">Command_Index</gui_name>
                    <description language="en">This bit shall be set to the command number (CMD0-63, ACMD0-63).</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Command_Type_ENUM" high_bit="23" low_bit="22" name="Command_Type">
                    <gui_name language="en">Command_Type</gui_name>
                    <description language="en">There are three types of special commands. Suspend, Resume and Abort. These bits shall bet set to 00b for all other commands. Suspend Command If the Suspend command succeeds, the HC shall assume the SD Bus has been released and that it is possible to issue the next command which uses the DAT line. The HC shall de-assert Read Wait for read transactions and stop checking busy for write transactions. The Interrupt cycle shall start, in 4-bit mode. If the Suspend command fails, the HC shall maintain its current state. and the HD shall restart the transfer by setting Continue Request in the Block Gap Control Register. Resume Command The HD re-starts the data transfer by restoring the registers in the range of 000-00Dh. The HC shall check for busy before starting write transfers. Abort Command If this command is set when executing a read transfer, the HC shall stop reads to the buffer. If this command is set when executing a write transfer, the HC shall stop driving the DAT line. After issuing the Abort command, the HD should issue a software reset
00b - Normal
01b - Suspend
10b - Resume
11b - Abort</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Data_Present_Select_ENUM" high_bit="21" low_bit="21" name="Data_Present_Select">
                    <gui_name language="en">Data_Present_Select</gui_name>
                    <description language="en">This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. If is set to 0 for the following:
1. Commands using only CMD line (ex. CMD52)
2. Commands with no data transfer but using busy signal on DAT[0]
line (R1b or R5b ex. CMD38)
3. Resume Command
0 - No Data Present
1 - Data Present</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Command_Index_Check_Enable_ENUM" high_bit="20" low_bit="20" name="Command_Index_Check_Enable">
                    <gui_name language="en">Command_Index_Check_Enable</gui_name>
                    <description language="en">If this bit is set to 1, the HC shall check the index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Command_CRC_Check_Enable_ENUM" high_bit="19" low_bit="19" name="Command_CRC_Check_Enable">
                    <gui_name language="en">Command_CRC_Check_Enable</gui_name>
                    <description language="en">If this bit is set to 1, the HC shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Response_Type_Select_ENUM" high_bit="17" low_bit="16" name="Response_Type_Select">
                    <gui_name language="en">Response_Type_Select</gui_name>
                    <description language="en">Response Type Select
00 - No Response
01 - Response length 136
10 - Response length 48
11 - Response length 48 check
Busy after response</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Multi_Single_Block_Select_ENUM" high_bit="5" low_bit="5" name="Multi_Single_Block_Select">
                    <gui_name language="en">Multi_Single_Block_Select</gui_name>
                    <description language="en">This bit enables multiple block DAT line data transfers.
0 - Single Block
1 - Multiple Block</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Data_Transfer_Direction_Select_ENUM" high_bit="4" low_bit="4" name="Data_Transfer_Direction_Select">
                    <gui_name language="en">Data_Transfer_Direction_Select</gui_name>
                    <description language="en">This bit defines the direction of DAT line data transfers.
0 - Write (Host to Card)
1 - Read (Card to Host)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Auto_CMD12_Enable_ENUM" high_bit="2" low_bit="2" name="Auto_CMD12_Enable">
                    <gui_name language="en">Auto_CMD12_Enable</gui_name>
                    <description language="en">Multiple block transfers for memory require CMD12 to stop the ransaction. When this bit is set to 1, the HC shall issue CMD12 utomatically when last block transfer is completed. The HD shall not set this bit to issue commands that do not require CMD12 to stop data transfer.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_Block_Count_Enable_ENUM" high_bit="1" low_bit="1" name="Block_Count_Enable">
                    <gui_name language="en">Block_Count_Enable</gui_name>
                    <description language="en">This bit is used to enable the Block count register, which is only relevant for multiple block transfers. When this bit is 0, the Block Count register is disabled, which is useful in executing an infinite transfer.
0 - Disable
1 - Enable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Transfer_Mode_Command_DMA_Enable_ENUM" high_bit="0" low_bit="0" name="DMA_Enable">
                    <gui_name language="en">DMA_Enable</gui_name>
                    <description language="en">DMA can be enabled only if DMA Support bit in the Capabilities register is set. If this bit is set to 1, a DMA operation shall begin when the HD writes to the upper byte of Command register (00Fh).
0 - Disable
1 - Enable</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_RESPONSE0" offset="0xe0101010" size="0x4">
                <gui_name language="en">Response0</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_RESPONSE1" offset="0xe0101014" size="0x4">
                <gui_name language="en">Response1</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_RESPONSE2" offset="0xe0101018" size="0x4">
                <gui_name language="en">Response2</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_RESPONSE3" offset="0xe010101c" size="0x4">
                <gui_name language="en">Response3</gui_name>
                <description language="en">Response register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="Command_Response">
                    <gui_name language="en">Command_Response</gui_name>
                    <description language="en">command responses registers</description>
                </bitField>
            </register>
            <register name="SD1_BUFFER_DATA_PORT" offset="0xe0101020" size="0x4">
                <gui_name language="en">Buffer_Data_Port</gui_name>
                <description language="en">Buffer data port register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Buffer_Data">
                    <gui_name language="en">Buffer_Data</gui_name>
                    <description language="en">The Host Controller Buffer can be accessed through this 32-bit Data Port Register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_PRESENT_STATE" offset="0xe0101024" size="0x4">
                <gui_name language="en">Present_State</gui_name>
                <description language="en">Present State register</description>
                <bitField access="Read Only" high_bit="24" low_bit="24" name="CMD_Line_Signal_Level">
                    <gui_name language="en">CMD_Line_Signal_Level</gui_name>
                    <description language="en">This status is used to check CMD line level to recover from errors, and for debugging.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="DAT_Bit3_Bit0_Line_Signal_Level">
                    <gui_name language="en">DAT_Bit3_Bit0_Line_Signal_Level</gui_name>
                    <description language="en">This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT[0].
D23 - DAT[3]
D22 - DAT[2]
D21 - DAT[1]
D20 - DAT[0]</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Write_Protect_Switch_Pin_Level_ENUM" high_bit="19" low_bit="19" name="Write_Protect_Switch_Pin_Level">
                    <gui_name language="en">Write_Protect_Switch_Pin_Level</gui_name>
                    <description language="en">The Write Protect Switch is supported for memory and combo cards. This bit reflects the SDWP# pin.
0 - Write protected (SDWP# = 1)
1 - Write enabled (SDWP# = 0)</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Card_Detect_Pin_Level_ENUM" high_bit="18" low_bit="18" name="Card_Detect_Pin_Level">
                    <gui_name language="en">Card_Detect_Pin_Level</gui_name>
                    <description language="en">This bit reflects the inverse value of the SDCD# pin.
0 - No Card present (SDCD# = 1)
1 - Card present (SDCD# = 0)</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Card_State_Stable_ENUM" high_bit="17" low_bit="17" name="Card_State_Stable">
                    <gui_name language="en">Card_State_Stable</gui_name>
                    <description language="en">This bit is used for testing. If it is 0, the Card Detect Pin Level is not stable. If this bit is set to 1, it means the Card Detect Pin Level is stable. The Software Reset For All in the Software Reset Register shall not affect this bit.
0 - Reset of Debouncing
1 - No Card or Inserted</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Card_Inserted_ENUM" high_bit="16" low_bit="16" name="Card_Inserted">
                    <gui_name language="en">Card_Inserted</gui_name>
                    <description language="en">This bit indicates whether a card has been inserted. Changing from 0 to 1 generates a Card Insertion interrupt in the Normal Interrupt Status register and changing from 1 to 0 generates a Card Removal Interrupt in the Normal Interrupt Status register. The Software Reset For All in the Software Reset register shall not affect this bit. If a Card is removed while its power is on and its clock is oscillating, the HC shall clear SD Bus Power in the Power Control register and SD Clock Enable in the Clock control register. In addition the HD should clear the HC by the Software Reset For All in Software register. The card detect is active regardless of the SD Bus Power.
0 - Reset or Debouncing or No Card
1 - Card Inserted</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Buffer_Read_Enable_ENUM" high_bit="11" low_bit="11" name="Buffer_Read_Enable">
                    <gui_name language="en">Buffer_Read_Enable</gui_name>
                    <description language="en">This status is used for non-DMA read transfers. This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt.
0 - Read Disable
1 - Read Enable.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Buffer_Write_Enable_ENUM" high_bit="10" low_bit="10" name="Buffer_Write_Enable">
                    <gui_name language="en">Buffer_Write_Enable</gui_name>
                    <description language="en">This status is used for non-DMA write transfers. This read only flag indicates if space is available for write data. If this bit is 1, data can be written to the buffer. A change of this bit from 1 to 0 occurs when all the block data is written to the buffer. A change of this bit from 0 to 1 occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt.
0 - Write Disable
1 - Write Enable.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Read_Transfer_Active_ENUM" high_bit="9" low_bit="9" name="Read_Transfer_Active">
                    <gui_name language="en">Read_Transfer_Active</gui_name>
                    <description language="en">This status is used for detecting completion of a read transfer.
This bit is set to 1 for either of the following conditions:
1. After the end bit of the read command
2. When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer
This bit is cleared to 0 for either of the following
conditions:
1. When the last data block as specified by block length is transferred to the system.
2. When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop At Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0.
1 - Transferring data
0 - No valid data</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Write_Transfer_Active_ENUM" high_bit="8" low_bit="8" name="Write_Transfer_Active">
                    <gui_name language="en">Write_Transfer_Active</gui_name>
                    <description language="en">This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the HC. This bit is set in either of the following cases:
1. After the end bit of the write command.
2. When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer.
This bit is cleared in either of the following cases:
1. After getting the CRC status of the last data block as specified by the transfer count (Single or Multiple)
2. After getting a CRC status of any block where data transmission is about to be stopped by a Stop At Block Gap Request.
During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop At Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.
1 - transferring data
0 - No valid data</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_DAT_Line_Active_ENUM" high_bit="2" low_bit="2" name="DAT_Line_Active">
                    <gui_name language="en">DAT_Line_Active</gui_name>
                    <description language="en">This bit indicates whether one of the DAT line on SD bus is in use.
1 - DAT line active
0 - DAT line inactive</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Present_State_Command_Inhibit_DAT_ENUM" high_bit="1" low_bit="1" name="Command_Inhibit_DAT">
                    <gui_name language="en">Command_Inhibit_DAT</gui_name>
                    <description language="en">This status bit is generated if either the DAT Line Active or the Read transfer Active is set to 1. If this bit is 0, it indicates the HC can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). Changing from 1 to 0 generates a Transfer Complete interrupt in the Normal interrupt status register.
Note: The SD Host Driver can save registers in the range of 000-00Dh for a suspend transaction after this bit has changed from 1 to 0.
1 - cannot issue command which uses the DAT line
0 - Can issue command which uses the DAT line</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Command_Inhibit_CMD">
                    <gui_name language="en">Command_Inhibit_CMD</gui_name>
                    <description language="en">If this bit is 0, it indicates the CMD line is not in use and the HC can issue a SD command using the CMD line. This bit is set immediately after the Command register (00Fh) is written. This bit is cleared when the command response is received. Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the HC cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. Status issuing Auto CMD12 is not read from this bit.</description>
                </bitField>
            </register>
            <register name="SD1_HOST_CONTROL_POWER_CONTROL_BLOCK_GAP_CONTROL_WAKEUP_CONTROL" offset="0xe0101028" size="0x4">
                <gui_name language="en">Host_control_Power_control_Block_Gap_Control_Wakeup_control</gui_name>
                <description language="en">Host control register
Power control register
Block gap control register
Wake-up control register</description>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_SD_Card_Removal_ENUM" high_bit="26" low_bit="26" name="Wakeup_Event_Enable_On_SD_Card_Removal">
                    <gui_name language="en">Wakeup_Event_Enable_On_SD_Card_Removal</gui_name>
                    <description language="en">This bit enables wakeup event via
Card Removal assertion in the
Normal Interrupt Status register.
FN_WUS (Wake up Support) in
CIS does not affect this bit.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_SD_Card_Insertion_ENUM" high_bit="25" low_bit="25" name="Wakeup_Event_Enable_On_SD_Card_Insertion">
                    <gui_name language="en">Wakeup_Event_Enable_On_SD_Card_Insertion</gui_name>
                    <description language="en">This bit enables wakeup event via Card Insertion assertion in the Normal Interrupt Status register. FN_WUS (Wake up Support) in CIS does not affect this bit.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_Card_Interrupt_ENUM" high_bit="24" low_bit="24" name="Wakeup_Event_Enable_On_Card_Interrupt">
                    <gui_name language="en">Wakeup_Event_Enable_On_Card_Interrupt</gui_name>
                    <description language="en">This bit enables wakeup event via
Card Interrupt assertion in the
Normal Interrupt Status register.
This bit can be set to 1 if FN_WUS
(Wake Up Support) in CIS is set to
1.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="Interrupt_At_Block_Gap">
                    <gui_name language="en">Interrupt_At_Block_Gap</gui_name>
                    <description language="en">This bit is valid only in 4-bit mode of the SDIO
card and selects a sample point in the interrupt
cycle. Setting to 1 enables interrupt detection at
the block gap for a multiple block transfer. If the
SD card cannot signal an interrupt during a multiple
block transfer, this bit should be set to 0.
When the HD detects an SD card insertion, it shall
set this bit according to the CCCR of the SDIO
card.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Read_Wait_Control_ENUM" high_bit="18" low_bit="18" name="Read_Wait_Control">
                    <gui_name language="en">Read_Wait_Control</gui_name>
                    <description language="en">The read wait function is optional for SDIO cards.
If the card supports read wait, set this bit to
enable use of the read wait protocol to stop read
data using DAT[2] line. Otherwise the HC has to
stop the SD clock to hold read data, which
restricts commands generation. When the HD
detects an SD card insertion, it shall set this bit
according to the CCCR of the SDIO card. If the
card does not support read wait, this bit shall
never be set to 1 otherwise DAT line conflict may
occur. If this bit is set to 0, Suspend / Resume
cannot be supported
1 - Enable Read Wait Control
0 - Disable Read Wait Control</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Continue_Request_ENUM" high_bit="17" low_bit="17" name="Continue_Request">
                    <gui_name language="en">Continue_Request</gui_name>
                    <description language="en">This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request. To
cancel stop at the block gap, set Stop At block
Gap Request to 0 and set this bit to restart the
transfer.
The HC automatically clears this bit in either of
the following cases:
1) In the case of a read transaction, the DAT Line
Active changes from 0 to 1 as a read transaction
restarts.
2) In the case of a write transaction, the Write
transfer active changes from 0 to 1 as the write
transaction restarts.
Therefore it is not necessary for Host driver to set
this bit to 0. If Stop At Block Gap Request is set to
1, any write to this bit is ignored.
1 - Restart
0 - Ignored</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Stop_At_Block_Gap_Request_ENUM" high_bit="16" low_bit="16" name="Stop_At_Block_Gap_Request">
                    <gui_name language="en">Stop_At_Block_Gap_Request</gui_name>
                    <description language="en">This bit is used to stop executing a transaction at the next block gap for non- DMA,SDMA and ADMA transfers. Until the transfer complete is set
to 1, indicating a transfer completion the HD shall leave this bit set to 1. Clearing both the Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. Read Wait is used to stop the read transaction at the block gap. The HC shall honour Stop At Block Gap Request for write transfers, but for read transfers it requires that the SD card support Read Wait. Therefore the HD shall not set this bit during read transfers unless the SD card supports Read Wait and has set Read Wait Control to 1. In case of write transfers in which the HD writes data to the Buffer Data Port register, the HD shall set this bit after all block data is written. If this bit is set to 1, the HD shall not write data to Buffer data port register. This bit affects Read Transfer Active, Write Transfer Active, DAT line active and Command Inhibit (DAT) in the Present State register.
1 - Stop
0 - Transfer</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_SD_Bus_Voltage_Select_ENUM" high_bit="11" low_bit="9" name="SD_Bus_Voltage_Select">
                    <gui_name language="en">SD_Bus_Voltage_Select</gui_name>
                    <description language="en">By setting these bits, the HD selects the voltage level for the SD card. Before setting this register, the HD shall check the voltage support bits
in the capabilities register. If an unsupported voltage is selected, the
Host System shall not supply SD bus voltage
111b - 3.3 Flattop.)
110b - 3.0 V(Typ.)
101b - 1.8 V(Typ.)
100b - 000b - Reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_SD_Bus_Power_ENUM" high_bit="8" low_bit="8" name="SD_Bus_Power">
                    <gui_name language="en">SD_Bus_Power</gui_name>
                    <description language="en">Before setting this bit, the SD host driver shall set SD Bus Voltage Select. If the HC detects the No Card State, this bit shall be cleared.
1 - Power on
0 - Power off</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Card_detect_signal_detetction_ENUM" high_bit="7" low_bit="7" name="Card_detect_signal_detetction">
                    <gui_name language="en">Card_detect_signal_detetction</gui_name>
                    <description language="en">This bit selects source for card detection.
1- The card detect test level is selected
0 -SDCD# is selected (for normal use)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Card_Detect_Test_Level_ENUM" high_bit="6" low_bit="6" name="Card_Detect_Test_Level">
                    <gui_name language="en">Card_Detect_Test_Level</gui_name>
                    <description language="en">This bit is enabled while the Card Detect Signal Selection is set to 1 and it
indicates card inserted or not. Generates (card ins or card removal) interrupt when the normal int sts enable bit is set.
1 - Card Inserted
0 - No Card</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_DMA_Select_ENUM" high_bit="4" low_bit="3" name="DMA_Select">
                    <gui_name language="en">DMA_Select</gui_name>
                    <description language="en">One of supported DMA modes can be selected. The host driver shall check support of DMA modes by referring the Capabilities register.
00 - SDMA is selected
01 - 32-bit Address ADMA1 is selected
10 -32-bit Address ADMA2 is selected
11 - 64-bit Address ADMA2 is selected</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_High_Speed_Enable_ENUM" high_bit="2" low_bit="2" name="High_Speed_Enable">
                    <gui_name language="en">High_Speed_Enable</gui_name>
                    <description language="en">This bit is optional. Before setting this bit, the HD shall check the High Speed Support in the capabilities register. If this bit is set to 0 (default), the HC outputs CMD line and DAT lines at the falling edge of the SD clock (up to 25 MHz/20MHz for MMC). If this bit is set to 1, the HC outputs CMD line and DAT lines at the rising edge of the SD clock (up to 50 MHz for SD/52MHz for MMC)
1 - High Speed Mode
0 - Normal Speed Mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Data_Transfer_Width_SD1_or_SD4_ENUM" high_bit="1" low_bit="1" name="Data_Transfer_Width_SD1_or_SD4">
                    <gui_name language="en">Data_Transfer_Width_SD1_or_SD4</gui_name>
                    <description language="en">This bit selects the data width of the HC. The HD shall select it to match the data width of the SD card.
1 - 4 bit mode
0 - 1 bit mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Host_control_Power_control_Block_Gap_Control_Wakeup_control_LED_Control_ENUM" high_bit="0" low_bit="0" name="LED_Control">
                    <gui_name language="en">LED_Control</gui_name>
                    <description language="en">This bit is used to caution the user not to remove the card while the SD card is being accessed. If the software is going to issue multiple SD commands, this bit can be set during all transactions. It is not necessary to change for each transaction.
1 - LED on
0 - LED off</description>
                </bitField>
            </register>
            <register name="SD1_CLOCK_CONTROL_TIMEOUT_CONTROL_SOFTWARE_RESET" offset="0xe010102c" size="0x4">
                <gui_name language="en">Clock_Control_Timeout_control_Software_reset</gui_name>
                <description language="en">Clock Control register
Timeout control register
Software reset register</description>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_DAT_Line_ENUM" high_bit="26" low_bit="26" name="Software_Reset_for_DAT_Line">
                    <gui_name language="en">Software_Reset_for_DAT_Line</gui_name>
                    <description language="en">Only part of data circuit is reset. The following registers and bits are cleared by this bit:
Buffer Data Port Register
Buffer is cleared and Initialized.
Present State register
Buffer read Enable
Buffer write Enable
Read Transfer Active
Write Transfer Active
DAT Line Active
Command Inhibit (DAT)
Block Gap Control register
Continue Request
Stop At Block Gap Request
Normal Interrupt Status register
Buffer Read Ready
Buffer Write Ready
Block Gap Event
Transfer Complete
1 - Reset
0 - Work</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_CMD_Line_ENUM" high_bit="25" low_bit="25" name="Software_Reset_for_CMD_Line">
                    <gui_name language="en">Software_Reset_for_CMD_Line</gui_name>
                    <description language="en">Only part of command circuit is reset. The following registers and bits are cleared by this bit:
Present State register
Command Inhibit (CMD)
Normal Interrupt Status register
Command Complete
1 - Reset
0 - Work</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_All_ENUM" high_bit="24" low_bit="24" name="Software_Reset_for_All">
                    <gui_name language="en">Software_Reset_for_All</gui_name>
                    <description language="en">This reset affects the entire HC except for the card detection circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when capabilities registers are valid and the HD
can read them. Additional use of Software Reset For All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be re initialized by the HD.
1 - Reset
0 - Work</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Data_Timeout_Counter_Value__ENUM" high_bit="19" low_bit="16" name="Data_Timeout_Counter_Value_">
                    <gui_name language="en">Data_Timeout_Counter_Value_</gui_name>
                    <description language="en">This value determines the interval by which DAT line time-outs are detected. Refer to the Data Time-out Error in the Error Interrupt Status register for information on factors that dictate time-out generation. Time-out clock frequency will be generated by dividing the sdclockTMCLK by this value. When setting this register, prevent inadvertent time-out events by clearing the Data
Time-out Error Status Enable (in the Error Interrupt Status Enable register)
1111 - Reserved
1110 - TMCLK * 2^27
------------------------------
------------------------------
0001 - TMCLK * 2^14
0000 - TMCLK * 2^13</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_SDCLK_Frequency_Select_ENUM" high_bit="15" low_bit="8" name="SDCLK_Frequency_Select">
                    <gui_name language="en">SDCLK_Frequency_Select</gui_name>
                    <description language="en">This register is used to select the frequency of the SDCLK pin. The frequency is not programmed directly; rather this register holds the divisor of the Base Clock Frequency For SD clock in the capabilities register. Only the following settings are allowed.
80h - base clock divided by 256
40h - base clock divided by 128
20h - base clock divided by 64
10h - base clock divided by 32
08h - base clock divided by 16
04h - base clock divided by 8
02h - base clock divided by 4
01h - base clock divided by 2
00h - base clock(10MHz-63MHz)
Setting 00h specifies the highest frequency of the SD Clock. When setting multiple bits, the most significant bit is used as the divisor. But multiple bits should not be set. The two default divider values can be calculated by the frequency that is defined by the Base Clock Frequency For SD Clock in the Capabilities register.
1) 25 MHz divider value
2) 400 KHz divider value
The frequency of the SDCLK is set by the following formula:
Clock Frequency = (Baseclock) / divisor.
Thus choose the smallest possible divisor which results in a clock frequency that is less than or equal to the target frequency.
Maximum Frequency for SD = 50Mhz (base clock)
Maximum Frequency for MMC = 52Mhz (base clock)
Minimum Frequency = 195.3125Khz (50Mhz / 256), same calc for MMC also</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_SD_Clock_Enable_ENUM" high_bit="2" low_bit="2" name="SD_Clock_Enable">
                    <gui_name language="en">SD_Clock_Enable</gui_name>
                    <description language="en">The HC shall stop SDCLK when writing this bit to 0. SDCLK frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped (Stop at SDCLK = 0). If the HC detects the No Card state, this bit shall be cleared.
1 - Enable
0 - Disable</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Clock_Control_Timeout_control_Software_reset_Internal_Clock_Stable_ENUM" high_bit="1" low_bit="1" name="Internal_Clock_Stable">
                    <gui_name language="en">Internal_Clock_Stable</gui_name>
                    <description language="en">This bit is set to 1 when SD clock is stable after writing to Internal Clock Enable in this register to 1. The SD Host Driver shall wait to set SD Clock Enable until this bit is set to 1.
Note: This is useful when using PLL for a clock oscillator that requires setup time.
1 - Ready
0 - Not Ready</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Clock_Control_Timeout_control_Software_reset_Internal_Clock_Enable_ENUM" high_bit="0" low_bit="0" name="Internal_Clock_Enable">
                    <gui_name language="en">Internal_Clock_Enable</gui_name>
                    <description language="en">This bit is set to 0 when the HD is not using the HC or the HC awaits a wakeup event. The HC should stop its internal clock to go very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection.
1 - Oscillate
0 - Stop</description>
                </bitField>
            </register>
            <register name="SD1_NORMAL_INTERRUPT_STATUS_ERROR_INTERRUPT_STATUS" offset="0xe0101030" size="0x4">
                <gui_name language="en">Normal_interrupt_status_Error_interrupt_status</gui_name>
                <description language="en">Normal interrupt status register
Error interrupt status register</description>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Ceata_Error_Status_ENUM" high_bit="29" low_bit="29" name="Ceata_Error_Status">
                    <gui_name language="en">Ceata_Error_Status</gui_name>
                    <description language="en">Occurs when ATA command termination has occured due to an error condition the device has encountered.
0 - no error
1 - error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Target_Response_error_ENUM" high_bit="28" low_bit="28" name="Target_Response_error">
                    <gui_name language="en">Target_Response_error</gui_name>
                    <description language="en">Occurs when detecting ERROR in m_hresp(dma transaction)
0 - no error
1 - error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_ADMA_Error_ENUM" high_bit="25" low_bit="25" name="ADMA_Error">
                    <gui_name language="en">ADMA_Error</gui_name>
                    <description language="en">This bit is set when the Host Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the ADMA Error Status Register.
1- Error
0 -No error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Auto_CMD12_Error_ENUM" high_bit="24" low_bit="24" name="Auto_CMD12_Error">
                    <gui_name language="en">Auto_CMD12_Error</gui_name>
                    <description language="en">Occurs when detecting that one of the bits in Auto CMD12 Error Status register has changed from 0 to 1. This bit is set to 1 also when Auto CMD12 is not executed due to the previous command error.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Current_Limit_Error_ENUM" high_bit="23" low_bit="23" name="Current_Limit_Error">
                    <gui_name language="en">Current_Limit_Error</gui_name>
                    <description language="en">By setting the SD Bus Power bit in the Power Control Register, the HC is requested to supply power for the SD Bus. If the HC supports the Current Limit Function, it can be protected from an Illegal card by stopping power supply to the card in which case this bit indicates a failure status. Reading 1 means the HC is not supplying power to SD card due to some failure. Reading 0 means that the HC is supplying power and no error has occurred. This bit shall always set to be 0, if the HC does not support this function.
0 - No Error
1 - Power Fail</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Data_End_Bit_Error_ENUM" high_bit="22" low_bit="22" name="Data_End_Bit_Error">
                    <gui_name language="en">Data_End_Bit_Error</gui_name>
                    <description language="en">Occurs when detecting 0 at the end bit position of read data which uses the DAT line or the end bit position of the CRC status.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Data_CRC_Error_ENUM" high_bit="21" low_bit="21" name="Data_CRC_Error">
                    <gui_name language="en">Data_CRC_Error</gui_name>
                    <description language="en">Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than '010'.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Data_Timeout_Error_ENUM" high_bit="20" low_bit="20" name="Data_Timeout_Error">
                    <gui_name language="en">Data_Timeout_Error</gui_name>
                    <description language="en">Occurs when detecting one of following timeout conditions.
1. Busy Timeout for R1b, R5b type.
2. Busy Timeout after Write CRC status
3. Write CRC status Timeout
4. Read Data Timeout
0 - No Error
1 - Timeout</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_Index_Error_ENUM" high_bit="19" low_bit="19" name="Command_Index_Error">
                    <gui_name language="en">Command_Index_Error</gui_name>
                    <description language="en">Occurs if a Command Index error occurs in the Command Response.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_End_Bit_Error_ENUM" high_bit="18" low_bit="18" name="Command_End_Bit_Error">
                    <gui_name language="en">Command_End_Bit_Error</gui_name>
                    <description language="en">Occurs when detecting that the end bit of a command response is 0.
0 - No Error
1 - End Bit Error Generated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_CRC_Error_ENUM" high_bit="17" low_bit="17" name="Command_CRC_Error">
                    <gui_name language="en">Command_CRC_Error</gui_name>
                    <description language="en">Command CRC Error is generated in two cases.
1. If a response is returned and the Command Time-out Error is set to 0, this bit is set to 1 when detecting a CRT error in the command response
2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SDCLK edge, then the HC shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict.
0 - No Error
1 - CRC Error Generated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_Timeout_Error_ENUM" high_bit="16" low_bit="16" name="Command_Timeout_Error">
                    <gui_name language="en">Command_Timeout_Error</gui_name>
                    <description language="en">Occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command. If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC.
0 - No Error
1 - Timeout</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Normal_interrupt_status_Error_interrupt_status_Error_Interrupt_ENUM" high_bit="15" low_bit="15" name="Error_Interrupt">
                    <gui_name language="en">Error_Interrupt</gui_name>
                    <description language="en">If any of the bits in the Error Interrupt Status Register are set, then this bit is set. Therefore the HD can test for an error by checking this bit first.
0 - No Error.
1 - Error.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Boot_terminate_Interrupt_ENUM" high_bit="10" low_bit="10" name="Boot_terminate_Interrupt">
                    <gui_name language="en">Boot_terminate_Interrupt</gui_name>
                    <description language="en">This status is set if the boot opeartion get terminated
0 - Boot operation is not teminated.
1 - Boot operation is teminated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Boot_ack_rcv_ENUM" high_bit="9" low_bit="9" name="Boot_ack_rcv">
                    <gui_name language="en">Boot_ack_rcv</gui_name>
                    <description language="en">This status is set if the boot acknowledge is received from device.
0 - Boot ack is not received.
1 - Boot ack is received.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Normal_interrupt_status_Error_interrupt_status_Card_Interrupt_ENUM" high_bit="8" low_bit="8" name="Card_Interrupt">
                    <gui_name language="en">Card_Interrupt</gui_name>
                    <description language="en">Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor. In 1-bit mode, the HC shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the card and the interrupt to the Host system.
when this status has been set and the HD needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status register shall be set to 0 in order to clear the card interrupt statuses latched in the HC and stop driving the Host System. After completion of the card interrupt service (the reset factor in the SD card and the interrupt signal may not be asserted), set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again.
0 - No Card Interrupt
1 - Generate Card Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Card_Removal_ENUM" high_bit="7" low_bit="7" name="Card_Removal">
                    <gui_name language="en">Card_Removal</gui_name>
                    <description language="en">This status is set if the Card Inserted in the Present State register changes from 1 to 0. When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed.
Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.
0 - Card State Stable or Debouncing
1 - Card Removed</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Card_Insertion_ENUM" high_bit="6" low_bit="6" name="Card_Insertion">
                    <gui_name language="en">Card_Insertion</gui_name>
                    <description language="en">This status is set if the Card Inserted in the Present State register changes from 0 to 1. When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed.
Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.
0 - Card State Stable or Debouncing
1 - Card Inserted</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Buffer_Read_Ready_ENUM" high_bit="5" low_bit="5" name="Buffer_Read_Ready">
                    <gui_name language="en">Buffer_Read_Ready</gui_name>
                    <description language="en">This status is set if the Buffer Read Enable
changes from 0 to 1.
0 - Not Ready to read Buffer.
1 - Ready to read Buffer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Buffer_Write_Ready_ENUM" high_bit="4" low_bit="4" name="Buffer_Write_Ready">
                    <gui_name language="en">Buffer_Write_Ready</gui_name>
                    <description language="en">This status is set if the Buffer Write Enable
changes from 0 to 1.
0 - Not Ready to Write Buffer.
1 - Ready to Write Buffer.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_DMA_Interrupt_ENUM" high_bit="3" low_bit="3" name="DMA_Interrupt">
                    <gui_name language="en">DMA_Interrupt</gui_name>
                    <description language="en">This status is set if the HC detects the Host
DMA Buffer Boundary in the Block Size
regiser.
0 - No DMA Interrupt
1 - DMA Interrupt is Generated</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Block_Gap_Event_ENUM" high_bit="2" low_bit="2" name="Block_Gap_Event">
                    <gui_name language="en">Block_Gap_Event</gui_name>
                    <description language="en">If the Stop At Block Gap Request in the Block
Gap Control Register is set, this bit is set.
Read Transaction:
This bit is set at the falling edge of the DAT
Line Active Status (When the transaction is
stopped at SD Bus timing. The Read Wait
must be supported inorder to use this function).
Write Transaction:
This bit is set at the falling edge of Write
Transfer Active Status (After getting CRC status
at SD Bus timing).
0 - No Block Gap Event
1 - Transaction stopped at Block
Gap</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Transfer_Complete_ENUM" high_bit="1" low_bit="1" name="Transfer_Complete">
                    <gui_name language="en">Transfer_Complete</gui_name>
                    <description language="en">This bit is set when a read / write transaction is completed.
Read Transaction:
This bit is set at the falling edge of Read Transfer Active Status.
There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting the Stop At Block Gap Request in the Block Gap Control Register (After valid
data has been read to the Host System).
Write Transaction:
This bit is set at the falling edge of the DAT
Line Active Status.
There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop At Block Gap Request in the Block Gap Control Register and data transfers completed. (After valid data is written to the SD card and the busy signal is released).
Note: Transfer Complete has higher priority than Data Time-out Error. If both bits are set to 1, the data transfer can be considered complete
0 - No Data Transfer Complete
1 - Data Transfer Complete</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_Error_interrupt_status_Command_Complete_ENUM" high_bit="0" low_bit="0" name="Command_Complete">
                    <gui_name language="en">Command_Complete</gui_name>
                    <description language="en">This bit is set when get the end bit of the command response (Except Auto CMD12).
Note: Command Time-out Error has higher priority than Command Complete. If both are set to 1, it can be considered that the response was not received correctly.
0 - No Command Complete
1 - Command Complete</description>
                </bitField>
            </register>
            <register name="SD1_NORMAL_INTERRUPT_STATUS_ENABLE_ERROR_INTERRUPT_STATUS_ENABLE" offset="0xe0101034" size="0x4">
                <gui_name language="en">Normal_interrupt_status_enable_Error_interrupt_status_enable</gui_name>
                <description language="en">Normal interrupt status enable register
Error interrupt status enable register</description>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Ceata_Error_Status_Enable_ENUM" high_bit="29" low_bit="29" name="Ceata_Error_Status_Enable">
                    <gui_name language="en">Ceata_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Target_Response_Error_Status_Enable_ENUM" high_bit="28" low_bit="28" name="Target_Response_Error_Status_Enable">
                    <gui_name language="en">Target_Response_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_ADMA_Error_Status_Enable_ENUM" high_bit="25" low_bit="25" name="ADMA_Error_Status_Enable">
                    <gui_name language="en">ADMA_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Auto_CMD12_Error_Status_Enable_ENUM" high_bit="24" low_bit="24" name="Auto_CMD12_Error_Status_Enable">
                    <gui_name language="en">Auto_CMD12_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Current_Limit_Error_Status_Enable_ENUM" high_bit="23" low_bit="23" name="Current_Limit_Error_Status_Enable">
                    <gui_name language="en">Current_Limit_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_End_Bit_Error_Status_Enable_ENUM" high_bit="22" low_bit="22" name="Data_End_Bit_Error_Status_Enable">
                    <gui_name language="en">Data_End_Bit_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_CRC_Error_Status_Enable_ENUM" high_bit="21" low_bit="21" name="Data_CRC_Error_Status_Enable">
                    <gui_name language="en">Data_CRC_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_Timeout_Error_Status_Enable_ENUM" high_bit="20" low_bit="20" name="Data_Timeout_Error_Status_Enable">
                    <gui_name language="en">Data_Timeout_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Index_Error_Status_Enable_ENUM" high_bit="19" low_bit="19" name="Command_Index_Error_Status_Enable">
                    <gui_name language="en">Command_Index_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_End_Bit_Error_Status_Enable_ENUM" high_bit="18" low_bit="18" name="Command_End_Bit_Error_Status_Enable">
                    <gui_name language="en">Command_End_Bit_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_CRC_Error_Status_Enable_ENUM" high_bit="17" low_bit="17" name="Command_CRC_Error_Status_Enable">
                    <gui_name language="en">Command_CRC_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Timeout_Error_Status_Enable_ENUM" high_bit="16" low_bit="16" name="Command_Timeout_Error_Status_Enable">
                    <gui_name language="en">Command_Timeout_Error_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="Fixed_to_0">
                    <gui_name language="en">Fixed_to_0</gui_name>
                    <description language="en">The HC shall control error Interrupts using the Error Interrupt Status Enable register.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Boot_terminate_Interrupt_enable_ENUM" high_bit="10" low_bit="10" name="Boot_terminate_Interrupt_enable">
                    <gui_name language="en">Boot_terminate_Interrupt_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Boot_ack_rcv_enable_ENUM" high_bit="9" low_bit="9" name="Boot_ack_rcv_enable">
                    <gui_name language="en">Boot_ack_rcv_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Interrupt_Status_Enable_ENUM" high_bit="8" low_bit="8" name="Card_Interrupt_Status_Enable">
                    <gui_name language="en">Card_Interrupt_Status_Enable</gui_name>
                    <description language="en">If this bit is set to 0, the HC shall clear Interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The HD should clear the Card Interrupt Status Enable before servicing the Card Interrupt and should set this bit again after all Interrupt requests from the card are cleared to prevent inadvertent Interrupts.
0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Removal_Status_Enable_ENUM" high_bit="7" low_bit="7" name="Card_Removal_Status_Enable">
                    <gui_name language="en">Card_Removal_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Insertion_Status_Enable_ENUM" high_bit="6" low_bit="6" name="Card_Insertion_Status_Enable">
                    <gui_name language="en">Card_Insertion_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Buffer_Read_Ready_Status_Enable_ENUM" high_bit="5" low_bit="5" name="Buffer_Read_Ready_Status_Enable">
                    <gui_name language="en">Buffer_Read_Ready_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Buffer_Write_Ready_Status_Enable_ENUM" high_bit="4" low_bit="4" name="Buffer_Write_Ready_Status_Enable">
                    <gui_name language="en">Buffer_Write_Ready_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_DMA_Interrupt_Status_Enable_ENUM" high_bit="3" low_bit="3" name="DMA_Interrupt_Status_Enable">
                    <gui_name language="en">DMA_Interrupt_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Block_Gap_Event_Status_Enable_ENUM" high_bit="2" low_bit="2" name="Block_Gap_Event_Status_Enable">
                    <gui_name language="en">Block_Gap_Event_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Transfer_Complete_Status_Enable_ENUM" high_bit="1" low_bit="1" name="Transfer_Complete_Status_Enable">
                    <gui_name language="en">Transfer_Complete_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Complete_Status_Enable_ENUM" high_bit="0" low_bit="0" name="Command_Complete_Status_Enable">
                    <gui_name language="en">Command_Complete_Status_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
            </register>
            <register name="SD1_NORMAL_INTERRUPT_SIGNAL_ENABLE_ERROR_INTERRUPT_SIGNAL_ENABLE" offset="0xe0101038" size="0x4">
                <gui_name language="en">Normal_interrupt_signal_enable_Error_interrupt_signal_enable</gui_name>
                <description language="en">Normal interrupt signal enable register
Error interrupt signal enable register</description>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Ceata_Error_Signal_Enable_ENUM" high_bit="29" low_bit="29" name="Ceata_Error_Signal_Enable">
                    <gui_name language="en">Ceata_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Target_Response_Error_Signal_Enable_ENUM" high_bit="28" low_bit="28" name="Target_Response_Error_Signal_Enable">
                    <gui_name language="en">Target_Response_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_ADMA_Error_Signal_Enable_ENUM" high_bit="25" low_bit="25" name="ADMA_Error_Signal_Enable">
                    <gui_name language="en">ADMA_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Auto_CMD12_Error_Signal_Enable_ENUM" high_bit="24" low_bit="24" name="Auto_CMD12_Error_Signal_Enable">
                    <gui_name language="en">Auto_CMD12_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Current_Limit_Error_Signal_Enable_ENUM" high_bit="23" low_bit="23" name="Current_Limit_Error_Signal_Enable">
                    <gui_name language="en">Current_Limit_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_End_Bit_Error_Signal_Enable_ENUM" high_bit="22" low_bit="22" name="Data_End_Bit_Error_Signal_Enable">
                    <gui_name language="en">Data_End_Bit_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_CRC_Error_Signal_Enable_ENUM" high_bit="21" low_bit="21" name="Data_CRC_Error_Signal_Enable">
                    <gui_name language="en">Data_CRC_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_Timeout_Error_Signal_Enable_ENUM" high_bit="20" low_bit="20" name="Data_Timeout_Error_Signal_Enable">
                    <gui_name language="en">Data_Timeout_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Index_Error_Signal_Enable_ENUM" high_bit="19" low_bit="19" name="Command_Index_Error_Signal_Enable">
                    <gui_name language="en">Command_Index_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_End_Bit_Error_Signal_Enable_ENUM" high_bit="18" low_bit="18" name="Command_End_Bit_Error_Signal_Enable">
                    <gui_name language="en">Command_End_Bit_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_CRC_Error_Signal_Enable_ENUM" high_bit="17" low_bit="17" name="Command_CRC_Error_Signal_Enable">
                    <gui_name language="en">Command_CRC_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Timeout_Error_Signal_Enable_ENUM" high_bit="16" low_bit="16" name="Command_Timeout_Error_Signal_Enable">
                    <gui_name language="en">Command_Timeout_Error_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="Fixed_to_0">
                    <gui_name language="en">Fixed_to_0</gui_name>
                    <description language="en">The HD shall control error Interrupts using the Error Interrupt Signal Enable register.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Boot_terminate_Interrupt_signal_enable_ENUM" high_bit="10" low_bit="10" name="Boot_terminate_Interrupt_signal_enable">
                    <gui_name language="en">Boot_terminate_Interrupt_signal_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Boot_ack_rcv_signal_enable_ENUM" high_bit="9" low_bit="9" name="Boot_ack_rcv_signal_enable">
                    <gui_name language="en">Boot_ack_rcv_signal_enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Interrupt_Signal_Enable_ENUM" high_bit="8" low_bit="8" name="Card_Interrupt_Signal_Enable">
                    <gui_name language="en">Card_Interrupt_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Removal_Signal_Enable_ENUM" high_bit="7" low_bit="7" name="Card_Removal_Signal_Enable">
                    <gui_name language="en">Card_Removal_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Insertion_Signal_Enable_ENUM" high_bit="6" low_bit="6" name="Card_Insertion_Signal_Enable">
                    <gui_name language="en">Card_Insertion_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Buffer_Read_Ready_Signal_Enable_ENUM" high_bit="5" low_bit="5" name="Buffer_Read_Ready_Signal_Enable">
                    <gui_name language="en">Buffer_Read_Ready_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Buffer_Write_Ready_Signal_Enable_ENUM" high_bit="4" low_bit="4" name="Buffer_Write_Ready_Signal_Enable">
                    <gui_name language="en">Buffer_Write_Ready_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_DMA_Interrupt_Signal_Enable_ENUM" high_bit="3" low_bit="3" name="DMA_Interrupt_Signal_Enable">
                    <gui_name language="en">DMA_Interrupt_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Block_Gap_Event_Signal_Enable_ENUM" high_bit="2" low_bit="2" name="Block_Gap_Event_Signal_Enable">
                    <gui_name language="en">Block_Gap_Event_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Transfer_Complete_Signal_Enable_ENUM" high_bit="1" low_bit="1" name="Transfer_Complete_Signal_Enable">
                    <gui_name language="en">Transfer_Complete_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Complete_Signal_Enable_ENUM" high_bit="0" low_bit="0" name="Command_Complete_Signal_Enable">
                    <gui_name language="en">Command_Complete_Signal_Enable</gui_name>
                    <description language="en">0 - Masked
1 - Enabled</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_AUTO_CMD12_ERROR_STATUS" offset="0xe010103c" size="0x2">
                <gui_name language="en">Auto_CMD12_error_status</gui_name>
                <description language="en">Auto CMD12 error status register</description>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Command_Not_Issued_By_Auto_CMD12_Error_ENUM" high_bit="7" low_bit="7" name="Command_Not_Issued_By_Auto_CMD12_Error">
                    <gui_name language="en">Command_Not_Issued_By_Auto_CMD12_Error</gui_name>
                    <description language="en">Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register.
0 - No Error
1 - Not Issued</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_Index_Error_ENUM" high_bit="4" low_bit="4" name="Auto_CMD12_Index_Error">
                    <gui_name language="en">Auto_CMD12_Index_Error</gui_name>
                    <description language="en">Occurs if the Command Index error occurs in response to a command.
0 - No Error
1 - Error</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_End_Bit_Error_ENUM" high_bit="3" low_bit="3" name="Auto_CMD12_End_Bit_Error">
                    <gui_name language="en">Auto_CMD12_End_Bit_Error</gui_name>
                    <description language="en">Occurs when detecting that the end bit of command response is 0.
0 - No Error
1 - End Bit Error Generated</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_CRC_Error_ENUM" high_bit="2" low_bit="2" name="Auto_CMD12_CRC_Error">
                    <gui_name language="en">Auto_CMD12_CRC_Error</gui_name>
                    <description language="en">Occurs when detecting a CRC error in the command response.
0 - No Error
1 - CRC Error Generated</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_Timeout_Error_ENUM" high_bit="1" low_bit="1" name="Auto_CMD12_Timeout_Error">
                    <gui_name language="en">Auto_CMD12_Timeout_Error</gui_name>
                    <description language="en">Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless.
0 - No Error
1 - Timeout</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Auto_CMD12_error_status_Auto_CMD12_not_Executed_ENUM" high_bit="0" low_bit="0" name="Auto_CMD12_not_Executed">
                    <gui_name language="en">Auto_CMD12_not_Executed</gui_name>
                    <description language="en">If memory multiple block data transfer is not started due to command
error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless.
0 - Executed
1 - Not Executed</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_CAPABILITIES" offset="0xe0101040" size="0x4">
                <gui_name language="en">Capabilities</gui_name>
                <description language="en">Capabilities register</description>
                <bitField access="Read Only" enumerationId="Capabilities_Spi_block_mode_ENUM" high_bit="30" low_bit="30" name="Spi_block_mode">
                    <gui_name language="en">Spi_block_mode</gui_name>
                    <description language="en">Spi block mode
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Spi_mode_ENUM" high_bit="29" low_bit="29" name="Spi_mode">
                    <gui_name language="en">Spi_mode</gui_name>
                    <description language="en">Spi mode
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_n64_bit_System_Bus_Support_ENUM" high_bit="28" low_bit="28" name="n64_bit_System_Bus_Support">
                    <gui_name language="en">n64_bit_System_Bus_Support</gui_name>
                    <description language="en">1 - supports 64 bit system address
0 - Does not support 64 bit system
address</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Interrupt_mode_ENUM" high_bit="27" low_bit="27" name="Interrupt_mode">
                    <gui_name language="en">Interrupt_mode</gui_name>
                    <description language="en">Interrupt mode
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Voltage_Support_1_8_V_ENUM" high_bit="26" low_bit="26" name="Voltage_Support_1_8_V">
                    <gui_name language="en">Voltage_Support_1_8_V</gui_name>
                    <description language="en">0 - 1.8 V Not Supported
1 - 1.8 V Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Voltage_Support_3_0_V_ENUM" high_bit="25" low_bit="25" name="Voltage_Support_3_0_V">
                    <gui_name language="en">Voltage_Support_3_0_V</gui_name>
                    <description language="en">0 - 3.0 V Not Supported
1 - 3.0 V Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Voltage_Support_3_3_V_ENUM" high_bit="24" low_bit="24" name="Voltage_Support_3_3_V">
                    <gui_name language="en">Voltage_Support_3_3_V</gui_name>
                    <description language="en">0 - 3.3 V Not Supported
1 - 3.3 V Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Suspend_Resume_Support_ENUM" high_bit="23" low_bit="23" name="Suspend_Resume_Support">
                    <gui_name language="en">Suspend_Resume_Support</gui_name>
                    <description language="en">This bit indicates whether the HC supports Suspend / Resume functionality. If this bit is 0, the Suspend and Resume mechanism are not supported and the HD shall not issue either Suspend / Resume commands.
0 - Not Supported
1 - Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_SDMA_Support_ENUM" high_bit="22" low_bit="22" name="SDMA_Support">
                    <gui_name language="en">SDMA_Support</gui_name>
                    <description language="en">This bit indicates whether the HC is capable of using DMA to transfer data between system memory and the HC directly.
0 - SDMA Not Supported
1 - SDMA Supported.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_High_Speed_Support_ENUM" high_bit="21" low_bit="21" name="High_Speed_Support">
                    <gui_name language="en">High_Speed_Support</gui_name>
                    <description language="en">This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25Mhz to 50 Mhz (for SD)/ 20MHz to 52MHz (for MMC).
0 - High Speed Not Supported
1 - High Speed Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_ADMA2_Support_ENUM" high_bit="19" low_bit="19" name="ADMA2_Support">
                    <gui_name language="en">ADMA2_Support</gui_name>
                    <description language="en">1 - ADMA2 support.
0 - ADMA2 not support</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Extended_Media_Bus_Support_ENUM" high_bit="18" low_bit="18" name="Extended_Media_Bus_Support">
                    <gui_name language="en">Extended_Media_Bus_Support</gui_name>
                    <description language="en">This bit indicates whether the Host Controller is capable bus.
1 - Extended Media Bus Supported
0 - Extended Media Bus not Supported</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Max_Block_Length_ENUM" high_bit="17" low_bit="16" name="Max_Block_Length">
                    <gui_name language="en">Max_Block_Length</gui_name>
                    <description language="en">This value indicates the maximum block size that the HD can read and write to the buffer in the HC. The buffer shall transfer this block size without wait cycles. Three sizes can be defined as indicated below.
00 - 512 byte
01 - 1024 byte
10 - 2048 byte
11 - 4096 byte</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Base_Clock_Frequency_for_SD_Clock_ENUM" high_bit="13" low_bit="8" name="Base_Clock_Frequency_for_SD_Clock">
                    <gui_name language="en">Base_Clock_Frequency_for_SD_Clock</gui_name>
                    <description language="en">This value indicates the base (maximum) clock frequency for the SD clock. Unit values are 1Mhz. If the real frequency is 16.5 Mhz, the larger value shall be set 010001b (17 Mhz) because the HD uses this value to calculate the clock divider value and it shall not exceed the upper limit of the SD clock frequency. The supported range is 10Mhz to 63 Mhz. If these bits are all 0, the Host System has to get information via another method. Not 0 - 1 Mhz to 63 Mhz
000000b - Get information via another method.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Capabilities_Timeout_Clock_Unit_ENUM" high_bit="7" low_bit="7" name="Timeout_Clock_Unit">
                    <gui_name language="en">Timeout_Clock_Unit</gui_name>
                    <description language="en">This bit shows the unit of base clock frequency used to detect Data Timeout Error.
0 - Khz
1 - Mhz</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="0" name="Timeout_Clock_Frequency">
                    <gui_name language="en">Timeout_Clock_Frequency</gui_name>
                    <description language="en">This bit shows the base clock frequency used to detect Data Timeout Error.
Not 0 - 1Khz to 63Khz or 1Mhz to 63Mhz 000000b - Get Information via another method.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_MAXIMUM_CURRENT_CAPABILITIES" offset="0xe0101048" size="0x4">
                <gui_name language="en">Maximum_current_capabilities</gui_name>
                <description language="en">Maximum current capabilities register</description>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="Maximum_Current_for_1_8V">
                    <gui_name language="en">Maximum_Current_for_1_8V</gui_name>
                    <description language="en">Maximum Current for 1.8V</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="Maximum_Current_for_3_0V">
                    <gui_name language="en">Maximum_Current_for_3_0V</gui_name>
                    <description language="en">Maximum Current for 3.0V</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Maximum_Current_for_3_3V">
                    <gui_name language="en">Maximum_Current_for_3_3V</gui_name>
                    <description language="en">Maximum Current for 3.3V</description>
                </bitField>
            </register>
            <register name="SD1_FORCE_EVENT_FOR_AUTOCMD12_ERROR_STATUS_FORCE_EVENT_REGISTER_FOR_ERROR_INTERRUPT_STATUS" offset="0xe0101050" size="0x4">
                <gui_name language="en">Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status</gui_name>
                <description language="en">Force event register for Auto CMD12 error status register
Force event register for error interrupt status</description>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Vendor_Specific_Error_Status_ENUM" high_bit="31" low_bit="30" name="Force_Event_for_Vendor_Specific_Error_Status">
                    <gui_name language="en">Force_Event_for_Vendor_Specific_Error_Status</gui_name>
                    <description language="en">Additional status bits can be defined in
this register by the vendor.
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Ceata_error_ENUM" high_bit="29" low_bit="29" name="Force_Event_for_Ceata_error">
                    <gui_name language="en">Force_Event_for_Ceata_error</gui_name>
                    <description language="en">Force Event for Ceata Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_event_for_Target_Response_error_ENUM" high_bit="28" low_bit="28" name="Force_event_for_Target_Response_error">
                    <gui_name language="en">Force_event_for_Target_Response_error</gui_name>
                    <description language="en">Force Event for Target Response Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_ADMA_Error_ENUM" high_bit="25" low_bit="25" name="Force_Event_for_ADMA_Error">
                    <gui_name language="en">Force_Event_for_ADMA_Error</gui_name>
                    <description language="en">Force Event for ADMA Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_Error_ENUM" high_bit="24" low_bit="24" name="Force_Event_for_Auto_CMD12_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_Error</gui_name>
                    <description language="en">Force Event for Auto CMD12 Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Current_Limit_Error_ENUM" high_bit="23" low_bit="23" name="Force_Event_for_Current_Limit_Error">
                    <gui_name language="en">Force_Event_for_Current_Limit_Error</gui_name>
                    <description language="en">Force Event for Current Limit Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data_End_Bit_Error_ENUM" high_bit="22" low_bit="22" name="Force_Event_for_Data_End_Bit_Error">
                    <gui_name language="en">Force_Event_for_Data_End_Bit_Error</gui_name>
                    <description language="en">Force Event for Data End Bit Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data_CRC_Error_ENUM" high_bit="21" low_bit="21" name="Force_Event_for_Data_CRC_Error">
                    <gui_name language="en">Force_Event_for_Data_CRC_Error</gui_name>
                    <description language="en">Force Event for Data CRC Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data__Timeout_Error_ENUM" high_bit="20" low_bit="20" name="Force_Event_for_Data__Timeout_Error">
                    <gui_name language="en">Force_Event_for_Data__Timeout_Error</gui_name>
                    <description language="en">Force Event for Data Timeout Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_Index_Error_ENUM" high_bit="19" low_bit="19" name="Force_Event_for_Command_Index_Error">
                    <gui_name language="en">Force_Event_for_Command_Index_Error</gui_name>
                    <description language="en">Force Event for Command Index Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_End_Bit_Error_ENUM" high_bit="18" low_bit="18" name="Force_Event_for_Command_End_Bit_Error">
                    <gui_name language="en">Force_Event_for_Command_End_Bit_Error</gui_name>
                    <description language="en">Force Event for Command End Bit Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_CRC_Error_ENUM" high_bit="17" low_bit="17" name="Force_Event_for_Command_CRC_Error">
                    <gui_name language="en">Force_Event_for_Command_CRC_Error</gui_name>
                    <description language="en">Force Event for Command CRC Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_Timeout_Error_ENUM" high_bit="16" low_bit="16" name="Force_Event_for_Command_Timeout_Error">
                    <gui_name language="en">Force_Event_for_Command_Timeout_Error</gui_name>
                    <description language="en">Force Event for Command Timeout Error
1 - Interrupt is generated
0 - No interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_command_not_issued_by_Auto_CMD12_Error_ENUM" high_bit="7" low_bit="7" name="Force_Event_for_command_not_issued_by_Auto_CMD12_Error">
                    <gui_name language="en">Force_Event_for_command_not_issued_by_Auto_CMD12_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_Index_Error_ENUM" high_bit="4" low_bit="4" name="Force_Event_for_Auto_CMD12_Index_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_Index_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_End_bit_Error_ENUM" high_bit="3" low_bit="3" name="Force_Event_for_Auto_CMD12_End_bit_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_End_bit_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_CRC_Error_ENUM" high_bit="2" low_bit="2" name="Force_Event_for_Auto_CMD12_CRC_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_CRC_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_timeout_Error_ENUM" high_bit="1" low_bit="1" name="Force_Event_for_Auto_CMD12_timeout_Error">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_timeout_Error</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_NOT_Executed_ENUM" high_bit="0" low_bit="0" name="Force_Event_for_Auto_CMD12_NOT_Executed">
                    <gui_name language="en">Force_Event_for_Auto_CMD12_NOT_Executed</gui_name>
                    <description language="en">1 - Interrupt is generated
0 - no interrupt</description>
                </bitField>
            </register>
            <register name="SD1_ADMA_ERROR_STATUS" offset="0xe0101054" size="0x2">
                <gui_name language="en">ADMA_error_status</gui_name>
                <description language="en">ADMA error status register</description>
                <bitField access="Read Write" enumerationId="ADMA_error_status_ADMA_Length_Mismatch_Error_ENUM" high_bit="2" low_bit="2" name="ADMA_Length_Mismatch_Error">
                    <gui_name language="en">ADMA_Length_Mismatch_Error</gui_name>
                    <description language="en">This error occurs in the following 2 cases.
1. While Block Count Enable being set, the total
data length specified by the
Descriptor table is different from that specified by
the Block Count and
Block Length.
2. Total data length can not be divided by the block
length.
1 - Error
0 - No error</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ADMA_error_status_ADMA_Error_State_ENUM" high_bit="1" low_bit="0" name="ADMA_Error_State">
                    <gui_name language="en">ADMA_Error_State</gui_name>
                    <description language="en">This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates "10" because ADMA never stops in this state.
D01 - D00 : ADMA Error State when
error is occurred
Contents of SYS_SDR register
00 - ST_STOP (Stop DMA) Points next of the error
descriptor
01 - ST_FDS (Fetch Descriptor) Points the error
descriptor
10 - Never set this state (Not used)
11 - ST_TFR (Transfer Data) Points the next of the
error descriptor</description>
                </bitField>
            </register>
            <register name="SD1_ADMA_SYSTEM_ADDRESS" offset="0xe0101058" size="0x4">
                <gui_name language="en">ADMA_system_address</gui_name>
                <description language="en">ADMA system address register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="ADMA_System_Address">
                    <gui_name language="en">ADMA_System_Address</gui_name>
                    <description language="en">This register holds byte address of executing
command of the Descriptor table.
32-bit Address Descriptor uses lower 32-
bit of this register. At the start of ADMA,
the Host Driver shall set start address of
the Descriptor table. The ADMA
increments this register address, which
points to next line, when every fetching a
Descriptor line. When the ADMA Error
Interrupt is generated, this register shall
hold valid Descriptor address depending
on the ADMA state. The Host Driver shall
program Descriptor Table on 32-bit
boundary and set 32-bit boundary
address to this register. ADMA2 ignores
lower 2-bit of this register and assumes it
to be 00b.
32-bit Address ADMA Register Value 32-
bit System Address
0x00000000 0x00000000
0x00000004 0x00000004
to
0xFFFFFFFC 0xFFFFFFFC</description>
                </bitField>
            </register>
            <register name="SD1_BOOT_TIMEOUT_CONTROL" offset="0xe0101060" size="0x4">
                <gui_name language="en">Boot_Timeout_control</gui_name>
                <description language="en">Boot Timeout control register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="Boot_Data_Timeout_Counter_Value">
                    <gui_name language="en">Boot_Data_Timeout_Counter_Value</gui_name>
                    <description language="en">This value determines the interval by
which DAT line time-outs are detected
during boot operation for MMC3.31
card.
The value is in number of sd clock.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SD1_DEBUG_SELECTION" offset="0xe0101064" size="0x2">
                <gui_name language="en">Debug_Selection</gui_name>
                <description language="en">Debug Selection Register</description>
                <bitField access="Write Only" enumerationId="Debug_Selection_Debug_sel_ENUM" high_bit="0" low_bit="0" name="Debug_sel">
                    <gui_name language="en">Debug_sel</gui_name>
                    <description language="en">1- cmd register, Interrupt status, transmitter
module, ahb_iface module and clk
sdcard signals are probed out.
0 - receiver module and fifo_ctrl module
signals are probed out</description>
                </bitField>
            </register>
            <register name="SD1_SPI_INTERRUPT_SUPPORT" offset="0xe01010f0" size="0x2">
                <gui_name language="en">SPI_interrupt_support</gui_name>
                <description language="en">SPI interrupt support register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="SPI_INT_SUPPORT">
                    <gui_name language="en">SPI_INT_SUPPORT</gui_name>
                    <description language="en">This bit is set to indicate the assertion of interrupts in the SPI mode at any time, irrespective of the status of the card select (CS) line. If this bit is zero,
then SDIO card can only assert the interrupt line in the SPI mode when the CS line is asserted.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SD1_SLOT_INTERRUPT_STATUS_HOST_CONTROLLER_VERSION" offset="0xe01010fc" size="0x4">
                <gui_name language="en">Slot_interrupt_status_Host_controller_version</gui_name>
                <description language="en">Slot interrupt status register and
Host controller version register</description>
                <bitField access="Read Only" enumerationId="Slot_interrupt_status_Host_controller_version_Specification_Version_Number_ENUM" high_bit="31" low_bit="24" name="Specification_Version_Number">
                    <gui_name language="en">Specification_Version_Number</gui_name>
                    <description language="en">This status indicates the Host Controller Spec. Version. The upper and lower 4-bits indicate the version. 00 - SD Host Specification version
1.0
01 - SD Host Specification version 2.00 including only the feature of theTest Register
others - Reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="Vendor_Version_Number">
                    <gui_name language="en">Vendor_Version_Number</gui_name>
                    <description language="en">This status is reserved for the vendor version number. The HD should not use this status.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="Interrupt_Signal_for_Each_Slot">
                    <gui_name language="en">Interrupt_Signal_for_Each_Slot</gui_name>
                    <description language="en">These status bit indicate the logical OR of Interrupt signal and Wakeup
signal for each slot. A maximum of 8 slots can be defined. If one interrupt
signal is associated with multiple slots. the HD can know which interrupt
is generated by reading these status bits. By a power on reset or by Software Reset For All, the Interrupt signal shall be de asserted and this
status shall read 00h.
Bit 00 - Slot 1
Bit 01 - Slot 2
Bit 02 - Slot 3
----- -----
Bit 07 - Slot 8</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SLCR" name="SLCR" offset="0xf8000000">
            <gui_name language="en">slcr</gui_name>
            <description language="en">slcr</description>
            <register name="SLCR_SCL" offset="0xf8000000" size="0x4">
                <gui_name language="en">SCL</gui_name>
                <description language="en">Secure Configuration Lock</description>
                <bitField access="Read Write" enumerationId="SCL_LOCK_ENUM" high_bit="0" low_bit="0" name="LOCK">
                    <gui_name language="en">LOCK</gui_name>
                    <description language="en">Secure configuration lock: 0 = unlocked, Secure writes to Secure configuration registers are enabled
1 = locked, all writes to Secure configuration registers are disabled and cannot be enabled until power-on reset is asserted.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SLCR_SLCR_LOCK" offset="0xf8000004" size="0x4">
                <gui_name language="en">SLCR_LOCK</gui_name>
                <description language="en">SLCR Write Protection Lock</description>
                <bitField access="Write Only" high_bit="15" low_bit="0" name="LOCK_KEY">
                    <gui_name language="en">LOCK_KEY</gui_name>
                    <description language="en">When write data contains the lock key value of 0x767B, the write protection mode is enabled. All registers defined in SLCR are write protected until unlocked again through the SLCR_UNLOCK register. A read of this register always returns zero.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SLCR_SLCR_UNLOCK" offset="0xf8000008" size="0x4">
                <gui_name language="en">SLCR_UNLOCK</gui_name>
                <description language="en">SLCR Write Protection Unlock</description>
                <bitField access="Write Only" high_bit="15" low_bit="0" name="UNLOCK_KEY">
                    <gui_name language="en">UNLOCK_KEY</gui_name>
                    <description language="en">When write data contains the unlock key value of 0xDF0D, the write protection mode is disabled. All registers defined in SLCR are writeable until locked again through the SLCR_LOCK register. A read of this register always returns zero.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SLCR_SLCR_LOCKSTA" offset="0xf800000c" size="0x4">
                <gui_name language="en">SLCR_LOCKSTA</gui_name>
                <description language="en">SLCR Write Protection Status</description>
                <bitField access="Read Only" enumerationId="SLCR_LOCKSTA_LOCK_STATUS_ENUM" high_bit="0" low_bit="0" name="LOCK_STATUS">
                    <gui_name language="en">LOCK_STATUS</gui_name>
                    <description language="en">Current state of write protection mode of SLCR:
0 - Registers are writeable;
1 - Registers are not writeable. Any attempted writes are ignored, but reads will complete as normal.</description>
                </bitField>
            </register>
            <register name="SLCR_ARM_PLL_CTRL" offset="0xf8000100" size="0x4">
                <gui_name language="en">ARM_PLL_CTRL</gui_name>
                <description language="en">ARM PLL Control</description>
                <bitField access="Read Write" high_bit="18" low_bit="12" name="PLL_FDIV">
                    <gui_name language="en">PLL_FDIV</gui_name>
                    <description language="en">Provides the feedback divisor for the PLL. NOTE: Before changing this value the PLL must first be bypassed and then put into powerdown or reset state.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="PLL_BYPASS_FORCE">
                    <gui_name language="en">PLL_BYPASS_FORCE</gui_name>
                    <description language="en">Overides control of the PLL bypass function within the clock controller to force into bypass state. 0 - PLL not forced to be bypassed (may still be bypassed through bootstrap pin). 1 - PLL forced to be bypassed.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PLL_BYPASS_QUAL">
                    <gui_name language="en">PLL_BYPASS_QUAL</gui_name>
                    <description language="en">Qualifies the PLL bootstrap signal sampled from boot_mode[3] in the MIO. By default the bootstrap will directly control all three PLL bypass muxes within the clock controller. 0 - PLL bypass mux in clock controller is only controlled by PLL_BYPASS_FORCE bit. 1 - PLL bypass mux in clock controller
is controlled by sampled boot_mode[3] provided PLL_BYPASS_FORCE is not set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PLL_PWRDWN">
                    <gui_name language="en">PLL_PWRDWN</gui_name>
                    <description language="en">Drives the PWRDWN input of the PLL: 0 - PLL powered up; 1 - PLL powered down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PLL_RESET">
                    <gui_name language="en">PLL_RESET</gui_name>
                    <description language="en">Drives the RESET input of the PLL. 0 - PLL out of reset; 1 - PLL held in reset. Remember that after reset, the user should program the PLLs and ensure that the serviced bit below is asserted before using.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_PLL_CTRL" offset="0xf8000104" size="0x4">
                <gui_name language="en">DDR_PLL_CTRL</gui_name>
                <description language="en">DDR PLL Control</description>
                <bitField access="Read Write" high_bit="18" low_bit="12" name="PLL_FDIV">
                    <gui_name language="en">PLL_FDIV</gui_name>
                    <description language="en">Provides the feedback divisor for the PLL. NOTE: Before changing this value the PLL must first be bypassed and then put into powerdown or reset state.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="PLL_BYPASS_FORCE">
                    <gui_name language="en">PLL_BYPASS_FORCE</gui_name>
                    <description language="en">Overides control of the PLL bypass function within the clock controller to force into bypass state. 0 - PLL not forced to be bypassed (may still be bypassed through bootstrap pin). 1 - PLL forced to be bypassed</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PLL_BYPASS_QUAL">
                    <gui_name language="en">PLL_BYPASS_QUAL</gui_name>
                    <description language="en">Qualifies the PLL bootstrap signal sampled from boot_mode[3] in the MIO. By default the bootstrap will directly control all three PLL bypass muxes within the clock controller. 0 - PLL bypass mux in clock controller is only controlled by PLL_BYPASS_FORCE bit. 1 - PLL bypass mux in clock controller
is controlled by sampled boot_mode[3] provided PLL_BYPASS_FORCE is not set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PLL_PWRDWN">
                    <gui_name language="en">PLL_PWRDWN</gui_name>
                    <description language="en">Drives the PWRDWN input of the PLL. 0 - PLL powered up.1 - PLL powered down</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PLL_RESET">
                    <gui_name language="en">PLL_RESET</gui_name>
                    <description language="en">Drives the RESET input of the PLL. 0 - PLL out of reset. 1 - PLL held in reset. Remember that after reset, the user should program the PLLs and ensure that the serviced bit below is asserted before using.</description>
                </bitField>
            </register>
            <register name="SLCR_IO_PLL_CTRL" offset="0xf8000108" size="0x4">
                <gui_name language="en">IO_PLL_CTRL</gui_name>
                <description language="en">IO PLL Control</description>
                <bitField access="Read Write" high_bit="18" low_bit="12" name="PLL_FDIV">
                    <gui_name language="en">PLL_FDIV</gui_name>
                    <description language="en">Provides the feedback divisor for the PLL. NOTE: Before changing this value the PLL must first be bypassed and then put into powerdown or reset state.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IO_PLL_CTRL_PLL_BYPASS_FORCE_ENUM" high_bit="4" low_bit="4" name="PLL_BYPASS_FORCE">
                    <gui_name language="en">PLL_BYPASS_FORCE</gui_name>
                    <description language="en">Overides control of the PLL bypass function within the clock controller to force into bypass state. 0 - PLL not forced to be bypassed (may still be bypassed through bootstrap pin).
1 - PLL forced to be bypassed</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PLL_BYPASS_QUAL">
                    <gui_name language="en">PLL_BYPASS_QUAL</gui_name>
                    <description language="en">Qualifies the PLL bootstrap signal sampled from boot_mode[3] in the MIO. By default the bootstrap will directly control all three PLL bypass muxes within the clock controller. 0 - PLL bypass mux in clock controller is only controlled by PLL_BYPASS_FORCE bit. 1 - PLL bypass mux in clock controller
is controlled by sampled boot_mode[3] provided PLL_BYPASS_FORCE is not set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PLL_PWRDWN">
                    <gui_name language="en">PLL_PWRDWN</gui_name>
                    <description language="en">Drives the PWRDWN input of the PLL. 0 - PLL powered up. 1 - PLL powered down</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PLL_RESET">
                    <gui_name language="en">PLL_RESET</gui_name>
                    <description language="en">Drives the RESET input of the PLL. 0 - PLL out of reset. 1 - PLL held in reset. Remember that after reset, the user should program the PLLs and ensure that the serviced bit below is asserted before using.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SLCR_PLL_STATUS" offset="0xf800010c" size="0x4">
                <gui_name language="en">PLL_STATUS</gui_name>
                <description language="en">PLL Status</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="IO_PLL_STABLE">
                    <gui_name language="en">IO_PLL_STABLE</gui_name>
                    <description language="en">IO PLL clock stable status. 0 - IO PLL out of lock and not bypassed. 1 - IO PLL in lock or bypassed. Note: Reset condition is actually 0, but will always be 1 by the time this register can be read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="DDR_PLL_STABLE">
                    <gui_name language="en">DDR_PLL_STABLE</gui_name>
                    <description language="en">DDR PLL clock stable status. 0 - DDR PLL out of lock and not bypassed. 1 - DDR PLL in lock or bypassed. Note: Reset condition is actually 0, but will always be 1 by the time this register can be read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="ARM_PLL_STABLE">
                    <gui_name language="en">ARM_PLL_STABLE</gui_name>
                    <description language="en">ARM PLL clock stable status. 0 - ARM PLL out of lock and not in bypass. 1 - ARM PLL in lock or bypassed. Note: Reset condition is actually 0, but will always be 1 by the time this register can be read.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="IO_PLL_LOCK">
                    <gui_name language="en">IO_PLL_LOCK</gui_name>
                    <description language="en">IO PLL lock status. 0 - IO PLL out of lock. 1 - IO PLL in lock. Note: Reset condition is actually 0, but will always be 1 by the time this register can be read if PLL's are being used.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="DDR_PLL_LOCK">
                    <gui_name language="en">DDR_PLL_LOCK</gui_name>
                    <description language="en">DDR PLL lock status. 0 - DDR PLL out of lock. 1 - DDR PLL in lock. Note: Reset condition is actually 0, but will always be 1 by the time this register can be read if PLL's are being used.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ARM_PLL_LOCK">
                    <gui_name language="en">ARM_PLL_LOCK</gui_name>
                    <description language="en">ARM PLL lock status. 0 - ARM PLL out of lock. 1 - ARM PLL in lock. Note: Reset condition is actually 0, but will always be 1 by the time this register can be read if PLL's are being used.</description>
                </bitField>
            </register>
            <register name="SLCR_ARM_PLL_CFG" offset="0xf8000110" size="0x4">
                <gui_name language="en">ARM_PLL_CFG</gui_name>
                <description language="en">ARM PLL Configuration</description>
                <bitField access="Read Write" high_bit="21" low_bit="12" name="LOCK_CNT">
                    <gui_name language="en">LOCK_CNT</gui_name>
                    <description language="en">Drives the LOCK_CNT[9:0] input of the PLL to set the number of clock cycles the PLL needs to have clkref and clkfb aligned withth a certain window before syaing locked.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="PLL_CP">
                    <gui_name language="en">PLL_CP</gui_name>
                    <description language="en">Drives the PLL_CP[3:0] input of the PLL to set the PLL charge pump control</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="PLL_RES">
                    <gui_name language="en">PLL_RES</gui_name>
                    <description language="en">Drives the PLL_RES[3:0] input of the PLL to set the PLL loop filter resistor control</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_PLL_CFG" offset="0xf8000114" size="0x4">
                <gui_name language="en">DDR_PLL_CFG</gui_name>
                <description language="en">DDR PLL Configuration</description>
                <bitField access="Read Write" high_bit="21" low_bit="12" name="LOCK_CNT">
                    <gui_name language="en">LOCK_CNT</gui_name>
                    <description language="en">Drives the LOCK_CNT[9:0] input of the PLL to set the number of clock cycles the PLL needs to have clkref and clkfb aligned withth a certain window before syaing locked.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="PLL_CP">
                    <gui_name language="en">PLL_CP</gui_name>
                    <description language="en">Drives the PLL_CP[3:0] input of the PLL to set the PLL charge pump control</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="PLL_RES">
                    <gui_name language="en">PLL_RES</gui_name>
                    <description language="en">Drives the PLL_RES[3:0] input of the PLL to set the PLL loop filter resistor control</description>
                </bitField>
            </register>
            <register name="SLCR_IO_PLL_CFG" offset="0xf8000118" size="0x4">
                <gui_name language="en">IO_PLL_CFG</gui_name>
                <description language="en">IO PLL Configuration</description>
                <bitField access="Read Write" high_bit="21" low_bit="12" name="LOCK_CNT">
                    <gui_name language="en">LOCK_CNT</gui_name>
                    <description language="en">Drives the LOCK_CNT[9:0] input of the PLL to set the number of clock cycles the PLL needs to have clkref and clkfb aligned withth a certain window before syaing locked.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="PLL_CP">
                    <gui_name language="en">PLL_CP</gui_name>
                    <description language="en">Drives the PLL_CP[3:0] input of the PLL to set the PLL charge pump control</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="PLL_RES">
                    <gui_name language="en">PLL_RES</gui_name>
                    <description language="en">Drives the PLL_RES[3:0] input of the PLL to set the PLL loop filter resistor control</description>
                </bitField>
            </register>
            <register name="SLCR_PLL_BG_CTRL" offset="0xf800011c" size="0x4">
                <gui_name language="en">PLL_BG_CTRL</gui_name>
                <description language="en">PLL Bandgap control</description>
                <bitField access="Read Write" enumerationId="PLL_BG_CTRL_BG_PWRDWN_ENUM" high_bit="0" low_bit="0" name="BG_PWRDWN">
                    <gui_name language="en">BG_PWRDWN</gui_name>
                    <description language="en">Drives the PWRDWN input of the PLL BandGap
0 - PLL BandGap powered up
1 - PLL BandGap powered down
These signal should not be changed by the end user. This Bandgap is shared by IOB, so IOB may go X if changed.</description>
                </bitField>
            </register>
            <register name="SLCR_ARM_CLK_CTRL" offset="0xf8000120" size="0x4">
                <gui_name language="en">ARM_CLK_CTRL</gui_name>
                <description language="en">CORTEX A9 Clock Control</description>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="CPU_PERI_CLKACT">
                    <gui_name language="en">CPU_PERI_CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="CPU_1XCLKACT">
                    <gui_name language="en">CPU_1XCLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="CPU_2XCLKACT">
                    <gui_name language="en">CPU_2XCLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="CPU_3OR2XCLKACT">
                    <gui_name language="en">CPU_3OR2XCLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="CPU_6OR4XCLKACT">
                    <gui_name language="en">CPU_6OR4XCLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 0x - Source for generated clock is CPU PLL. 10 - Source for generated clock is DDR divided clock. 11 - Source for generated clock is IO PLL</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_CLK_CTRL" offset="0xf8000124" size="0x4">
                <gui_name language="en">DDR_CLK_CTRL</gui_name>
                <description language="en">DDR Clock Control</description>
                <bitField access="Read Write" high_bit="31" low_bit="26" name="DDR_2XCLK_DIVISOR">
                    <gui_name language="en">DDR_2XCLK_DIVISOR</gui_name>
                    <description language="en">Divisor value for the ddr_2xclk (does not have to be 2/3 speed of ddr_3xclk)</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DDR_3XCLK_DIVISOR">
                    <gui_name language="en">DDR_3XCLK_DIVISOR</gui_name>
                    <description language="en">Divisor value for the ddr_3xclk</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="DDR_2XCLKACT">
                    <gui_name language="en">DDR_2XCLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DDR_3XCLKACT">
                    <gui_name language="en">DDR_3XCLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_DCI_CLK_CTRL" offset="0xf8000128" size="0x4">
                <gui_name language="en">DCI_CLK_CTRL</gui_name>
                <description language="en">DCI clock control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_APER_CLK_CTRL" offset="0xf800012c" size="0x4">
                <gui_name language="en">APER_CLK_CTRL</gui_name>
                <description language="en">AMBA Peripheral Clock Control</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="SMC_CPU_1XCLKACT">
                    <gui_name language="en">SMC_CPU_1XCLKACT</gui_name>
                    <description language="en">SMC AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="LQSPI_CPU_1XCLKACT">
                    <gui_name language="en">LQSPI_CPU_1XCLKACT</gui_name>
                    <description language="en">LQSPI AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="GPIO_CPU_1XCLKACT">
                    <gui_name language="en">GPIO_CPU_1XCLKACT</gui_name>
                    <description language="en">GPIO AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="UART1_CPU_1XCLKACT">
                    <gui_name language="en">UART1_CPU_1XCLKACT</gui_name>
                    <description language="en">UART 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="UART0_CPU_1XCLKACT">
                    <gui_name language="en">UART0_CPU_1XCLKACT</gui_name>
                    <description language="en">UART 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="I2C1_CPU_1XCLKACT">
                    <gui_name language="en">I2C1_CPU_1XCLKACT</gui_name>
                    <description language="en">I2C 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="I2C0_CPU_1XCLKACT">
                    <gui_name language="en">I2C0_CPU_1XCLKACT</gui_name>
                    <description language="en">I2C 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="CAN1_CPU_1XCLKACT">
                    <gui_name language="en">CAN1_CPU_1XCLKACT</gui_name>
                    <description language="en">CAN 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="CAN0_CPU_1XCLKACT">
                    <gui_name language="en">CAN0_CPU_1XCLKACT</gui_name>
                    <description language="en">CAN 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="SPI1_CPU_1XCLKACT">
                    <gui_name language="en">SPI1_CPU_1XCLKACT</gui_name>
                    <description language="en">SPI 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="SPI0_CPU_1XCLKACT">
                    <gui_name language="en">SPI0_CPU_1XCLKACT</gui_name>
                    <description language="en">SPI 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="SDI1_CPU_1XCLKACT">
                    <gui_name language="en">SDI1_CPU_1XCLKACT</gui_name>
                    <description language="en">SDIO 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="SDI0_CPU_1XCLKACT">
                    <gui_name language="en">SDI0_CPU_1XCLKACT</gui_name>
                    <description language="en">SDIO0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="GEM1_CPU_1XCLKACT">
                    <gui_name language="en">GEM1_CPU_1XCLKACT</gui_name>
                    <description language="en">Gigabit Ethernet MAC 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="GEM0_CPU_1XCLKACT">
                    <gui_name language="en">GEM0_CPU_1XCLKACT</gui_name>
                    <description language="en">Gigabit Ethernet MAC 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="USB1_CPU_1XCLKACT">
                    <gui_name language="en">USB1_CPU_1XCLKACT</gui_name>
                    <description language="en">USB 1 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="USB0_CPU_1XCLKACT">
                    <gui_name language="en">USB0_CPU_1XCLKACT</gui_name>
                    <description language="en">USB 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DMA_CPU_2XCLKACT">
                    <gui_name language="en">DMA_CPU_2XCLKACT</gui_name>
                    <description language="en">DMA 0 AMBA Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_USB0_CLK_CTRL" offset="0xf8000130" size="0x4">
                <gui_name language="en">USB0_CLK_CTRL</gui_name>
                <description language="en">USB 0 ULPI Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USB0_CLK_CTRL_SRCSEL_ENUM" high_bit="6" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
1xx - Source for generated clock is USB0 MIO ULPI clock (top level USB0 MIO ULPI clock is an input).
00x - Source for generated clock is IO PLL (top level USB0 MIO ULPI clock is an output).
010 - Source for generated clock is ARM PLL (top level USB0 MIO ULPI clock is an output).
011 - Source for generated clock is DDR PLL (top level USB0 MIO ULPI clock is an output)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_USB1_CLK_CTRL" offset="0xf8000134" size="0x4">
                <gui_name language="en">USB1_CLK_CTRL</gui_name>
                <description language="en">USB 1 ULPI Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USB1_CLK_CTRL_SRCSEL_ENUM" high_bit="6" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
1xx - Source for generated clock is USB0 MIO ULPI clock (top level USB0 MIO ULPI clock is an input).
00x - Source for generated clock is IO PLL (top level USB0 MIO ULPI clock is an output).
010 - Source for generated clock is ARM PLL (top level USB0 MIO ULPI clock is an output).
011 - Source for generated clock is DDR PLL (top level USB0 MIO ULPI clock is an output)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_GEM0_RCLK_CTRL" offset="0xf8000138" size="0x4">
                <gui_name language="en">GEM0_RCLK_CTRL</gui_name>
                <description language="en">Gigabit Ethernet MAC 0 RX Clock Control</description>
                <bitField access="Read Write" enumerationId="GEM0_RCLK_CTRL_SRCSEL_ENUM" high_bit="4" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0 - Source for generated clock is GEM 0 MIO RX clock.
1 - Source for generated clock is GEM 0 FMIO RX clock.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_GEM1_RCLK_CTRL" offset="0xf800013c" size="0x4">
                <gui_name language="en">GEM1_RCLK_CTRL</gui_name>
                <description language="en">Gigabit Ethernet MAC 1 RX Clock Control</description>
                <bitField access="Read Write" enumerationId="GEM1_RCLK_CTRL_SRCSEL_ENUM" high_bit="4" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0 - Source for generated clock is GEM 0 MIO RX clock.
1 - Source for generated clock is GEM 0 FMIO RX clock.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_GEM0_CLK_CTRL" offset="0xf8000140" size="0x4">
                <gui_name language="en">GEM0_CLK_CTRL</gui_name>
                <description language="en">Gigabit Ethernet MAC 0 Ref Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.
First cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 1xx - Source for generated clock is Ethernet 0 FMIO clock. 00x - Source for generated clock is IO PLL. 010 - Source for generated clock is ARM PLL. 011 - Source for generated clock is DDR PLL</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_GEM1_CLK_CTRL" offset="0xf8000144" size="0x4">
                <gui_name language="en">GEM1_CLK_CTRL</gui_name>
                <description language="en">Gigabit Ethernet MAC 1 Ref Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.
First cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 1xx - Source for generated clock is Ethernet 0 FMIO clock. 00x - Source for generated clock is IO PLL. 010 - Source for generated clock is ARM PLL. 011 - Source for generated clock is DDR PLL</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_SMC_CLK_CTRL" offset="0xf8000148" size="0x4">
                <gui_name language="en">SMC_CLK_CTRL</gui_name>
                <description language="en">SMC Reference Clock Control</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 0x - Source for generated clock is IO PLL. 10 - Source for generated clock is ARM PLL. 11 - Source for generated clock is DDR PLL.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_LQSPI_CLK_CTRL" offset="0xf800014c" size="0x4">
                <gui_name language="en">LQSPI_CLK_CTRL</gui_name>
                <description language="en">Linear Quad-SPI Reference Clock Control</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 0x - Source for generated clock is IO PLL. 10 - Source for generated clock is ARM PLL. 11 - Source for generated clock is DDR PLL.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_SDIO_CLK_CTRL" offset="0xf8000150" size="0x4">
                <gui_name language="en">SDIO_CLK_CTRL</gui_name>
                <description language="en">SDIO Reference Clock Control</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="SDIO_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CLKACT1">
                    <gui_name language="en">CLKACT1</gui_name>
                    <description language="en">SDIO 1 Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT0">
                    <gui_name language="en">CLKACT0</gui_name>
                    <description language="en">SDIO 0 Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_UART_CLK_CTRL" offset="0xf8000154" size="0x4">
                <gui_name language="en">UART_CLK_CTRL</gui_name>
                <description language="en">UART Reference Clock Control</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="UART_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CLKACT1">
                    <gui_name language="en">CLKACT1</gui_name>
                    <description language="en">UART 1 reference clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT0">
                    <gui_name language="en">CLKACT0</gui_name>
                    <description language="en">UART 0 reference clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_SPI_CLK_CTRL" offset="0xf8000158" size="0x4">
                <gui_name language="en">SPI_CLK_CTRL</gui_name>
                <description language="en">SPI Reference Clock Control</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="SPI_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CLKACT1">
                    <gui_name language="en">CLKACT1</gui_name>
                    <description language="en">SPI 1 reference clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT0">
                    <gui_name language="en">CLKACT0</gui_name>
                    <description language="en">SPI 0 reference clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_CAN_CLK_CTRL" offset="0xf800015c" size="0x4">
                <gui_name language="en">CAN_CLK_CTRL</gui_name>
                <description language="en">CAN Reference Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CAN_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CLKACT1">
                    <gui_name language="en">CLKACT1</gui_name>
                    <description language="en">CAN 1 Reference Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT0">
                    <gui_name language="en">CLKACT0</gui_name>
                    <description language="en">CAN 0 Reference Clock active. 0 - Clock is disabled. 1 - Clock is enabled.</description>
                </bitField>
            </register>
            <register name="SLCR_CAN_MIOCLK_CTRL" offset="0xf8000160" size="0x4">
                <gui_name language="en">CAN_MIOCLK_CTRL</gui_name>
                <description language="en">CAN MIO Clock Control</description>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="CAN1_REF_SEL">
                    <gui_name language="en">CAN1_REF_SEL</gui_name>
                    <description language="en">CAN1 Reference Clock selection. 0 - From internal PLL. 1 - From MIO based on the next field</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="16" name="CAN1_MUX">
                    <gui_name language="en">CAN1_MUX</gui_name>
                    <description language="en">CAN1 mux selection for MIO.
Setting this to zero will select MIO[0] as the clock source.
Only values 0-53 are valid.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="CAN0_REF_SEL">
                    <gui_name language="en">CAN0_REF_SEL</gui_name>
                    <description language="en">CAN 0 Reference Clock selection. 0 - From internal PLL. 1 - From MIO based on the next field</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="CAN0_MUX">
                    <gui_name language="en">CAN0_MUX</gui_name>
                    <description language="en">CAN0 mux selection for MIO.
Setting this to zero will select MIO[0] as the clock source.
Only values 0-53 are valid.</description>
                </bitField>
            </register>
            <register name="SLCR_DBG_CLK_CTRL" offset="0xf8000164" size="0x4">
                <gui_name language="en">DBG_CLK_CTRL</gui_name>
                <description language="en">SoC Debug Clock Control</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated debug trace clock frequency.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 1xx - Source for generated clock FMIO trace clock. 00x - Source for generated clock is IO PLL. 010 - Source for generated clock is ARM PLL. 011 - Source for generated clock is DDR PLL</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CPU_1XCLKACT">
                    <gui_name language="en">CPU_1XCLKACT</gui_name>
                    <description language="en">Debug
CPU 1x Clock active. 0 - Clocks are disabled. 1 - Clocks are enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT_TRC">
                    <gui_name language="en">CLKACT_TRC</gui_name>
                    <description language="en">Debug Trace Clock active. 0 - Clock is disabled. 1 - Clock is enabled</description>
                </bitField>
            </register>
            <register name="SLCR_PCAP_CLK_CTRL" offset="0xf8000168" size="0x4">
                <gui_name language="en">PCAP_CLK_CTRL</gui_name>
                <description language="en">PCAP 2X Clock Contol</description>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR">
                    <gui_name language="en">DIVISOR</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock. 0x - Source for generated clock is IO PLL. 10 - Source for generated clock is ARM PLL. 11 - Source for generated clock is DDR PLL</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLKACT">
                    <gui_name language="en">CLKACT</gui_name>
                    <description language="en">Clock active 0 - Clock is disabled 1 - Clock is enabled</description>
                </bitField>
            </register>
            <register name="SLCR_TOPSW_CLK_CTRL" offset="0xf800016c" size="0x4">
                <gui_name language="en">TOPSW_CLK_CTRL</gui_name>
                <description language="en">Top-Level Switch Clock Control</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CLK_DIS">
                    <gui_name language="en">CLK_DIS</gui_name>
                    <description language="en">Clock disable control. 0 - Clock is not disabled. 1 - Clock can be disabled</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA0_CLK_CTRL" offset="0xf8000170" size="0x4">
                <gui_name language="en">FPGA0_CLK_CTRL</gui_name>
                <description language="en">FPGA 0 Output Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA0_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA0_THR_CTRL" offset="0xf8000174" size="0x4">
                <gui_name language="en">FPGA0_THR_CTRL</gui_name>
                <description language="en">FPGA 0 Clock Throttle Control</description>
                <bitField access="Read Write" enumerationId="FPGA0_THR_CTRL_SYNC_ENUM" high_bit="3" low_bit="3" name="SYNC">
                    <gui_name language="en">SYNC</gui_name>
                    <description language="en">Indicates whether fpga_stop input from the fabric should be considered synchronous or asynchronous to generated FPGA clock output.
0 - fpga_stop is asynchronous to FPGA clock.
1 - fpga_stop is synchronous to FPGA clock.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA0_THR_CTRL_EDGE_ENUM" high_bit="2" low_bit="2" name="EDGE">
                    <gui_name language="en">EDGE</gui_name>
                    <description language="en">Selects between edge stop or level stop modes of operation for the clock throttle logic.
0 - debug level stop mode.
1 - debug edge stop mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA0_THR_CTRL_CNT_RST_ENUM" high_bit="1" low_bit="1" name="CNT_RST">
                    <gui_name language="en">CNT_RST</gui_name>
                    <description language="en">Resets clock throttle counter when in halt state.
0 - No effect.
1 - Causes counter to be reset once HALT state is entered.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA0_THR_CTRL_CPU_START_ENUM" high_bit="0" low_bit="0" name="CPU_START">
                    <gui_name language="en">CPU_START</gui_name>
                    <description language="en">Start or restart count on detection of 0 to 1 transition in the value of this bit. A read will always return the written value.
0 - No effect.
1 - Start count or restart count if previous value was 0.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA0_THR_CNT" offset="0xf8000178" size="0x4">
                <gui_name language="en">FPGA0_THR_CNT</gui_name>
                <description language="en">FPGA 0 Clock Throttle Count</description>
                <bitField access="Read Write" high_bit="19" low_bit="16" name="DLY_CNT">
                    <gui_name language="en">DLY_CNT</gui_name>
                    <description language="en">Delay count value. Specifies the minimum number of output clock pulses before entering HALT state due to fpga_stop assertion.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="LAST_CNT">
                    <gui_name language="en">LAST_CNT</gui_name>
                    <description language="en">Last count value. Specifies the total number of clocks output in debug mode by the clock throttle logic.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA0_THR_STA" offset="0xf800017c" size="0x4">
                <gui_name language="en">FPGA0_THR_STA</gui_name>
                <description language="en">FPGA 0 Clock Throttle Status</description>
                <bitField access="Read Write" enumerationId="FPGA0_THR_STA_RUNNING_ENUM" high_bit="16" low_bit="16" name="RUNNING">
                    <gui_name language="en">RUNNING</gui_name>
                    <description language="en">Current running status of FPGA clock output.
0 - Clock is stopped or in normal mode (OK to change config).
1 - Clock is runnnig in debug mode (Keep config static).</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CURR_VAL">
                    <gui_name language="en">CURR_VAL</gui_name>
                    <description language="en">Current clock throttle counter value, which indicates the number of clock pulses output so far (only accurate when halted).</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA1_CLK_CTRL" offset="0xf8000180" size="0x4">
                <gui_name language="en">FPGA1_CLK_CTRL</gui_name>
                <description language="en">FPGA 1 Output Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA1_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA1_THR_CTRL" offset="0xf8000184" size="0x4">
                <gui_name language="en">FPGA1_THR_CTRL</gui_name>
                <description language="en">FPGA 1 Clock Throttle Control</description>
                <bitField access="Read Write" enumerationId="FPGA1_THR_CTRL_SYNC_ENUM" high_bit="3" low_bit="3" name="SYNC">
                    <gui_name language="en">SYNC</gui_name>
                    <description language="en">Indicates whether fpga_stop input from the fabric should be considered synchronous or asynchronous to generated FPGA clock output.
0 - fpga_stop is asynchronous to FPGA clock.
1 - fpga_stop is synchronous to FPGA clock.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA1_THR_CTRL_EDGE_ENUM" high_bit="2" low_bit="2" name="EDGE">
                    <gui_name language="en">EDGE</gui_name>
                    <description language="en">Selects between edge stop or level stop modes of operation for the clock throttle logic.
0 - debug level stop mode.
1 - debug edge stop mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA1_THR_CTRL_CNT_RST_ENUM" high_bit="1" low_bit="1" name="CNT_RST">
                    <gui_name language="en">CNT_RST</gui_name>
                    <description language="en">Resets clock throttle counter when in halt state.
0 - No effect.
1 - Causes counter to be reset once HALT state is entered.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA1_THR_CTRL_CPU_START_ENUM" high_bit="0" low_bit="0" name="CPU_START">
                    <gui_name language="en">CPU_START</gui_name>
                    <description language="en">Start or restart count on detection of 0 to 1 transition in the value of this bit. A read will always return the written value.
0 - No effect.
1 - Start count or restart count if previous value was 0.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA1_THR_CNT" offset="0xf8000188" size="0x4">
                <gui_name language="en">FPGA1_THR_CNT</gui_name>
                <description language="en">FPGA 1 Clock Throttle Count</description>
                <bitField access="Read Write" high_bit="19" low_bit="16" name="DLY_CNT">
                    <gui_name language="en">DLY_CNT</gui_name>
                    <description language="en">Delay count value. Specifies the minimum number of output clock pulses before entering HALT state due to fpga_stop assertion.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="LAST_CNT">
                    <gui_name language="en">LAST_CNT</gui_name>
                    <description language="en">Last count value. Specifies the total number of clocks output in debug mode by the clock throttle logic.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA1_THR_STA" offset="0xf800018c" size="0x4">
                <gui_name language="en">FPGA1_THR_STA</gui_name>
                <description language="en">FPGA 1 Clock Throttle Status</description>
                <bitField access="Read Write" enumerationId="FPGA1_THR_STA_RUNNING_ENUM" high_bit="16" low_bit="16" name="RUNNING">
                    <gui_name language="en">RUNNING</gui_name>
                    <description language="en">Current running status of FPGA clock output.
0 - Clock is stopped or in normal mode (OK to change config).
1 - Clock is runnnig in debug mode (Keep config static).</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CURR_VAL">
                    <gui_name language="en">CURR_VAL</gui_name>
                    <description language="en">Current clock throttle counter value, which indicates the number of clock pulses output so far (only accurate when halted).</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA2_CLK_CTRL" offset="0xf8000190" size="0x4">
                <gui_name language="en">FPGA2_CLK_CTRL</gui_name>
                <description language="en">FPGA 2 Output Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA2_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA2_THR_CTRL" offset="0xf8000194" size="0x4">
                <gui_name language="en">FPGA2_THR_CTRL</gui_name>
                <description language="en">FPGA 2 Clock Throttle Control</description>
                <bitField access="Read Write" enumerationId="FPGA2_THR_CTRL_SYNC_ENUM" high_bit="3" low_bit="3" name="SYNC">
                    <gui_name language="en">SYNC</gui_name>
                    <description language="en">Indicates whether fpga_stop input from the fabric should be considered synchronous or asynchronous to generated FPGA clock output.
0 - fpga_stop is asynchronous to FPGA clock.
1 - fpga_stop is synchronous to FPGA clock.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA2_THR_CTRL_EDGE_ENUM" high_bit="2" low_bit="2" name="EDGE">
                    <gui_name language="en">EDGE</gui_name>
                    <description language="en">Selects between edge stop or level stop modes of operation for the clock throttle logic.
0 - debug level stop mode.
1 - debug edge stop mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA2_THR_CTRL_CNT_RST_ENUM" high_bit="1" low_bit="1" name="CNT_RST">
                    <gui_name language="en">CNT_RST</gui_name>
                    <description language="en">Resets clock throttle counter when in halt state.
0 - No effect.
1 - Causes counter to be reset once HALT state is entered.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA2_THR_CTRL_CPU_START_ENUM" high_bit="0" low_bit="0" name="CPU_START">
                    <gui_name language="en">CPU_START</gui_name>
                    <description language="en">Start or restart count on detection of 0 to 1 transition in the value of this bit. A read will always return the written value.
0 - No effect.
1 - Start count or restart count if previous value was 0.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA2_THR_CNT" offset="0xf8000198" size="0x4">
                <gui_name language="en">FPGA2_THR_CNT</gui_name>
                <description language="en">FPGA 2 Clock Throttle Count</description>
                <bitField access="Read Write" high_bit="19" low_bit="16" name="DLY_CNT">
                    <gui_name language="en">DLY_CNT</gui_name>
                    <description language="en">Delay count value. Specifies the minimum number of output clock pulses before entering HALT state due to fpga_stop assertion.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="LAST_CNT">
                    <gui_name language="en">LAST_CNT</gui_name>
                    <description language="en">Last count value. Specifies the total number of clocks output in debug mode by the clock throttle logic.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA2_THR_STA" offset="0xf800019c" size="0x4">
                <gui_name language="en">FPGA2_THR_STA</gui_name>
                <description language="en">FPGA 2 Clock Throttle Status</description>
                <bitField access="Read Write" enumerationId="FPGA2_THR_STA_RUNNING_ENUM" high_bit="16" low_bit="16" name="RUNNING">
                    <gui_name language="en">RUNNING</gui_name>
                    <description language="en">Current running status of FPGA clock output.
0 - Clock is stopped or in normal mode (OK to change config).
1 - Clock is runnnig in debug mode (Keep config static).</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CURR_VAL">
                    <gui_name language="en">CURR_VAL</gui_name>
                    <description language="en">Current clock throttle counter value, which indicates the number of clock pulses output so far (only accurate when halted).</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA3_CLK_CTRL" offset="0xf80001a0" size="0x4">
                <gui_name language="en">FPGA3_CLK_CTRL</gui_name>
                <description language="en">FPGA 3 Output Clock Control</description>
                <bitField access="Read Write" high_bit="25" low_bit="20" name="DIVISOR1">
                    <gui_name language="en">DIVISOR1</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. Second cascade divider</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="8" name="DIVISOR0">
                    <gui_name language="en">DIVISOR0</gui_name>
                    <description language="en">Provides the divisor used to divide the source clock to generate the required generated clock frequency. First cascade divider</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA3_CLK_CTRL_SRCSEL_ENUM" high_bit="5" low_bit="4" name="SRCSEL">
                    <gui_name language="en">SRCSEL</gui_name>
                    <description language="en">Selects the source used to generate the clock.
0x - Source for generated clock is IO PLL.
10 - Source for generated clock is ARM PLL.
11 - Source for generated clock is DDR PLL.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA3_THR_CTRL" offset="0xf80001a4" size="0x4">
                <gui_name language="en">FPGA3_THR_CTRL</gui_name>
                <description language="en">FPGA 3 Clock Throttle Control</description>
                <bitField access="Read Write" enumerationId="FPGA3_THR_CTRL_SYNC_ENUM" high_bit="3" low_bit="3" name="SYNC">
                    <gui_name language="en">SYNC</gui_name>
                    <description language="en">Indicates whether fpga_stop input from the fabric should be considered synchronous or asynchronous to generated FPGA clock output.
0 - fpga_stop is asynchronous to FPGA clock.
1 - fpga_stop is synchronous to FPGA clock.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA3_THR_CTRL_EDGE_ENUM" high_bit="2" low_bit="2" name="EDGE">
                    <gui_name language="en">EDGE</gui_name>
                    <description language="en">Selects between edge stop or level stop modes of operation for the clock throttle logic.
0 - debug level stop mode.
1 - debug edge stop mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA3_THR_CTRL_CNT_RST_ENUM" high_bit="1" low_bit="1" name="CNT_RST">
                    <gui_name language="en">CNT_RST</gui_name>
                    <description language="en">Resets clock throttle counter when in halt state.
0 - No effect.
1 - Causes counter to be reset once HALT state is entered.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="FPGA3_THR_CTRL_CPU_START_ENUM" high_bit="0" low_bit="0" name="CPU_START">
                    <gui_name language="en">CPU_START</gui_name>
                    <description language="en">Start or restart count on detection of 0 to 1 transition in the value of this bit. A read will always return the written value.
0 - No effect.
1 - Start count or restart count if previous value was 0.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA3_THR_CNT" offset="0xf80001a8" size="0x4">
                <gui_name language="en">FPGA3_THR_CNT</gui_name>
                <description language="en">FPGA 3 Clock Throttle Count</description>
                <bitField access="Read Write" high_bit="19" low_bit="16" name="DLY_CNT">
                    <gui_name language="en">DLY_CNT</gui_name>
                    <description language="en">Delay count value. Specifies the minimum number of output clock pulses before entering HALT state due to fpga_stop assertion.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="LAST_CNT">
                    <gui_name language="en">LAST_CNT</gui_name>
                    <description language="en">Last count value. Specifies the total number of clocks output in debug mode by the clock throttle logic.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA3_THR_STA" offset="0xf80001ac" size="0x4">
                <gui_name language="en">FPGA3_THR_STA</gui_name>
                <description language="en">FPGA 3 Clock Throttle Status</description>
                <bitField access="Read Write" enumerationId="FPGA3_THR_STA_RUNNING_ENUM" high_bit="16" low_bit="16" name="RUNNING">
                    <gui_name language="en">RUNNING</gui_name>
                    <description language="en">Current running status of FPGA clock output.
0 - Clock is stopped or in normal mode (OK to change config).
1 - Clock is runnnig in debug mode (Keep config static).</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="CURR_VAL">
                    <gui_name language="en">CURR_VAL</gui_name>
                    <description language="en">Current clock throttle counter value, which indicates the number of clock pulses output so far (only accurate when halted).</description>
                </bitField>
            </register>
            <register name="SLCR_SYNC_CTRL" offset="0xf80001b0" size="0x4">
                <gui_name language="en">SYNC_CTRL</gui_name>
                <description language="en">Clock Synchronisation Mode Control</description>
                <bitField access="Read Write" enumerationId="SYNC_CTRL_APU_DDR_1TO1_ENUM" high_bit="0" low_bit="0" name="APU_DDR_1TO1">
                    <gui_name language="en">APU_DDR_1TO1</gui_name>
                    <description language="en">Synchronous mode control for the CPU - DDR path
0 - asynchronous mode
1 - CPU and DDR at 1 to 1 clock ratio</description>
                </bitField>
            </register>
            <register name="SLCR_BANDGAP_TRIM" offset="0xf80001b8" size="0x4">
                <gui_name language="en">BANDGAP_TRIM</gui_name>
                <description language="en">Band gap trim register</description>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TRIM_EN">
                    <gui_name language="en">TRIM_EN</gui_name>
                    <description language="en">Use the trim value in this register, if set</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="TRIM_VAL">
                    <gui_name language="en">TRIM_VAL</gui_name>
                    <description language="en">Bandgap trim value</description>
                </bitField>
            </register>
            <register name="SLCR_CC_TEST" offset="0xf80001bc" size="0x4">
                <gui_name language="en">CC_TEST</gui_name>
                <description language="en">Test register</description>
                <bitField access="Read Write" high_bit="6" low_bit="4" name="FB">
                    <gui_name language="en">FB</gui_name>
                    <description language="en">PLL test</description>
                </bitField>
            </register>
            <register name="SLCR_PLL_PREDIVISOR" offset="0xf80001c0" size="0x4">
                <gui_name language="en">PLL_PREDIVISOR</gui_name>
                <description language="en">Divider on the input clock</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="PRE_DIVISOR">
                    <gui_name language="en">PRE_DIVISOR</gui_name>
                    <description language="en">Divisor value.
The input frequency of Zync is between 30-60MHz and the input to the
PLL is between 30-60MHz, there is no reason to change this number from the default
value of one during normal operation.</description>
                </bitField>
            </register>
            <register name="SLCR_CLK_621_TRUE" offset="0xf80001c4" size="0x4">
                <gui_name language="en">CLK_621_TRUE</gui_name>
                <description language="en">6:2:1 ratio clock, if set</description>
                <bitField access="Read Write" enumerationId="CLK_621_TRUE_CLK_621_TRUE_ENUM" high_bit="0" low_bit="0" name="CLK_621_TRUE">
                    <gui_name language="en">CLK_621_TRUE</gui_name>
                    <description language="en">Enable the 6:2:1 mode.
1 for 6:3:2:1.
0 for 4:2:2:1.</description>
                </bitField>
            </register>
            <register name="SLCR_PICTURE_DBG" offset="0xf80001d0" size="0x4">
                <gui_name language="en">PICTURE_DBG</gui_name>
                <description language="en">Picture debug configuartion register</description>
                <bitField access="Read Write" enumerationId="PICTURE_DBG_CLOCK_SEL_ENUM" high_bit="6" low_bit="5" name="CLOCK_SEL">
                    <gui_name language="en">CLOCK_SEL</gui_name>
                    <description language="en">Clock Select.
00=APU PLL clock (default).
01=DDR PLL clock.
10= IO PLL clock.
11= reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TRIGGER_EN">
                    <gui_name language="en">TRIGGER_EN</gui_name>
                    <description language="en">This enables all the triggers.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CNT_LOAD">
                    <gui_name language="en">CNT_LOAD</gui_name>
                    <description language="en">Load the count value into the counter.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PICTURE_DBG_TRIGGER_SEL_ENUM" high_bit="2" low_bit="1" name="TRIGGER_SEL">
                    <gui_name language="en">TRIGGER_SEL</gui_name>
                    <description language="en">Trigger Select.
00 SLCR (default).
01 Fabric (Not implemented).
10 Address match (AXIM) (not implemented)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="START">
                    <gui_name language="en">START</gui_name>
                    <description language="en">Picture debug start, if set.</description>
                </bitField>
            </register>
            <register name="SLCR_PICTURE_DBG_UCNT" offset="0xf80001d4" size="0x4">
                <gui_name language="en">PICTURE_DBG_UCNT</gui_name>
                <description language="en">Picture debug count register, upper 32-bit</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="COUNT_UPPER">
                    <gui_name language="en">COUNT_UPPER</gui_name>
                    <description language="en">Upper 32-bit count value.</description>
                </bitField>
            </register>
            <register name="SLCR_PICTURE_DBG_LCNT" offset="0xf80001d8" size="0x4">
                <gui_name language="en">PICTURE_DBG_LCNT</gui_name>
                <description language="en">Picture debug count register, lower 32-bit</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="COUNT_LOWER">
                    <gui_name language="en">COUNT_LOWER</gui_name>
                    <description language="en">Lower 32-bit count value.</description>
                </bitField>
            </register>
            <register name="SLCR_PSS_RST_CTRL" offset="0xf8000200" size="0x4">
                <gui_name language="en">PSS_RST_CTRL</gui_name>
                <description language="en">PSS Software Reset Control</description>
                <bitField access="Read Write" enumerationId="PSS_RST_CTRL_SOFT_RST_ENUM" high_bit="0" low_bit="0" name="SOFT_RST">
                    <gui_name language="en">SOFT_RST</gui_name>
                    <description language="en">PSS software reset. On assertion of this reset, the entire design will be reset except for the clock generator. This bit is self clearing in that the reset generated will result in the SLCR being reset.
0 - No reset.
1 - PSS software reset initiated.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_RST_CTRL" offset="0xf8000204" size="0x4">
                <gui_name language="en">DDR_RST_CTRL</gui_name>
                <description language="en">DDR Software Reset Control</description>
                <bitField access="Read Write" enumerationId="DDR_RST_CTRL_DDR_RST_ENUM" high_bit="0" low_bit="0" name="DDR_RST">
                    <gui_name language="en">DDR_RST</gui_name>
                    <description language="en">DDR software reset. On assertion of this reset, the DDR subsystem will be reset.
0 - No reset.
1 - DDR subsystem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_DMAC_RST_CTRL" offset="0xf800020c" size="0x4">
                <gui_name language="en">DMAC_RST_CTRL</gui_name>
                <description language="en">DMAC Software Reset Control</description>
                <bitField access="Read Write" enumerationId="DMAC_RST_CTRL_DMAC_RST_ENUM" high_bit="0" low_bit="0" name="DMAC_RST">
                    <gui_name language="en">DMAC_RST</gui_name>
                    <description language="en">DMAC software reset. On assertion of this reset DMAC will be reset.
0 - DMAC not in reset. DMAC TrustZone register is read only.
1 - DMAC held in reset. DMAC TrustZone register is now programmable.</description>
                </bitField>
            </register>
            <register name="SLCR_USB_RST_CTRL" offset="0xf8000210" size="0x4">
                <gui_name language="en">USB_RST_CTRL</gui_name>
                <description language="en">USB Software Reset Control</description>
                <bitField access="Read Write" enumerationId="USB_RST_CTRL_USB1_ULPI_RST_ENUM" high_bit="5" low_bit="5" name="USB1_ULPI_RST">
                    <gui_name language="en">USB1_ULPI_RST</gui_name>
                    <description language="en">USB 1 ULPI software reset. On assertion of this reset, the ULPI clock portion of the USB 1 subsystem will be reset.
0 - No reset.
1 - ULPI clock portion of USB 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USB_RST_CTRL_USB0_ULPI_RST_ENUM" high_bit="4" low_bit="4" name="USB0_ULPI_RST">
                    <gui_name language="en">USB0_ULPI_RST</gui_name>
                    <description language="en">USB 0 ULPI software reset. On assertion of this reset, the ULPI clock portion of the USB 0 subsystem will be reset.
0 - No reset.
1 - ULPI clock portion of USB 0 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USB_RST_CTRL_USB1_CPU1X_RST_ENUM" high_bit="1" low_bit="1" name="USB1_CPU1X_RST">
                    <gui_name language="en">USB1_CPU1X_RST</gui_name>
                    <description language="en">USB 1 master and slave AMBA software reset. On assertion of this reset, the master and slave AMBA clock portion of the USB 1 subsystem will be reset.
0 - No reset.
1 - master and slave AMBA clock portion of USB 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USB_RST_CTRL_USB0_CPU1X_RST_ENUM" high_bit="0" low_bit="0" name="USB0_CPU1X_RST">
                    <gui_name language="en">USB0_CPU1X_RST</gui_name>
                    <description language="en">USB 0 master and slave AMBA software reset. On assertion of this reset, the master and slave AMBA clock portion of the USB 0 subsystem will be reset.
0 - No reset.
1 - master and slave AMBA clock portion of USB 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_GEM_RST_CTRL" offset="0xf8000214" size="0x4">
                <gui_name language="en">GEM_RST_CTRL</gui_name>
                <description language="en">Gigabit Ethernet MAC Software Reset Control</description>
                <bitField access="Read Write" enumerationId="GEM_RST_CTRL_GEM1_REF_RST_ENUM" high_bit="7" low_bit="7" name="GEM1_REF_RST">
                    <gui_name language="en">GEM1_REF_RST</gui_name>
                    <description language="en">Gigabit Ethernet 1 Reference software reset. On assertion of this reset, the Reference clock portion of the GEM 1 subsystem will be reset.
0 - No reset.
1 - Reference clock portion of GEM 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GEM_RST_CTRL_GEM0_REF_RST_ENUM" high_bit="6" low_bit="6" name="GEM0_REF_RST">
                    <gui_name language="en">GEM0_REF_RST</gui_name>
                    <description language="en">Gigabit Ethernet 0 Reference software reset. On assertion of this reset, the Reference clock portion of the GEM 0 subsystem will be reset.
0 - No reset.
1 - Reference clock portion of GEM 0 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GEM_RST_CTRL_GEM1_RX_RST_ENUM" high_bit="5" low_bit="5" name="GEM1_RX_RST">
                    <gui_name language="en">GEM1_RX_RST</gui_name>
                    <description language="en">Gigabit Ethernet MAC 1 RX software reset. On assertion of this reset, the RX clock portion of the GEM 1 subsystem will be reset.
0 - No reset.
1 - RX clock portion of GEM 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GEM_RST_CTRL_GEM0_RX_RST_ENUM" high_bit="4" low_bit="4" name="GEM0_RX_RST">
                    <gui_name language="en">GEM0_RX_RST</gui_name>
                    <description language="en">Gigabit Ethernet MAC 0 RX software reset. On assertion of this reset, the RX clock portion of the GEM 0 subsystem will be reset.
0 - No reset.
1 - RX clock portion of GEM 0 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GEM_RST_CTRL_GEM1_CPU1X_RST_ENUM" high_bit="1" low_bit="1" name="GEM1_CPU1X_RST">
                    <gui_name language="en">GEM1_CPU1X_RST</gui_name>
                    <description language="en">Giagbit Ethernet MAC 1 software reset. On assertion of this reset, the Gigabit Ethernet MAC 1 subsystem will be reset.
0 - No reset.
1 - Gigabit Ethernet MAC 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GEM_RST_CTRL_GEM0_CPU1X_RST_ENUM" high_bit="0" low_bit="0" name="GEM0_CPU1X_RST">
                    <gui_name language="en">GEM0_CPU1X_RST</gui_name>
                    <description language="en">Gigabit Ethernet MAC 0 software reset. On assertion of this reset, the Gigabit Ethernet 0 subsystem will be reset.
0 - No reset.
1 - Gigabit Ethernet MAC 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_SDIO_RST_CTRL" offset="0xf8000218" size="0x4">
                <gui_name language="en">SDIO_RST_CTRL</gui_name>
                <description language="en">SDIO Software Reset Control</description>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="SDIO1_REF_RST">
                    <gui_name language="en">SDIO1_REF_RST</gui_name>
                    <description language="en">SDIO 1 Reference software reset. On assertion of this reset, the Reference clock portion of the SDIO 1 subsystem will be reset. 0 - No reset. 1 - Reference clock portion of SDIO 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SDIO0_REF_RST">
                    <gui_name language="en">SDIO0_REF_RST</gui_name>
                    <description language="en">SDIO 0 Reference software reset. On assertion of this reset, the Reference clock portion of the SDIO 0 subsystem will be reset. 0 - No reset. 1 - Reference clock portion of SDIO 0 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="SDIO_RST_CTRL_SDIO1_CPU1X_RST_ENUM" high_bit="1" low_bit="1" name="SDIO1_CPU1X_RST">
                    <gui_name language="en">SDIO1_CPU1X_RST</gui_name>
                    <description language="en">SDIO 1 master and slave AMBA software reset. On assertion of this reset, the master and slave AMBA clock portion of the SDIO 1 subsystem will be reset.
0 - No reset.
1 - master and slave AMBA clock portion of SDIO 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="SDIO_RST_CTRL_SDIO0_CPU1X_RST_ENUM" high_bit="0" low_bit="0" name="SDIO0_CPU1X_RST">
                    <gui_name language="en">SDIO0_CPU1X_RST</gui_name>
                    <description language="en">SDIO 0 master and slave AMBA software reset. On assertion of this reset, the master and slave AMBA clock portion of the SDIO 0 subsystem will be reset.
0 - No reset.
1 - master and slave AMBA clock portion of SDIO 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_SPI_RST_CTRL" offset="0xf800021c" size="0x4">
                <gui_name language="en">SPI_RST_CTRL</gui_name>
                <description language="en">SPI Software Reset Control</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="SPI1_REF_RST">
                    <gui_name language="en">SPI1_REF_RST</gui_name>
                    <description language="en">SPI 1 Reference software reset. On assertion of this reset, the Reference clock portion of the SPI 1 subsystem will be reset. 0 - No reset. 1 - Reference clock portion of SPI 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="SPI0_REF_RST">
                    <gui_name language="en">SPI0_REF_RST</gui_name>
                    <description language="en">SPI 0 Reference software reset. On assertion of this reset, the Reference clock portion of the SPI 0 subsystem will be reset. 0 - No reset. 1 - Reference clock portion of SPI 0 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="SPI1_CPU1X_RST">
                    <gui_name language="en">SPI1_CPU1X_RST</gui_name>
                    <description language="en">SPI 1 AMBA software reset. On assertion of this reset, the AMBA clock portion of the SPI 1 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of SPI 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="SPI0_CPU1X_RST">
                    <gui_name language="en">SPI0_CPU1X_RST</gui_name>
                    <description language="en">SPI 0 AMBA software reset. On assertion of this reset, the AMBA clock portion of the SPI 0 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of SPI 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_CAN_RST_CTRL" offset="0xf8000220" size="0x4">
                <gui_name language="en">CAN_RST_CTRL</gui_name>
                <description language="en">CAN Software Reset Control</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="CAN1_REF_RST">
                    <gui_name language="en">CAN1_REF_RST</gui_name>
                    <description language="en">CAN 1 Reference software reset. On assertion of this reset, the Reference clock portion of the CAN 1 subsystem will be reset. 0 - No reset. 1 - Reference clock portion of CAN 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CAN0_REF_RST">
                    <gui_name language="en">CAN0_REF_RST</gui_name>
                    <description language="en">CAN 0 Reference software reset. On assertion of this reset, the Reference clock portion of the CAN 0 subsystem will be reset. 0 - No reset. 1 - Reference clock portion of CAN 0 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CAN1_CPU1X_RST">
                    <gui_name language="en">CAN1_CPU1X_RST</gui_name>
                    <description language="en">CAN 1 AMBA software reset. On assertion of this reset, the AMBA clock portion of the CAN 1 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of CAN 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="CAN0_CPU1X_RST">
                    <gui_name language="en">CAN0_CPU1X_RST</gui_name>
                    <description language="en">CAN 0 AMBA software reset. On assertion of this reset, the AMBA clock portion of the CAN 0 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of CAN 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_I2C_RST_CTRL" offset="0xf8000224" size="0x4">
                <gui_name language="en">I2C_RST_CTRL</gui_name>
                <description language="en">I2C Software Reset Control</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="I2C1_CPU1X_RST">
                    <gui_name language="en">I2C1_CPU1X_RST</gui_name>
                    <description language="en">I2C 1 AMBA software reset. On assertion of this reset, the AMBA clock portion of the I2C 1 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of I2C 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="I2C0_CPU1X_RST">
                    <gui_name language="en">I2C0_CPU1X_RST</gui_name>
                    <description language="en">I2C 0 AMBA software reset. On assertion of this reset, the AMBA clock portion of the I2C 0 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of I2C 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_UART_RST_CTRL" offset="0xf8000228" size="0x4">
                <gui_name language="en">UART_RST_CTRL</gui_name>
                <description language="en">UART Software Reset Control</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="UART1_REF_RST">
                    <gui_name language="en">UART1_REF_RST</gui_name>
                    <description language="en">UART1 Reference software reset. 0 - deassert soft reset. 1 - assert soft reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="UART0_REF_RST">
                    <gui_name language="en">UART0_REF_RST</gui_name>
                    <description language="en">UART0 Reference software reset. 0 - deassert soft reset. 1 - assert soft reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="UART1_CPU1X_RST">
                    <gui_name language="en">UART1_CPU1X_RST</gui_name>
                    <description language="en">UART 1 AMBA software reset. On assertion of this reset, the AMBA clock portion of the UART 1 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of UART 1 subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="UART0_CPU1X_RST">
                    <gui_name language="en">UART0_CPU1X_RST</gui_name>
                    <description language="en">UART 0 AMBA software reset. On assertion of this reset, the AMBA clock portion of the UART 0 subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of UART 0 subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_GPIO_RST_CTRL" offset="0xf800022c" size="0x4">
                <gui_name language="en">GPIO_RST_CTRL</gui_name>
                <description language="en">GPIO Software Reset Control</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GPIO_CPU1X_RST">
                    <gui_name language="en">GPIO_CPU1X_RST</gui_name>
                    <description language="en">GPIO AMBA software reset. On assertion of this reset, the AMBA clock portion of the GPIO subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of GPIO subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_LQSPI_RST_CTRL" offset="0xf8000230" size="0x4">
                <gui_name language="en">LQSPI_RST_CTRL</gui_name>
                <description language="en">Linear Quad-SpI Software Reset Control</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="QSPI_REF_RST">
                    <gui_name language="en">QSPI_REF_RST</gui_name>
                    <description language="en">QSPI Reference software reset. On assertion of this reset, the Reference clock portion of the QSPI subsystem will be reset. 0 - No reset. 1 - Reference clock portion of QSPI subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="LQSPI_CPU1X_RST">
                    <gui_name language="en">LQSPI_CPU1X_RST</gui_name>
                    <description language="en">Linear QSPI AMBA software reset. On assertion of this reset, the AMBA clock portion of the LQSPI subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of QSPI subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_SMC_RST_CTRL" offset="0xf8000234" size="0x4">
                <gui_name language="en">SMC_RST_CTRL</gui_name>
                <description language="en">SMC Software Reset Control</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="SMC_REF_RST">
                    <gui_name language="en">SMC_REF_RST</gui_name>
                    <description language="en">SMC Reference software reset. On assertion of this reset, the Reference clock portion of the SMC subsystem will be reset. 0 - No reset. 1 - Reference clock portion of SMC subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="SMC_CPU1X_RST">
                    <gui_name language="en">SMC_CPU1X_RST</gui_name>
                    <description language="en">SMC AMBA software reset. On assertion of this reset, the AMBA clock portion of the SMC subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of SMC subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_OCM_RST_CTRL" offset="0xf8000238" size="0x4">
                <gui_name language="en">OCM_RST_CTRL</gui_name>
                <description language="en">OCM Software Reset Control</description>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="OCM_RST">
                    <gui_name language="en">OCM_RST</gui_name>
                    <description language="en">OCM software reset. On assertion of this reset, the OCM subsystem will be reset. 0 - No reset. 1 - OCM subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_DEVCI_RST_CTRL" offset="0xf800023c" size="0x4">
                <gui_name language="en">DEVCI_RST_CTRL</gui_name>
                <description language="en">Device Config Interface Software Reset Control</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="DEVCI_CPU1X_RST">
                    <gui_name language="en">DEVCI_CPU1X_RST</gui_name>
                    <description language="en">Device Configuration AMBA software reset. On assertion of this reset, the AMBA clock portion of the Device Config subsystem will be reset. 0 - No reset. 1 - AMBA clock portion of Device Configuration subsytem held in reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PCAP2X_RST">
                    <gui_name language="en">PCAP2X_RST</gui_name>
                    <description language="en">Device Configuration PCAP2X software reset. On assertion of this reset, the PCAP2X clock portion of the Device Config subsystem will be reset. 0 - No reset. 1 - PCAP2X clock portion of Device Configuration subsytem held in reset.</description>
                </bitField>
            </register>
            <register name="SLCR_FPGA_RST_CTRL" offset="0xf8000240" size="0x4">
                <gui_name language="en">FPGA_RST_CTRL</gui_name>
                <description language="en">FPGA Software Reset Control</description>
                <bitField access="Read Write" enumerationId="FPGA_RST_CTRL_FPGA_ACP_RST_ENUM" high_bit="24" low_bit="24" name="FPGA_ACP_RST">
                    <gui_name language="en">FPGA_ACP_RST</gui_name>
                    <description language="en">FPGA ACP port soft reset.
0 - No reset. 1 - ACP AXI interface reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="FPGA_AXDS3_RST">
                    <gui_name language="en">FPGA_AXDS3_RST</gui_name>
                    <description language="en">AXDS3AXI interface soft reset. On assertion of this reset, the AXDS3AXI interface reset output will be asserted. 0 - No reset. 1 - AXDS3AXI interface reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="FPGA_AXDS2_RST">
                    <gui_name language="en">FPGA_AXDS2_RST</gui_name>
                    <description language="en">AXDS2 AXI interface soft reset. On assertion of this reset, the AXDS2 AXI interface reset output will be asserted. 0 - No reset. 1 - AXDS2 AXI interface reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="FPGA_AXDS1_RST">
                    <gui_name language="en">FPGA_AXDS1_RST</gui_name>
                    <description language="en">AXDS1 AXI interface soft reset. On assertion of this reset, the AXDS1 AXI interface reset output will be asserted. 0 - No reset. 1 - AXDS1 AXI interface reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="FPGA_AXDS0_RST">
                    <gui_name language="en">FPGA_AXDS0_RST</gui_name>
                    <description language="en">AXDS0 AXI interface soft reset. On assertion of this reset, the AXDS0 AXI interface reset output will be asserted. 0 - No reset. 1 - AXDS0 AXI interface reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="FSSW1_FPGA_RST">
                    <gui_name language="en">FSSW1_FPGA_RST</gui_name>
                    <description language="en">General purpose FPGA slave interface 1 soft reset. On assertion of this reset, the FPGA slave interface 1 reset will be asserted. 0 - No reset. 1 - FPGA slave interface 1 reset is asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="FSSW0_FPGA_RST">
                    <gui_name language="en">FSSW0_FPGA_RST</gui_name>
                    <description language="en">General purpose FPGA slave interface 0 soft reset. On assertion of this reset, the FPGA slave interface 0 reset will be asserted. 0 - No reset. 1 - FPGA slave interface 0 reset is asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="FPGA_FMSW1_RST">
                    <gui_name language="en">FPGA_FMSW1_RST</gui_name>
                    <description language="en">General purpose FPGA master interface 1 soft reset. On assertion of this reset, the FPGA master interface 1 reset will be asserted. 0 - No reset. 1 - FPGA master interface 1 reset is asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="FPGA_FMSW0_RST">
                    <gui_name language="en">FPGA_FMSW0_RST</gui_name>
                    <description language="en">General purpose FPGA master interface 0 soft reset. On assertion of this reset, the FPGA master interface 0 reset will be asserted. 0 - No reset. 1 - FPGA master interface 0 reset is asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="FPGA_DMA3_RST">
                    <gui_name language="en">FPGA_DMA3_RST</gui_name>
                    <description language="en">FPGA DMA 3 peripheral request soft reset. On assertion of this reset, the FPGA DMA 3 peripheral request reset output will be asserted. 0 - No reset. 1 - FPGA DMA 3 peripheral request reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="FPGA_DMA2_RST">
                    <gui_name language="en">FPGA_DMA2_RST</gui_name>
                    <description language="en">FPGA DMA 2 peripheral request soft reset. On assertion of this reset, the FPGA DMA 2 peripheral request reset output will be asserted. 0 - No reset. 1 - FPGA DMA 2 peripheral request reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="FPGA_DMA1_RST">
                    <gui_name language="en">FPGA_DMA1_RST</gui_name>
                    <description language="en">FPGA DMA 1 peripheral request soft reset. On assertion of this reset, the FPGA DMA 1 peripheral request reset output will be asserted. 0 - No reset. 1 - FPGA DMA 1 peripheral request reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="FPGA_DMA0_RST">
                    <gui_name language="en">FPGA_DMA0_RST</gui_name>
                    <description language="en">FPGA DMA 0 peripheral request soft reset. On assertion of this reset, the FPGA DMA 0 peripheral request reset output will be asserted. 0 - No reset. 1 - FPGA DMA 0 peripheral request reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="FPGA3_OUT_RST">
                    <gui_name language="en">FPGA3_OUT_RST</gui_name>
                    <description language="en">FPGA3software reset. On assertion of this reset, the FPGA 3 top level reset output will be asserted. 0 - No reset. 1 - FPGA 3 top level reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="FPGA2_OUT_RST">
                    <gui_name language="en">FPGA2_OUT_RST</gui_name>
                    <description language="en">FPGA2 software reset. On assertion of this reset, the FPGA 2 top level reset output will be asserted. 0 - No reset. 1 - FPGA 2 top level reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="FPGA1_OUT_RST">
                    <gui_name language="en">FPGA1_OUT_RST</gui_name>
                    <description language="en">FPGA1 software reset. On assertion of this reset, the FPGA 1 top level reset output will be asserted. 0 - No reset. 1 - FPGA 1 top level reset output asserted.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="FPGA0_OUT_RST">
                    <gui_name language="en">FPGA0_OUT_RST</gui_name>
                    <description language="en">FPGA0 software reset. On assertion of this reset, the FPGA 0 top level reset output will be asserted. 0 - No reset. 1 - FPGA 0 top level reset output asserted.</description>
                </bitField>
            </register>
            <register name="SLCR_A9_CPU_RST_CTRL" offset="0xf8000244" size="0x4">
                <gui_name language="en">A9_CPU_RST_CTRL</gui_name>
                <description language="en">A9 CPU software Reset Control</description>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="PERI_RST">
                    <gui_name language="en">PERI_RST</gui_name>
                    <description language="en">CPU peripheral soft reset.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="A9_CLKSTOP1">
                    <gui_name language="en">A9_CLKSTOP1</gui_name>
                    <description language="en">Clock stop if 1 for core 1</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="A9_CLKSTOP0">
                    <gui_name language="en">A9_CLKSTOP0</gui_name>
                    <description language="en">Clock stop if 1 for core 0</description>
                </bitField>
                <bitField access="Read Write" enumerationId="A9_CPU_RST_CTRL_A9_RST1_ENUM" high_bit="1" low_bit="1" name="A9_RST1">
                    <gui_name language="en">A9_RST1</gui_name>
                    <description language="en">0 - No reset.
1 - reset A9 core 1.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="A9_CPU_RST_CTRL_A9_RST0_ENUM" high_bit="0" low_bit="0" name="A9_RST0">
                    <gui_name language="en">A9_RST0</gui_name>
                    <description language="en">0 - No reset.
1 - reset A9 core 0.</description>
                </bitField>
            </register>
            <register name="SLCR_RS_AWDT_CTRL" offset="0xf800024c" size="0x4">
                <gui_name language="en">RS_AWDT_CTRL</gui_name>
                <description language="en">Watchdog Timer Reset Control</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CTRL1">
                    <gui_name language="en">CTRL1</gui_name>
                    <description language="en">When the APU watchdog timer 1 goes off, the SLCR can control whether the whole system is reboot or just the ARM core who's WDT went off will be reset. 0 - reset Pele; 1 - reset ARM core</description>
                </bitField>
                <bitField access="Read Write" enumerationId="RS_AWDT_CTRL_CTRL0_ENUM" high_bit="0" low_bit="0" name="CTRL0">
                    <gui_name language="en">CTRL0</gui_name>
                    <description language="en">When the APU watchdog timer 0 goes off, the SLCR can control whether the whole system is reboot or just the ARM core who's WDT went off will be reset.
0 - reset Pele;
1 - reset ARM core</description>
                </bitField>
            </register>
            <register access="Read Only" name="SLCR_RST_REASON" offset="0xf8000250" size="0x4">
                <gui_name language="en">RST_REASON</gui_name>
                <description language="en">Reset Reason</description>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="POR">
                    <gui_name language="en">POR</gui_name>
                    <description language="en">Last reset was due to POR (power on reset), if set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="SRST_B">
                    <gui_name language="en">SRST_B</gui_name>
                    <description language="en">Last reset was due to SRST_B (soft reset), if set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="DBG_RST">
                    <gui_name language="en">DBG_RST</gui_name>
                    <description language="en">Last reset was due to debug system
reset, if set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="SLC_RST">
                    <gui_name language="en">SLC_RST</gui_name>
                    <description language="en">Last reset was due to SLC soft reset, if set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="AWDT1_RST">
                    <gui_name language="en">AWDT1_RST</gui_name>
                    <description language="en">Last reset was due to APU watchdog timer 1, if set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="AWDT0_RST">
                    <gui_name language="en">AWDT0_RST</gui_name>
                    <description language="en">Last reset was due to APU watchdog timer 0, if set.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="SWDT_RST">
                    <gui_name language="en">SWDT_RST</gui_name>
                    <description language="en">Last reset was due to system watchdog timeout, if set (see watchdog status for more details).</description>
                </bitField>
            </register>
            <register name="SLCR_RST_REASON_CLR" offset="0xf8000254" size="0x4">
                <gui_name language="en">RST_REASON_CLR</gui_name>
                <description language="en">Reset Reason Clear</description>
                <bitField access="Write Only" high_bit="0" low_bit="0" name="CLEAR">
                    <gui_name language="en">CLEAR</gui_name>
                    <description language="en">Clears reset reason source within the reset controller. 0 - No effect. 1 - Clears reset reason source. A read of this register always returns zero.</description>
                </bitField>
            </register>
            <register name="SLCR_REBOOT_STATUS" offset="0xf8000258" size="0x4">
                <gui_name language="en">REBOOT_STATUS</gui_name>
                <description language="en">Reboot Status (persistent through all resets except Power-on reset)</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="REBOOT_STATE">
                    <gui_name language="en">REBOOT_STATE</gui_name>
                    <description language="en">General 32-bit R/W field to allow software to store information that persists through all resets except power-on reset.</description>
                </bitField>
            </register>
            <register name="SLCR_BOOT_MODE" offset="0xf800025c" size="0x4">
                <gui_name language="en">BOOT_MODE</gui_name>
                <description language="en">Boot Mode bootstrap register</description>
                <bitField access="Read Only" enumerationId="BOOT_MODE_PLL_BYPASS_ENUM" high_bit="4" low_bit="4" name="PLL_BYPASS">
                    <gui_name language="en">PLL_BYPASS</gui_name>
                    <description language="en">Sampled bootstrap to indicate whether PLLs should be bypassed by default after deglicthed power on reset has completed.
0 - All PLL outputs are by default routed to clock distribution.
1 - All PLL outputs are bypassed and reference clock input will feed clock distribution</description>
                </bitField>
                <bitField access="Read Only" enumerationId="BOOT_MODE_BOOT_MODE_ENUM" high_bit="3" low_bit="0" name="BOOT_MODE">
                    <gui_name language="en">BOOT_MODE</gui_name>
                    <description language="en">Sampled bootstrap to indicate current boot mode. Interpreted by software:
x000 - PSS boots from QSPI
x001 - PSS boots from NAND
x010 - PSS boots from NOR
x011 - PSS boots from FPGA, Xilinx internal mode
0100 - PSS boots from JTAG on FPGA side
0111 - DFT mode, special mode to enable FPGA immediately with security shut down.
The reset value depends on what the mode pins are tied to at immediately after reset.</description>
                </bitField>
            </register>
            <register name="SLCR_APU_CTRL" offset="0xf8000300" size="0x4">
                <gui_name language="en">APU_CTRL</gui_name>
                <description language="en">APU Control</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="CFGSDISABLE">
                    <gui_name language="en">CFGSDISABLE</gui_name>
                    <description language="en">Disables write access to some system control processor registers, and some GIC registers.
Set only.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="CP15SDISABLE">
                    <gui_name language="en">CP15SDISABLE</gui_name>
                    <description language="en">Disable write access to some system control processor (CP15) registers, in each processor. Set only.
Once set, individual core reset cannot reset this value.</description>
                </bitField>
            </register>
            <register name="SLCR_WDT_CLK_SEL" offset="0xf8000304" size="0x4">
                <gui_name language="en">WDT_CLK_SEL</gui_name>
                <description language="en">APU watchdog timer clock select</description>
                <bitField access="Read Write" enumerationId="WDT_CLK_SEL_SEL_ENUM" high_bit="0" low_bit="0" name="SEL">
                    <gui_name language="en">SEL</gui_name>
                    <description language="en">Watchdog timer clock source selection.
0 - cpu_1xclk.
1 - wdt_clk_in from FPGA.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_OCM_RAM0" offset="0xf8000400" size="0x4">
                <gui_name language="en">TZ_OCM_RAM0</gui_name>
                <description language="en">OCM RAM TrustZone Configuration Register 0</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="TZ31">
                    <gui_name language="en">TZ31</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="TZ30">
                    <gui_name language="en">TZ30</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="TZ29">
                    <gui_name language="en">TZ29</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="TZ28">
                    <gui_name language="en">TZ28</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="TZ27">
                    <gui_name language="en">TZ27</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="TZ26">
                    <gui_name language="en">TZ26</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TZ25">
                    <gui_name language="en">TZ25</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TZ24">
                    <gui_name language="en">TZ24</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="TZ23">
                    <gui_name language="en">TZ23</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="TZ22">
                    <gui_name language="en">TZ22</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="TZ21">
                    <gui_name language="en">TZ21</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="TZ20">
                    <gui_name language="en">TZ20</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="TZ19">
                    <gui_name language="en">TZ19</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="TZ18">
                    <gui_name language="en">TZ18</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="TZ17">
                    <gui_name language="en">TZ17</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TZ16">
                    <gui_name language="en">TZ16</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="TZ15">
                    <gui_name language="en">TZ15</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="TZ14">
                    <gui_name language="en">TZ14</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="TZ13">
                    <gui_name language="en">TZ13</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="TZ12">
                    <gui_name language="en">TZ12</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="TZ11">
                    <gui_name language="en">TZ11</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="TZ10">
                    <gui_name language="en">TZ10</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TZ9">
                    <gui_name language="en">TZ9</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TZ8">
                    <gui_name language="en">TZ8</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="TZ7">
                    <gui_name language="en">TZ7</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="TZ6">
                    <gui_name language="en">TZ6</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="TZ5">
                    <gui_name language="en">TZ5</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TZ4">
                    <gui_name language="en">TZ4</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="TZ3">
                    <gui_name language="en">TZ3</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="TZ2">
                    <gui_name language="en">TZ2</gui_name>
                    <description language="en">TrustZone status for 4KB page 2 at 8KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TZ1">
                    <gui_name language="en">TZ1</gui_name>
                    <description language="en">TrustZone status for 4KB page 1 at 4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TZ0">
                    <gui_name language="en">TZ0</gui_name>
                    <description language="en">TrustZone status for 4KB page 0 at 0KB</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_OCM_RAM1" offset="0xf8000404" size="0x4">
                <gui_name language="en">TZ_OCM_RAM1</gui_name>
                <description language="en">OCM RAM TrustZone Configuration Register 1</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="TZ63">
                    <gui_name language="en">TZ63</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="TZ62">
                    <gui_name language="en">TZ62</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="TZ61">
                    <gui_name language="en">TZ61</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="TZ60">
                    <gui_name language="en">TZ60</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="TZ59">
                    <gui_name language="en">TZ59</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="TZ58">
                    <gui_name language="en">TZ58</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TZ57">
                    <gui_name language="en">TZ57</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TZ56">
                    <gui_name language="en">TZ56</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="TZ55">
                    <gui_name language="en">TZ55</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="TZ54">
                    <gui_name language="en">TZ54</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="TZ53">
                    <gui_name language="en">TZ53</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="TZ52">
                    <gui_name language="en">TZ52</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="TZ51">
                    <gui_name language="en">TZ51</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="TZ50">
                    <gui_name language="en">TZ50</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="TZ49">
                    <gui_name language="en">TZ49</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TZ48">
                    <gui_name language="en">TZ48</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="TZ47">
                    <gui_name language="en">TZ47</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="TZ46">
                    <gui_name language="en">TZ46</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="TZ45">
                    <gui_name language="en">TZ45</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="TZ44">
                    <gui_name language="en">TZ44</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="TZ43">
                    <gui_name language="en">TZ43</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="TZ42">
                    <gui_name language="en">TZ42</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TZ41">
                    <gui_name language="en">TZ41</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TZ40">
                    <gui_name language="en">TZ40</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="TZ39">
                    <gui_name language="en">TZ39</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="TZ38">
                    <gui_name language="en">TZ38</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="TZ37">
                    <gui_name language="en">TZ37</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TZ36">
                    <gui_name language="en">TZ36</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="TZ35">
                    <gui_name language="en">TZ35</gui_name>
                    <description language="en">TrustZone status for 4KB page (32+n) at (32+n)*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="TZ34">
                    <gui_name language="en">TZ34</gui_name>
                    <description language="en">TrustZone status for 4KB page 34 at 136KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TZ33">
                    <gui_name language="en">TZ33</gui_name>
                    <description language="en">TrustZone status for 4KB page 33 at 132KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TZ32">
                    <gui_name language="en">TZ32</gui_name>
                    <description language="en">TrustZone status for 4KB page 32 at 128KB</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_OCM_ROM" offset="0xf8000408" size="0x4">
                <gui_name language="en">TZ_OCM_ROM</gui_name>
                <description language="en">OCM ROM TrustZone Configuration Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="TZ95">
                    <gui_name language="en">TZ95</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="TZ94">
                    <gui_name language="en">TZ94</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="TZ93">
                    <gui_name language="en">TZ93</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="TZ92">
                    <gui_name language="en">TZ92</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="TZ91">
                    <gui_name language="en">TZ91</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="TZ90">
                    <gui_name language="en">TZ90</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TZ89">
                    <gui_name language="en">TZ89</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TZ88">
                    <gui_name language="en">TZ88</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="TZ87">
                    <gui_name language="en">TZ87</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="TZ86">
                    <gui_name language="en">TZ86</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="TZ85">
                    <gui_name language="en">TZ85</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="TZ84">
                    <gui_name language="en">TZ84</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="TZ83">
                    <gui_name language="en">TZ83</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="TZ82">
                    <gui_name language="en">TZ82</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="TZ81">
                    <gui_name language="en">TZ81</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TZ80">
                    <gui_name language="en">TZ80</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="TZ79">
                    <gui_name language="en">TZ79</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="TZ78">
                    <gui_name language="en">TZ78</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="TZ77">
                    <gui_name language="en">TZ77</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="TZ76">
                    <gui_name language="en">TZ76</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="TZ75">
                    <gui_name language="en">TZ75</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="TZ74">
                    <gui_name language="en">TZ74</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TZ73">
                    <gui_name language="en">TZ73</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TZ72">
                    <gui_name language="en">TZ72</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="TZ71">
                    <gui_name language="en">TZ71</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="TZ70">
                    <gui_name language="en">TZ70</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="TZ69">
                    <gui_name language="en">TZ69</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TZ68">
                    <gui_name language="en">TZ68</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="TZ67">
                    <gui_name language="en">TZ67</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="TZ66">
                    <gui_name language="en">TZ66</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TZ65">
                    <gui_name language="en">TZ65</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TZ64">
                    <gui_name language="en">TZ64</gui_name>
                    <description language="en">TrustZone status for 4KB page n at n*4KB</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_DDR_RAM" offset="0xf8000430" size="0x4">
                <gui_name language="en">TZ_DDR_RAM</gui_name>
                <description language="en">DDR RAM TrustZone Configuration Register</description>
                <bitField access="Read Write" enumerationId="TZ_DDR_RAM_TZ31_ENUM" high_bit="31" low_bit="31" name="TZ31">
                    <gui_name language="en">TZ31</gui_name>
                    <description language="en">TrustZone status for 64MB section n at n*64MB.
0 = Secure, reset value.
1 = Non-secure.</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="TZ30">
                    <gui_name language="en">TZ30</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="TZ29">
                    <gui_name language="en">TZ29</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="TZ28">
                    <gui_name language="en">TZ28</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="TZ27">
                    <gui_name language="en">TZ27</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="TZ26">
                    <gui_name language="en">TZ26</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TZ25">
                    <gui_name language="en">TZ25</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TZ24">
                    <gui_name language="en">TZ24</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="TZ23">
                    <gui_name language="en">TZ23</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="TZ22">
                    <gui_name language="en">TZ22</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="TZ21">
                    <gui_name language="en">TZ21</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="TZ20">
                    <gui_name language="en">TZ20</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="TZ19">
                    <gui_name language="en">TZ19</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="TZ18">
                    <gui_name language="en">TZ18</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="TZ17">
                    <gui_name language="en">TZ17</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TZ16">
                    <gui_name language="en">TZ16</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="TZ15">
                    <gui_name language="en">TZ15</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="TZ14">
                    <gui_name language="en">TZ14</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="TZ13">
                    <gui_name language="en">TZ13</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="TZ12">
                    <gui_name language="en">TZ12</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="TZ11">
                    <gui_name language="en">TZ11</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="TZ10">
                    <gui_name language="en">TZ10</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="TZ9">
                    <gui_name language="en">TZ9</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TZ8">
                    <gui_name language="en">TZ8</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="TZ7">
                    <gui_name language="en">TZ7</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="TZ6">
                    <gui_name language="en">TZ6</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="TZ5">
                    <gui_name language="en">TZ5</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TZ4">
                    <gui_name language="en">TZ4</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="TZ3">
                    <gui_name language="en">TZ3</gui_name>
                    <description language="en">same</description>
                </bitField>
                <bitField access="Read Write" enumerationId="TZ_DDR_RAM_TZ2_ENUM" high_bit="2" low_bit="2" name="TZ2">
                    <gui_name language="en">TZ2</gui_name>
                    <description language="en">TrustZone status for 64MB section n at n*64MB.
0 = Secure, reset value.
1 = Non-secure.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="TZ_DDR_RAM_TZ1_ENUM" high_bit="1" low_bit="1" name="TZ1">
                    <gui_name language="en">TZ1</gui_name>
                    <description language="en">TrustZone status for 64MB section 1 at 64MB.
0 = Secure, reset value.
1 = Non-secure.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="TZ_DDR_RAM_TZ0_ENUM" high_bit="0" low_bit="0" name="TZ0">
                    <gui_name language="en">TZ0</gui_name>
                    <description language="en">TrustZone status for 64MB section 0 at 0MB.
0 = Secure, reset value.
1 = Non-secure.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_DMA_NS" offset="0xf8000440" size="0x4">
                <gui_name language="en">TZ_DMA_NS</gui_name>
                <description language="en">DMAC TrustZone Configuration Register</description>
                <bitField access="Read Write" enumerationId="TZ_DMA_NS_DMAC_NS_ENUM" high_bit="0" low_bit="0" name="DMAC_NS">
                    <gui_name language="en">DMAC_NS</gui_name>
                    <description language="en">TZ security.
0 = secure, DMAC operates in the secure state.
1 = non-secure, DMAC operates in the non-secure state.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_DMA_IRQ_NS" offset="0xf8000444" size="0x4">
                <gui_name language="en">TZ_DMA_IRQ_NS</gui_name>
                <description language="en">DMAC TrustZone Configuration Register for Interrupts</description>
                <bitField access="Read Write" enumerationId="TZ_DMA_IRQ_NS_DMA_IRQ_NS_ENUM" high_bit="15" low_bit="0" name="DMA_IRQ_NS">
                    <gui_name language="en">DMA_IRQ_NS</gui_name>
                    <description language="en">TZ security.
0 = secure, DMAC operates in the secure state.
1 = non-secure, DMAC interrupt/event bit is in the non-secure state.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_DMA_PERIPH_NS" offset="0xf8000448" size="0x4">
                <gui_name language="en">TZ_DMA_PERIPH_NS</gui_name>
                <description language="en">DMAC TrustZone Configuration Register for Peripherals</description>
                <bitField access="Read Write" enumerationId="TZ_DMA_PERIPH_NS_DMAC_PERIPH_NS_ENUM" high_bit="3" low_bit="0" name="DMAC_PERIPH_NS">
                    <gui_name language="en">DMAC_PERIPH_NS</gui_name>
                    <description language="en">TZ security.
0 = secure, DMAC operates in the secure state.
1 = non-secure, reset value: DMAC peripheral i/f is in the non-secure state.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_GEM" offset="0xf8000450" size="0x4">
                <gui_name language="en">TZ_GEM</gui_name>
                <description language="en">GEM TrustZone Configuration Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E1">
                    <gui_name language="en">E1</gui_name>
                    <description language="en">TrustZone status for Gigabit Ethernet MAC 1. 0 = Secure, reset value. 1 = Non-secure.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E0">
                    <gui_name language="en">E0</gui_name>
                    <description language="en">TrustZone status for Gigabit Ethernet MAC 0. 0 = Secure, reset value. 1 = Non-secure.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_SDIO" offset="0xf8000454" size="0x4">
                <gui_name language="en">TZ_SDIO</gui_name>
                <description language="en">SDIO TrustZone Configuration Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="S1">
                    <gui_name language="en">S1</gui_name>
                    <description language="en">TrustZone status for SDIO controller 1. 0 = Secure, reset value. 1 = Non-secure.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="S0">
                    <gui_name language="en">S0</gui_name>
                    <description language="en">TrustZone status for SDIO controller 0. 0 = Secure, reset value. 1 = Non-secure.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_USB" offset="0xf8000458" size="0x4">
                <gui_name language="en">TZ_USB</gui_name>
                <description language="en">USB TrustZone Configuration Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="U1">
                    <gui_name language="en">U1</gui_name>
                    <description language="en">TrustZone status for USB controller 1. 0 = Secure, reset value. 1 = Non-secure.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="U0">
                    <gui_name language="en">U0</gui_name>
                    <description language="en">TrustZone status for USB controller 0. 0 = Secure, reset value. 1 = Non-secure.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_FPGA_M" offset="0xf8000484" size="0x4">
                <gui_name language="en">TZ_FPGA_M</gui_name>
                <description language="en">FPGA master ports TrustZone Disable Register</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Secure disable for FPGA AXI master port 1. 0 = master port can make Secure and Non-secure accesses, reset value. 1 = master port can only make Non-secure accesses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="M0">
                    <gui_name language="en">M0</gui_name>
                    <description language="en">Secure disable for FPGA AXI master port 0. 0 = master port can make Secure and Non-secure accesses, reset value. 1 = master port can only make Non-secure accesses.</description>
                </bitField>
            </register>
            <register name="SLCR_TZ_FPGA_AFI" offset="0xf8000488" size="0x4">
                <gui_name language="en">TZ_FPGA_AFI</gui_name>
                <description language="en">FPGA AFI AXI ports TrustZone Disable Register</description>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="P3">
                    <gui_name language="en">P3</gui_name>
                    <description language="en">Secure disable for FPGA AFI AXI port 3. 0 = port can make Secure and Non-secure accesses, reset value. 1 = port can only make Non-secure accesses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="P2">
                    <gui_name language="en">P2</gui_name>
                    <description language="en">Secure disable for FPGA AFI AXI port 2. 0 = port can make Secure and Non-secure accesses, reset value. 1 = port can only make Non-secure accesses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="P1">
                    <gui_name language="en">P1</gui_name>
                    <description language="en">Secure disable for FPGA AFI AXI port 1. 0 = port can make Secure and Non-secure accesses, reset value. 1 = port can only make Non-secure accesses.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="P0">
                    <gui_name language="en">P0</gui_name>
                    <description language="en">Secure disable for FPGA AFI AXI port 0. 0 = port can make Secure and Non-secure accesses, reset value. 1 = port can only make Non-secure accesses.</description>
                </bitField>
            </register>
            <register name="SLCR_DBG_CTRL" offset="0xf8000500" size="0x4">
                <gui_name language="en">DBG_CTRL</gui_name>
                <description language="en">SoC Debug Control</description>
                <bitField access="Read Write" enumerationId="DBG_CTRL_SRST_B_TRI_B_ENUM" high_bit="0" low_bit="0" name="SRST_B_TRI_B">
                    <gui_name language="en">SRST_B_TRI_B</gui_name>
                    <description language="en">Controls direction of top level SRST_B
pad.. When an output, the SRST_B pin is fed by the UART0 TX for firmware debug messages.
0 - SRST_B pad is an input for soft reset signal.
1 - SRST_B pad is an output dirven by UART0 TX.</description>
                </bitField>
            </register>
            <register name="SLCR_PSS_IDCODE" offset="0xf8000530" size="0x4">
                <gui_name language="en">PSS_IDCODE</gui_name>
                <description language="en">PSS IDCODE</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="IDCODE">
                    <gui_name language="en">IDCODE</gui_name>
                    <description language="en">PSS IDCODE value, defined as follows:
IDCODE[0] - Reserved = 1.
IDCODE[11:1] - Manufacturer ID = 000 0100 1001.
IDCODE[16:12] - Device from FPGA gasket = idcode_devtype[4:0].
IDCODE[20:17] - Subfamily from FPGA gasket = 1001.
IDCODE[27:21] - Family = 001 1011.
IDCODE[31:28] - Revision from FPGA gasket = idcode_version[3:0]</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_URGENT" offset="0xf8000600" size="0x4">
                <gui_name language="en">DDR_URGENT</gui_name>
                <description language="en">DDR Urgent Control</description>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="S3_ARURGENT">
                    <gui_name language="en">S3_ARURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S3 read prioritisation. Same as below.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="S2_ARURGENT">
                    <gui_name language="en">S2_ARURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S2 read prioritisation. Same as below.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="S1_ARURGENT">
                    <gui_name language="en">S1_ARURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S1 read prioritisation. Same as below.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDR_URGENT_S0_ARURGENT_ENUM" high_bit="4" low_bit="4" name="S0_ARURGENT">
                    <gui_name language="en">S0_ARURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S0 read prioritisation:
0 - DDR's AXI port S0 read not requesting urgent prioritization.
1 - DDR's AXI port S0 read is requesting urgent prioritization.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="S3_AWURGENT">
                    <gui_name language="en">S3_AWURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S3write prioritisation. Same as below.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="S2_AWURGENT">
                    <gui_name language="en">S2_AWURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S2 write prioritisation. Same as below.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="S1_AWURGENT">
                    <gui_name language="en">S1_AWURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S1 write prioritisation. Same as below.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDR_URGENT_S0_AWURGENT_ENUM" high_bit="0" low_bit="0" name="S0_AWURGENT">
                    <gui_name language="en">S0_AWURGENT</gui_name>
                    <description language="en">Identifies DDR's AXI port S0 write prioritisation:
0 - DDR's AXI port S0 write not requesting urgent prioritization.
1 - DDR's AXI port S0 write is requesting urgent prioritization.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_CAL_START" offset="0xf800060c" size="0x4">
                <gui_name language="en">DDR_CAL_START</gui_name>
                <description language="en">DDR Calibration Start Triggers</description>
                <bitField access="Write Only" enumerationId="DDR_CAL_START_START_CAL_DLL_ENUM" high_bit="1" low_bit="1" name="START_CAL_DLL">
                    <gui_name language="en">START_CAL_DLL</gui_name>
                    <description language="en">This register creates a pulse which is first synchronised into the ddr_clk domain and then directly drives the co_gs_dll_calib input into the DDR controller. This signal is a command that indicates to the controller to issue a dll_calib to the DRAM. This signal should pulse for 1 ddrc_core_clk clock cycle to request a dll_calib to be issued. This is only required if the DDR controller register reg_ddrc_dis_dll_calib is 1. If reg_ddrc_dis_dll_calib is 0, the controller will automatically issue DLL Calibs.
0 - Do nothing.
1 - Start DLL calibration command.
A read of this register always returns zero.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="DDR_CAL_START_START_CAL_SHORT_ENUM" high_bit="0" low_bit="0" name="START_CAL_SHORT">
                    <gui_name language="en">START_CAL_SHORT</gui_name>
                    <description language="en">This register creates a pulse which is first synchronised into the ddr_clk domain and then directly drives the co_gs_zq_calib_short input into the DDR controller. This is required to pulse for 1 clock to issue ZQ Calibration Short Command to the DDR. There should be a minimum of 512 clks gap between 2 ZQ Calib Short commands from the core. If DDR controller register reg_ddrc_dis_auto_zq=0, asserting co_gs_zq_calib_short is not required, as this will be done automatically. If reg_ddrc_dis_auto_zq=1, then the core logic is required to assert co_gs_zq_calib_short periodically to update DDR3 ZQ calibration.
0 - Do nothing.
1 - Start ZQ calibration short command.
A read of this register always returns zero.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_REF_START" offset="0xf8000614" size="0x4">
                <gui_name language="en">DDR_REF_START</gui_name>
                <description language="en">DDR Refresh Start Triggers</description>
                <bitField access="Write Only" enumerationId="DDR_REF_START_START_REF_ENUM" high_bit="0" low_bit="0" name="START_REF">
                    <gui_name language="en">START_REF</gui_name>
                    <description language="en">This register creates a pulse which is first synchronised into the ddr_clk domain and then directly drives the co_gs_rank_refresh input into the DDR controller. This register must be used with the Virage DRAM controller register bit reg_ddrc_dis_auto_refresh.
This signal is a command that indicates to the controller to issue a refresh to the DRAM. One bit per rank. This signal should pulse for 1 ddrc_core_clk clock cycle to request a refresh to be issued.
0 - Do nothing.
1 - Start refresh.
A read of this register always returns zero.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_CMD_STA" offset="0xf8000618" size="0x4">
                <gui_name language="en">DDR_CMD_STA</gui_name>
                <description language="en">DDR Command Store Status</description>
                <bitField access="Read Only" enumerationId="DDR_CMD_STA_CMD_Q_NEMPTY_ENUM" high_bit="0" low_bit="0" name="CMD_Q_NEMPTY">
                    <gui_name language="en">CMD_Q_NEMPTY</gui_name>
                    <description language="en">DDR controller command store fill status.
0 - indicates DDRC command store is empty.
1 - indicates there are commands pending in DDRC command store.
This register is a continuous monitor of the ddrc_co_q_not_empty output from the DDR controller, which is first synchronised from ddr_clk into amba1x_clk.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_URGENT_SEL" offset="0xf800061c" size="0x4">
                <gui_name language="en">DDR_URGENT_SEL</gui_name>
                <description language="en">DDR Urgent Select</description>
                <bitField access="Read Write" high_bit="15" low_bit="14" name="S3_ARQOS_MODE">
                    <gui_name language="en">S3_ARQOS_MODE</gui_name>
                    <description language="en">Selects between the AXI port s3_arqos[3], fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s3_arurgent bit is driven from the 'S3_ARURGENT' field of the DDR_URGENT_VAL register. 2'b01 - The DDRC s3_arurgent bit is driven from the s3_arqos bit. 2'b10 - The DDRC s3_arurgent bit is driven from the fabric ddr_arb[3] input. 2'b11 - Undefined</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="12" name="S2_ARQOS_MODE">
                    <gui_name language="en">S2_ARQOS_MODE</gui_name>
                    <description language="en">Selects between the AXI port s2_arqos[3], fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s2_arurgent bit is driven from the 'S2_ARURGENT' field of the DDR_URGENT_VAL register. 2'b01 - The DDRC s2_arurgent bit is driven from the s2_arqos bit. 2'b10 - The DDRC s2_arurgent bit is driven from the fabric ddr_arb[2] input. 2'b11 - Undefined.</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="S1_ARQOS_MODE">
                    <gui_name language="en">S1_ARQOS_MODE</gui_name>
                    <description language="en">Selects between the AXI port s1_arqos[3], fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s1_arurgent bit is driven from the 'S1_ARURGENT' field of the DDR_URGENT_VAL register. 2'b01 - The DDRC s1_arurgent bit is driven from the s1_arqos bit. 2'b10 - The DDRC s1_arurgent bit is driven from the fabric ddr_arb[1] input. 2'b11 - Undefined.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="S0_ARQOS_MODE">
                    <gui_name language="en">S0_ARQOS_MODE</gui_name>
                    <description language="en">Selects between the fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s0_arurgent bit is driven from the 'S0_ARURGENT' field of the DDR_URGENT_VAL register. 2'b01 -Undefined. 2'b10 - The DDRC s0_arurgent bit is driven from the fabric ddr_arb[0] input. 2'b11 - Undefined</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="6" name="S3_AWQOS_MODE">
                    <gui_name language="en">S3_AWQOS_MODE</gui_name>
                    <description language="en">Selects between the AXI port s3_awqos[3], fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s3_awurgent bit is driven from the 'S3_AWURGENT' field of the DDR_URGENT_VAL register. 2'b01 - The DDRC s3_awurgent bit is driven from the s3_awqos bit. 2'b10 - The DDRC s3_awurgent bit is driven from the fabric ddr_arb[3] input. 2'b11 - Undefined</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="4" name="S2_AWQOS_MODE">
                    <gui_name language="en">S2_AWQOS_MODE</gui_name>
                    <description language="en">Selects between the AXI port s2_awqos[3], fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s2_awurgent bit is driven from the 'S2_AWURGENT' field of the DDR_URGENT_VAL register. 2'b01 - The DDRC s2_awurgent bit is driven from the s2_awqos bit. 2'b10 - The DDRC s2_awurgent bit is driven from the fabric ddr_arb[2] input. 2'b11 - Undefined</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="S1_AWQOS_MODE">
                    <gui_name language="en">S1_AWQOS_MODE</gui_name>
                    <description language="en">Selects between the AXI port s1_awqos[3], fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s1_awurgent bit is driven from the 'S1_AWURGENT' field of the DDR_URGENT_VAL register. 2'b01 - The DDRC s1_awurgent bit is driven from the s1_awqos bit. 2'b10 - The DDRC s1_awurgent bit is driven from the fabric ddr_arb[1] input. 2'b11 - Undefined</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="S0_AWQOS_MODE">
                    <gui_name language="en">S0_AWQOS_MODE</gui_name>
                    <description language="en">Selects between the fabric signal or static register  to drive the DDRC urgent bit as follows: 2'b00 - The DDRC s0_awurgent bit is driven from the 'S0_AWURGENT' field of the DDR_URGENT_VAL register. 2'b01 -Undefined. 2'b10 - The DDRC s0_awurgent bit is driven from the fabric ddr_arb[0] input. 2'b11 - Undefined.</description>
                </bitField>
            </register>
            <register name="SLCR_DDR_DFI_STATUS" offset="0xf8000620" size="0x4">
                <gui_name language="en">DDR_DFI_STATUS</gui_name>
                <description language="en">DDR DFI status</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="DFI_CAL_ST">
                    <gui_name language="en">DFI_CAL_ST</gui_name>
                    <description language="en">This signal is intended to allow a calibration of the IOB's at a time when the DDR controller is in its calibration mode, i.e. during an idle period.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_00" offset="0xf8000700" size="0x4">
                <gui_name language="en">MIO_PIN_00</gui_name>
                <description language="en">MIO Control for Pin 0</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_00_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_00_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_00_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[0]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[0]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_00_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= smc_cs0, Output, smc_sram_cs_n[0]- (SRAM CS0)
2= nand_cs, Output, smc_nand_cs_n- (NAND chip select)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_00_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_00_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi_sel, Output, qspi_n_ss_out_upper- (QSPI Upper select)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_01" offset="0xf8000704" size="0x4">
                <gui_name language="en">MIO_PIN_01</gui_name>
                <description language="en">MIO Control for Pin 1</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_01_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_01_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_01_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[1]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[1]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_01_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= smc_a25, Output, smc_sram_add[25]- (SRAM Address)
2= smc_cs1, Output, smc_sram_cs_n[1]- (SRAM CS1)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_01_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_01_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi_sel, Output, qspi_n_ss_out- (QSPI Select)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_02" offset="0xf8000708" size="0x4">
                <gui_name language="en">MIO_PIN_02</gui_name>
                <description language="en">MIO Control for Pin 2</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_02_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_02_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for mode[0]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_02_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[2]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[2]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_02_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_clk- (SRAM Clock)
2= nand, Output, smc_nand_ale- (NAND Address Latch Enable)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_02_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[8]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Output, qspi_mo_mo0- (QSPI Databus)
1= qspi, Input, qspi_si_mi0- (QSPI Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_03" offset="0xf800070c" size="0x4">
                <gui_name language="en">MIO_PIN_03</gui_name>
                <description language="en">MIO Control for Pin 3</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_03_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_03_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for mode[1]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_03_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[3]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[3]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_03_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[0]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[0]- (SRAM Data)
2= nand, Output, smc_nand_we_b- (NAND Write Enable)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_03_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[9]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi_mi1- (QSPI Databus)
1= qspi, Output, qspi_so_mo1- (QSPI Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_04" offset="0xf8000710" size="0x4">
                <gui_name language="en">MIO_PIN_04</gui_name>
                <description language="en">MIO Control for Pin 4</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_04_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_04_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for mode[2]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_04_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[4]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[4]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_04_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[1]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[1]- (SRAM Data)
2= nand, Input, smc_nand_data_in[2]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[2]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_04_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[10]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi2- (QSPI Databus)
1= qspi, Output, qspi_mo2- (QSPI Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_05" offset="0xf8000714" size="0x4">
                <gui_name language="en">MIO_PIN_05</gui_name>
                <description language="en">MIO Control for Pin 5</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_05_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_05_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for mode[3]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_05_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[5]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[5]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_05_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[2]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[2]- (SRAM Data)
2= nand, Input, smc_nand_data_in[0]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[0]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_05_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[11]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi3- (QSPI Databus)
1= qspi, Output, qspi_mo3- (QSPI Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_06" offset="0xf8000718" size="0x4">
                <gui_name language="en">MIO_PIN_06</gui_name>
                <description language="en">MIO Control for Pin 6</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_06_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_06_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for mode[4]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_06_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[6]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[6]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_06_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[3]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[3]- (SRAM Data)
2= nand, Input, smc_nand_data_in[1]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[1]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_06_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[12]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_06_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Output, qspi_sclk_out- (QSPI Clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_07" offset="0xf800071c" size="0x4">
                <gui_name language="en">MIO_PIN_07</gui_name>
                <description language="en">MIO Control for Pin 7</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for vcfg[0]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_L3_SEL_ENUM" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Output, gpio_0_pin_out[7]- (GPIO bank 0)
1= Not Used
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_oe_b- (SRAM Output enable)
2= nand, Output, smc_nand_cle- (NAND Command Latch Enable)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[13]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_07_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_08" offset="0xf8000720" size="0x4">
                <gui_name language="en">MIO_PIN_08</gui_name>
                <description language="en">MIO Control for Pin 8</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled
Pull-up disabled by default as this pin is used for vcfg[1]</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_L3_SEL_ENUM" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Output, gpio_0_pin_out[8]- (GPIO bank 0)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_we_b- (SRAM Write enable)
2= nand, Output, smc_nand_re_b- (NAND Read Enable)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[14]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_08_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Output, qspi_clk_for_lpbk- (QSPI Clock to be fed-back)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_09" offset="0xf8000724" size="0x4">
                <gui_name language="en">MIO_PIN_09</gui_name>
                <description language="en">MIO Control for Pin 9</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_09_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_09_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_09_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[9]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[9]- (GPIO bank 0)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= Not Used
3= Not Used
4= Not Used
5= Not Used
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_09_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[6]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[6]- (SRAM Data)
2= nand, Input, smc_nand_data_in[4]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[4]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_09_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[15]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_09_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Output, qspi_sclk_out_upper- (QSPI Upper Clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_10" offset="0xf8000728" size="0x4">
                <gui_name language="en">MIO_PIN_10</gui_name>
                <description language="en">MIO Control for Pin 10</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_10_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_10_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_10_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[10]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[10]- (GPIO bank 0)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_data_in[0]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[0]- (4-bit Data bus)
5= spi1, Output, spi1_mo- (MOSI signal)
5= spi1, Input, spi1_si- (MOSI signal)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_10_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[7]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[7]- (SRAM Data)
2= nand, Input, smc_nand_data_in[5]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[5]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_10_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[2]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi_upper[0]- (QSPI Upper Databus)
1= qspi, Output, qspi_mo_upper[0]- (QSPI Upper Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_11" offset="0xf800072c" size="0x4">
                <gui_name language="en">MIO_PIN_11</gui_name>
                <description language="en">MIO Control for Pin 11</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_11_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_11_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_11_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[11]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[11]- (GPIO bank 0)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_cmd_in- (Command Indicator)
4= sd1, Output, sd1_cmd_out- (Command Indicator)
5= spi1, Input, spi1_mi- (MISO signal)
5= spi1, Output, spi1_so- (MISO signal)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_11_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[4]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[4]- (SRAM Data)
2= nand, Input, smc_nand_data_in[6]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[6]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_11_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[3]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi_upper[1]- (QSPI Upper Databus)
1= qspi, Output, qspi_mo_upper[1]- (QSPI Upper Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_12" offset="0xf8000730" size="0x4">
                <gui_name language="en">MIO_PIN_12</gui_name>
                <description language="en">MIO Control for Pin 12</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_12_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_12_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_12_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[12]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[12]- (GPIO bank 0)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_clk_in- (SDSDIO clock)
4= sd1, Output, sd1_clk_out- (SDSDIO clock)
5= spi1, Input, spi1_sclk_in- (SPI Clock)
5= spi1, Output, spi1_sclk_out- (SPI Clock)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_12_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_wait- (SRAM Wait State indicator)
2= nand, Input, smc_nand_data_in[7]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[7]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_12_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_ctl, Output, traceclk- (Trace Port Clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi_upper[2]- (QSPI Upper Databus)
1= qspi, Output, qspi_mo_upper[2]- (QSPI Upper Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_13" offset="0xf8000734" size="0x4">
                <gui_name language="en">MIO_PIN_13</gui_name>
                <description language="en">MIO Control for Pin 13</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_13_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_13_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_13_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[13]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[13]- (GPIO bank 0)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_data_in[1]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[1]- (4-bit Data bus)
5= spi1, Input, spi1_n_ss_in- (SPI Master Selects)
5= spi1, Output, spi1_n_ss_out[0]- (SPI Master Selects)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_13_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_data_in[5]- (SRAM Data)
= sram_nor, Output, smc_sram_data_out[5]- (SRAM Data)
2= nand, Input, smc_nand_data_in[3]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[3]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_13_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_ctl, Output, tracectl- (Trace Port Control Signal)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= qspi, Input, qspi_mi_upper[3]- (QSPI Upper Databus)
1= qspi, Output, qspi_mo_upper[3]- (QSPI Upper Databus)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_14" offset="0xf8000738" size="0x4">
                <gui_name language="en">MIO_PIN_14</gui_name>
                <description language="en">MIO Control for Pin 14</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_14_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_14_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_14_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[14]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[14]- (GPIO bank 0)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= wdt, Input, wdt_clk_in- (Watch Dog Timer Input clock)
4= sd1, Input, sd1_data_in[2]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[2]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[1]- (SPI Master Selects)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_14_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Input, smc_sram_fbclk- (SRAM Feedback Clock)
2= nand, Input, smc_nand_busy- (NAND Busy)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_14_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[0]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_14_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_15" offset="0xf800073c" size="0x4">
                <gui_name language="en">MIO_PIN_15</gui_name>
                <description language="en">MIO Control for Pin 15</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_15_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_15_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_15_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[15]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[15]- (GPIO bank 0)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= wdt, Output, wdt_rst_out- (Watch Dog Timer Output clock)
4= sd1, Input, sd1_data_in[3]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[3]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_15_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[0]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_15_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[1]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_15_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_16" offset="0xf8000740" size="0x4">
                <gui_name language="en">MIO_PIN_16</gui_name>
                <description language="en">MIO Control for Pin 16</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_16_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_16_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_16_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[16]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[16]- (GPIO bank 0)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_clk_in- (SDSDIO clock)
4= sd0, Output, sd0_clk_out- (SDSDIO clock)
5= spi0, Input, spi0_sclk_in- (SPI Clock)
5= spi0, Output, spi0_sclk_out- (SPI Clock)
6= ttc1, Output, ttc1_wave_out- (TTC waveform clock)
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_16_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[1]- (SRAM Address)
2= nand, Input, smc_nand_data_in[8]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[8]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_16_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[4]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_16_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Output, gem0_rgmii_tx_clk- (TX RGMII clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_17" offset="0xf8000744" size="0x4">
                <gui_name language="en">MIO_PIN_17</gui_name>
                <description language="en">MIO Control for Pin 17</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_17_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_17_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_17_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[17]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[17]- (GPIO bank 0)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_cmd_in- (Command Indicator)
4= sd0, Output, sd0_cmd_out- (Command Indicator)
5= spi0, Input, spi0_mi- (MISO signal)
5= spi0, Output, spi0_so- (MISO signal)
6= ttc1, Input, ttc1_clk_in- (TTC input clock)
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_17_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[2]- (SRAM Address)
2= nand, Input, smc_nand_data_in[9]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[9]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_17_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[5]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_17_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Output, gem0_rgmii_txd[0]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_18" offset="0xf8000748" size="0x4">
                <gui_name language="en">MIO_PIN_18</gui_name>
                <description language="en">MIO Control for Pin 18</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_18_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_18_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_18_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[18]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[18]- (GPIO bank 0)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_data_in[0]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[0]- (4-bit Data bus)
5= spi0, Input, spi0_n_ss_in- (SPI Master Selects)
5= spi0, Output, spi0_n_ss_out[0]- (SPI Master Selects)
6= ttc0, Output, ttc0_wave_out- (TTC waveform clock)
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_18_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[3]- (SRAM Address)
2= nand, Input, smc_nand_data_in[10]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[10]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_18_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[6]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_18_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Output, gem0_rgmii_txd[1]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_19" offset="0xf800074c" size="0x4">
                <gui_name language="en">MIO_PIN_19</gui_name>
                <description language="en">MIO Control for Pin 19</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_19_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_19_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_19_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[19]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[19]- (GPIO bank 0)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_data_in[1]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[1]- (4-bit Data bus)
5= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects)
6= ttc0, Input, ttc0_clk_in- (TTC input clock)
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_19_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[4]- (SRAM Address)
2= nand, Input, smc_nand_data_in[11]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[11]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_19_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[7]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_19_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Output, gem0_rgmii_txd[2]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_20" offset="0xf8000750" size="0x4">
                <gui_name language="en">MIO_PIN_20</gui_name>
                <description language="en">MIO Control for Pin 20</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_20_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_20_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_20_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[20]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[20]- (GPIO bank 0)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_data_in[2]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[2]- (4-bit Data bus)
5= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_20_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[5]- (SRAM Address)
2= nand, Input, smc_nand_data_in[12]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[12]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_20_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_20_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Output, gem0_rgmii_txd[3]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_21" offset="0xf8000754" size="0x4">
                <gui_name language="en">MIO_PIN_21</gui_name>
                <description language="en">MIO Control for Pin 21</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_21_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_21_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_21_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[21]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[21]- (GPIO bank 0)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_data_in[3]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[3]- (4-bit Data bus)
5= spi0, Output, spi0_mo- (MOSI signal)
5= spi0, Input, spi0_si- (MOSI signal)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_21_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[6]- (SRAM Address)
2= nand, Input, smc_nand_data_in[13]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[13]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_21_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_21_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Output, gem0_rgmii_tx_ctl- (TX RGMII control)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_22" offset="0xf8000758" size="0x4">
                <gui_name language="en">MIO_PIN_22</gui_name>
                <description language="en">MIO Control for Pin 22</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_22_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_22_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_22_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[22]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[22]- (GPIO bank 0)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_data_in[0]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[0]- (4-bit Data bus)
5= spi1, Output, spi1_mo- (MOSI signal)
5= spi1, Input, spi1_si- (MOSI signal)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_22_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[7]- (SRAM Address)
2= nand, Input, smc_nand_data_in[14]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[14]- (NAND Data Bus)
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_22_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[2]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_22_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Input, gem0_rgmii_rx_clk- (RX RGMII clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_23" offset="0xf800075c" size="0x4">
                <gui_name language="en">MIO_PIN_23</gui_name>
                <description language="en">MIO Control for Pin 23</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_23_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_23_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_23_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[23]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[23]- (GPIO bank 0)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_cmd_in- (Command Indicator)
4= sd1, Output, sd1_cmd_out- (Command Indicator)
5= spi1, Input, spi1_mi- (MISO signal)
5= spi1, Output, spi1_so- (MISO signal)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_23_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[8]- (SRAM Address)
2= nand, Input, smc_nand_data_in[15]- (NAND Data Bus)
= nand, Output, smc_nand_data_out[15]- (NAND Data Bus)
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_23_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[3]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_23_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Input, gem0_rgmii_rxd[0]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_24" offset="0xf8000760" size="0x4">
                <gui_name language="en">MIO_PIN_24</gui_name>
                <description language="en">MIO Control for Pin 24</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_24_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_24_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_24_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[24]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[24]- (GPIO bank 0)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_clk_in- (SDSDIO clock)
4= sd1, Output, sd1_clk_out- (SDSDIO clock)
5= spi1, Input, spi1_sclk_in- (SPI Clock)
5= spi1, Output, spi1_sclk_out- (SPI Clock)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_24_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[9]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_24_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_ctl, Output, traceclk- (Trace Port Clock)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_24_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Input, gem0_rgmii_rxd[1]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_25" offset="0xf8000764" size="0x4">
                <gui_name language="en">MIO_PIN_25</gui_name>
                <description language="en">MIO Control for Pin 25</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_25_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_25_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_25_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[25]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[25]- (GPIO bank 0)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_data_in[1]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[1]- (4-bit Data bus)
5= spi1, Input, spi1_n_ss_in- (SPI Master Selects)
5= spi1, Output, spi1_n_ss_out[0]- (SPI Master Selects)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_25_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[10]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_25_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_ctl, Output, tracectl- (Trace Port Control Signal)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_25_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Input, gem0_rgmii_rxd[2]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_26" offset="0xf8000768" size="0x4">
                <gui_name language="en">MIO_PIN_26</gui_name>
                <description language="en">MIO Control for Pin 26</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_26_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_26_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_26_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[26]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[26]- (GPIO bank 0)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= wdt, Input, wdt_clk_in- (Watch Dog Timer Input clock)
4= sd1, Input, sd1_data_in[2]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[2]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[1]- (SPI Master Selects)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_26_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[11]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_26_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[0]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_26_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Input, gem0_rgmii_rxd[3]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_27" offset="0xf800076c" size="0x4">
                <gui_name language="en">MIO_PIN_27</gui_name>
                <description language="en">MIO Control for Pin 27</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_27_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_27_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_27_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[27]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[27]- (GPIO bank 0)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= wdt, Output, wdt_rst_out- (Watch Dog Timer Output clock)
4= sd1, Input, sd1_data_in[3]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[3]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_27_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[12]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_27_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= trace_data, Output, tracedq[1]- (Trace Port Databus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_27_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem0, Input, gem0_rgmii_rx_ctl- (RX RGMII control )</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_28" offset="0xf8000770" size="0x4">
                <gui_name language="en">MIO_PIN_28</gui_name>
                <description language="en">MIO Control for Pin 28</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_28_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_28_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_28_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[28]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[28]- (GPIO bank 0)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_clk_in- (SDSDIO clock)
4= sd0, Output, sd0_clk_out- (SDSDIO clock)
5= spi0, Input, spi0_sclk_in- (SPI Clock)
5= spi0, Output, spi0_sclk_out- (SPI Clock)
6= ttc1, Output, ttc1_wave_out- (TTC waveform clock)
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_28_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[13]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[4]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[4]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_28_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Output, gem1_rgmii_tx_clk- (TX RGMII clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_29" offset="0xf8000774" size="0x4">
                <gui_name language="en">MIO_PIN_29</gui_name>
                <description language="en">MIO Control for Pin 29</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_29_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_29_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_29_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[29]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[29]- (GPIO bank 0)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_cmd_in- (Command Indicator)
4= sd0, Output, sd0_cmd_out- (Command Indicator)
5= spi0, Input, spi0_mi- (MISO signal)
5= spi0, Output, spi0_so- (MISO signal)
6= ttc1, Input, ttc1_clk_in- (TTC input clock)
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_29_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[14]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_29_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_dir- (Data bus direction control)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_29_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Output, gem1_rgmii_txd[0]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_30" offset="0xf8000778" size="0x4">
                <gui_name language="en">MIO_PIN_30</gui_name>
                <description language="en">MIO Control for Pin 30</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_30_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_30_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_30_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[30]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[30]- (GPIO bank 0)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_data_in[0]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[0]- (4-bit Data bus)
5= spi0, Input, spi0_n_ss_in- (SPI Master Selects)
5= spi0, Output, spi0_n_ss_out[0]- (SPI Master Selects)
6= ttc0, Output, ttc0_wave_out- (TTC waveform clock)
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_30_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[15]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_30_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Output, usb0_ulpi_stp- (Asserted to end or interrupt transfers)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_30_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Output, gem1_rgmii_txd[1]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_31" offset="0xf800077c" size="0x4">
                <gui_name language="en">MIO_PIN_31</gui_name>
                <description language="en">MIO Control for Pin 31</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_31_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_31_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_31_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio0, Input, gpio_0_pin_in[31]- (GPIO bank 0)
0= gpio0, Output, gpio_0_pin_out[31]- (GPIO bank 0)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_data_in[1]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[1]- (4-bit Data bus)
5= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects)
6= ttc0, Input, ttc0_clk_in- (TTC input clock)
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_31_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[16]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_31_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_nxt- (Data flow control signal from the PHY)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_31_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Output, gem1_rgmii_txd[2]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_32" offset="0xf8000780" size="0x4">
                <gui_name language="en">MIO_PIN_32</gui_name>
                <description language="en">MIO Control for Pin 32</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_32_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_32_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_32_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[0]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[0]- (GPIO bank 1)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_data_in[2]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[2]- (4-bit Data bus)
5= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_32_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[17]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[0]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[0]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_32_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Output, gem1_rgmii_txd[3]- (TX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_33" offset="0xf8000784" size="0x4">
                <gui_name language="en">MIO_PIN_33</gui_name>
                <description language="en">MIO Control for Pin 33</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_33_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_33_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_33_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[1]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[1]- (GPIO bank 1)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_data_in[3]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[3]- (4-bit Data bus)
5= spi0, Output, spi0_mo- (MOSI signal)
5= spi0, Input, spi0_si- (MOSI signal)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_33_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[18]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[1]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[1]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_33_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Output, gem1_rgmii_tx_ctl- (TX RGMII control)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_34" offset="0xf8000788" size="0x4">
                <gui_name language="en">MIO_PIN_34</gui_name>
                <description language="en">MIO Control for Pin 34</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_34_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_34_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_34_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[2]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[2]- (GPIO bank 1)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_data_in[0]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[0]- (4-bit Data bus)
5= spi1, Output, spi1_mo- (MOSI signal)
5= spi1, Input, spi1_si- (MOSI signal)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_34_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[19]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[2]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[2]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_34_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Input, gem1_rgmii_rx_clk- (RX RGMII clock)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_35" offset="0xf800078c" size="0x4">
                <gui_name language="en">MIO_PIN_35</gui_name>
                <description language="en">MIO Control for Pin 35</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_35_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_35_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_35_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[3]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[3]- (GPIO bank 1)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_cmd_in- (Command Indicator)
4= sd1, Output, sd1_cmd_out- (Command Indicator)
5= spi1, Input, spi1_mi- (MISO signal)
5= spi1, Output, spi1_so- (MISO signal)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_35_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[20]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[3]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[3]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_35_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Input, gem1_rgmii_rxd[0]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_36" offset="0xf8000790" size="0x4">
                <gui_name language="en">MIO_PIN_36</gui_name>
                <description language="en">MIO Control for Pin 36</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_36_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_36_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_36_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[4]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[4]- (GPIO bank 1)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_clk_in- (SDSDIO clock)
4= sd1, Output, sd1_clk_out- (SDSDIO clock)
5= spi1, Input, spi1_sclk_in- (SPI Clock)
5= spi1, Output, spi1_sclk_out- (SPI Clock)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_36_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[21]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_xcvr_clk_in- (ULPI clock)
1= usb0, Output, usb0_xcvr_clk_out- (ULPI clock)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_36_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Input, gem1_rgmii_rxd[1]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_37" offset="0xf8000794" size="0x4">
                <gui_name language="en">MIO_PIN_37</gui_name>
                <description language="en">MIO Control for Pin 37</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_37_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_37_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_37_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[5]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[5]- (GPIO bank 1)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_data_in[1]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[1]- (4-bit Data bus)
5= spi1, Input, spi1_n_ss_in- (SPI Master Selects)
5= spi1, Output, spi1_n_ss_out[0]- (SPI Master Selects)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_37_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[22]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[5]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[5]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_37_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Input, gem1_rgmii_rxd[2]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_38" offset="0xf8000798" size="0x4">
                <gui_name language="en">MIO_PIN_38</gui_name>
                <description language="en">MIO Control for Pin 38</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_38_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_38_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_38_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[6]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[6]- (GPIO bank 1)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= wdt, Input, wdt_clk_in- (Watch Dog Timer Input clock)
4= sd1, Input, sd1_data_in[2]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[2]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[1]- (SPI Master Selects)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_38_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[23]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[6]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[6]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_38_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Input, gem1_rgmii_rxd[3]- (RX RGMII data)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_39" offset="0xf800079c" size="0x4">
                <gui_name language="en">MIO_PIN_39</gui_name>
                <description language="en">MIO Control for Pin 39</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_39_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_39_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_39_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[7]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[7]- (GPIO bank 1)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= wdt, Output, wdt_rst_out- (Watch Dog Timer Output clock)
4= sd1, Input, sd1_data_in[3]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[3]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_39_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= sram_nor, Output, smc_sram_add[24]- (SRAM Address)
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb0, Input, usb0_ulpi_rx_data[7]- (ULPI data bus)
1= usb0, Output, usb0_ulpi_tx_data[7]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_39_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= gem1, Input, gem1_rgmii_rx_ctl- (RX RGMII control )</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_40" offset="0xf80007a0" size="0x4">
                <gui_name language="en">MIO_PIN_40</gui_name>
                <description language="en">MIO Control for Pin 40</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_40_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_40_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_40_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[8]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[8]- (GPIO bank 1)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_clk_in- (SDSDIO clock)
4= sd0, Output, sd0_clk_out- (SDSDIO clock)
5= spi0, Input, spi0_sclk_in- (SPI Clock)
5= spi0, Output, spi0_sclk_out- (SPI Clock)
6= ttc1, Output, ttc1_wave_out- (TTC waveform clock)
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_40_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[4]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[4]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_40_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_41" offset="0xf80007a4" size="0x4">
                <gui_name language="en">MIO_PIN_41</gui_name>
                <description language="en">MIO Control for Pin 41</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_41_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_41_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_41_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[9]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[9]- (GPIO bank 1)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_cmd_in- (Command Indicator)
4= sd0, Output, sd0_cmd_out- (Command Indicator)
5= spi0, Input, spi0_mi- (MISO signal)
5= spi0, Output, spi0_so- (MISO signal)
6= ttc1, Input, ttc1_clk_in- (TTC input clock)
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_41_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_41_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_dir- (Data bus direction control)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_41_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_42" offset="0xf80007a8" size="0x4">
                <gui_name language="en">MIO_PIN_42</gui_name>
                <description language="en">MIO Control for Pin 42</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_42_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_42_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_42_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[10]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[10]- (GPIO bank 1)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_data_in[0]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[0]- (4-bit Data bus)
5= spi0, Input, spi0_n_ss_in- (SPI Master Selects)
5= spi0, Output, spi0_n_ss_out[0]- (SPI Master Selects)
6= ttc0, Output, ttc0_wave_out- (TTC waveform clock)
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_42_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_42_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Output, usb1_ulpi_stp- (Asserted to end or interrupt transfers)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_42_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_43" offset="0xf80007ac" size="0x4">
                <gui_name language="en">MIO_PIN_43</gui_name>
                <description language="en">MIO Control for Pin 43</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_43_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_43_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_43_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[11]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[11]- (GPIO bank 1)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_data_in[1]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[1]- (4-bit Data bus)
5= spi0, Output, spi0_n_ss_out[1]- (SPI Master Selects)
6= ttc0, Input, ttc0_clk_in- (TTC input clock)
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_43_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_43_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_nxt- (Data flow control signal from the PHY)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_43_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_44" offset="0xf80007b0" size="0x4">
                <gui_name language="en">MIO_PIN_44</gui_name>
                <description language="en">MIO Control for Pin 44</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_44_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_44_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_44_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[12]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[12]- (GPIO bank 1)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd0, Input, sd0_data_in[2]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[2]- (4-bit Data bus)
5= spi0, Output, spi0_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_44_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[0]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[0]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_44_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_45" offset="0xf80007b4" size="0x4">
                <gui_name language="en">MIO_PIN_45</gui_name>
                <description language="en">MIO Control for Pin 45</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_45_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_45_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_45_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[13]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[13]- (GPIO bank 1)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd0, Input, sd0_data_in[3]- (4-bit Data bus)
4= sd0, Output, sd0_data_out[3]- (4-bit Data bus)
5= spi0, Output, spi0_mo- (MOSI signal)
5= spi0, Input, spi0_si- (MOSI signal)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_45_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[1]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[1]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_45_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_46" offset="0xf80007b8" size="0x4">
                <gui_name language="en">MIO_PIN_46</gui_name>
                <description language="en">MIO Control for Pin 46</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_46_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_46_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_46_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[14]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[14]- (GPIO bank 1)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_data_in[0]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[0]- (4-bit Data bus)
5= spi1, Output, spi1_mo- (MOSI signal)
5= spi1, Input, spi1_si- (MOSI signal)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_46_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[2]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[2]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_46_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_47" offset="0xf80007bc" size="0x4">
                <gui_name language="en">MIO_PIN_47</gui_name>
                <description language="en">MIO Control for Pin 47</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_47_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_47_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_47_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[15]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[15]- (GPIO bank 1)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_cmd_in- (Command Indicator)
4= sd1, Output, sd1_cmd_out- (Command Indicator)
5= spi1, Input, spi1_mi- (MISO signal)
5= spi1, Output, spi1_so- (MISO signal)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_47_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[3]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[3]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_47_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_48" offset="0xf80007c0" size="0x4">
                <gui_name language="en">MIO_PIN_48</gui_name>
                <description language="en">MIO Control for Pin 48</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_48_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_48_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_48_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[16]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[16]- (GPIO bank 1)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= Not Used
4= sd1, Input, sd1_clk_in- (SDSDIO clock)
4= sd1, Output, sd1_clk_out- (SDSDIO clock)
5= spi1, Input, spi1_sclk_in- (SPI Clock)
5= spi1, Output, spi1_sclk_out- (SPI Clock)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_48_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_xcvr_clk_in- (ULPI Clock)
1= usb1, Output, usb1_xcvr_clk_out- (ULPI Clock)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_48_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_49" offset="0xf80007c4" size="0x4">
                <gui_name language="en">MIO_PIN_49</gui_name>
                <description language="en">MIO Control for Pin 49</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_49_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_49_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_49_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[17]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[17]- (GPIO bank 1)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= Not Used
4= sd1, Input, sd1_data_in[1]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[1]- (4-bit Data bus)
5= spi1, Input, spi1_n_ss_in- (SPI Master Selects)
5= spi1, Output, spi1_n_ss_out[0]- (SPI Master Selects)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_49_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[5]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[5]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_49_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_50" offset="0xf80007c8" size="0x4">
                <gui_name language="en">MIO_PIN_50</gui_name>
                <description language="en">MIO Control for Pin 50</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_50_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_50_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_50_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[18]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[18]- (GPIO bank 1)
1= can0, Input, can0_phy_rx- (Can RX signal)
2= i2c0, Input, i2c0_scl_input- (SCL signal)
2= i2c0, Output, i2c0_scl_out- (SCL signal)
3= wdt, Input, wdt_clk_in- (Watch Dog Timer Input clock)
4= sd1, Input, sd1_data_in[2]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[2]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[1]- (SPI Master Selects)
6= Not Used
7= ua0, Input, ua0_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_50_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[6]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[6]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_50_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_51" offset="0xf80007cc" size="0x4">
                <gui_name language="en">MIO_PIN_51</gui_name>
                <description language="en">MIO Control for Pin 51</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_51_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_51_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_51_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[19]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[19]- (GPIO bank 1)
1= can0, Output, can0_phy_tx- (Can TX signal)
2= i2c0, Input, i2c0_sda_input- (SDA signal)
2= i2c0, Output, i2c0_sda_out- (SDA signal)
3= wdt, Output, wdt_rst_out- (Watch Dog Timer Output clock)
4= sd1, Input, sd1_data_in[3]- (4-bit Data bus)
4= sd1, Output, sd1_data_out[3]- (4-bit Data bus)
5= spi1, Output, spi1_n_ss_out[2]- (SPI Master Selects)
6= Not Used
7= ua0, Output, ua0_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_51_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= usb1, Input, usb1_ulpi_rx_data[7]- (ULPI data bus)
1= usb1, Output, usb1_ulpi_tx_data[7]- (ULPI data bus)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_51_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_52" offset="0xf80007d0" size="0x4">
                <gui_name language="en">MIO_PIN_52</gui_name>
                <description language="en">MIO Control for Pin 52</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_52_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_52_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_52_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[20]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[20]- (GPIO bank 1)
1= can1, Output, can1_phy_tx- (Can TX signal)
2= i2c1, Input, i2c1_scl_input- (SCL signal)
2= i2c1, Output, i2c1_scl_out- (SCL signal)
3= wdt, Input, wdt_clk_in- (Watch Dog Timer Input clock)
4= mdio0, Output, gem0_mdc- (MDIO Clock)
5= mdio1, Output, gem1_mdc- (MDIO Clock)
6= Not Used
7= ua1, Output, ua1_txd- (UART transmitter serial output)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_52_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio0_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_52_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_52_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_PIN_53" offset="0xf80007d4" size="0x4">
                <gui_name language="en">MIO_PIN_53</gui_name>
                <description language="en">MIO Control for Pin 53</description>
                <bitField access="Read Write" enumerationId="MIO_PIN_53_DisableRcvr_ENUM" high_bit="13" low_bit="13" name="DisableRcvr">
                    <gui_name language="en">DisableRcvr</gui_name>
                    <description language="en">Enables the receiver.
If the IO is an output only then the receiver can be disabled and save power
Only used when IO_Type=HSTL
0= Receiver Enabled
1= Receiver disabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_53_PULLUP_ENUM" high_bit="12" low_bit="12" name="PULLUP">
                    <gui_name language="en">PULLUP</gui_name>
                    <description language="en">Controls the use of a pull-up for the associated GPIOB
0= Pull-up disabled
1= Pull-up enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_53_IO_Type_ENUM" high_bit="11" low_bit="9" name="IO_Type">
                    <gui_name language="en">IO_Type</gui_name>
                    <description language="en">Selects the IO Type
0= LVTTL
1= LVCMOS18
2= LVCMOS25
3= LVCMOS33
4= HSTL
5-7= LVCMOS33</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="Speed">
                    <gui_name language="en">Speed</gui_name>
                    <description language="en">Selects the speed of the I/O when IO_Type=CMOS
0=Slow CMOS
1=Fast CMOS</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="5" name="L3_SEL">
                    <gui_name language="en">L3_SEL</gui_name>
                    <description language="en">Level 3 Mux Select
0= gpio1, Input, gpio_1_pin_in[21]- (GPIO bank 1)
0= gpio1, Output, gpio_1_pin_out[21]- (GPIO bank 1)
1= can1, Input, can1_phy_rx- (Can RX signal)
2= i2c1, Input, i2c1_sda_input- (SDA signal)
2= i2c1, Output, i2c1_sda_out- (SDA signal)
3= wdt, Output, wdt_rst_out- (Watch Dog Timer Output clock)
4= mdio0, Input, gem0_mdio_in- (MDIO Data)
4= mdio0, Output, gem0_mdio_out- (MDIO Data)
5= mdio1, Input, gem1_mdio_in- (MDIO Data)
5= mdio1, Output, gem1_mdio_out- (MDIO Data)
6= Not Used
7= ua1, Input, ua1_rxd- (UART receiver serial input)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_53_L2_SEL_ENUM" high_bit="4" low_bit="3" name="L2_SEL">
                    <gui_name language="en">L2_SEL</gui_name>
                    <description language="en">Level 2 Mux Select
0= Level 3 Mux Output
1= Not Used
2= Not Used
3= sdio_pow, Output, sdio1_bus_pow- (SD card bus power)</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_53_L1_SEL_ENUM" high_bit="2" low_bit="2" name="L1_SEL">
                    <gui_name language="en">L1_SEL</gui_name>
                    <description language="en">Level 1 Mux Select
0= Level 2 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_PIN_53_L0_SEL_ENUM" high_bit="1" low_bit="1" name="L0_SEL">
                    <gui_name language="en">L0_SEL</gui_name>
                    <description language="en">Level 0 Mux Select
0= Level 1 Mux Output
1= Not Used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="TRI_ENABLE">
                    <gui_name language="en">TRI_ENABLE</gui_name>
                    <description language="en">Tri-state enable, active high.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_FMIO_GEM_SEL" offset="0xf8000800" size="0x4">
                <gui_name language="en">MIO_FMIO_GEM_SEL</gui_name>
                <description language="en">Select function to be routed via MIO or FMIO</description>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="GEM1_IF_SELECT">
                    <gui_name language="en">GEM1_IF_SELECT</gui_name>
                    <description language="en">GEM 1 Interface selection. 0 = RGMII to/from MIO. 1 = GMII to/from FMIO. The setting for this register generates the
gem0_rx_sel
signals to the GEM core wrappers within the IOU.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="GEM0_IF_SELECT">
                    <gui_name language="en">GEM0_IF_SELECT</gui_name>
                    <description language="en">GEM 0 Interface selection. 0 = RGMII to/from MIO. 1 = GMII to/from FMIO. The setting for this register generates the
gem0_rx_sel
signals to the GEM core wrappers within the IOU.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_LOOPBACK" offset="0xf8000804" size="0x4">
                <gui_name language="en">MIO_LOOPBACK</gui_name>
                <description language="en">Loopback function within MIO</description>
                <bitField access="Read Write" enumerationId="MIO_LOOPBACK_I2C0_LOOP_I2C1_ENUM" high_bit="3" low_bit="3" name="I2C0_LOOP_I2C1">
                    <gui_name language="en">I2C0_LOOP_I2C1</gui_name>
                    <description language="en">I2C Loopback Control.
0 = Connect I2C inputs according to MIO mapping.
1 = Loop I2C 0 outputs to I2C 1 inputs, and I2C 1 outputs
to I2C 0 inputs.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_LOOPBACK_CAN0_LOOP_CAN1_ENUM" high_bit="2" low_bit="2" name="CAN0_LOOP_CAN1">
                    <gui_name language="en">CAN0_LOOP_CAN1</gui_name>
                    <description language="en">CAN Loopback Control.
0 = Connect CAN inputs according to MIO mapping.
1 = Loop CAN 0 TX to CAN 1 RX, and CAN 1 TX to CAN 0 RX.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_LOOPBACK_UA0_LOOP_UA1_ENUM" high_bit="1" low_bit="1" name="UA0_LOOP_UA1">
                    <gui_name language="en">UA0_LOOP_UA1</gui_name>
                    <description language="en">UART Loopback Control.
0 = Connect UART inputs according to MIO mapping.
1 = Loop UART 0 outputs to UART 1 inputs, and UART 1 outputs to UART 0 inputs.
RXD/TXD cross-connected.
RTS/CTS cross-connected.
DSR, DTR, DCD and RI not used.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MIO_LOOPBACK_SPI0_LOOP_SPI1_ENUM" high_bit="0" low_bit="0" name="SPI0_LOOP_SPI1">
                    <gui_name language="en">SPI0_LOOP_SPI1</gui_name>
                    <description language="en">SPI Loopback Control.
0 = Connect SPI inputs according to MIO mapping.
1 = Loop SPI 0 outputs to SPI 1 inputs, and SPI 1 outputs to SPI 0 inputs.
The other SPI core will always appear on the LS Slave Select.</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_MST_TRI0" offset="0xf800080c" size="0x4">
                <gui_name language="en">MIO_MST_TRI0</gui_name>
                <description language="en">Parallel access to the master tri-state enables for all pins, least significant word</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="PIN_31_TRI">
                    <gui_name language="en">PIN_31_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 31, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="PIN_30_TRI">
                    <gui_name language="en">PIN_30_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 30, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="PIN_29_TRI">
                    <gui_name language="en">PIN_29_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 29, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="PIN_28_TRI">
                    <gui_name language="en">PIN_28_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 28, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="PIN_27_TRI">
                    <gui_name language="en">PIN_27_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 27, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="PIN_26_TRI">
                    <gui_name language="en">PIN_26_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 26, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="PIN_25_TRI">
                    <gui_name language="en">PIN_25_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 25, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="PIN_24_TRI">
                    <gui_name language="en">PIN_24_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 24, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="PIN_23_TRI">
                    <gui_name language="en">PIN_23_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 23, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="PIN_22_TRI">
                    <gui_name language="en">PIN_22_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 22, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="PIN_21_TRI">
                    <gui_name language="en">PIN_21_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 21, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="PIN_20_TRI">
                    <gui_name language="en">PIN_20_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 20, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="PIN_19_TRI">
                    <gui_name language="en">PIN_19_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 19, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="PIN_18_TRI">
                    <gui_name language="en">PIN_18_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 18, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="PIN_17_TRI">
                    <gui_name language="en">PIN_17_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 17, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="PIN_16_TRI">
                    <gui_name language="en">PIN_16_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 16, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="PIN_15_TRI">
                    <gui_name language="en">PIN_15_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 15, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="PIN_14_TRI">
                    <gui_name language="en">PIN_14_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 14, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="PIN_13_TRI">
                    <gui_name language="en">PIN_13_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 13, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="PIN_12_TRI">
                    <gui_name language="en">PIN_12_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 12, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PIN_11_TRI">
                    <gui_name language="en">PIN_11_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 11, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="PIN_10_TRI">
                    <gui_name language="en">PIN_10_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 10, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="PIN_09_TRI">
                    <gui_name language="en">PIN_09_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 9, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="PIN_08_TRI">
                    <gui_name language="en">PIN_08_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 8, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="PIN_07_TRI">
                    <gui_name language="en">PIN_07_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 7, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="PIN_06_TRI">
                    <gui_name language="en">PIN_06_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 6, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="PIN_05_TRI">
                    <gui_name language="en">PIN_05_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 5, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="PIN_04_TRI">
                    <gui_name language="en">PIN_04_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 4, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PIN_03_TRI">
                    <gui_name language="en">PIN_03_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 3, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PIN_02_TRI">
                    <gui_name language="en">PIN_02_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 2, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PIN_01_TRI">
                    <gui_name language="en">PIN_01_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 1, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PIN_00_TRI">
                    <gui_name language="en">PIN_00_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 0, active high</description>
                </bitField>
            </register>
            <register name="SLCR_MIO_MST_TR11" offset="0xf8000810" size="0x4">
                <gui_name language="en">MIO_MST_TR11</gui_name>
                <description language="en">Parallel access to the master tri-state enables for all pins, most significant word</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="PIN_63_TRI">
                    <gui_name language="en">PIN_63_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 63, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="PIN_62_TRI">
                    <gui_name language="en">PIN_62_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 62, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="PIN_61_TRI">
                    <gui_name language="en">PIN_61_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 61, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="PIN_60_TRI">
                    <gui_name language="en">PIN_60_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 60, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="PIN_59_TRI">
                    <gui_name language="en">PIN_59_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 59, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="PIN_58_TRI">
                    <gui_name language="en">PIN_58_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 58, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="PIN_57_TRI">
                    <gui_name language="en">PIN_57_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 57, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="PIN_56_TRI">
                    <gui_name language="en">PIN_56_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 56 active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="PIN_55_TRI">
                    <gui_name language="en">PIN_55_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 55, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="PIN_54_TRI">
                    <gui_name language="en">PIN_54_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 54, active high. Unused</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="PIN_53_TRI">
                    <gui_name language="en">PIN_53_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 53, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="PIN_52_TRI">
                    <gui_name language="en">PIN_52_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 52, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="PIN_51_TRI">
                    <gui_name language="en">PIN_51_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 51, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="PIN_50_TRI">
                    <gui_name language="en">PIN_50_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 50, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="PIN_49_TRI">
                    <gui_name language="en">PIN_49_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 49, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="PIN_48_TRI">
                    <gui_name language="en">PIN_48_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 48, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="PIN_47_TRI">
                    <gui_name language="en">PIN_47_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 47, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="PIN_46_TRI">
                    <gui_name language="en">PIN_46_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 46, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="PIN_45_TRI">
                    <gui_name language="en">PIN_45_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 45, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="PIN_44_TRI">
                    <gui_name language="en">PIN_44_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 44, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PIN_43_TRI">
                    <gui_name language="en">PIN_43_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 43, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="PIN_42_TRI">
                    <gui_name language="en">PIN_42_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 42, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="PIN_41_TRI">
                    <gui_name language="en">PIN_41_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 41, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="PIN_40_TRI">
                    <gui_name language="en">PIN_40_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 40, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="PIN_39_TRI">
                    <gui_name language="en">PIN_39_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 39, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="PIN_38_TRI">
                    <gui_name language="en">PIN_38_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 38, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="PIN_37_TRI">
                    <gui_name language="en">PIN_37_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 37, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="PIN_36_TRI">
                    <gui_name language="en">PIN_36_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 36, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PIN_35_TRI">
                    <gui_name language="en">PIN_35_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 35, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PIN_34_TRI">
                    <gui_name language="en">PIN_34_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 34, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="PIN_33_TRI">
                    <gui_name language="en">PIN_33_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 33, active high</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PIN_32_TRI">
                    <gui_name language="en">PIN_32_TRI</gui_name>
                    <description language="en">Master Tri-state Enable for pin 32, active high</description>
                </bitField>
            </register>
            <register name="SLCR_SD0_WP_CD_SEL" offset="0xf8000830" size="0x4">
                <gui_name language="en">SD0_WP_CD_SEL</gui_name>
                <description language="en">SDIO 0 WP CD select register</description>
                <bitField access="Read Write" high_bit="21" low_bit="16" name="SDIO0_CD_SEL">
                    <gui_name language="en">SDIO0_CD_SEL</gui_name>
                    <description language="en">SDIO0 CD Select. 0-53 = Selects matching MIO input however bits 7/8 are not supported and should not be used as they will conflict with the VCFG inputs. 54-63 = Selects the FMIO source</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="SDIO0_WP_SEL">
                    <gui_name language="en">SDIO0_WP_SEL</gui_name>
                    <description language="en">SDIO0 WP Select. 0-53 = Selects matching MIO input however bits 7/8 are not supported and should not be used as they will conflict with the VCFG inputs. 54-63 = Selects the FMIO source</description>
                </bitField>
            </register>
            <register name="SLCR_SD1_WP_CD_SEL" offset="0xf8000834" size="0x4">
                <gui_name language="en">SD1_WP_CD_SEL</gui_name>
                <description language="en">SDIO 1 WP CD select register</description>
                <bitField access="Read Write" high_bit="21" low_bit="16" name="SDIO1_CD_SEL">
                    <gui_name language="en">SDIO1_CD_SEL</gui_name>
                    <description language="en">SDIO1 CD Select. 0-53 = Selects matching MIO input however bits 7/8 are not supported and should not be used as they will conflict with the VCFG inputs. 54-63 = Selects the FMIO source</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="SDIO1_WP_SEL">
                    <gui_name language="en">SDIO1_WP_SEL</gui_name>
                    <description language="en">SDIO1 WP Select. 0-53 = Selects matching MIO input however bits 7/8 are not supported and should not be used as they will conflict with the VCFG inputs. 54-63 = Selects the FMIO source</description>
                </bitField>
            </register>
            <register name="SLCR_LVL_SHFTR_EN" offset="0xf8000900" size="0x4">
                <gui_name language="en">LVL_SHFTR_EN</gui_name>
                <description language="en">Level Shifters Enable</description>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="USER_INP_ICT_EN_1">
                    <gui_name language="en">USER_INP_ICT_EN_1</gui_name>
                    <description language="en">Enable level shifters for PSS user inputs to FPGA in FPGA tile 1, drives slcr_fpga_if_ctrl1[1:0].</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="USER_INP_ICT_EN_0">
                    <gui_name language="en">USER_INP_ICT_EN_0</gui_name>
                    <description language="en">Enable level shifters for PSS user inputs to FPGA in FPGA tile 0, drives slcr_fpga_if_ctrl0[1:0].</description>
                </bitField>
            </register>
            <register name="SLCR_OCM_CFG" offset="0xf8000910" size="0x4">
                <gui_name language="en">OCM_CFG</gui_name>
                <description language="en">OCM configuration</description>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SWAP">
                    <gui_name language="en">SWAP</gui_name>
                    <description language="en">When cleared (0), the RAM is located starting at address 32'h0004_0000. This is the reset state. When set (1), the RAM is 'swapped' with the ROM at the bottom of the OCM address map. The base address for the RAM will now be 32'h0000_0000.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="RAM_HI">
                    <gui_name language="en">RAM_HI</gui_name>
                    <description language="en">Maps the RAM, in 64kByte chunks, to the high address space (1) or the low address space(0). Refer to the OCM spec. for more details.
Note that  the 'RAM_HI' bits are only valid when the 'SWAP' bit is set.</description>
                </bitField>
            </register>
            <register name="SLCR_CPU0_RAM0" offset="0xf8000a00" size="0x4">
                <gui_name language="en">CPU0_RAM0</gui_name>
                <description language="en">CPU#0: dcache outer, dcache tag, dcache data (3 RAM controls)</description>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_CPU0_RAM1" offset="0xf8000a04" size="0x4">
                <gui_name language="en">CPU0_RAM1</gui_name>
                <description language="en">CPU#0: global history buffer, icache tag, icache data (3 RAM controls)</description>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_CPU0_RAM2" offset="0xf8000a08" size="0x4">
                <gui_name language="en">CPU0_RAM2</gui_name>
                <description language="en">CPU#0: TLB hi, TLB lo, btac_target, btac_control (4 RAM controls)</description>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="EMAS3">
                    <gui_name language="en">EMAS3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="27" name="EMAW3">
                    <gui_name language="en">EMAW3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMA3">
                    <gui_name language="en">EMA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_CPU1_RAM0" offset="0xf8000a0c" size="0x4">
                <gui_name language="en">CPU1_RAM0</gui_name>
                <description language="en">CPU#1: dcache outer, dcache tag, dcache data (3 RAM controls)</description>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_CPU1_RAM1" offset="0xf8000a10" size="0x4">
                <gui_name language="en">CPU1_RAM1</gui_name>
                <description language="en">CPU#1: global history buffer, icache tag, icache data (3 RAM controls)</description>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_CPU1_RAM2" offset="0xf8000a14" size="0x4">
                <gui_name language="en">CPU1_RAM2</gui_name>
                <description language="en">CPU#1: TLB hi, TLB lo, btac_target, btac_control (4 RAM controls)</description>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="EMAS3">
                    <gui_name language="en">EMAS3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="27" name="EMAW3">
                    <gui_name language="en">EMAW3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMA3">
                    <gui_name language="en">EMA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_SCU_RAM" offset="0xf8000a18" size="0x4">
                <gui_name language="en">SCU_RAM</gui_name>
                <description language="en">SCU: tag (1 RAM control)</description>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_L2C_RAM" offset="0xf8000a1c" size="0x4">
                <gui_name language="en">L2C_RAM</gui_name>
                <description language="en">L2 Cache: tag, parity, data (3 RAM controls)</description>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_GEM01" offset="0xf8000a30" size="0x4">
                <gui_name language="en">IOU_RAM_GEM01</gui_name>
                <description language="en">IOU: GEM 0/1, 4 RAM controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_USB01" offset="0xf8000a34" size="0x4">
                <gui_name language="en">IOU_RAM_USB01</gui_name>
                <description language="en">IOU: USB 0/1, 4 RAM controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_SDIO0" offset="0xf8000a38" size="0x4">
                <gui_name language="en">IOU_RAM_SDIO0</gui_name>
                <description language="en">IOU: SDIO 0, 4 RAM controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_SDIO1" offset="0xf8000a3c" size="0x4">
                <gui_name language="en">IOU_RAM_SDIO1</gui_name>
                <description language="en">IOU: SDIO 1, 4 RAM controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_CAN0" offset="0xf8000a40" size="0x4">
                <gui_name language="en">IOU_RAM_CAN0</gui_name>
                <description language="en">IOU: CAN 0, 3 RAM controls</description>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_CAN1" offset="0xf8000a44" size="0x4">
                <gui_name language="en">IOU_RAM_CAN1</gui_name>
                <description language="en">IOU: CAN 1, 3 RAM controls</description>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_IOU_RAM_LQSPI" offset="0xf8000a48" size="0x4">
                <gui_name language="en">IOU_RAM_LQSPI</gui_name>
                <description language="en">IOU: LQSPI, 2 RAM controls</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_DMAC_RAM" offset="0xf8000a50" size="0x4">
                <gui_name language="en">DMAC_RAM</gui_name>
                <description language="en">DMA Controller: 1 RAM control</description>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI0_RAM0" offset="0xf8000a60" size="0x4">
                <gui_name language="en">AFI0_RAM0</gui_name>
                <description language="en">AFI0: RAM 3 to RAM 0 controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI0_RAM1" offset="0xf8000a64" size="0x4">
                <gui_name language="en">AFI0_RAM1</gui_name>
                <description language="en">AFI0: RAM 7 to RAM 4controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI0_RAM2" offset="0xf8000a68" size="0x4">
                <gui_name language="en">AFI0_RAM2</gui_name>
                <description language="en">AFI0: RAM 9 to RAM 8 controls</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI1_RAM0" offset="0xf8000a6c" size="0x4">
                <gui_name language="en">AFI1_RAM0</gui_name>
                <description language="en">AFI1: RAM 3 to RAM 0 controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI1_RAM1" offset="0xf8000a70" size="0x4">
                <gui_name language="en">AFI1_RAM1</gui_name>
                <description language="en">AFI1: RAM 7 to RAM 4controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI1_RAM2" offset="0xf8000a74" size="0x4">
                <gui_name language="en">AFI1_RAM2</gui_name>
                <description language="en">AFI1: RAM 9 to RAM 8 controls</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI2_RAM0" offset="0xf8000a78" size="0x4">
                <gui_name language="en">AFI2_RAM0</gui_name>
                <description language="en">AFI2: RAM 3 to RAM 0 controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI2_RAM1" offset="0xf8000a7c" size="0x4">
                <gui_name language="en">AFI2_RAM1</gui_name>
                <description language="en">AFI2: RAM 7 to RAM 4controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI2_RAM2" offset="0xf8000a80" size="0x4">
                <gui_name language="en">AFI2_RAM2</gui_name>
                <description language="en">AFI2: RAM 9 to RAM 8 controls</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI3_RAM0" offset="0xf8000a84" size="0x4">
                <gui_name language="en">AFI3_RAM0</gui_name>
                <description language="en">AFI3: RAM 3 to RAM 0 controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI3_RAM1" offset="0xf8000a88" size="0x4">
                <gui_name language="en">AFI3_RAM1</gui_name>
                <description language="en">AFI3: RAM 7 to RAM 4controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="27" name="EMAB3">
                    <gui_name language="en">EMAB3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMAA3">
                    <gui_name language="en">EMAA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="EMAB2">
                    <gui_name language="en">EMAB2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMAA2">
                    <gui_name language="en">EMAA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_AFI3_RAM2" offset="0xf8000a8c" size="0x4">
                <gui_name language="en">AFI3_RAM2</gui_name>
                <description language="en">AFI3: RAM 9 to RAM 8 controls</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_OCM_RAM" offset="0xf8000a90" size="0x4">
                <gui_name language="en">OCM_RAM</gui_name>
                <description language="en">OCM: 4 RAM controls</description>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="EMAS3">
                    <gui_name language="en">EMAS3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="27" name="EMAW3">
                    <gui_name language="en">EMAW3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="EMA3">
                    <gui_name language="en">EMA3</gui_name>
                    <description language="en">RAM 3 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="EMAS2">
                    <gui_name language="en">EMAS2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="19" name="EMAW2">
                    <gui_name language="en">EMAW2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">RAM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="EMAS1">
                    <gui_name language="en">EMAS1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="11" name="EMAW1">
                    <gui_name language="en">EMAW1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register access="Read Only" name="SLCR_OCM_ROM0" offset="0xf8000a94" size="0x4">
                <gui_name language="en">OCM_ROM0</gui_name>
                <description language="en">OCM: 4 ROM controls</description>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="KEN3">
                    <gui_name language="en">KEN3</gui_name>
                    <description language="en">ROM 3 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="24" name="EMA3">
                    <gui_name language="en">EMA3</gui_name>
                    <description language="en">ROM 3 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="KEN2">
                    <gui_name language="en">KEN2</gui_name>
                    <description language="en">ROM 2 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">ROM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="KEN1">
                    <gui_name language="en">KEN1</gui_name>
                    <description language="en">ROM 1 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">ROM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="KEN0">
                    <gui_name language="en">KEN0</gui_name>
                    <description language="en">ROM 0 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">ROM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register access="Read Only" name="SLCR_OCM_ROM1" offset="0xf8000a98" size="0x4">
                <gui_name language="en">OCM_ROM1</gui_name>
                <description language="en">OCM: 4 ROM controls</description>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="KEN3">
                    <gui_name language="en">KEN3</gui_name>
                    <description language="en">ROM 3 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="24" name="EMA3">
                    <gui_name language="en">EMA3</gui_name>
                    <description language="en">ROM 3 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="KEN2">
                    <gui_name language="en">KEN2</gui_name>
                    <description language="en">ROM 2 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="16" name="EMA2">
                    <gui_name language="en">EMA2</gui_name>
                    <description language="en">ROM 2 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="KEN1">
                    <gui_name language="en">KEN1</gui_name>
                    <description language="en">ROM 1 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="EMA1">
                    <gui_name language="en">EMA1</gui_name>
                    <description language="en">ROM 1 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="KEN0">
                    <gui_name language="en">KEN0</gui_name>
                    <description language="en">ROM 0 Keeper Enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">ROM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_DEVCI_RAM" offset="0xf8000aa0" size="0x4">
                <gui_name language="en">DEVCI_RAM</gui_name>
                <description language="en">DEVCI: Tx and Rx FIFOs (2 RAM controls)</description>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="EMAB1">
                    <gui_name language="en">EMAB1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="EMAA1">
                    <gui_name language="en">EMAA1</gui_name>
                    <description language="en">RAM 1 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="3" name="EMAB0">
                    <gui_name language="en">EMAB0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAB[0] = LSB)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMAA0">
                    <gui_name language="en">EMAA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMAA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_CSG_RAM" offset="0xf8000ab0" size="0x4">
                <gui_name language="en">CSG_RAM</gui_name>
                <description language="en">Coresight: embedded trace buffer</description>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="EMAS0">
                    <gui_name language="en">EMAS0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (sensing)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="3" name="EMAW0">
                    <gui_name language="en">EMAW0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (writes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="0" name="EMA0">
                    <gui_name language="en">EMA0</gui_name>
                    <description language="en">RAM 0 Extra Margin Adjustment (EMA[0] = LSB)</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_CTRL" offset="0xf8000b00" size="0x4">
                <gui_name language="en">GPIOB_CTRL</gui_name>
                <description language="en">GPIOB control</description>
                <bitField access="Read Write" enumerationId="GPIOB_CTRL_VREF_SW_EN_ENUM" high_bit="11" low_bit="11" name="VREF_SW_EN">
                    <gui_name language="en">VREF_SW_EN</gui_name>
                    <description language="en">Enables the VREF switch
0 - internal
1 - external</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GPIOB_CTRL_VREF_EXT_ENUM" high_bit="10" low_bit="10" name="VREF_EXT">
                    <gui_name language="en">VREF_EXT</gui_name>
                    <description language="en">Enables higher performance if needed...uses more power
0 - normal operation (should be sufficient)
1 - higher performance (more power)</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="SRSTN_PULLUP_EN">
                    <gui_name language="en">SRSTN_PULLUP_EN</gui_name>
                    <description language="en">Enables internal pullup. 0 - no pullup. 1 - pullup.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="CLK_PULLUP_EN">
                    <gui_name language="en">CLK_PULLUP_EN</gui_name>
                    <description language="en">Enables internal pullup. 0 - no pullup. 1 - pullup.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="GPIOB_CTRL_VREF_SEL_ENUM" high_bit="7" low_bit="2" name="VREF_SEL">
                    <gui_name language="en">VREF_SEL</gui_name>
                    <description language="en">Specifies GP
IOB Vref generator output
000000 - VREF = test mode - external VREF selected
000001 - VREF = test mode - 060
000010 - VREF = test mode - 075
000100 - VREF = test mode - 090
001000 - VREF = test mode - 108
010000 - VREF = test mode - 125
100000 - VREF = test mode - 0675</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="VREF_PULLUP_EN">
                    <gui_name language="en">VREF_PULLUP_EN</gui_name>
                    <description language="en">Enables internal pullup. 0 - no pullup. 1 - pullup.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="VREF_EN">
                    <gui_name language="en">VREF_EN</gui_name>
                    <description language="en">Enables VREF internal generator</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_CFG_CMOS18" offset="0xf8000b04" size="0x4">
                <gui_name language="en">GPIOB_CFG_CMOS18</gui_name>
                <description language="en">GPIOB CMOS 1.8V IO configuration</description>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="m_nslew_slow">
                    <gui_name language="en">m_nslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="22" name="m_nslew_fast">
                    <gui_name language="en">m_nslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="m_pslew_slow">
                    <gui_name language="en">m_pslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="m_pslew_fast">
                    <gui_name language="en">m_pslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="m_ndrv_slow">
                    <gui_name language="en">m_ndrv_slow</gui_name>
                    <description language="en">N Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="m_ndrv_fast">
                    <gui_name language="en">m_ndrv_fast</gui_name>
                    <description language="en">N Drive for fast mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="m_pdrv_slow">
                    <gui_name language="en">m_pdrv_slow</gui_name>
                    <description language="en">P Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="m_pdrv_fast">
                    <gui_name language="en">m_pdrv_fast</gui_name>
                    <description language="en">P Drive for fast mode</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_CFG_CMOS25" offset="0xf8000b08" size="0x4">
                <gui_name language="en">GPIOB_CFG_CMOS25</gui_name>
                <description language="en">GPIOB CMOS 2.5V IO configuration</description>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="m_nslew_slow">
                    <gui_name language="en">m_nslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="22" name="m_nslew_fast">
                    <gui_name language="en">m_nslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="m_pslew_slow">
                    <gui_name language="en">m_pslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="m_pslew_fast">
                    <gui_name language="en">m_pslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="m_ndrv_slow">
                    <gui_name language="en">m_ndrv_slow</gui_name>
                    <description language="en">N Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="m_ndrv_fast">
                    <gui_name language="en">m_ndrv_fast</gui_name>
                    <description language="en">N Drive for fast mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="m_pdrv_slow">
                    <gui_name language="en">m_pdrv_slow</gui_name>
                    <description language="en">P Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="m_pdrv_fast">
                    <gui_name language="en">m_pdrv_fast</gui_name>
                    <description language="en">P Drive for fast mode</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_CFG_CMOS33" offset="0xf8000b0c" size="0x4">
                <gui_name language="en">GPIOB_CFG_CMOS33</gui_name>
                <description language="en">GPIOB CMOS 3.3V IO configuration</description>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="m_nslew_slow">
                    <gui_name language="en">m_nslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="22" name="m_nslew_fast">
                    <gui_name language="en">m_nslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="m_pslew_slow">
                    <gui_name language="en">m_pslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="m_pslew_fast">
                    <gui_name language="en">m_pslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="m_ndrv_slow">
                    <gui_name language="en">m_ndrv_slow</gui_name>
                    <description language="en">N Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="m_ndrv_fast">
                    <gui_name language="en">m_ndrv_fast</gui_name>
                    <description language="en">N Drive for fast mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="m_pdrv_slow">
                    <gui_name language="en">m_pdrv_slow</gui_name>
                    <description language="en">P Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="m_pdrv_fast">
                    <gui_name language="en">m_pdrv_fast</gui_name>
                    <description language="en">P Drive for fast mode</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_CFG_LVTTL" offset="0xf8000b10" size="0x4">
                <gui_name language="en">GPIOB_CFG_LVTTL</gui_name>
                <description language="en">GPIOB LVTTL IO configuration</description>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="m_nslew_slow">
                    <gui_name language="en">m_nslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="22" name="m_nslew_fast">
                    <gui_name language="en">m_nslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="m_pslew_slow">
                    <gui_name language="en">m_pslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="m_pslew_fast">
                    <gui_name language="en">m_pslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="m_ndrv_slow">
                    <gui_name language="en">m_ndrv_slow</gui_name>
                    <description language="en">N Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="m_ndrv_fast">
                    <gui_name language="en">m_ndrv_fast</gui_name>
                    <description language="en">N Drive for fast mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="m_pdrv_slow">
                    <gui_name language="en">m_pdrv_slow</gui_name>
                    <description language="en">P Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="m_pdrv_fast">
                    <gui_name language="en">m_pdrv_fast</gui_name>
                    <description language="en">P Drive for fast mode</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_CFG_HSTL" offset="0xf8000b14" size="0x4">
                <gui_name language="en">GPIOB_CFG_HSTL</gui_name>
                <description language="en">GPIOB HSTL configuration</description>
                <bitField access="Read Write" high_bit="27" low_bit="25" name="m_nslew_slow">
                    <gui_name language="en">m_nslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="22" name="m_nslew_fast">
                    <gui_name language="en">m_nslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="19" name="m_pslew_slow">
                    <gui_name language="en">m_pslew_slow</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="16" name="m_pslew_fast">
                    <gui_name language="en">m_pslew_fast</gui_name>
                    <description language="en">Skew</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="12" name="m_ndrv_slow">
                    <gui_name language="en">m_ndrv_slow</gui_name>
                    <description language="en">N Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="8" name="m_ndrv_fast">
                    <gui_name language="en">m_ndrv_fast</gui_name>
                    <description language="en">N Drive for fast mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="4" name="m_pdrv_slow">
                    <gui_name language="en">m_pdrv_slow</gui_name>
                    <description language="en">P Drive for slow mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="0" name="m_pdrv_fast">
                    <gui_name language="en">m_pdrv_fast</gui_name>
                    <description language="en">P Drive for fast mode</description>
                </bitField>
            </register>
            <register name="SLCR_GPIOB_DRVR_BIAS_CTRL" offset="0xf8000b18" size="0x4">
                <gui_name language="en">GPIOB_DRVR_BIAS_CTRL</gui_name>
                <description language="en">GPIOB Driver Bias Control [31:0]</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="RB_VCFG">
                    <gui_name language="en">RB_VCFG</gui_name>
                    <description language="en">This is the right BANK's VCFG (Read Only)</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="16" name="RB_DRVR_BIAS">
                    <gui_name language="en">RB_DRVR_BIAS</gui_name>
                    <description language="en">This is the right BANK's driver bias control</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="LB_VCFG">
                    <gui_name language="en">LB_VCFG</gui_name>
                    <description language="en">This is the left BANK's VCFG (Read Only)</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="0" name="LB_DRVR_BIAS">
                    <gui_name language="en">LB_DRVR_BIAS</gui_name>
                    <description language="en">This is the left BANK's driver bias control</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_ADDR0" offset="0xf8000b40" size="0x4">
                <gui_name language="en">DDRIOB_ADDR0</gui_name>
                <description language="en">DDRIOB Address 0 Configuartion Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_ADDR0_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_ADDR1" offset="0xf8000b44" size="0x4">
                <gui_name language="en">DDRIOB_ADDR1</gui_name>
                <description language="en">DDRIOB Address 1 Configuration Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_ADDR1_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DATA0" offset="0xf8000b48" size="0x4">
                <gui_name language="en">DDRIOB_DATA0</gui_name>
                <description language="en">DDRIOB Data 0 Configuration Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_DATA0_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DATA1" offset="0xf8000b4c" size="0x4">
                <gui_name language="en">DDRIOB_DATA1</gui_name>
                <description language="en">DDRIOB Data 1 Configuration Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_DATA1_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DIFF0" offset="0xf8000b50" size="0x4">
                <gui_name language="en">DDRIOB_DIFF0</gui_name>
                <description language="en">DDRIOB Differential DQS 0 Configuration Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_DIFF0_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DIFF1" offset="0xf8000b54" size="0x4">
                <gui_name language="en">DDRIOB_DIFF1</gui_name>
                <description language="en">DDRIOB Differential DQS 1 Configuration Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_DIFF1_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_CLOCK" offset="0xf8000b58" size="0x4">
                <gui_name language="en">DDRIOB_CLOCK</gui_name>
                <description language="en">DDRIOB Differential Clock Configuration Register</description>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="PULLUP_EN">
                    <gui_name language="en">PULLUP_EN</gui_name>
                    <description language="en">enables pullup on output 0 - no pullup 1 - pullup enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="9" name="OUTPUT_EN">
                    <gui_name language="en">OUTPUT_EN</gui_name>
                    <description language="en">Enables output mode to enable output ties to 00 - ibuf 01 - reserved 10 - reserved 11 - obuf</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="TERM_DISABLE_MODE">
                    <gui_name language="en">TERM_DISABLE_MODE</gui_name>
                    <description language="en">Use dynamic_dci_ts to control dci 0 - termination enabled 1 - use 'dynamic_dci_ts' control termination</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="IBUF_DISABLE_MODE">
                    <gui_name language="en">IBUF_DISABLE_MODE</gui_name>
                    <description language="en">Use ibuf_disable_into control ibuf 0 -ibuf is always enabled 1 - use ibuf_disable_in_to control enable</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="DCR_TYPE">
                    <gui_name language="en">DCR_TYPE</gui_name>
                    <description language="en">DCI Update 00 - DCI Disabled 01 - DCI Drive (HSTL12_DCI) 10 - Reserved 11 - DCI Termination (SSTL15_T_DCI)</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TERM_EN">
                    <gui_name language="en">TERM_EN</gui_name>
                    <description language="en">Tri State Termination Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="DCI_UPDATE">
                    <gui_name language="en">DCI_UPDATE</gui_name>
                    <description language="en">DCI Update Enabled 0 - disabled 1 - enabled</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_CLOCK_INP_TYPE_ENUM" high_bit="2" low_bit="1" name="INP_TYPE">
                    <gui_name language="en">INP_TYPE</gui_name>
                    <description language="en">Input buffer controls.
00 - Input off, reads 0.
01 - Vref based differential reciever for SSTL, HSTL.
10 - Differential input reciever.
11- LVCMOS reviever.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="INP_POWER">
                    <gui_name language="en">INP_POWER</gui_name>
                    <description language="en">Specifies DDR IOB input amp power mode. 0- low power mode. 1- high performance mode.</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DRIVE_SLEW_ADDR" offset="0xf8000b5c" size="0x4">
                <gui_name language="en">DDRIOB_DRIVE_SLEW_ADDR</gui_name>
                <description language="en">DDRIOB Drive Slew Address Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="27" name="RTERM">
                    <gui_name language="en">RTERM</gui_name>
                    <description language="en">Program the rterm</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="GTL">
                    <gui_name language="en">GTL</gui_name>
                    <description language="en">Test Control 000 - Normal Operation 001 : 111 - Test Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="19" name="SLEW_N">
                    <gui_name language="en">SLEW_N</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="14" name="SLEW_P">
                    <gui_name language="en">SLEW_P</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the P devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="7" name="DRIVE_N">
                    <gui_name language="en">DRIVE_N</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="DRIVE_P">
                    <gui_name language="en">DRIVE_P</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the P devices</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DRIVE_SLEW_DATA" offset="0xf8000b60" size="0x4">
                <gui_name language="en">DDRIOB_DRIVE_SLEW_DATA</gui_name>
                <description language="en">DDRIOB Drive Slew Data Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="27" name="RTERM">
                    <gui_name language="en">RTERM</gui_name>
                    <description language="en">Program the rterm</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="GTL">
                    <gui_name language="en">GTL</gui_name>
                    <description language="en">Test Control 000 - Normal Operation 001 : 111 - Test Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="19" name="SLEW_N">
                    <gui_name language="en">SLEW_N</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="14" name="SLEW_P">
                    <gui_name language="en">SLEW_P</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the P devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="7" name="DRIVE_N">
                    <gui_name language="en">DRIVE_N</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="DRIVE_P">
                    <gui_name language="en">DRIVE_P</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the P devices</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DRIVE_SLEW_DIFF" offset="0xf8000b64" size="0x4">
                <gui_name language="en">DDRIOB_DRIVE_SLEW_DIFF</gui_name>
                <description language="en">DDRIOB Drive Slew Differential Strobe Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="27" name="RTERM">
                    <gui_name language="en">RTERM</gui_name>
                    <description language="en">Program the rterm</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="GTL">
                    <gui_name language="en">GTL</gui_name>
                    <description language="en">Test Control 000 - Normal Operation 001 : 111 - Test Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="19" name="SLEW_N">
                    <gui_name language="en">SLEW_N</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="14" name="SLEW_P">
                    <gui_name language="en">SLEW_P</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the P devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="7" name="DRIVE_N">
                    <gui_name language="en">DRIVE_N</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="DRIVE_P">
                    <gui_name language="en">DRIVE_P</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the P devices</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DRIVE_SLEW_CLOCK" offset="0xf8000b68" size="0x4">
                <gui_name language="en">DDRIOB_DRIVE_SLEW_CLOCK</gui_name>
                <description language="en">DDRIOB Drive Slew Clcok Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="27" name="RTERM">
                    <gui_name language="en">RTERM</gui_name>
                    <description language="en">Program the rterm</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="GTL">
                    <gui_name language="en">GTL</gui_name>
                    <description language="en">Test Control 000 - Normal Operation 001 : 111 - Test Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="19" name="SLEW_N">
                    <gui_name language="en">SLEW_N</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="14" name="SLEW_P">
                    <gui_name language="en">SLEW_P</gui_name>
                    <description language="en">Programs the DDRIO slew rate for the P devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="7" name="DRIVE_N">
                    <gui_name language="en">DRIVE_N</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the N devices</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="DRIVE_P">
                    <gui_name language="en">DRIVE_P</gui_name>
                    <description language="en">Programs the DDRIO drive strength for the P devices</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DDR_CTRL" offset="0xf8000b6c" size="0x4">
                <gui_name language="en">DDRIOB_DDR_CTRL</gui_name>
                <description language="en">DDRIOB DDR Control Register</description>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="CKE_PULLUP_EN">
                    <gui_name language="en">CKE_PULLUP_EN</gui_name>
                    <description language="en">Enables pull-up resistors 0 -no pull-up 1 - enable pull-up resistors</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="DRST_B_PULLUP_EN">
                    <gui_name language="en">DRST_B_PULLUP_EN</gui_name>
                    <description language="en">Enables pull-up resistors 0 -no pull-up 1 - enable pull-up resistors</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="REFIO_PULLUP_EN">
                    <gui_name language="en">REFIO_PULLUP_EN</gui_name>
                    <description language="en">Enables VRP,VRN pull-up resistors 0 -no pull-up 1 - enable pull-up resistors</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="10" name="REFIO_TSEN">
                    <gui_name language="en">REFIO_TSEN</gui_name>
                    <description language="en">Enables VRP,VRN as normal outputs 00 - VRP/VRN not used 11 - VRP/VRN used as normal IO</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="REFIO_EN">
                    <gui_name language="en">REFIO_EN</gui_name>
                    <description language="en">Enables VRP,VRN 0 - VRP/VRN not used 1 - VRP/VRN used as refio</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="7" name="VREF_PULLUP_EN">
                    <gui_name language="en">VREF_PULLUP_EN</gui_name>
                    <description language="en">Enables VREF pull-up resistors X0 - Disable VREF pull-up for lower 16 bits X1 - Enable VREF pull-up for lower 16 bits 0X - Disable VREF pull-up for upper 16 bits 1X - Enable VREF pull-up for upper 16 bits</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="5" name="VREF_EXT_EN">
                    <gui_name language="en">VREF_EXT_EN</gui_name>
                    <description language="en">Enables External VREF input X0 - Disable External VREF for lower 16 bits X1 - Enable External VREF for lower 16 bits 0X - Disable External VREF for upper 16 bits 1X - Enable External VREF for upper 16 bits</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="VREF_SEL">
                    <gui_name language="en">VREF_SEL</gui_name>
                    <description language="en">Specifies DDR IOB Vref generator output 0001 - VREF = 0.6V for LPDDR2 with 1.2V IO 0010 - VREF = 0.675V for LPDDR3 1.35 V IO 0100 - VREF = 0.75V for DDR3 with 1.5V IO 1000 - VREF = 0.90V for DDR2 with 1.8V IO</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="VREF_INT_EN">
                    <gui_name language="en">VREF_INT_EN</gui_name>
                    <description language="en">Enables VREF internal generator</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DCI_CTRL" offset="0xf8000b70" size="0x4">
                <gui_name language="en">DDRIOB_DCI_CTRL</gui_name>
                <description language="en">DDRIOB DCI configuration</description>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="INT_DCI_EN">
                    <gui_name language="en">INT_DCI_EN</gui_name>
                    <description language="en">Need explanation here</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TST_RST">
                    <gui_name language="en">TST_RST</gui_name>
                    <description language="en">Emulate Reset</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TST_HLP">
                    <gui_name language="en">TST_HLP</gui_name>
                    <description language="en">Emulate comparator output (VRP)</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="23" name="TST_HLN">
                    <gui_name language="en">TST_HLN</gui_name>
                    <description language="en">Emulate comparator output (VRN)</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="TST_CLK">
                    <gui_name language="en">TST_CLK</gui_name>
                    <description language="en">Emulate DCI clock</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="INIT_COMPLETE">
                    <gui_name language="en">INIT_COMPLETE</gui_name>
                    <description language="en">test Internal to IO bank</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="UPDATE_CONTROL">
                    <gui_name language="en">UPDATE_CONTROL</gui_name>
                    <description language="en">DCI Update</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="17" name="PREF_OPT2">
                    <gui_name language="en">PREF_OPT2</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="14" name="PREF_OPT1">
                    <gui_name language="en">PREF_OPT1</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="11" name="NREF_OPT4">
                    <gui_name language="en">NREF_OPT4</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="8" name="NREF_OPT2">
                    <gui_name language="en">NREF_OPT2</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="6" name="NREF_OPT1">
                    <gui_name language="en">NREF_OPT1</gui_name>
                    <description language="en">Reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="VRN_OUT">
                    <gui_name language="en">VRN_OUT</gui_name>
                    <description language="en">VRN output value</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="VRP_OUT">
                    <gui_name language="en">VRP_OUT</gui_name>
                    <description language="en">VRP output value</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="VRN_TRI">
                    <gui_name language="en">VRN_TRI</gui_name>
                    <description language="en">VRN tristate value</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="VRP_TRI">
                    <gui_name language="en">VRP_TRI</gui_name>
                    <description language="en">VRP tristate value</description>
                </bitField>
                <bitField access="Read Write" enumerationId="DDRIOB_DCI_CTRL_ENABLE_ENUM" high_bit="1" low_bit="1" name="ENABLE">
                    <gui_name language="en">ENABLE</gui_name>
                    <description language="en">1 if any iob's use a terminate type, or if dci test block used</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RESET">
                    <gui_name language="en">RESET</gui_name>
                    <description language="en">At least toggle once to initialise flops in DCI system</description>
                </bitField>
            </register>
            <register name="SLCR_DDRIOB_DCI_STATUS" offset="0xf8000b74" size="0x4">
                <gui_name language="en">DDRIOB_DCI_STATUS</gui_name>
                <description language="en">DDRIOB digital control impedance status</description>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="DONE">
                    <gui_name language="en">DONE</gui_name>
                    <description language="en">DCI done signal</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="12" name="HL_P_B_INIT">
                    <gui_name language="en">HL_P_B_INIT</gui_name>
                    <description language="en">dci test</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="HL_N_B_INIT">
                    <gui_name language="en">HL_N_B_INIT</gui_name>
                    <description language="en">dci test</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="SCK">
                    <gui_name language="en">SCK</gui_name>
                    <description language="en">Clock for Serial data</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="REFIO_UPDATE">
                    <gui_name language="en">REFIO_UPDATE</gui_name>
                    <description language="en">Update VRN/VRP</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="NORP">
                    <gui_name language="en">NORP</gui_name>
                    <description language="en">dci test</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="IO_UPDATE">
                    <gui_name language="en">IO_UPDATE</gui_name>
                    <description language="en">Update IO</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="DATA">
                    <gui_name language="en">DATA</gui_name>
                    <description language="en">Serial data</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="3" name="ADDR">
                    <gui_name language="en">ADDR</gui_name>
                    <description language="en">DCI address</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="VRN_IN">
                    <gui_name language="en">VRN_IN</gui_name>
                    <description language="en">Current Value of VRN IO</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="VRP_IN">
                    <gui_name language="en">VRP_IN</gui_name>
                    <description language="en">Current Value of VRP IO</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="LOCK">
                    <gui_name language="en">LOCK</gui_name>
                    <description language="en">DCI Status input Read Only</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SMCC" name="SMCC" offset="0xe000e000">
            <gui_name language="en">smcc</gui_name>
            <description language="en">smcc</description>
            <register access="Read Only" name="SMCC_MEMC_STATUS" offset="0xe000e000" size="0x2">
                <gui_name language="en">memc_status</gui_name>
                <description language="en">The read-only memc_status Register provides information on the configuration of the SMC and also the current state of the SMC. You cannot read this register in the Reset state</description>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="raw_ecc_int1">
                    <gui_name language="en">raw_ecc_int1</gui_name>
                    <description language="en">Raw status of the ECC interrupt on interface 1</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="raw_ecc_int0">
                    <gui_name language="en">raw_ecc_int0</gui_name>
                    <description language="en">Raw status of the ECC interrupt on interface 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="ecc_int1">
                    <gui_name language="en">ecc_int1</gui_name>
                    <description language="en">Status of the ECC interrupt on interface 1</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="ecc_int0">
                    <gui_name language="en">ecc_int0</gui_name>
                    <description language="en">Status of the ECC interrupt on interface 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="ecc_int1_en">
                    <gui_name language="en">ecc_int1_en</gui_name>
                    <description language="en">Status of the ECC interrupt enable on interface 1</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="ecc_int0_en">
                    <gui_name language="en">ecc_int0_en</gui_name>
                    <description language="en">Status of the ECC interrupt enable on interface 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="raw_int_status1">
                    <gui_name language="en">raw_int_status1</gui_name>
                    <description language="en">Current raw interrupt status for interface 1</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="raw_int_status0">
                    <gui_name language="en">raw_int_status0</gui_name>
                    <description language="en">Current raw interrupt status for interface 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="int_status1">
                    <gui_name language="en">int_status1</gui_name>
                    <description language="en">Current interrupt status for interface 1</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="int_status0">
                    <gui_name language="en">int_status0</gui_name>
                    <description language="en">Current interrupt status for interface 0</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="int_en1">
                    <gui_name language="en">int_en1</gui_name>
                    <description language="en">Status of memory interface 1 interrupt enable</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="int_en0">
                    <gui_name language="en">int_en0</gui_name>
                    <description language="en">Status of memory interface 0 interrupt enable</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memc_status_state_ENUM" high_bit="0" low_bit="0" name="state">
                    <gui_name language="en">state</gui_name>
                    <description language="en">Operating state of the SMC:
0 = SMC is in the ready state
1 = SMC is in the low-power state.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_MEMIF_CFG" offset="0xe000e004" size="0x4">
                <gui_name language="en">memif_cfg</gui_name>
                <description language="en">The read-only memif_cfg Register provides information on the configuration of the memory interface. You cannot read this register in the Reset state</description>
                <bitField access="Read Only" enumerationId="memif_cfg_exclusive_monitors_ENUM" high_bit="17" low_bit="16" name="exclusive_monitors">
                    <gui_name language="en">exclusive_monitors</gui_name>
                    <description language="en">Returns the number of exclusive access monitor resources that are implemented in the SMC.
b00 = 0 monitors
b01 = 1 monitor
b10 = 2 monitors
b11 = 4 monitors.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="remap1">
                    <gui_name language="en">remap1</gui_name>
                    <description language="en">Returns the value of the remap_1 input.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memif_cfg_memory_width1_ENUM" high_bit="13" low_bit="12" name="memory_width1">
                    <gui_name language="en">memory_width1</gui_name>
                    <description language="en">Returns the maximum width of the SMC memory data bus for interface 1:
b00 = 8 bits
b01 = 16 bits
b10 = 32 bits
b11 = reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memif_cfg_memory_chips1_ENUM" high_bit="11" low_bit="10" name="memory_chips1">
                    <gui_name language="en">memory_chips1</gui_name>
                    <description language="en">Returns the number of different chip selects that the memory interface 1 supports:
b00 = 1 chip
b01 = 2 chips
b10 = 3 chips
b11 = 4 chips.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memif_cfg_memory_type1_ENUM" high_bit="9" low_bit="8" name="memory_type1">
                    <gui_name language="en">memory_type1</gui_name>
                    <description language="en">Returns the memory interface 1 type: b00 = Configuration does not include this memory interface
b01 = SRAM non-multiplexed
b10 = NAND
b11 = SRAM multiplexed.
If b00, the remaining bit slices for memory interface 1 are always read as 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="remap0">
                    <gui_name language="en">remap0</gui_name>
                    <description language="en">Returns the value of the remap_0 input</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memif_cfg_memory_width0_ENUM" high_bit="5" low_bit="4" name="memory_width0">
                    <gui_name language="en">memory_width0</gui_name>
                    <description language="en">Returns the maximum width of the SMC memory data bus for interface 0:
b00 = 8 bits
b01 = 16 bits
b10 = 32 bits
b11 = reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memif_cfg_memory_chips0_ENUM" high_bit="3" low_bit="2" name="memory_chips0">
                    <gui_name language="en">memory_chips0</gui_name>
                    <description language="en">Returns the number of different chip selects that the memory interface 0 supports:
b00 = 1 chip
b01 = 2 chips
b10 = 3 chips
b11 = 4 chips.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="memif_cfg_memory_type0_ENUM" high_bit="1" low_bit="0" name="memory_type0">
                    <gui_name language="en">memory_type0</gui_name>
                    <description language="en">Returns the memory interface 0 type:
b00 =reserved
b01 = SRAM non-multiplexed
b10 = NAND
b11 = SRAM multiplexed.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SMCC_MEMC_CFG_SET" offset="0xe000e008" size="0x2">
                <gui_name language="en">memc_cfg_set</gui_name>
                <description language="en">The write-only memc_cfg_set Register enables the SMC to be changed to low-power state, and interrupts enabled. You cannot write to this register in the Reset state.</description>
                <bitField access="Write Only" enumerationId="memc_cfg_set_ecc_int_enable1_ENUM" high_bit="6" low_bit="6" name="ecc_int_enable1">
                    <gui_name language="en">ecc_int_enable1</gui_name>
                    <description language="en">0 = No effect
1 = ECC interrupt enable, memory interface 1.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_set_ecc_int_enable0_ENUM" high_bit="5" low_bit="5" name="ecc_int_enable0">
                    <gui_name language="en">ecc_int_enable0</gui_name>
                    <description language="en">0 = No effect
1 = ECC interrupt enable, memory interface 0.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_set_low_power_req_ENUM" high_bit="2" low_bit="2" name="low_power_req">
                    <gui_name language="en">low_power_req</gui_name>
                    <description language="en">0 = No effect
1 = Request the SMC to enter low-power state when it next becomes idle.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_set_int_enable1_ENUM" high_bit="1" low_bit="1" name="int_enable1">
                    <gui_name language="en">int_enable1</gui_name>
                    <description language="en">0 = No effect
1 = Interrupt enable, memory interface 1.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_set_int_enable0_ENUM" high_bit="0" low_bit="0" name="int_enable0">
                    <gui_name language="en">int_enable0</gui_name>
                    <description language="en">0 = No effect
1 = Interrupt enable, memory interface 0.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SMCC_MEMC_CFG_CLR" offset="0xe000e00c" size="0x2">
                <gui_name language="en">memc_cfg_clr</gui_name>
                <description language="en">The write-only memc_cfg_clr Register enables the SMC to be moved out of the low-power state, and the interrupts disabled. You cannot write to this register in the Reset state</description>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_ecc_int_disable1_ENUM" high_bit="6" low_bit="6" name="ecc_int_disable1">
                    <gui_name language="en">ecc_int_disable1</gui_name>
                    <description language="en">0 = No effect
1 = Disable ECC Interrupt on IF1.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_ecc_int_disable0_ENUM" high_bit="5" low_bit="5" name="ecc_int_disable0">
                    <gui_name language="en">ecc_int_disable0</gui_name>
                    <description language="en">0 = No effect
1 = Disable ECC Interrupt on IF0.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_int_clr_1_ENUM" high_bit="4" low_bit="4" name="int_clr_1">
                    <gui_name language="en">int_clr_1</gui_name>
                    <description language="en">0 = No effect
1 = Clear SMC Interrupt 1 as an alternative to an AXI read.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_int_clr_0_ENUM" high_bit="3" low_bit="3" name="int_clr_0">
                    <gui_name language="en">int_clr_0</gui_name>
                    <description language="en">0 = No effect
1 = Clear SMC Interrupt 0 (as an alternative to an AXI read).</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_low_power_exit_ENUM" high_bit="2" low_bit="2" name="low_power_exit">
                    <gui_name language="en">low_power_exit</gui_name>
                    <description language="en">0 = No effect
1 = Request the SMC to exit low-power state.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_int_disable1_ENUM" high_bit="1" low_bit="1" name="int_disable1">
                    <gui_name language="en">int_disable1</gui_name>
                    <description language="en">0 = No effect
1 = Interrupt disable, memory interface 1.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="memc_cfg_clr_int_disable0_ENUM" high_bit="0" low_bit="0" name="int_disable0">
                    <gui_name language="en">int_disable0</gui_name>
                    <description language="en">0 = No effect
1 = Interrupt disable, memory interface 0.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SMCC_DIRECT_CMD" offset="0xe000e010" size="0x4">
                <gui_name language="en">direct_cmd</gui_name>
                <description language="en">The write-only direct_cmd Register passes commands to the external memory, and controls the updating of the chip configuration registers with values held in the set_cycles Register and set_opmode Register. You cannot write to this register in either the Reset or low-power states</description>
                <bitField access="Write Only" high_bit="25" low_bit="23" name="chip_select">
                    <gui_name language="en">chip_select</gui_name>
                    <description language="en">Selects chip configuration register bank to update, and enables chip mode register access depending on cmd_type. The encoding is:
b000-b011 = Chip selects 1-4 on interface 0 (NOR only has 2 CS so only b000/b001 are valid)
b100-b111 = Chip selects 1-4 on interface 1 (NAND only has 1 CS so only b100 is valid)</description>
                </bitField>
                <bitField access="Write Only" enumerationId="direct_cmd_cmd_type_ENUM" high_bit="22" low_bit="21" name="cmd_type">
                    <gui_name language="en">cmd_type</gui_name>
                    <description language="en">Selects the command type:
b00 = UpdateRegs and AXI
b01 = ModeReg
b10 = UpdateRegs
b11 = ModeReg and UpdateRegs.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="direct_cmd_set_cre_ENUM" high_bit="20" low_bit="20" name="set_cre">
                    <gui_name language="en">set_cre</gui_name>
                    <description language="en">Maps to the configuration register enable signal, cre, when a ModeReg command is issued. The encoding is:
0 = cre is LOW
1 = cre is HIGH when ModeReg write occurs.</description>
                </bitField>
                <bitField access="Write Only" high_bit="19" low_bit="0" name="addr">
                    <gui_name language="en">addr</gui_name>
                    <description language="en">When cmd_type = UpdateRegs and AXI then:
[[*]] bits [15:0] are used to match wdata[15:0]
[[*]] bits [19:16] are reserved. Write as zero.
When cmd_type = ModeReg or ModeReg and UpdateRegs, these bits map to the external memory address bits [19:0].
When cmd_type = UpdateRegs, these bits are reserved. Write as zero.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SMCC_SET_CYCLES" offset="0xe000e014" size="0x4">
                <gui_name language="en">set_cycles</gui_name>
                <description language="en">This write-only register contains values that are written to the sram_cycles register or nand_cycles when the SMC receives a write to the Direct Command Register.You cannot write to this register in either the Reset or low-power states.</description>
                <bitField access="Write Only" high_bit="23" low_bit="20" name="Set_t6">
                    <gui_name language="en">Set_t6</gui_name>
                    <description language="en">Contains the value to be written to either the:
[[*]] we_time bit of the sram_cycles Register The permitted values are 0x0 and 0x1.
[[*]] t_rr field of the nand_cycles Register.</description>
                </bitField>
                <bitField access="Write Only" high_bit="19" low_bit="17" name="Set_t5">
                    <gui_name language="en">Set_t5</gui_name>
                    <description language="en">Contains the value to be written to either the:
[[*]] t_tr field of the sram_cycles Register.
[[*]] t_ar field of the nand_cycles Register.</description>
                </bitField>
                <bitField access="Write Only" high_bit="16" low_bit="14" name="Set_t4">
                    <gui_name language="en">Set_t4</gui_name>
                    <description language="en">Contains the value to be written to either the:
[[*]] t_pc field of the sram_cycles Register.
[[*]] t_clr field of the nand_cycles Register.</description>
                </bitField>
                <bitField access="Write Only" high_bit="13" low_bit="11" name="Set_t3">
                    <gui_name language="en">Set_t3</gui_name>
                    <description language="en">Contains the value to be written to the t_wp field in either the:
[[*]] sram_cycles Register
[[*]] nand_cycles Register.</description>
                </bitField>
                <bitField access="Write Only" high_bit="10" low_bit="8" name="Set_t2">
                    <gui_name language="en">Set_t2</gui_name>
                    <description language="en">Contains the value to be written to either the:
[[*]] t_ceoe field of the sram_cycles Register
[[*]] t_rea field of the nand_cycles Register .</description>
                </bitField>
                <bitField access="Write Only" high_bit="7" low_bit="4" name="Set_t1">
                    <gui_name language="en">Set_t1</gui_name>
                    <description language="en">Contains the value to be written to the t_wc field in either the:
[[*]] sram_cycles Register
[[*]] nand_cycles Register.</description>
                </bitField>
                <bitField access="Write Only" high_bit="3" low_bit="0" name="Set_t0">
                    <gui_name language="en">Set_t0</gui_name>
                    <description language="en">Contains the value to be written to the t_rc field in either the:
[[*]] sram_cycles Register
[[*]] nand_cycles Register.</description>
                </bitField>
            </register>
            <register name="SMCC_SET_OPMODE" offset="0xe000e018" size="0x2">
                <gui_name language="en">set_opmode</gui_name>
                <description language="en">This write-only register is the holding register for the opmode&lt;x&gt;_&lt;n&gt; Registers. You cannot write to it in either the Reset or low-power states</description>
                <bitField access="Write Only" enumerationId="set_opmode_set_burst_align_ENUM" high_bit="15" low_bit="13" name="set_burst_align">
                    <gui_name language="en">set_burst_align</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register burst_align field. When you configure the SMC to perform synchronous transfersa, these bits control if memory bursts are split on memory burst boundaries:
b000 = bursts can cross any address boundary
b001 = burst split on memory burst boundary, that is, 32 beats for continuous
b010 = burst split on 64 beat boundary
b011 = burst split on 128 beat boundary
b100 = burst split on 256 beat boundary
b101-b111 = reserved.
For a NAND memory interface these bits are reserved, and written as zero.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="set_opmode_set_bls_ENUM" high_bit="12" low_bit="12" name="set_bls">
                    <gui_name language="en">set_bls</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register byte lane strobe (bls) bit. This bit affects the assertion of the byte-lane strobe outputs.
0 = bls timing equals chip select timing. This is the default setting.
1 = bls timing equals we_n timing. This setting is used for eight memories that have no bls_n inputs. In this case, the bls_n output of the SMC is connected to the we_n memory input.
For a NAND memory interface this bit is reserved, and written as zero.</description>
                </bitField>
                <bitField access="Write Only" high_bit="11" low_bit="11" name="set_adv">
                    <gui_name language="en">set_adv</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register address valid (adv) bit. The memory uses the address advance signal adv_n when set.
For a NAND memory interface this bit is reserved, and written as zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="set_baa">
                    <gui_name language="en">set_baa</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register burst address advance (baa) bit. The memory uses the baa_n signal when set.
For a NAND memory interface this bit is reserved, and written as zero.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="set_opmode_set_wr_bl_ENUM" high_bit="9" low_bit="7" name="set_wr_bl">
                    <gui_name language="en">set_wr_bl</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register wr_bl field.
Encodes the memory burst length:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved, and written as zero.</description>
                </bitField>
                <bitField access="Write Only" high_bit="6" low_bit="6" name="set_wr_sync">
                    <gui_name language="en">set_wr_sync</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register wr_sync bit. The memory writes are synchronous when set.
For a NAND memory interface this bit is reserved, and written as zero</description>
                </bitField>
                <bitField access="Write Only" enumerationId="set_opmode_set_rd_bl_ENUM" high_bit="5" low_bit="3" name="set_rd_bl">
                    <gui_name language="en">set_rd_bl</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register rd_bl field.
Encodes the memory burst length:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved, and written as zero.</description>
                </bitField>
                <bitField access="Write Only" high_bit="2" low_bit="2" name="set_rd_sync">
                    <gui_name language="en">set_rd_sync</gui_name>
                    <description language="en">Contains the value to be written to the specific SRAM chip opmode Register rd_sync bit. Memory in sync mode when set.
For a NAND memory interface this bit is reserved, and written as zero.</description>
                </bitField>
                <bitField access="Write Only" enumerationId="set_opmode_set_mw_ENUM" high_bit="1" low_bit="0" name="set_mw">
                    <gui_name language="en">set_mw</gui_name>
                    <description language="en">Contains the value to be written to the specific chip opmode Register memory width (mw) field.
Encodes the memory data bus width:
b00 = 8 bitsb
b01 = 16 bitsb
b10 = 32 bits
b11 = reserved.
You can program this to the configured width, or half that width.</description>
                </bitField>
            </register>
            <register name="SMCC_REFRESH_PERIOD_0" offset="0xe000e020" size="0x2">
                <gui_name language="en">refresh_period_0</gui_name>
                <description language="en">The read/write refresh_period_0 Register enables the SMC to insert idle cycles during consecutive bursts, that enables the PSRAM devices on memory interface 0, to initiate a refresh cycle. You cannot access this register in either the Reset or low-power states.
Note
You can only access this register when you are using an SRAM memory interface.</description>
                <bitField access="Read Write" enumerationId="refresh_period_0_period_ENUM" high_bit="3" low_bit="0" name="period">
                    <gui_name language="en">period</gui_name>
                    <description language="en">Sets the number of consecutive memory burstsa that are permitted, prior to the SMC deasserting chip select to enable the PSRAM to initiate a refresh cycle. The options are:
b0000 = disables the insertion of idle cycles between consecutive bursts
b0001 = an idle cycle occurs after each burst
b0010 = an idle cycle occurs after 2 consecutive bursts
b0011 = an idle cycle occurs after 3 consecutive bursts
b0100 = an idle cycle occurs after 4 consecutive bursts
.
.
.
b1111 = an idle cycle occurs after 15 consecutive bursts.</description>
                </bitField>
            </register>
            <register name="SMCC_REFRESH_PERIOD_1" offset="0xe000e024" size="0x2">
                <gui_name language="en">refresh_period_1</gui_name>
                <description language="en">The read/write refresh_period_1 Register enables the SMC to insert idle cycles during consecutive bursts, that enables the PSRAM devices on memory interface 1, to initiate a refresh cycle</description>
                <bitField access="Read Write" enumerationId="refresh_period_1_period_ENUM" high_bit="3" low_bit="0" name="period">
                    <gui_name language="en">period</gui_name>
                    <description language="en">Sets the number of consecutive memory burstsa that are permitted, prior to the SMC deasserting chip select to enable the PSRAM to initiate a refresh cycle. The options are:
b0000 = disables the insertion of idle cycles between consecutive bursts
b0001 = an idle cycle occurs after each burst
b0010 = an idle cycle occurs after 2 consecutive bursts
b0011 = an idle cycle occurs after 3 consecutive bursts
b0100 = an idle cycle occurs after 4 consecutive bursts
.
.
.
b1111 = an idle cycle occurs after 15 consecutive bursts.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_SRAM_CYCLES0_0" offset="0xe000e100" size="0x4">
                <gui_name language="en">sram_cycles0_0</gui_name>
                <description language="en">There is an instance of this register for each SRAM chip supported. You cannot read the read-only sram_cycles Register in the Reset state</description>
                <bitField access="Read Only" enumerationId="sram_cycles0_0_we_time_ENUM" high_bit="20" low_bit="20" name="we_time">
                    <gui_name language="en">we_time</gui_name>
                    <description language="en">For asynchronous multiplexed transfers this bit controls when the SMC asserts we_n:
0 = SMC asserts we_n two mclk cycles after asserting cs_n.
1 = SMC asserts we_n and cs_n together.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="17" name="t_tr">
                    <gui_name language="en">t_tr</gui_name>
                    <description language="en">Turnaround time for SRAM chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="14" name="t_pc">
                    <gui_name language="en">t_pc</gui_name>
                    <description language="en">Page cycle time for SRAM chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="t_wp">
                    <gui_name language="en">t_wp</gui_name>
                    <description language="en">we_n assertion delay.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="t_ceoe">
                    <gui_name language="en">t_ceoe</gui_name>
                    <description language="en">oe_n assertion delay for SRAM chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="t_wc">
                    <gui_name language="en">t_wc</gui_name>
                    <description language="en">Write cycle time.Minimum permitted value = 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="t_rc">
                    <gui_name language="en">t_rc</gui_name>
                    <description language="en">Read cycle time.Minimum permitted value = 2.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_OPMODE0_0" offset="0xe000e104" size="0x4">
                <gui_name language="en">opmode0_0</gui_name>
                <description language="en">There is an instance of the opmode Register for each chip supported. This register is read-only and you cannot read it in the Reset state</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="address_match">
                    <gui_name language="en">address_match</gui_name>
                    <description language="en">Returns the value of this tie-off. This is the comparison value for address bits [31:24] to determine the chip that is selected.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="address_mask">
                    <gui_name language="en">address_mask</gui_name>
                    <description language="en">Returns the value of this tie-off. This is the mask for address bits[31:24] to determine the chip that must be selected. A logic 1 indicates the bit is used for comparison.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_0_burst_align_ENUM" high_bit="15" low_bit="13" name="burst_align">
                    <gui_name language="en">burst_align</gui_name>
                    <description language="en">When you configure the SMC to perform synchronous transfersa, these bits control if memory bursts are split on memory burst boundaries:
b000 = bursts can cross any address boundary
b001 = burst split on memory burst boundary, that is, 32 beats for continuous
b010 = burst split on 64 beat boundary
b011 = burst split on 128 beat boundary
b100 = burst split on 256 beat boundary
b101-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_0_bls_ENUM" high_bit="12" low_bit="12" name="bls">
                    <gui_name language="en">bls</gui_name>
                    <description language="en">This bit affects the assertion of the byte-lane strobe outputs:
0 = bls timing equals chip select timing. This is the default setting.
1 = bls timing equals we_n timing. This setting is used for 8-bit memories that have no bls inputs. In this case, the bls_n output of the SMC is connected to the we_n memory input.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="adv">
                    <gui_name language="en">adv</gui_name>
                    <description language="en">The memory uses the address advance signal, adv_n, when set.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="baa">
                    <gui_name language="en">baa</gui_name>
                    <description language="en">The memory uses the burst address advance signal, baa_n, when set.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_0_wr_bl_ENUM" high_bit="9" low_bit="7" name="wr_bl">
                    <gui_name language="en">wr_bl</gui_name>
                    <description language="en">Selects the memory burst length for writes:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="wr_sync">
                    <gui_name language="en">wr_sync</gui_name>
                    <description language="en">When set, the memory operates in write sync mode.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_0_rd_bl_ENUM" high_bit="5" low_bit="3" name="rd_bl">
                    <gui_name language="en">rd_bl</gui_name>
                    <description language="en">Selects the memory burst length for reads:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rd_sync">
                    <gui_name language="en">rd_sync</gui_name>
                    <description language="en">When set, the memory operates in read sync mode.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_0_mw_ENUM" high_bit="1" low_bit="0" name="mw">
                    <gui_name language="en">mw</gui_name>
                    <description language="en">Selects the SMC memory data bus width:
b00 = 8 bits
b01 = 16 bits
b10 = 32 bits
b11 = reserved.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_SRAM_CYCLES0_1" offset="0xe000e120" size="0x4">
                <gui_name language="en">sram_cycles0_1</gui_name>
                <description language="en">There is an instance of this register for each SRAM chip supported. You cannot read the read-only sram_cycles Register in the Reset state</description>
                <bitField access="Read Only" enumerationId="sram_cycles0_1_we_time_ENUM" high_bit="20" low_bit="20" name="we_time">
                    <gui_name language="en">we_time</gui_name>
                    <description language="en">For asynchronous multiplexed transfers this bit controls when the SMC asserts we_n:
0 = SMC asserts we_n two mclk cycles after asserting cs_n.
1 = SMC asserts we_n and cs_n together.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="17" name="t_tr">
                    <gui_name language="en">t_tr</gui_name>
                    <description language="en">Turnaround time for SRAM chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="14" name="t_pc">
                    <gui_name language="en">t_pc</gui_name>
                    <description language="en">Page cycle time for SRAM chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="t_wp">
                    <gui_name language="en">t_wp</gui_name>
                    <description language="en">we_n assertion delay.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="t_ceoe">
                    <gui_name language="en">t_ceoe</gui_name>
                    <description language="en">oe_n assertion delay for SRAM chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="t_wc">
                    <gui_name language="en">t_wc</gui_name>
                    <description language="en">Write cycle time.Minimum permitted value = 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="t_rc">
                    <gui_name language="en">t_rc</gui_name>
                    <description language="en">Read cycle time.Minimum permitted value = 2.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_OPMODE0_1" offset="0xe000e124" size="0x4">
                <gui_name language="en">opmode0_1</gui_name>
                <description language="en">There is an instance of the opmode Register for each chip supported. This register is read-only and you cannot read it in the Reset state.</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="address_match">
                    <gui_name language="en">address_match</gui_name>
                    <description language="en">Returns the value of this tie-off. This is the comparison value for address bits [31:24] to determine the chip that is selected.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="address_mask">
                    <gui_name language="en">address_mask</gui_name>
                    <description language="en">Returns the value of this tie-off. This is the mask for address bits[31:24] to determine the chip that must be selected. A logic 1 indicates the bit is used for comparison.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_1_burst_align_ENUM" high_bit="15" low_bit="13" name="burst_align">
                    <gui_name language="en">burst_align</gui_name>
                    <description language="en">When you configure the SMC to perform synchronous transfersa, these bits control if memory bursts are split on memory burst boundaries:
b000 = bursts can cross any address boundary
b001 = burst split on memory burst boundary, that is, 32 beats for continuous
b010 = burst split on 64 beat boundary
b011 = burst split on 128 beat boundary
b100 = burst split on 256 beat boundary
b101-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_1_bls_ENUM" high_bit="12" low_bit="12" name="bls">
                    <gui_name language="en">bls</gui_name>
                    <description language="en">This bit affects the assertion of the byte-lane strobe outputs:
0 = bls timing equals chip select timing. This is the default setting.
1 = bls timing equals we_n timing. This setting is used for 8-bit memories that have no bls inputs. In this case, the bls_n output of the SMC is connected to the we_n memory input.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="adv">
                    <gui_name language="en">adv</gui_name>
                    <description language="en">The memory uses the address advance signal, adv_n, when set.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="baa">
                    <gui_name language="en">baa</gui_name>
                    <description language="en">The memory uses the burst address advance signal, baa_n, when set.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_1_wr_bl_ENUM" high_bit="9" low_bit="7" name="wr_bl">
                    <gui_name language="en">wr_bl</gui_name>
                    <description language="en">Selects the memory burst length for writes:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="wr_sync">
                    <gui_name language="en">wr_sync</gui_name>
                    <description language="en">When set, the memory operates in write sync mode.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_1_rd_bl_ENUM" high_bit="5" low_bit="3" name="rd_bl">
                    <gui_name language="en">rd_bl</gui_name>
                    <description language="en">Selects the memory burst length for reads:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rd_sync">
                    <gui_name language="en">rd_sync</gui_name>
                    <description language="en">When set, the memory operates in read sync mode.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode0_1_mw_ENUM" high_bit="1" low_bit="0" name="mw">
                    <gui_name language="en">mw</gui_name>
                    <description language="en">Selects the SMC memory data bus width:
b00 = 8 bits
b01 = 16 bits
b10 = 32 bits
b11 = reserved.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_NAND_CYCLES1_0" offset="0xe000e180" size="0x4">
                <gui_name language="en">nand_cycles1_0</gui_name>
                <description language="en">There is an instance of this register for each NAND chip supported. You cannot read the read-only nand_cycles Register in the Reset state</description>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="t_rr">
                    <gui_name language="en">t_rr</gui_name>
                    <description language="en">busy to re_n for NAND chip configurations.Minimum permitted value = 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="17" name="t_ar">
                    <gui_name language="en">t_ar</gui_name>
                    <description language="en">ID read time for NAND chip configurations.Minimum permitted value = 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="14" name="t_clr">
                    <gui_name language="en">t_clr</gui_name>
                    <description language="en">Status read time for NAND chip configurations.Minimum permitted value = 0.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="11" name="t_wp">
                    <gui_name language="en">t_wp</gui_name>
                    <description language="en">we_n de-assertion delay.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="t_rea">
                    <gui_name language="en">t_rea</gui_name>
                    <description language="en">re_n assertion delay for NAND chip configurations.Minimum permitted value = 1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="t_wc">
                    <gui_name language="en">t_wc</gui_name>
                    <description language="en">Write cycle time.Minimum permitted value = 2.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="t_rc">
                    <gui_name language="en">t_rc</gui_name>
                    <description language="en">Read cycle time.Minimum permitted value = 2.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_OPMODE1_0" offset="0xe000e184" size="0x4">
                <gui_name language="en">opmode1_0</gui_name>
                <description language="en">There is an instance of the opmode Register for each chip supported. This register is read-only and you cannot read it in the Reset state</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="address_match">
                    <gui_name language="en">address_match</gui_name>
                    <description language="en">Returns the value of this tie-off. This is the comparison value for address bits [31:24] to determine the chip that is selected.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="address_mask">
                    <gui_name language="en">address_mask</gui_name>
                    <description language="en">Returns the value of this tie-off. This is the mask for address bits[31:24] to determine the chip that must be selected. A logic 1 indicates the bit is used for comparison.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode1_0_burst_align_ENUM" high_bit="15" low_bit="13" name="burst_align">
                    <gui_name language="en">burst_align</gui_name>
                    <description language="en">When you configure the SMC to perform synchronous transfersa, these bits control if memory bursts are split on memory burst boundaries:
b000 = bursts can cross any address boundary
b001 = burst split on memory burst boundary, that is, 32 beats for continuous
b010 = burst split on 64 beat boundary
b011 = burst split on 128 beat boundary
b100 = burst split on 256 beat boundary
b101-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode1_0_bls_ENUM" high_bit="12" low_bit="12" name="bls">
                    <gui_name language="en">bls</gui_name>
                    <description language="en">This bit affects the assertion of the byte-lane strobe outputs:
0 = bls timing equals chip select timing. This is the default setting.
1 = bls timing equals we_n timing. This setting is used for 8-bit memories that have no bls inputs. In this case, the bls_n output of the SMC is connected to the we_n memory input.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="adv">
                    <gui_name language="en">adv</gui_name>
                    <description language="en">The memory uses the address advance signal, adv_n, when set.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="baa">
                    <gui_name language="en">baa</gui_name>
                    <description language="en">The memory uses the burst address advance signal, baa_n, when set.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode1_0_wr_bl_ENUM" high_bit="9" low_bit="7" name="wr_bl">
                    <gui_name language="en">wr_bl</gui_name>
                    <description language="en">Selects the memory burst length for writes:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="6" name="wr_sync">
                    <gui_name language="en">wr_sync</gui_name>
                    <description language="en">When set, the memory operates in write sync mode.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode1_0_rd_bl_ENUM" high_bit="5" low_bit="3" name="rd_bl">
                    <gui_name language="en">rd_bl</gui_name>
                    <description language="en">Selects the memory burst length for reads:
b000 = 1 beat
b001 = 4 beats
b010 = 8 beats
b011 = 16 beats
b100 = 32 beats
b101 = continuous
b110-b111 = reserved.
For a NAND memory interface these bits are reserved.</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="rd_sync">
                    <gui_name language="en">rd_sync</gui_name>
                    <description language="en">When set, the memory operates in read sync mode.
For a NAND memory interface this bit is reserved.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="opmode1_0_mw_ENUM" high_bit="1" low_bit="0" name="mw">
                    <gui_name language="en">mw</gui_name>
                    <description language="en">Selects the SMC memory data bus width:
b00 = 8 bits
b01 = 16 bits
b10 = 32 bits
b11 = reserved.</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_USER_STATUS" offset="0xe000e200" size="0x2">
                <gui_name language="en">user_status</gui_name>
                <description language="en">The user_status Register is read-only and returns the value of the user_status[7:0] signals. You can read this register in all operating states</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="user_status">
                    <gui_name language="en">user_status</gui_name>
                    <description language="en">This value returns the state of the user_status[7:0] inputs</description>
                </bitField>
            </register>
            <register access="Write Only" name="SMCC_USER_CONFIG" offset="0xe000e204" size="0x2">
                <gui_name language="en">user_config</gui_name>
                <description language="en">The user_config Register is write-only and controls the status of the user_config[7:0] signals. You can write to this register in all operating states</description>
                <bitField access="Write Only" high_bit="7" low_bit="0" name="user_config">
                    <gui_name language="en">user_config</gui_name>
                    <description language="en">This value sets the state of the user_config[7:0] outputs</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_STATUS_0" offset="0xe000e300" size="0x4">
                <gui_name language="en">ecc_status_0</gui_name>
                <description language="en">The ecc_status Register is read-only and contains status information for the ECC. Although this is a read-only register, the bottom five bits can be written to clear the corresponding interrupts.To clear the interrupt, you must write a 1 to the appropriate bit.</description>
                <bitField access="Read Only" enumerationId="ecc_status_0_ecc_read_ENUM" high_bit="29" low_bit="25" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Read flags for ECC blocks. Indicates whether the stored ECC value for each block has been read from memory
0 = not read
1 = read.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_0_ecc_can_correct_ENUM" high_bit="24" low_bit="20" name="ecc_can_correct">
                    <gui_name language="en">ecc_can_correct</gui_name>
                    <description language="en">Correctable flag for each ECC block. Indicates if the detected error is correctable.
0 = not correctable
1 = correctable.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="15" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Pass/fail flag for each ECC block</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="10" name="ecc_value_valid">
                    <gui_name language="en">ecc_value_valid</gui_name>
                    <description language="en">Valid flag for each ECC block.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_0_ecc_read_not_write_ENUM" high_bit="9" low_bit="9" name="ecc_read_not_write">
                    <gui_name language="en">ecc_read_not_write</gui_name>
                    <description language="en">0 = write
1 = read.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_0_ecc_last_status_ENUM" high_bit="8" low_bit="7" name="ecc_last_status">
                    <gui_name language="en">ecc_last_status</gui_name>
                    <description language="en">b00 = Completed successfully
b01 = Unaligned Address, or out-of-range
b10 = Data stop after incomplete block
b11 = Data stopped but values not read/written because of ecc_jump value.
Note
The ecc_last_status bit is only updated at the completion of an ECC calculation.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_0_ecc_status_ENUM" high_bit="6" low_bit="6" name="ecc_status">
                    <gui_name language="en">ecc_status</gui_name>
                    <description language="en">Describes the status of the ECC block
0 = idle
1 = busy.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="0" name="raw_int_status">
                    <gui_name language="en">raw_int_status</gui_name>
                    <description language="en">The interrupts are:
[5] Abort.
[4] Extra block (if used).
[3] Block 3.
[2] Block 2.
[1] Block 1.
[0] Block 0.
To clear the interrupt, you must write a 1 to the appropriate bit</description>
                </bitField>
            </register>
            <register name="SMCC_ECC_MEMCFG_0" offset="0xe000e304" size="0x2">
                <gui_name language="en">ecc_memcfg_0</gui_name>
                <description language="en">The ecc_memcfg Register is read-write and contains information about the structure of the memory. Note
You must not write to this register while the ECC block is busy. You can read the current ECC block status from the ECC Status Register</description>
                <bitField access="Read Write" enumerationId="ecc_memcfg_0_ecc_extra_block_size_ENUM" high_bit="12" low_bit="11" name="ecc_extra_block_size">
                    <gui_name language="en">ecc_extra_block_size</gui_name>
                    <description language="en">The size of the extra block in memory after the last 512 block:
b00 = 4 bytes
b01 = 8 bytes
b10 = 16 bytes
b11 = 32 bytes.
Note
These bits are only present if you configure the SMC to use the ECC Extra Block Enable option</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ecc_extra_block">
                    <gui_name language="en">ecc_extra_block</gui_name>
                    <description language="en">If configured, this enables a small block for extra information after the last 512 bytes block in the page.
Note
These bits are only present if the ECC Extra Block Enable option is configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="ecc_int_abort">
                    <gui_name language="en">ecc_int_abort</gui_name>
                    <description language="en">Interrupt on ECC abort</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="ecc_int_pass">
                    <gui_name language="en">ecc_int_pass</gui_name>
                    <description language="en">Interrupt when a correct ECC value is read from memory.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_0_ecc_ignore_add_eight_ENUM" high_bit="7" low_bit="7" name="ecc_ignore_add_eight">
                    <gui_name language="en">ecc_ignore_add_eight</gui_name>
                    <description language="en">This bit is used to indicate if A8 is output with the address, required to find the aligned start of blocks:
0 = A8 is output
1 = A8 is not output.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_0_ecc_jump_ENUM" high_bit="6" low_bit="5" name="ecc_jump">
                    <gui_name language="en">ecc_jump</gui_name>
                    <description language="en">Indicates that the memory supports column change address commands:
b00 = no jumping, reads and writes only occur at end of page
b01 = jump using column change commands
b10 = jump using full command
b11 = reserved.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_0_ecc_read_end_ENUM" high_bit="4" low_bit="4" name="ecc_read_end">
                    <gui_name language="en">ecc_read_end</gui_name>
                    <description language="en">Indicates when ECC values are read from memory:
0 = the ECC value for a block must be read immediately after the block. Data access must stop on a 512 byte boundary.
1 = ECC values for all blocks are read at the end of the page.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_0_ecc_mode_ENUM" high_bit="3" low_bit="2" name="ecc_mode">
                    <gui_name language="en">ecc_mode</gui_name>
                    <description language="en">This specifies the mode of the ECC block:
b00 = bypassed.
b01 = ECC values are calculated and made available on the APB interface. But they are not read to or written from memory.
b10 = ECC values and calculated and read/written to memory. For a read, the ECC value is checked and the result of the check is made available on the APB interface.
b11 = reserved.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_0_page_size_ENUM" high_bit="1" low_bit="0" name="page_size">
                    <gui_name language="en">page_size</gui_name>
                    <description language="en">The number of 512 byte blocks in a page:
b00 = No 512 byte blocks. Reserved if an ecc_extra_block is not configured and enabled.
b01 = One 512 byte block.
b10 = Two 512 byte blocks.
b11 = Four 512 byte blocks.</description>
                </bitField>
            </register>
            <register name="SMCC_ECC_MEMCOMMAND1_0" offset="0xe000e308" size="0x4">
                <gui_name language="en">ecc_memcommand1_0</gui_name>
                <description language="en">The ecc_memcommand1 Register is read-write and contains the commands that the ECC block uses to detect the start of an ECC operation</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="nand_rd_cmd_end_valid">
                    <gui_name language="en">nand_rd_cmd_end_valid</gui_name>
                    <description language="en">Use end command</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="nand_rd_cmd_end">
                    <gui_name language="en">nand_rd_cmd_end</gui_name>
                    <description language="en">The NAND command used to initiate a write (0x30)</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="nand_rd_cmd">
                    <gui_name language="en">nand_rd_cmd</gui_name>
                    <description language="en">The NAND command used to initiate a read (0x00)</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="nand_wr_cmd">
                    <gui_name language="en">nand_wr_cmd</gui_name>
                    <description language="en">The NAND command used to initiate a write (0x80)</description>
                </bitField>
            </register>
            <register name="SMCC_ECC_MEMCOMMAND2_0" offset="0xe000e30c" size="0x4">
                <gui_name language="en">ecc_memcommand2_0</gui_name>
                <description language="en">The ecc_memcommand2 Register is read-write and contains the commands that the ECC block uses to access different parts of a NAND page. The reset value is suitable for ONFI 1.0 compliant devices</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="nand_rd_col_change_end_valid">
                    <gui_name language="en">nand_rd_col_change_end_valid</gui_name>
                    <description language="en">Use end command</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="nand_rd_col_change_end">
                    <gui_name language="en">nand_rd_col_change_end</gui_name>
                    <description language="en">The NAND command used to initiate a write</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="nand_rd_col_change">
                    <gui_name language="en">nand_rd_col_change</gui_name>
                    <description language="en">The NAND command used to initiate a read or Spare bits pointer command</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="nand_wr_col_change">
                    <gui_name language="en">nand_wr_col_change</gui_name>
                    <description language="en">The NAND command used to initiate a write</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_ADDR0_0" offset="0xe000e310" size="0x4">
                <gui_name language="en">ecc_addr0_0</gui_name>
                <description language="en">The ecc_addr0 Register is read-only and contains the lower 32 bits of the ECC address</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="ecc_addr">
                    <gui_name language="en">ecc_addr</gui_name>
                    <description language="en">Address bits 31 to 0</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_ADDR1_0" offset="0xe000e314" size="0x4">
                <gui_name language="en">ecc_addr1_0</gui_name>
                <description language="en">The ecc_addr1 Register is read-only and contains the upper 24 bits of the ECC address</description>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_addr">
                    <gui_name language="en">ecc_addr</gui_name>
                    <description language="en">Address bits 55 to 32</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE0_0" offset="0xe000e318" size="0x4">
                <gui_name language="en">ecc_value0_0</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE1_0" offset="0xe000e31c" size="0x4">
                <gui_name language="en">ecc_value1_0</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE2_0" offset="0xe000e320" size="0x4">
                <gui_name language="en">ecc_value2_0</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE3_0" offset="0xe000e324" size="0x4">
                <gui_name language="en">ecc_value3_0</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_STATUS_1" offset="0xe000e400" size="0x4">
                <gui_name language="en">ecc_status_1</gui_name>
                <description language="en">The ecc_status Register is read-only and contains status information for the ECC. Although this is a read-only register, the bottom five bits can be written to clear the corresponding interrupts.</description>
                <bitField access="Read Only" enumerationId="ecc_status_1_ecc_read_ENUM" high_bit="29" low_bit="25" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Read flags for ECC blocks. Indicates whether the stored ECC value for each block has been read from memory
0 = not read
1 = read.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_1_ecc_can_correct_ENUM" high_bit="24" low_bit="20" name="ecc_can_correct">
                    <gui_name language="en">ecc_can_correct</gui_name>
                    <description language="en">Correctable flag for each ECC block. Indicates if the detected error is correctable.
0 = not correctable
1 = correctable.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="15" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Pass/fail flag for each ECC block</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="10" name="ecc_value_valid">
                    <gui_name language="en">ecc_value_valid</gui_name>
                    <description language="en">Valid flag for each ECC block.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_1_ecc_read_not_write_ENUM" high_bit="9" low_bit="9" name="ecc_read_not_write">
                    <gui_name language="en">ecc_read_not_write</gui_name>
                    <description language="en">0 = write
1 = read.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_1_ecc_last_status_ENUM" high_bit="8" low_bit="7" name="ecc_last_status">
                    <gui_name language="en">ecc_last_status</gui_name>
                    <description language="en">b00 = Completed successfully
b01 = Unaligned Address, or out-of-range
b10 = Data stop after incomplete block
b11 = Data stopped but values not read/written because of ecc_jump value.
Note
The ecc_last_status bit is only updated at the completion of an ECC calculation.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ecc_status_1_ecc_status_ENUM" high_bit="6" low_bit="6" name="ecc_status">
                    <gui_name language="en">ecc_status</gui_name>
                    <description language="en">Describes the status of the ECC block
0 = idle
1 = busy.</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="0" name="raw_int_status">
                    <gui_name language="en">raw_int_status</gui_name>
                    <description language="en">The interrupts are:
[5] Abort.
[4] Extra block (if used).
[3] Block 3.
[2] Block 2.
[1] Block 1.
[0] Block 0.
To clear the interrupt, you must write a 1 to the appropriate bit</description>
                </bitField>
            </register>
            <register name="SMCC_ECC_MEMCFG_1" offset="0xe000e404" size="0x2">
                <gui_name language="en">ecc_memcfg_1</gui_name>
                <description language="en">The ecc_memcfg Register is read-write and contains information about the structure of the memory. Note
You must not write to this register while the ECC block is busy. You can read the current ECC block status from the ECC Status Register</description>
                <bitField access="Read Write" enumerationId="ecc_memcfg_1_ecc_extra_block_size_ENUM" high_bit="12" low_bit="11" name="ecc_extra_block_size">
                    <gui_name language="en">ecc_extra_block_size</gui_name>
                    <description language="en">The size of the extra block in memory after the last 512 block:
b00 = 4 bytes
b01 = 8 bytes
b10 = 16 bytes
b11 = 32 bytes.
Note
These bits are only present if you configure the SMC to use the ECC Extra Block Enable option</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ecc_extra_block">
                    <gui_name language="en">ecc_extra_block</gui_name>
                    <description language="en">If configured, this enables a small block for extra information after the last 512 bytes block in the page.
Note
These bits are only present if the ECC Extra Block Enable option is configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="9" name="ecc_int_abort">
                    <gui_name language="en">ecc_int_abort</gui_name>
                    <description language="en">Interrupt on ECC abort</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="ecc_int_pass">
                    <gui_name language="en">ecc_int_pass</gui_name>
                    <description language="en">Interrupt when a correct ECC value is read from memory.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_1_ecc_ignore_add_eight_ENUM" high_bit="7" low_bit="7" name="ecc_ignore_add_eight">
                    <gui_name language="en">ecc_ignore_add_eight</gui_name>
                    <description language="en">This bit is used to indicate if A8 is output with the address, required to find the aligned start of blocks:
0 = A8 is output
1 = A8 is not output.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_1_ecc_jump_ENUM" high_bit="6" low_bit="5" name="ecc_jump">
                    <gui_name language="en">ecc_jump</gui_name>
                    <description language="en">Indicates that the memory supports column change address commands:
b00 = no jumping, reads and writes only occur at end of page
b01 = jump using column change commands
b10 = jump using full command
b11 = reserved.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_1_ecc_read_end_ENUM" high_bit="4" low_bit="4" name="ecc_read_end">
                    <gui_name language="en">ecc_read_end</gui_name>
                    <description language="en">Indicates when ECC values are read from memory:
0 = the ECC value for a block must be read immediately after the block. Data access must stop on a 512 byte boundary.
1 = ECC values for all blocks are read at the end of the page.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_1_ecc_mode_ENUM" high_bit="3" low_bit="2" name="ecc_mode">
                    <gui_name language="en">ecc_mode</gui_name>
                    <description language="en">This specifies the mode of the ECC block:
b00 = bypassed.
b01 = ECC values are calculated and made available on the APB interface. But they are not read to or written from memory.
b10 = ECC values and calculated and read/written to memory. For a read, the ECC value is checked and the result of the check is made available on the APB interface.
b11 = reserved.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ecc_memcfg_1_page_size_ENUM" high_bit="1" low_bit="0" name="page_size">
                    <gui_name language="en">page_size</gui_name>
                    <description language="en">The number of 512 byte blocks in a page:
b00 = No 512 byte blocks. Reserved if an ecc_extra_block is not configured and enabled.
b01 = One 512 byte block.
b10 = Two 512 byte blocks.
b11 = Four 512 byte blocks.</description>
                </bitField>
            </register>
            <register name="SMCC_ECC_MEMCOMMAND1_1" offset="0xe000e408" size="0x4">
                <gui_name language="en">ecc_memcommand1_1</gui_name>
                <description language="en">The ecc_memcommand1 Register is read-write and contains the commands that the ECC block uses to detect the start of an ECC operation</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="nand_rd_cmd_end_valid">
                    <gui_name language="en">nand_rd_cmd_end_valid</gui_name>
                    <description language="en">Use end command</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="nand_rd_cmd_end">
                    <gui_name language="en">nand_rd_cmd_end</gui_name>
                    <description language="en">The NAND command used to initiate a write (0x30)</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="nand_rd_cmd">
                    <gui_name language="en">nand_rd_cmd</gui_name>
                    <description language="en">The NAND command used to initiate a read (0x00)</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="nand_wr_cmd">
                    <gui_name language="en">nand_wr_cmd</gui_name>
                    <description language="en">The NAND command used to initiate a write (0x80)</description>
                </bitField>
            </register>
            <register name="SMCC_ECC_MEMCOMMAND2_1" offset="0xe000e40c" size="0x4">
                <gui_name language="en">ecc_memcommand2_1</gui_name>
                <description language="en">The ecc_memcommand2 Register is read-write and contains the commands that the ECC block uses to access different parts of a NAND page. The reset value is suitable for ONFI 1.0 compliant devices</description>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="nand_rd_col_change_end_valid">
                    <gui_name language="en">nand_rd_col_change_end_valid</gui_name>
                    <description language="en">Use end command</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="nand_rd_col_change_end">
                    <gui_name language="en">nand_rd_col_change_end</gui_name>
                    <description language="en">The NAND command used to initiate a write</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="nand_rd_col_change">
                    <gui_name language="en">nand_rd_col_change</gui_name>
                    <description language="en">The NAND command used to initiate a read or Spare bits pointer command</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="nand_wr_col_change">
                    <gui_name language="en">nand_wr_col_change</gui_name>
                    <description language="en">The NAND command used to initiate a write</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_ADDR0_1" offset="0xe000e410" size="0x4">
                <gui_name language="en">ecc_addr0_1</gui_name>
                <description language="en">The ecc_addr0 Register is read-only and contains the lower 32 bits of the ECC address</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="ecc_addr">
                    <gui_name language="en">ecc_addr</gui_name>
                    <description language="en">Address bits 31 to 0</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_ADDR1_1" offset="0xe000e414" size="0x4">
                <gui_name language="en">ecc_addr1_1</gui_name>
                <description language="en">The ecc_addr1 Register is read-only and contains the upper 24 bits of the ECC address</description>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_addr">
                    <gui_name language="en">ecc_addr</gui_name>
                    <description language="en">Address bits 55 to 32</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE0_1" offset="0xe000e418" size="0x4">
                <gui_name language="en">ecc_value0_1</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE1_1" offset="0xe000e41c" size="0x4">
                <gui_name language="en">ecc_value1_1</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE2_1" offset="0xe000e420" size="0x4">
                <gui_name language="en">ecc_value2_1</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_ECC_VALUE3_1" offset="0xe000e424" size="0x4">
                <gui_name language="en">ecc_value3_1</gui_name>
                <description language="en">The five ecc_value Registers are read-only and contain block information for the ECC.
Note
Writing any value to an ecc_value Register clears the ecc_int bit.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="ecc_int">
                    <gui_name language="en">ecc_int</gui_name>
                    <description language="en">Interrupt flag for this value</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="30" name="ecc_valid">
                    <gui_name language="en">ecc_valid</gui_name>
                    <description language="en">Indicates if this value is valid</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="ecc_read">
                    <gui_name language="en">ecc_read</gui_name>
                    <description language="en">Indicates if the ECC value has been read from memory</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="ecc_fail">
                    <gui_name language="en">ecc_fail</gui_name>
                    <description language="en">Indicates if this value has failed</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ecc_correct">
                    <gui_name language="en">ecc_correct</gui_name>
                    <description language="en">Indicates if this block is correctable</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="0" name="ecc_value">
                    <gui_name language="en">ecc_value</gui_name>
                    <description language="en">ECC value of check result for block, depending on ECC configuration</description>
                </bitField>
            </register>
            <register name="SMCC_INTEGRATION_TEST" offset="0xe000ee00" size="0x4">
                <gui_name language="en">integration_test</gui_name>
                <description language="en">The read/write int_cfg Register selects the integration test registers. This register is only for test. You cannot read or write to this register in the Reset state.</description>
                <bitField access="Read Write" high_bit="31" low_bit="1" name="Undefined">
                    <gui_name language="en">Undefined</gui_name>
                    <description language="en">Read undefined. Write as zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="int_test_en">
                    <gui_name language="en">int_test_en</gui_name>
                    <description language="en">When set, outputs are driven from the integration test registers and tied-off, and inputs can change for integration testing</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PERIPH_ID_0" offset="0xe000efe0" size="0x2">
                <gui_name language="en">periph_id_0</gui_name>
                <description language="en">The periph_id_0 Register is hard-coded and the fields in the register determine the reset value</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="part_number_0">
                    <gui_name language="en">part_number_0</gui_name>
                    <description language="en">These bits read back as 0x5x</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PERIPH_ID_1" offset="0xe000efe4" size="0x2">
                <gui_name language="en">periph_id_1</gui_name>
                <description language="en">The periph_id_1 Register is hard-coded and the fields in the register determine the reset value.</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="designer_0">
                    <gui_name language="en">designer_0</gui_name>
                    <description language="en">These bits read back as 0x1</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="part_number_1">
                    <gui_name language="en">part_number_1</gui_name>
                    <description language="en">These bits read back as 0x3</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PERIPH_ID_2" offset="0xe000efe8" size="0x2">
                <gui_name language="en">periph_id_2</gui_name>
                <description language="en">The periph_id_2 Register is hard-coded and the fields in the register determine the reset value.</description>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="revision">
                    <gui_name language="en">revision</gui_name>
                    <description language="en">These bits read back as:
[[*]] 0x1 for r1p0
[[*]] 0x2 for r1p1
[[*]] 0x3 for r1p2
[[*]] 0x4 for r2p0
[[*]] 0x5 for r2p1.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="designer_1">
                    <gui_name language="en">designer_1</gui_name>
                    <description language="en">These bits read back as 0x4</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PERIPH_ID_3" offset="0xe000efec" size="0x2">
                <gui_name language="en">periph_id_3</gui_name>
                <description language="en">The periph_id_3 Register is hard-coded and the fields in the register determine the reset value.</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="integration_cfg">
                    <gui_name language="en">integration_cfg</gui_name>
                    <description language="en">When set, the integration test register map at address offset 0xE00 is present for reading and writing. If clear, the integration test registers have not been implemented</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PCELL_ID_0" offset="0xe000eff0" size="0x2">
                <gui_name language="en">pcell_id_0</gui_name>
                <description language="en">The pcell_id_0 Register is hard-coded and the fields in the register determine the reset value</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_0">
                    <gui_name language="en">pcell_id_0</gui_name>
                    <description language="en">These bits read back as 0x0D</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PCELL_ID_1" offset="0xe000eff4" size="0x2">
                <gui_name language="en">pcell_id_1</gui_name>
                <description language="en">The pcell_id_1 Register is hard-coded and the fields in the register determine the reset value</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_1">
                    <gui_name language="en">pcell_id_1</gui_name>
                    <description language="en">These bits read back as 0xF0</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PCELL_ID_2" offset="0xe000eff8" size="0x2">
                <gui_name language="en">pcell_id_2</gui_name>
                <description language="en">The pcell_id_2 Register is hard-coded and the fields in the register determine the reset value</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_2">
                    <gui_name language="en">pcell_id_2</gui_name>
                    <description language="en">These bits read back as 0x5</description>
                </bitField>
            </register>
            <register access="Read Only" name="SMCC_PCELL_ID_3" offset="0xe000effc" size="0x2">
                <gui_name language="en">pcell_id_3</gui_name>
                <description language="en">The pcell_id_3 Register is hard-coded and the fields in the register determine the reset value</description>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="pcell_id_3">
                    <gui_name language="en">pcell_id_3</gui_name>
                    <description language="en">These bits read back as 0xB1</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SPI0" name="SPI0" offset="0xe0006000">
            <gui_name language="en">spi0</gui_name>
            <description language="en">spi0</description>
            <register name="SPI0_CONFIG_REG0" offset="0xe0006000" size="0x4">
                <gui_name language="en">Config_reg0</gui_name>
                <description language="en">SPI configuration register</description>
                <bitField access="Read Write" enumerationId="Config_reg0_Modefail_gen_en_ENUM" high_bit="17" low_bit="17" name="Modefail_gen_en">
                    <gui_name language="en">Modefail_gen_en</gui_name>
                    <description language="en">ModeFail Generation Enable
1 = enable
0 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Config_reg0_Man_start_com_ENUM" high_bit="16" low_bit="16" name="Man_start_com">
                    <gui_name language="en">Man_start_com</gui_name>
                    <description language="en">Manual Start Command
1 = start transmission of data
0 = don't care</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_Man_start_en_ENUM" high_bit="15" low_bit="15" name="Man_start_en">
                    <gui_name language="en">Man_start_en</gui_name>
                    <description language="en">Manual Start Enable
1 = enables maual start
0 = auto mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_Manual_CS_ENUM" high_bit="14" low_bit="14" name="Manual_CS">
                    <gui_name language="en">Manual_CS</gui_name>
                    <description language="en">Manual CS
1 = manual CS mode
0 = auto mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_CS_ENUM" high_bit="13" low_bit="10" name="CS">
                    <gui_name language="en">CS</gui_name>
                    <description language="en">Peripheral chip select lines
xxx0 - slave 0 selected
xx01 - slave 1 selected
x011 - slave 2 selected
0111 - slave 3 selected
1111 - No slave selected</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_PERI_SEL_ENUM" high_bit="9" low_bit="9" name="PERI_SEL">
                    <gui_name language="en">PERI_SEL</gui_name>
                    <description language="en">Peripheral select decode
1 = allow external 4-to-16 decode
0 = only 1 of 4 selects</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_REF_CLK_ENUM" high_bit="8" low_bit="8" name="REF_CLK">
                    <gui_name language="en">REF_CLK</gui_name>
                    <description language="en">Master reference clock select
1 = use ext_clk
0 = use SPI REFERENCE CLOCK</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_FIFO_WIDTH_ENUM" high_bit="7" low_bit="6" name="FIFO_WIDTH">
                    <gui_name language="en">FIFO_WIDTH</gui_name>
                    <description language="en">FIFO width
00 = 8bits
01 = 16bits
10 = 24bits
11 = 32bits</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_BAUD_RATE_DIV_ENUM" high_bit="5" low_bit="3" name="BAUD_RATE_DIV">
                    <gui_name language="en">BAUD_RATE_DIV</gui_name>
                    <description language="en">Master mode baud rate divisor
000 = not supported
001 = divide by 4
010 = divide by 8
011 = divide by 16
100 = divide by 32
101 = divide by 64
110 = divide by 128
111 = divide by 256</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_CLK_PH_ENUM" high_bit="2" low_bit="2" name="CLK_PH">
                    <gui_name language="en">CLK_PH</gui_name>
                    <description language="en">Clock phase
1 = the SPI clock is inactive outside the word
0 = the SPI clock is active outside the word</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_CLK_POL_ENUM" high_bit="1" low_bit="1" name="CLK_POL">
                    <gui_name language="en">CLK_POL</gui_name>
                    <description language="en">Clock polarity outside SPI word
1 = the SPI clock is quiescent high
0 = the SPI clock is quiescent low</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_MODE_SEL_ENUM" high_bit="0" low_bit="0" name="MODE_SEL">
                    <gui_name language="en">MODE_SEL</gui_name>
                    <description language="en">Mode select
1 = the SPI is in master mode
0 = the SPI is in slave mode</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI0_INTR_STATUS_REG0" offset="0xe0006004" size="0x4">
                <gui_name language="en">Intr_status_reg0</gui_name>
                <description language="en">SPI interrupt status register</description>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
1 = underflow is detected
0 = no underflow has been detected</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
1 = FIFO is full
0 = FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
1 = FIFO has more than or equal to THRESHOLD entries
0 = FIFO has less than RX THRESHOLD entries</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
1 = FIFO is full
0 = FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
1 = FIFO has less than THRESHOLD entries
0 = FIFO has more than or equal toTHRESHOLD entries</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
1 = a mode fault has occurred
0 = no mode fault has been detected</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt
1 = overflow occured
0 = no overflow occurred</description>
                </bitField>
            </register>
            <register name="SPI0_INTRPT_EN_REG0" offset="0xe0006008" size="0x4">
                <gui_name language="en">Intrpt_en_reg0</gui_name>
                <description language="en">Interrupt Enable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
            </register>
            <register name="SPI0_INTRPT_DIS_REG0" offset="0xe000600c" size="0x4">
                <gui_name language="en">Intrpt_dis_reg0</gui_name>
                <description language="en">Interrupt disable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI0_INTRPT_MASK_REG0" offset="0xe0006010" size="0x4">
                <gui_name language="en">Intrpt_mask_reg0</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
            </register>
            <register name="SPI0_EN_REG0" offset="0xe0006014" size="0x4">
                <gui_name language="en">En_reg0</gui_name>
                <description language="en">SPI_Enable Register</description>
                <bitField access="Read Write" enumerationId="En_reg0_SPI_EN_ENUM" high_bit="0" low_bit="0" name="SPI_EN">
                    <gui_name language="en">SPI_EN</gui_name>
                    <description language="en">SPI_Enable
1 = enable the SPI
0 = disable the SPI</description>
                </bitField>
            </register>
            <register name="SPI0_DELAY_REG0" offset="0xe0006018" size="0x4">
                <gui_name language="en">Delay_reg0</gui_name>
                <description language="en">Delay Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="d_nss">
                    <gui_name language="en">d_nss</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles
for the length that the master mode chip select outputs are de-asserted between words when cpha=0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="d_btwn">
                    <gui_name language="en">d_btwn</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles
between one chip select being de-activated and the
activation of another</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="d_after">
                    <gui_name language="en">d_after</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles between last bit of current word and the first bit of the next word.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="d_int">
                    <gui_name language="en">d_int</gui_name>
                    <description language="en">Added delay in SPI REFERENCE CLOCK or ext_clk
cycles between setting n_ss_out low and first bit
transfer.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SPI0_TX_DATA_REG0" offset="0xe000601c" size="0x4">
                <gui_name language="en">Tx_data_reg0</gui_name>
                <description language="en">Transmit Data Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="TX_FIFO_data">
                    <gui_name language="en">TX_FIFO_data</gui_name>
                    <description language="en">Data to TX FIFO</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI0_RX_DATA_REG0" offset="0xe0006020" size="0x4">
                <gui_name language="en">Rx_data_reg0</gui_name>
                <description language="en">Receive Data Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="RX_FIFO_data">
                    <gui_name language="en">RX_FIFO_data</gui_name>
                    <description language="en">Data from TX FIFO</description>
                </bitField>
            </register>
            <register name="SPI0_SLAVE_IDLE_COUNT_REG0" offset="0xe0006024" size="0x4">
                <gui_name language="en">Slave_Idle_count_reg0</gui_name>
                <description language="en">Slave Idle Count Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="Slave_Idle_coun">
                    <gui_name language="en">Slave_Idle_coun</gui_name>
                    <description language="en">SPI in slave mode detects a start only when the
external SPI master serial clock (sclk_in) is stable
(quiescent state) for SPI REFERENCE CLOCK cycles
specified by slave idle count register or when the SPI
is deselected.</description>
                </bitField>
            </register>
            <register name="SPI0_TX_THRES_REG0" offset="0xe0006028" size="0x4">
                <gui_name language="en">TX_thres_reg0</gui_name>
                <description language="en">TX_FIFO Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="DEPTH_of_TX_FIFO">
                    <gui_name language="en">DEPTH_of_TX_FIFO</gui_name>
                    <description language="en">Defines the level at which the TX FIFO not full interrupt is generated</description>
                </bitField>
            </register>
            <register name="SPI0_RX_THRES_REG0" offset="0xe000602c" size="0x4">
                <gui_name language="en">RX_thres_reg0</gui_name>
                <description language="en">RX FIFO Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="DEPTH_of_RX_FIFO">
                    <gui_name language="en">DEPTH_of_RX_FIFO</gui_name>
                    <description language="en">Defines the level at which the RX FIFO not empty interrupt is generated</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI0_MOD_ID_REG0" offset="0xe00060fc" size="0x4">
                <gui_name language="en">Mod_id_reg0</gui_name>
                <description language="en">Module ID register</description>
                <bitField access="Read Only" high_bit="24" low_bit="0" name="module_ID">
                    <gui_name language="en">module_ID</gui_name>
                    <description language="en">Module ID number</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SPI1" name="SPI1" offset="0xe0007000">
            <gui_name language="en">spi1</gui_name>
            <description language="en">spi1</description>
            <register name="SPI1_CONFIG_REG0" offset="0xe0007000" size="0x4">
                <gui_name language="en">Config_reg0</gui_name>
                <description language="en">SPI configuration register</description>
                <bitField access="Read Write" enumerationId="Config_reg0_Modefail_gen_en_ENUM" high_bit="17" low_bit="17" name="Modefail_gen_en">
                    <gui_name language="en">Modefail_gen_en</gui_name>
                    <description language="en">ModeFail Generation Enable
1 = enable
0 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Config_reg0_Man_start_com_ENUM" high_bit="16" low_bit="16" name="Man_start_com">
                    <gui_name language="en">Man_start_com</gui_name>
                    <description language="en">Manual Start Command
1 = start transmission of data
0 = don't care</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_Man_start_en_ENUM" high_bit="15" low_bit="15" name="Man_start_en">
                    <gui_name language="en">Man_start_en</gui_name>
                    <description language="en">Manual Start Enable
1 = enables maual start
0 = auto mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_Manual_CS_ENUM" high_bit="14" low_bit="14" name="Manual_CS">
                    <gui_name language="en">Manual_CS</gui_name>
                    <description language="en">Manual CS
1 = manual CS mode
0 = auto mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_CS_ENUM" high_bit="13" low_bit="10" name="CS">
                    <gui_name language="en">CS</gui_name>
                    <description language="en">Peripheral chip select lines
xxx0 - slave 0 selected
xx01 - slave 1 selected
x011 - slave 2 selected
0111 - slave 3 selected
1111 - No slave selected</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_PERI_SEL_ENUM" high_bit="9" low_bit="9" name="PERI_SEL">
                    <gui_name language="en">PERI_SEL</gui_name>
                    <description language="en">Peripheral select decode
1 = allow external 4-to-16 decode
0 = only 1 of 4 selects</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_REF_CLK_ENUM" high_bit="8" low_bit="8" name="REF_CLK">
                    <gui_name language="en">REF_CLK</gui_name>
                    <description language="en">Master reference clock select
1 = use ext_clk
0 = use SPI REFERENCE CLOCK</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_FIFO_WIDTH_ENUM" high_bit="7" low_bit="6" name="FIFO_WIDTH">
                    <gui_name language="en">FIFO_WIDTH</gui_name>
                    <description language="en">FIFO width
00 = 8bits
01 = 16bits
10 = 24bits
11 = 32bits</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_BAUD_RATE_DIV_ENUM" high_bit="5" low_bit="3" name="BAUD_RATE_DIV">
                    <gui_name language="en">BAUD_RATE_DIV</gui_name>
                    <description language="en">Master mode baud rate divisor
000 = not supported
001 = divide by 4
010 = divide by 8
011 = divide by 16
100 = divide by 32
101 = divide by 64
110 = divide by 128
111 = divide by 256</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_CLK_PH_ENUM" high_bit="2" low_bit="2" name="CLK_PH">
                    <gui_name language="en">CLK_PH</gui_name>
                    <description language="en">Clock phase
1 = the SPI clock is inactive outside the word
0 = the SPI clock is active outside the word</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_CLK_POL_ENUM" high_bit="1" low_bit="1" name="CLK_POL">
                    <gui_name language="en">CLK_POL</gui_name>
                    <description language="en">Clock polarity outside SPI word
1 = the SPI clock is quiescent high
0 = the SPI clock is quiescent low</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Config_reg0_MODE_SEL_ENUM" high_bit="0" low_bit="0" name="MODE_SEL">
                    <gui_name language="en">MODE_SEL</gui_name>
                    <description language="en">Mode select
1 = the SPI is in master mode
0 = the SPI is in slave mode</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI1_INTR_STATUS_REG0" offset="0xe0007004" size="0x4">
                <gui_name language="en">Intr_status_reg0</gui_name>
                <description language="en">SPI interrupt status register</description>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
1 = underflow is detected
0 = no underflow has been detected</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
1 = FIFO is full
0 = FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
1 = FIFO has more than or equal to THRESHOLD entries
0 = FIFO has less than RX THRESHOLD entries</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
1 = FIFO is full
0 = FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
1 = FIFO has less than THRESHOLD entries
0 = FIFO has more than or equal toTHRESHOLD entries</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
1 = a mode fault has occurred
0 = no mode fault has been detected</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intr_status_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt
1 = overflow occured
0 = no overflow occurred</description>
                </bitField>
            </register>
            <register name="SPI1_INTRPT_EN_REG0" offset="0xe0007008" size="0x4">
                <gui_name language="en">Intrpt_en_reg0</gui_name>
                <description language="en">Interrupt Enable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = enable the interrupt
0 = no effect</description>
                </bitField>
            </register>
            <register name="SPI1_INTRPT_DIS_REG0" offset="0xe000700c" size="0x4">
                <gui_name language="en">Intrpt_dis_reg0</gui_name>
                <description language="en">Interrupt disable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = disables the interrupt
0 = no effect</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI1_INTRPT_MASK_REG0" offset="0xe0007010" size="0x4">
                <gui_name language="en">Intrpt_mask_reg0</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_FIFO_underflow_ENUM" high_bit="6" low_bit="6" name="TX_FIFO_underflow">
                    <gui_name language="en">TX_FIFO_underflow</gui_name>
                    <description language="en">TX FIFO underflow
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_FIFO_full_ENUM" high_bit="5" low_bit="5" name="RX_FIFO_full">
                    <gui_name language="en">RX_FIFO_full</gui_name>
                    <description language="en">RX FIFO full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_FIFO_not_empty_ENUM" high_bit="4" low_bit="4" name="RX_FIFO_not_empty">
                    <gui_name language="en">RX_FIFO_not_empty</gui_name>
                    <description language="en">RX FIFO not empty
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_FIFO_full_ENUM" high_bit="3" low_bit="3" name="TX_FIFO_full">
                    <gui_name language="en">TX_FIFO_full</gui_name>
                    <description language="en">TX FIFO full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TX_FIFO_not_full_ENUM" high_bit="2" low_bit="2" name="TX_FIFO_not_full">
                    <gui_name language="en">TX_FIFO_not_full</gui_name>
                    <description language="en">TX FIFO not full
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_MODE_FAIL_ENUM" high_bit="1" low_bit="1" name="MODE_FAIL">
                    <gui_name language="en">MODE_FAIL</gui_name>
                    <description language="en">ModeFail interrupt
enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RX_OVERFLOW_ENUM" high_bit="0" low_bit="0" name="RX_OVERFLOW">
                    <gui_name language="en">RX_OVERFLOW</gui_name>
                    <description language="en">Receive Overflow interrupt enable
1 = interrupt is disabled
0 = interrupt is enabled</description>
                </bitField>
            </register>
            <register name="SPI1_EN_REG0" offset="0xe0007014" size="0x4">
                <gui_name language="en">En_reg0</gui_name>
                <description language="en">SPI_Enable Register</description>
                <bitField access="Read Write" enumerationId="En_reg0_SPI_EN_ENUM" high_bit="0" low_bit="0" name="SPI_EN">
                    <gui_name language="en">SPI_EN</gui_name>
                    <description language="en">SPI_Enable
1 = enable the SPI
0 = disable the SPI</description>
                </bitField>
            </register>
            <register name="SPI1_DELAY_REG0" offset="0xe0007018" size="0x4">
                <gui_name language="en">Delay_reg0</gui_name>
                <description language="en">Delay Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="24" name="d_nss">
                    <gui_name language="en">d_nss</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles
for the length that the master mode chip select outputs are de-asserted between words when cpha=0.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="d_btwn">
                    <gui_name language="en">d_btwn</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles
between one chip select being de-activated and the
activation of another</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="8" name="d_after">
                    <gui_name language="en">d_after</gui_name>
                    <description language="en">Delay in SPI REFERENCE CLOCK or ext_clk cycles between last bit of current word and the first bit of the next word.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="d_int">
                    <gui_name language="en">d_int</gui_name>
                    <description language="en">Added delay in SPI REFERENCE CLOCK or ext_clk
cycles between setting n_ss_out low and first bit
transfer.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SPI1_TX_DATA_REG0" offset="0xe000701c" size="0x4">
                <gui_name language="en">Tx_data_reg0</gui_name>
                <description language="en">Transmit Data Register</description>
                <bitField access="Write Only" high_bit="31" low_bit="0" name="TX_FIFO_data">
                    <gui_name language="en">TX_FIFO_data</gui_name>
                    <description language="en">Data to TX FIFO</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI1_RX_DATA_REG0" offset="0xe0007020" size="0x4">
                <gui_name language="en">Rx_data_reg0</gui_name>
                <description language="en">Receive Data Register</description>
                <bitField access="Read Only" high_bit="31" low_bit="0" name="RX_FIFO_data">
                    <gui_name language="en">RX_FIFO_data</gui_name>
                    <description language="en">Data from TX FIFO</description>
                </bitField>
            </register>
            <register name="SPI1_SLAVE_IDLE_COUNT_REG0" offset="0xe0007024" size="0x4">
                <gui_name language="en">Slave_Idle_count_reg0</gui_name>
                <description language="en">Slave Idle Count Register</description>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="Slave_Idle_coun">
                    <gui_name language="en">Slave_Idle_coun</gui_name>
                    <description language="en">SPI in slave mode detects a start only when the
external SPI master serial clock (sclk_in) is stable
(quiescent state) for SPI REFERENCE CLOCK cycles
specified by slave idle count register or when the SPI
is deselected.</description>
                </bitField>
            </register>
            <register name="SPI1_TX_THRES_REG0" offset="0xe0007028" size="0x4">
                <gui_name language="en">TX_thres_reg0</gui_name>
                <description language="en">TX_FIFO Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="DEPTH_of_TX_FIFO">
                    <gui_name language="en">DEPTH_of_TX_FIFO</gui_name>
                    <description language="en">Defines the level at which the TX FIFO not full interrupt is generated</description>
                </bitField>
            </register>
            <register name="SPI1_RX_THRES_REG0" offset="0xe000702c" size="0x4">
                <gui_name language="en">RX_thres_reg0</gui_name>
                <description language="en">RX FIFO Threshold Register</description>
                <bitField access="Read Write" high_bit="31" low_bit="0" name="DEPTH_of_RX_FIFO">
                    <gui_name language="en">DEPTH_of_RX_FIFO</gui_name>
                    <description language="en">Defines the level at which the RX FIFO not empty interrupt is generated</description>
                </bitField>
            </register>
            <register access="Read Only" name="SPI1_MOD_ID_REG0" offset="0xe00070fc" size="0x4">
                <gui_name language="en">Mod_id_reg0</gui_name>
                <description language="en">Module ID register</description>
                <bitField access="Read Only" high_bit="24" low_bit="0" name="module_ID">
                    <gui_name language="en">module_ID</gui_name>
                    <description language="en">Module ID number</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_SWDT" name="SWDT" offset="0xf8005000">
            <gui_name language="en">swdt</gui_name>
            <description language="en">swdt</description>
            <register name="SWDT_MODE" offset="0xf8005000" size="0x4">
                <gui_name language="en">MODE</gui_name>
                <description language="en">WD zero mode register</description>
                <bitField access="Write Only" high_bit="23" low_bit="12" name="ZKEY">
                    <gui_name language="en">ZKEY</gui_name>
                    <description language="en">Zero access key - writes to the zero mode register are only valid if this field is set to 0xABC; this field is write only.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MODE_EXTLN_ENUM" high_bit="11" low_bit="9" name="EXTLN">
                    <gui_name language="en">EXTLN</gui_name>
                    <description language="en">External signal length - selects the number of pclk cycles during which the external
signal is held active after it is invoked:
000 = 2
001 = 4
010 = 8
011 = 16
100 = 32
101 = 64
110 = 128
111 = 256</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MODE_IRQLN_ENUM" high_bit="8" low_bit="7" name="IRQLN">
                    <gui_name language="en">IRQLN</gui_name>
                    <description language="en">Interrupt request length - selects the number of pclk cycles during which an interrupt request is held active after it is invoked:
00 = 4
01 = 8
10 = 16
11 = 32</description>
                </bitField>
                <bitField access="Read Write" enumerationId="MODE_RSTLN_ENUM" high_bit="6" low_bit="4" name="RSTLN">
                    <gui_name language="en">RSTLN</gui_name>
                    <description language="en">Reset length - selects the number of clock cycles (pclk) during which the internal system reset is held active after it is invoked:
000 = 2
001 = 4
010 = 8
011 = 16
100 = 32
101 = 64
110 = 128 111 = 256
Note: The minimum number of cycles required for an AMBA reset is two.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="EXTEN">
                    <gui_name language="en">EXTEN</gui_name>
                    <description language="en">External signal enable - if set, the watchdog will issue an external request when the counter reaches zero, if WDEN = 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="IRQEN">
                    <gui_name language="en">IRQEN</gui_name>
                    <description language="en">Interrupt request enable - if set, the watchdog will issue an interrupt request when the counter reaches zero, if WDEN = 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="RSTEN">
                    <gui_name language="en">RSTEN</gui_name>
                    <description language="en">Reset enable - if set, the watchdog will issue an internal reset when the counter reaches zero, if WDEN = 1.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="WDEN">
                    <gui_name language="en">WDEN</gui_name>
                    <description language="en">Watchdog enable - if set, the watchdog is enabled and can generate any signals that are enabled.</description>
                </bitField>
            </register>
            <register name="SWDT_CONTROL" offset="0xf8005004" size="0x4">
                <gui_name language="en">CONTROL</gui_name>
                <description language="en">Counter Control Register</description>
                <bitField access="Write Only" high_bit="25" low_bit="14" name="CKEY">
                    <gui_name language="en">CKEY</gui_name>
                    <description language="en">Counter access key - writes to the control register are only valid if this field is set to 0x248; this field is write only.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="2" name="CRV">
                    <gui_name language="en">CRV</gui_name>
                    <description language="en">Counter restart value - the counter is restarted with the value 0xNNNFFF, where NNN is the value of this field.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="CONTROL_CLKSEL_ENUM" high_bit="1" low_bit="0" name="CLKSEL">
                    <gui_name language="en">CLKSEL</gui_name>
                    <description language="en">Counter clock prescale - selects the prescaler division ratio:
00 = pclk divided by 8
01 = pclk divided by 64
10 = pclk divided by 256
11 = pclk divided by 4096
Note: If a restart signal is received the prescaler should be reset.</description>
                </bitField>
            </register>
            <register access="Write Only" name="SWDT_RESTART" offset="0xf8005008" size="0x2">
                <gui_name language="en">RESTART</gui_name>
                <description language="en">Restart key register - this not a real register as no data is stored</description>
                <bitField access="Write Only" high_bit="15" low_bit="0" name="RSTKEY">
                    <gui_name language="en">RSTKEY</gui_name>
                    <description language="en">Restart key - the watchdog is restarted if this field is set to the value 0x1999</description>
                </bitField>
            </register>
            <register access="Read Only" name="SWDT_STATUS" offset="0xf800500c" size="0x2">
                <gui_name language="en">STATUS</gui_name>
                <description language="en">Status Register</description>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="WDZ">
                    <gui_name language="en">WDZ</gui_name>
                    <description language="en">set when the watchdog reaches zero count</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_TTC0" name="TTC0" offset="0xf8001000">
            <gui_name language="en">ttc0</gui_name>
            <description language="en">ttc0</description>
            <register name="TTC0_CLOCK_CONTROL_1" offset="0xf8001000" size="0x2">
                <gui_name language="en">Clock_Control_1</gui_name>
                <description language="en">Clock Control register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Ex_E">
                    <gui_name language="en">Ex_E</gui_name>
                    <description language="en">External Clock Edge: when this bit is set and the extend clock is selected, the counter clocks on the negative going edge of the external clock input.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="C_Src">
                    <gui_name language="en">C_Src</gui_name>
                    <description language="en">Clock Source: when this bit is set the counter uses the external clock input, ext_clk; the default clock source is pclk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="PS_V">
                    <gui_name language="en">PS_V</gui_name>
                    <description language="en">Prescale value (N): if prescale is enabled, the count rate is divided by 2N+1 (divided by 2 to 65536)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PS_En">
                    <gui_name language="en">PS_En</gui_name>
                    <description language="en">Prescale enable: when this bit is set the counter, clock source is prescaled; the default clock source is that defined by C_Src.the default</description>
                </bitField>
            </register>
            <register name="TTC0_CLOCK_CONTROL_2" offset="0xf8001004" size="0x2">
                <gui_name language="en">Clock_Control_2</gui_name>
                <description language="en">Clock Control register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Ex_E">
                    <gui_name language="en">Ex_E</gui_name>
                    <description language="en">External Clock Edge: when this bit is set and the extend clock is selected, the counter clocks on the negative going edge of the external clock input.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="C_Src">
                    <gui_name language="en">C_Src</gui_name>
                    <description language="en">Clock Source: when this bit is set the counter uses the external clock input, ext_clk; the default clock source is pclk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="PS_V">
                    <gui_name language="en">PS_V</gui_name>
                    <description language="en">Prescale value (N): if prescale is enabled, the count rate is divided by 2N+1 (divided by 2 to 65536)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PS_En">
                    <gui_name language="en">PS_En</gui_name>
                    <description language="en">Prescale enable: when this bit is set the counter, clock source is prescaled; the default clock source is that defined by C_Src.the default</description>
                </bitField>
            </register>
            <register name="TTC0_CLOCK_CONTROL_3" offset="0xf8001008" size="0x2">
                <gui_name language="en">Clock_Control_3</gui_name>
                <description language="en">Clock Control register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Ex_E">
                    <gui_name language="en">Ex_E</gui_name>
                    <description language="en">External Clock Edge: when this bit is set and the extend clock is selected, the counter clocks on the negative going edge of the external clock input.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="C_Src">
                    <gui_name language="en">C_Src</gui_name>
                    <description language="en">Clock Source: when this bit is set the counter uses the external clock input, ext_clk; the default clock source is pclk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="PS_V">
                    <gui_name language="en">PS_V</gui_name>
                    <description language="en">Prescale value (N): if prescale is enabled, the count rate is divided by 2N+1 (divided by 2 to 65536)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PS_En">
                    <gui_name language="en">PS_En</gui_name>
                    <description language="en">Prescale enable: when this bit is set the counter, clock source is prescaled; the default clock source is that defined by C_Src.the default</description>
                </bitField>
            </register>
            <register name="TTC0_COUNTER_CONTROL_1" offset="0xf800100c" size="0x2">
                <gui_name language="en">Counter_Control_1</gui_name>
                <description language="en">Operational mode and reset</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Wave_pol">
                    <gui_name language="en">Wave_pol</gui_name>
                    <description language="en">Waveform polarity: When this bit is high, the waveform output goes from high to low on Match_1 interrupt and returns high on overflow or interval interrupt; when low, the waveform goes from low to high on Match_1 interrupt and returns low on overflow or interval interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="Wave_en">
                    <gui_name language="en">Wave_en</gui_name>
                    <description language="en">Output waveform enable, active low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Setting this bit high resets the counter value and restarts counting; the RST bit is automatically cleared on restart.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">Register Match mode: when Match is set, an interrupt is generated when the count value matches one of the three match registers and the corresponding bit is set in the Interrupt Enable register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="DEC">
                    <gui_name language="en">DEC</gui_name>
                    <description language="en">Decrement: when this bit is high the counter counts down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="INT">
                    <gui_name language="en">INT</gui_name>
                    <description language="en">When this bit is high, the timer is in Interval Mode, and the counter generates interrupts at regular intervals; when low, the timer is in overflow mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DIS">
                    <gui_name language="en">DIS</gui_name>
                    <description language="en">Disable counter: when this bit is high, the counter is stopped, holding its last value until reset, restarted or enabled again.</description>
                </bitField>
            </register>
            <register name="TTC0_COUNTER_CONTROL_2" offset="0xf8001010" size="0x2">
                <gui_name language="en">Counter_Control_2</gui_name>
                <description language="en">Operational mode and reset</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Wave_pol">
                    <gui_name language="en">Wave_pol</gui_name>
                    <description language="en">Waveform polarity: When this bit is high, the waveform output goes from high to low on Match_1 interrupt and returns high on overflow or interval interrupt; when low, the waveform goes from low to high on Match_1 interrupt and returns low on overflow or interval interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="Wave_en">
                    <gui_name language="en">Wave_en</gui_name>
                    <description language="en">Output waveform enable, active low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Setting this bit high resets the counter value and restarts counting; the RST bit is automatically cleared on restart.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">Register Match mode: when Match is set, an interrupt is generated when the count value matches one of the three match registers and the corresponding bit is set in the Interrupt Enable register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="DEC">
                    <gui_name language="en">DEC</gui_name>
                    <description language="en">Decrement: when this bit is high the counter counts down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="INT">
                    <gui_name language="en">INT</gui_name>
                    <description language="en">When this bit is high, the timer is in Interval Mode, and the counter generates interrupts at regular intervals; when low, the timer is in overflow mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DIS">
                    <gui_name language="en">DIS</gui_name>
                    <description language="en">Disable counter: when this bit is high, the counter is stopped, holding its last value until reset, restarted or enabled again.</description>
                </bitField>
            </register>
            <register name="TTC0_COUNTER_CONTROL_3" offset="0xf8001014" size="0x2">
                <gui_name language="en">Counter_Control_3</gui_name>
                <description language="en">Operational mode and reset</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Wave_pol">
                    <gui_name language="en">Wave_pol</gui_name>
                    <description language="en">Waveform polarity: When this bit is high, the waveform output goes from high to low on Match_1 interrupt and returns high on overflow or interval interrupt; when low, the waveform goes from low to high on Match_1 interrupt and returns low on overflow or interval interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="Wave_en">
                    <gui_name language="en">Wave_en</gui_name>
                    <description language="en">Output waveform enable, active low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Setting this bit high resets the counter value and restarts counting; the RST bit is automatically cleared on restart.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">Register Match mode: when Match is set, an interrupt is generated when the count value matches one of the three match registers and the corresponding bit is set in the Interrupt Enable register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="DEC">
                    <gui_name language="en">DEC</gui_name>
                    <description language="en">Decrement: when this bit is high the counter counts down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="INT">
                    <gui_name language="en">INT</gui_name>
                    <description language="en">When this bit is high, the timer is in Interval Mode, and the counter generates interrupts at regular intervals; when low, the timer is in overflow mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DIS">
                    <gui_name language="en">DIS</gui_name>
                    <description language="en">Disable counter: when this bit is high, the counter is stopped, holding its last value until reset, restarted or enabled again.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_COUNTER_VALUE_1" offset="0xf8001018" size="0x2">
                <gui_name language="en">Counter_Value_1</gui_name>
                <description language="en">Current counter value</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Value">
                    <gui_name language="en">Value</gui_name>
                    <description language="en">At any time, a Timer Counter's count value can be read from its Counter Value Register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_COUNTER_VALUE_2" offset="0xf800101c" size="0x2">
                <gui_name language="en">Counter_Value_2</gui_name>
                <description language="en">Current counter value</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Value">
                    <gui_name language="en">Value</gui_name>
                    <description language="en">At any time, a Timer Counter's count value can be read from its Counter Value Register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_COUNTER_VALUE_3" offset="0xf8001020" size="0x2">
                <gui_name language="en">Counter_Value_3</gui_name>
                <description language="en">Current counter value</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Value">
                    <gui_name language="en">Value</gui_name>
                    <description language="en">At any time, a Timer Counter's count value can be read from its Counter Value Register.</description>
                </bitField>
            </register>
            <register name="TTC0_INTERVAL_COUNTER_1" offset="0xf8001024" size="0x2">
                <gui_name language="en">Interval_Counter_1</gui_name>
                <description language="en">Interval value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Interval">
                    <gui_name language="en">Interval</gui_name>
                    <description language="en">If interval is enabled, this is the maximum value that the counter will count up to or down from.</description>
                </bitField>
            </register>
            <register name="TTC0_INTERVAL_COUNTER_2" offset="0xf8001028" size="0x2">
                <gui_name language="en">Interval_Counter_2</gui_name>
                <description language="en">Interval value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Interval">
                    <gui_name language="en">Interval</gui_name>
                    <description language="en">If interval is enabled, this is the maximum value that the counter will count up to or down from.</description>
                </bitField>
            </register>
            <register name="TTC0_INTERVAL_COUNTER_3" offset="0xf800102c" size="0x2">
                <gui_name language="en">Interval_Counter_3</gui_name>
                <description language="en">Interval value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Interval">
                    <gui_name language="en">Interval</gui_name>
                    <description language="en">If interval is enabled, this is the maximum value that the counter will count up to or down from.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_1_COUNTER_1" offset="0xf8001030" size="0x2">
                <gui_name language="en">Match_1_Counter_1</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_1_COUNTER_2" offset="0xf8001034" size="0x2">
                <gui_name language="en">Match_1_Counter_2</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_1_COUNTER_3" offset="0xf8001038" size="0x2">
                <gui_name language="en">Match_1_Counter_3</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_2_COUNTER_1" offset="0xf800103c" size="0x2">
                <gui_name language="en">Match_2_Counter_1</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_2_COUNTER_2" offset="0xf8001040" size="0x2">
                <gui_name language="en">Match_2_Counter_2</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_2_COUNTER_3" offset="0xf8001044" size="0x2">
                <gui_name language="en">Match_2_Counter_3</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_3_COUNTER_1" offset="0xf8001048" size="0x2">
                <gui_name language="en">Match_3_Counter_1</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_3_COUNTER_2" offset="0xf800104c" size="0x2">
                <gui_name language="en">Match_3_Counter_2</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC0_MATCH_3_COUNTER_3" offset="0xf8001050" size="0x2">
                <gui_name language="en">Match_3_Counter_3</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_INTERRUPT_REGISTER_1" offset="0xf8001054" size="0x2">
                <gui_name language="en">Interrupt_Register_1</gui_name>
                <description language="en">Counter 1 Interval, Match, Overflow
and Event interrupts</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="Ev">
                    <gui_name language="en">Ev</gui_name>
                    <description language="en">Event timer overflow interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Ov">
                    <gui_name language="en">Ov</gui_name>
                    <description language="en">Counter overflow</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="M3">
                    <gui_name language="en">M3</gui_name>
                    <description language="en">Match 3 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="M2">
                    <gui_name language="en">M2</gui_name>
                    <description language="en">Match 2 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Match 1 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Iv">
                    <gui_name language="en">Iv</gui_name>
                    <description language="en">Interval interrupt</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_INTERRUPT_REGISTER_2" offset="0xf8001058" size="0x2">
                <gui_name language="en">Interrupt_Register_2</gui_name>
                <description language="en">Counter 2 Interval, Match, Overflow and Event interrupts</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="Ev">
                    <gui_name language="en">Ev</gui_name>
                    <description language="en">Event timer overflow interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Ov">
                    <gui_name language="en">Ov</gui_name>
                    <description language="en">Counter overflow</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="M3">
                    <gui_name language="en">M3</gui_name>
                    <description language="en">Match 3 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="M2">
                    <gui_name language="en">M2</gui_name>
                    <description language="en">Match 2 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Match 1 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Iv">
                    <gui_name language="en">Iv</gui_name>
                    <description language="en">Interval interrupt</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_INTERRUPT_REGISTER_3" offset="0xf800105c" size="0x2">
                <gui_name language="en">Interrupt_Register_3</gui_name>
                <description language="en">Counter 3 Interval, Match, Overflow and Event interrupts</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="Ev">
                    <gui_name language="en">Ev</gui_name>
                    <description language="en">Event timer overflow interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Ov">
                    <gui_name language="en">Ov</gui_name>
                    <description language="en">Counter overflow</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="M3">
                    <gui_name language="en">M3</gui_name>
                    <description language="en">Match 3 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="M2">
                    <gui_name language="en">M2</gui_name>
                    <description language="en">Match 2 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Match 1 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Iv">
                    <gui_name language="en">Iv</gui_name>
                    <description language="en">Interval interrupt</description>
                </bitField>
            </register>
            <register name="TTC0_INTERRUPT_ENABLE_1" offset="0xf8001060" size="0x2">
                <gui_name language="en">Interrupt_Enable_1</gui_name>
                <description language="en">ANDed with corresponding Interrupt
Register</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="IEN">
                    <gui_name language="en">IEN</gui_name>
                    <description language="en">Enables for bits 05:00 in Interrupt Register: corresponding bits must be set to enable the
interrupt.</description>
                </bitField>
            </register>
            <register name="TTC0_INTERRUPT_ENABLE_2" offset="0xf8001064" size="0x2">
                <gui_name language="en">Interrupt_Enable_2</gui_name>
                <description language="en">ANDed with corresponding Interrupt
Register</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="IEN">
                    <gui_name language="en">IEN</gui_name>
                    <description language="en">Enables for bits 05:00 in Interrupt Register: corresponding bits must be set to enable the interrupt.</description>
                </bitField>
            </register>
            <register name="TTC0_INTERRUPT_ENABLE_3" offset="0xf8001068" size="0x2">
                <gui_name language="en">Interrupt_Enable_3</gui_name>
                <description language="en">ANDed with corresponding Interrupt
Register</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="IEN">
                    <gui_name language="en">IEN</gui_name>
                    <description language="en">Enables for bits 05:00 in Interrupt Register: corresponding bits must be set to enable the interrupt.</description>
                </bitField>
            </register>
            <register name="TTC0_EVENT_CONTROL_TIMER_1" offset="0xf800106c" size="0x2">
                <gui_name language="en">Event_Control_Timer_1</gui_name>
                <description language="en">Enable, pulse and overflow</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="E_Ov">
                    <gui_name language="en">E_Ov</gui_name>
                    <description language="en">When this bit is low, the event timer is disabled and set to zero when an Event Timer Register overflow occurs; when set high, the timer continues counting on overflow.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E_Lo">
                    <gui_name language="en">E_Lo</gui_name>
                    <description language="en">When this bit is high, the timer counts pclk cycles during the low level duration of ext_clk; when low, the event timer counts the high level duration of ext_clk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E_En">
                    <gui_name language="en">E_En</gui_name>
                    <description language="en">Enable timer: when this bit is high, the event timer is enabled.</description>
                </bitField>
            </register>
            <register name="TTC0_EVENT_CONTROL_TIMER_2" offset="0xf8001070" size="0x2">
                <gui_name language="en">Event_Control_Timer_2</gui_name>
                <description language="en">Enable, pulse and overflow</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="E_Ov">
                    <gui_name language="en">E_Ov</gui_name>
                    <description language="en">When this bit is low, the event timer is disabled and set to zero when an Event Timer Register overflow occurs; when set high, the timer continues counting on overflow.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E_Lo">
                    <gui_name language="en">E_Lo</gui_name>
                    <description language="en">When this bit is high, the timer counts pclk cycles during the low level duration of ext_clk; when low, the event timer counts the high level duration of ext_clk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E_En">
                    <gui_name language="en">E_En</gui_name>
                    <description language="en">Enable timer: when this bit is high, the event timer is enabled.</description>
                </bitField>
            </register>
            <register name="TTC0_EVENT_CONTROL_TIMER_3" offset="0xf8001074" size="0x2">
                <gui_name language="en">Event_Control_Timer_3</gui_name>
                <description language="en">Enable, pulse and overflow</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="E_Ov">
                    <gui_name language="en">E_Ov</gui_name>
                    <description language="en">When this bit is low, the event timer is disabled and set to zero when an Event Timer Register overflow occurs; when set high, the timer continues counting on overflow.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E_Lo">
                    <gui_name language="en">E_Lo</gui_name>
                    <description language="en">When this bit is high, the timer counts pclk cycles during the low level duration of ext_clk; when low, the event timer counts the high level duration of ext_clk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E_En">
                    <gui_name language="en">E_En</gui_name>
                    <description language="en">Enable timer: when this bit is high, the event timer is enabled.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_EVENT_REGISTER_1" offset="0xf8001078" size="0x2">
                <gui_name language="en">Event_Register_1</gui_name>
                <description language="en">pclk cycle count for event</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Event">
                    <gui_name language="en">Event</gui_name>
                    <description language="en">This register stores the result of the pclk count during the ext_clk high or low pulse.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_EVENT_REGISTER_2" offset="0xf800107c" size="0x2">
                <gui_name language="en">Event_Register_2</gui_name>
                <description language="en">pclk cycle count for event</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Event">
                    <gui_name language="en">Event</gui_name>
                    <description language="en">This register stores the result of the pclk count during the ext_clk high or low pulse.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC0_EVENT_REGISTER_3" offset="0xf8001080" size="0x2">
                <gui_name language="en">Event_Register_3</gui_name>
                <description language="en">pclk cycle count for event</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Event">
                    <gui_name language="en">Event</gui_name>
                    <description language="en">This register stores the result of the pclk count during the ext_clk high or low pulse.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_TTC1" name="TTC1" offset="0xf8002000">
            <gui_name language="en">ttc1</gui_name>
            <description language="en">ttc1</description>
            <register name="TTC1_CLOCK_CONTROL_1" offset="0xf8002000" size="0x2">
                <gui_name language="en">Clock_Control_1</gui_name>
                <description language="en">Clock Control register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Ex_E">
                    <gui_name language="en">Ex_E</gui_name>
                    <description language="en">External Clock Edge: when this bit is set and the extend clock is selected, the counter clocks on the negative going edge of the external clock input.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="C_Src">
                    <gui_name language="en">C_Src</gui_name>
                    <description language="en">Clock Source: when this bit is set the counter uses the external clock input, ext_clk; the default clock source is pclk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="PS_V">
                    <gui_name language="en">PS_V</gui_name>
                    <description language="en">Prescale value (N): if prescale is enabled, the count rate is divided by 2N+1 (divided by 2 to 65536)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PS_En">
                    <gui_name language="en">PS_En</gui_name>
                    <description language="en">Prescale enable: when this bit is set the counter, clock source is prescaled; the default clock source is that defined by C_Src.the default</description>
                </bitField>
            </register>
            <register name="TTC1_CLOCK_CONTROL_2" offset="0xf8002004" size="0x2">
                <gui_name language="en">Clock_Control_2</gui_name>
                <description language="en">Clock Control register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Ex_E">
                    <gui_name language="en">Ex_E</gui_name>
                    <description language="en">External Clock Edge: when this bit is set and the extend clock is selected, the counter clocks on the negative going edge of the external clock input.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="C_Src">
                    <gui_name language="en">C_Src</gui_name>
                    <description language="en">Clock Source: when this bit is set the counter uses the external clock input, ext_clk; the default clock source is pclk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="PS_V">
                    <gui_name language="en">PS_V</gui_name>
                    <description language="en">Prescale value (N): if prescale is enabled, the count rate is divided by 2N+1 (divided by 2 to 65536)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PS_En">
                    <gui_name language="en">PS_En</gui_name>
                    <description language="en">Prescale enable: when this bit is set the counter, clock source is prescaled; the default clock source is that defined by C_Src.the default</description>
                </bitField>
            </register>
            <register name="TTC1_CLOCK_CONTROL_3" offset="0xf8002008" size="0x2">
                <gui_name language="en">Clock_Control_3</gui_name>
                <description language="en">Clock Control register</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Ex_E">
                    <gui_name language="en">Ex_E</gui_name>
                    <description language="en">External Clock Edge: when this bit is set and the extend clock is selected, the counter clocks on the negative going edge of the external clock input.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="C_Src">
                    <gui_name language="en">C_Src</gui_name>
                    <description language="en">Clock Source: when this bit is set the counter uses the external clock input, ext_clk; the default clock source is pclk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="1" name="PS_V">
                    <gui_name language="en">PS_V</gui_name>
                    <description language="en">Prescale value (N): if prescale is enabled, the count rate is divided by 2N+1 (divided by 2 to 65536)</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="PS_En">
                    <gui_name language="en">PS_En</gui_name>
                    <description language="en">Prescale enable: when this bit is set the counter, clock source is prescaled; the default clock source is that defined by C_Src.the default</description>
                </bitField>
            </register>
            <register name="TTC1_COUNTER_CONTROL_1" offset="0xf800200c" size="0x2">
                <gui_name language="en">Counter_Control_1</gui_name>
                <description language="en">Operational mode and reset</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Wave_pol">
                    <gui_name language="en">Wave_pol</gui_name>
                    <description language="en">Waveform polarity: When this bit is high, the waveform output goes from high to low on Match_1 interrupt and returns high on overflow or interval interrupt; when low, the waveform goes from low to high on Match_1 interrupt and returns low on overflow or interval interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="Wave_en">
                    <gui_name language="en">Wave_en</gui_name>
                    <description language="en">Output waveform enable, active low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Setting this bit high resets the counter value and restarts counting; the RST bit is automatically cleared on restart.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">Register Match mode: when Match is set, an interrupt is generated when the count value matches one of the three match registers and the corresponding bit is set in the Interrupt Enable register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="DEC">
                    <gui_name language="en">DEC</gui_name>
                    <description language="en">Decrement: when this bit is high the counter counts down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="INT">
                    <gui_name language="en">INT</gui_name>
                    <description language="en">When this bit is high, the timer is in Interval Mode, and the counter generates interrupts at regular intervals; when low, the timer is in overflow mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DIS">
                    <gui_name language="en">DIS</gui_name>
                    <description language="en">Disable counter: when this bit is high, the counter is stopped, holding its last value until reset, restarted or enabled again.</description>
                </bitField>
            </register>
            <register name="TTC1_COUNTER_CONTROL_2" offset="0xf8002010" size="0x2">
                <gui_name language="en">Counter_Control_2</gui_name>
                <description language="en">Operational mode and reset</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Wave_pol">
                    <gui_name language="en">Wave_pol</gui_name>
                    <description language="en">Waveform polarity: When this bit is high, the waveform output goes from high to low on Match_1 interrupt and returns high on overflow or interval interrupt; when low, the waveform goes from low to high on Match_1 interrupt and returns low on overflow or interval interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="Wave_en">
                    <gui_name language="en">Wave_en</gui_name>
                    <description language="en">Output waveform enable, active low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Setting this bit high resets the counter value and restarts counting; the RST bit is automatically cleared on restart.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">Register Match mode: when Match is set, an interrupt is generated when the count value matches one of the three match registers and the corresponding bit is set in the Interrupt Enable register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="DEC">
                    <gui_name language="en">DEC</gui_name>
                    <description language="en">Decrement: when this bit is high the counter counts down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="INT">
                    <gui_name language="en">INT</gui_name>
                    <description language="en">When this bit is high, the timer is in Interval Mode, and the counter generates interrupts at regular intervals; when low, the timer is in overflow mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DIS">
                    <gui_name language="en">DIS</gui_name>
                    <description language="en">Disable counter: when this bit is high, the counter is stopped, holding its last value until reset, restarted or enabled again.</description>
                </bitField>
            </register>
            <register name="TTC1_COUNTER_CONTROL_3" offset="0xf8002014" size="0x2">
                <gui_name language="en">Counter_Control_3</gui_name>
                <description language="en">Operational mode and reset</description>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="Wave_pol">
                    <gui_name language="en">Wave_pol</gui_name>
                    <description language="en">Waveform polarity: When this bit is high, the waveform output goes from high to low on Match_1 interrupt and returns high on overflow or interval interrupt; when low, the waveform goes from low to high on Match_1 interrupt and returns low on overflow or interval interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="Wave_en">
                    <gui_name language="en">Wave_en</gui_name>
                    <description language="en">Output waveform enable, active low.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Setting this bit high resets the counter value and restarts counting; the RST bit is automatically cleared on restart.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">Register Match mode: when Match is set, an interrupt is generated when the count value matches one of the three match registers and the corresponding bit is set in the Interrupt Enable register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="DEC">
                    <gui_name language="en">DEC</gui_name>
                    <description language="en">Decrement: when this bit is high the counter counts down.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="INT">
                    <gui_name language="en">INT</gui_name>
                    <description language="en">When this bit is high, the timer is in Interval Mode, and the counter generates interrupts at regular intervals; when low, the timer is in overflow mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="DIS">
                    <gui_name language="en">DIS</gui_name>
                    <description language="en">Disable counter: when this bit is high, the counter is stopped, holding its last value until reset, restarted or enabled again.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_COUNTER_VALUE_1" offset="0xf8002018" size="0x2">
                <gui_name language="en">Counter_Value_1</gui_name>
                <description language="en">Current counter value</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Value">
                    <gui_name language="en">Value</gui_name>
                    <description language="en">At any time, a Timer Counter's count value can be read from its Counter Value Register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_COUNTER_VALUE_2" offset="0xf800201c" size="0x2">
                <gui_name language="en">Counter_Value_2</gui_name>
                <description language="en">Current counter value</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Value">
                    <gui_name language="en">Value</gui_name>
                    <description language="en">At any time, a Timer Counter's count value can be read from its Counter Value Register.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_COUNTER_VALUE_3" offset="0xf8002020" size="0x2">
                <gui_name language="en">Counter_Value_3</gui_name>
                <description language="en">Current counter value</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Value">
                    <gui_name language="en">Value</gui_name>
                    <description language="en">At any time, a Timer Counter's count value can be read from its Counter Value Register.</description>
                </bitField>
            </register>
            <register name="TTC1_INTERVAL_COUNTER_1" offset="0xf8002024" size="0x2">
                <gui_name language="en">Interval_Counter_1</gui_name>
                <description language="en">Interval value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Interval">
                    <gui_name language="en">Interval</gui_name>
                    <description language="en">If interval is enabled, this is the maximum value that the counter will count up to or down from.</description>
                </bitField>
            </register>
            <register name="TTC1_INTERVAL_COUNTER_2" offset="0xf8002028" size="0x2">
                <gui_name language="en">Interval_Counter_2</gui_name>
                <description language="en">Interval value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Interval">
                    <gui_name language="en">Interval</gui_name>
                    <description language="en">If interval is enabled, this is the maximum value that the counter will count up to or down from.</description>
                </bitField>
            </register>
            <register name="TTC1_INTERVAL_COUNTER_3" offset="0xf800202c" size="0x2">
                <gui_name language="en">Interval_Counter_3</gui_name>
                <description language="en">Interval value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Interval">
                    <gui_name language="en">Interval</gui_name>
                    <description language="en">If interval is enabled, this is the maximum value that the counter will count up to or down from.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_1_COUNTER_1" offset="0xf8002030" size="0x2">
                <gui_name language="en">Match_1_Counter_1</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_1_COUNTER_2" offset="0xf8002034" size="0x2">
                <gui_name language="en">Match_1_Counter_2</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_1_COUNTER_3" offset="0xf8002038" size="0x2">
                <gui_name language="en">Match_1_Counter_3</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_2_COUNTER_1" offset="0xf800203c" size="0x2">
                <gui_name language="en">Match_2_Counter_1</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_2_COUNTER_2" offset="0xf8002040" size="0x2">
                <gui_name language="en">Match_2_Counter_2</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_2_COUNTER_3" offset="0xf8002044" size="0x2">
                <gui_name language="en">Match_2_Counter_3</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_3_COUNTER_1" offset="0xf8002048" size="0x2">
                <gui_name language="en">Match_3_Counter_1</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_3_COUNTER_2" offset="0xf800204c" size="0x2">
                <gui_name language="en">Match_3_Counter_2</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register name="TTC1_MATCH_3_COUNTER_3" offset="0xf8002050" size="0x2">
                <gui_name language="en">Match_3_Counter_3</gui_name>
                <description language="en">Match value</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="Match">
                    <gui_name language="en">Match</gui_name>
                    <description language="en">When a counter has the same value as is stored in one of its match registers and match mode is enabled, a match interrupt is generated. Each counter has three match registers.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_INTERRUPT_REGISTER_1" offset="0xf8002054" size="0x2">
                <gui_name language="en">Interrupt_Register_1</gui_name>
                <description language="en">Counter 1 Interval, Match, Overflow
and Event interrupts</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="Ev">
                    <gui_name language="en">Ev</gui_name>
                    <description language="en">Event timer overflow interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Ov">
                    <gui_name language="en">Ov</gui_name>
                    <description language="en">Counter overflow</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="M3">
                    <gui_name language="en">M3</gui_name>
                    <description language="en">Match 3 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="M2">
                    <gui_name language="en">M2</gui_name>
                    <description language="en">Match 2 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Match 1 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Iv">
                    <gui_name language="en">Iv</gui_name>
                    <description language="en">Interval interrupt</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_INTERRUPT_REGISTER_2" offset="0xf8002058" size="0x2">
                <gui_name language="en">Interrupt_Register_2</gui_name>
                <description language="en">Counter 2 Interval, Match, Overflow and Event interrupts</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="Ev">
                    <gui_name language="en">Ev</gui_name>
                    <description language="en">Event timer overflow interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Ov">
                    <gui_name language="en">Ov</gui_name>
                    <description language="en">Counter overflow</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="M3">
                    <gui_name language="en">M3</gui_name>
                    <description language="en">Match 3 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="M2">
                    <gui_name language="en">M2</gui_name>
                    <description language="en">Match 2 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Match 1 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Iv">
                    <gui_name language="en">Iv</gui_name>
                    <description language="en">Interval interrupt</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_INTERRUPT_REGISTER_3" offset="0xf800205c" size="0x2">
                <gui_name language="en">Interrupt_Register_3</gui_name>
                <description language="en">Counter 3 Interval, Match, Overflow and Event interrupts</description>
                <bitField access="Read Only" high_bit="5" low_bit="5" name="Ev">
                    <gui_name language="en">Ev</gui_name>
                    <description language="en">Event timer overflow interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="Ov">
                    <gui_name language="en">Ov</gui_name>
                    <description language="en">Counter overflow</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="M3">
                    <gui_name language="en">M3</gui_name>
                    <description language="en">Match 3 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="M2">
                    <gui_name language="en">M2</gui_name>
                    <description language="en">Match 2 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="M1">
                    <gui_name language="en">M1</gui_name>
                    <description language="en">Match 1 interrupt</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="Iv">
                    <gui_name language="en">Iv</gui_name>
                    <description language="en">Interval interrupt</description>
                </bitField>
            </register>
            <register name="TTC1_INTERRUPT_ENABLE_1" offset="0xf8002060" size="0x2">
                <gui_name language="en">Interrupt_Enable_1</gui_name>
                <description language="en">ANDed with corresponding Interrupt
Register</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="IEN">
                    <gui_name language="en">IEN</gui_name>
                    <description language="en">Enables for bits 05:00 in Interrupt Register: corresponding bits must be set to enable the
interrupt.</description>
                </bitField>
            </register>
            <register name="TTC1_INTERRUPT_ENABLE_2" offset="0xf8002064" size="0x2">
                <gui_name language="en">Interrupt_Enable_2</gui_name>
                <description language="en">ANDed with corresponding Interrupt
Register</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="IEN">
                    <gui_name language="en">IEN</gui_name>
                    <description language="en">Enables for bits 05:00 in Interrupt Register: corresponding bits must be set to enable the interrupt.</description>
                </bitField>
            </register>
            <register name="TTC1_INTERRUPT_ENABLE_3" offset="0xf8002068" size="0x2">
                <gui_name language="en">Interrupt_Enable_3</gui_name>
                <description language="en">ANDed with corresponding Interrupt
Register</description>
                <bitField access="Read Write" high_bit="5" low_bit="0" name="IEN">
                    <gui_name language="en">IEN</gui_name>
                    <description language="en">Enables for bits 05:00 in Interrupt Register: corresponding bits must be set to enable the interrupt.</description>
                </bitField>
            </register>
            <register name="TTC1_EVENT_CONTROL_TIMER_1" offset="0xf800206c" size="0x2">
                <gui_name language="en">Event_Control_Timer_1</gui_name>
                <description language="en">Enable, pulse and overflow</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="E_Ov">
                    <gui_name language="en">E_Ov</gui_name>
                    <description language="en">When this bit is low, the event timer is disabled and set to zero when an Event Timer Register overflow occurs; when set high, the timer continues counting on overflow.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E_Lo">
                    <gui_name language="en">E_Lo</gui_name>
                    <description language="en">When this bit is high, the timer counts pclk cycles during the low level duration of ext_clk; when low, the event timer counts the high level duration of ext_clk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E_En">
                    <gui_name language="en">E_En</gui_name>
                    <description language="en">Enable timer: when this bit is high, the event timer is enabled.</description>
                </bitField>
            </register>
            <register name="TTC1_EVENT_CONTROL_TIMER_2" offset="0xf8002070" size="0x2">
                <gui_name language="en">Event_Control_Timer_2</gui_name>
                <description language="en">Enable, pulse and overflow</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="E_Ov">
                    <gui_name language="en">E_Ov</gui_name>
                    <description language="en">When this bit is low, the event timer is disabled and set to zero when an Event Timer Register overflow occurs; when set high, the timer continues counting on overflow.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E_Lo">
                    <gui_name language="en">E_Lo</gui_name>
                    <description language="en">When this bit is high, the timer counts pclk cycles during the low level duration of ext_clk; when low, the event timer counts the high level duration of ext_clk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E_En">
                    <gui_name language="en">E_En</gui_name>
                    <description language="en">Enable timer: when this bit is high, the event timer is enabled.</description>
                </bitField>
            </register>
            <register name="TTC1_EVENT_CONTROL_TIMER_3" offset="0xf8002074" size="0x2">
                <gui_name language="en">Event_Control_Timer_3</gui_name>
                <description language="en">Enable, pulse and overflow</description>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="E_Ov">
                    <gui_name language="en">E_Ov</gui_name>
                    <description language="en">When this bit is low, the event timer is disabled and set to zero when an Event Timer Register overflow occurs; when set high, the timer continues counting on overflow.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="E_Lo">
                    <gui_name language="en">E_Lo</gui_name>
                    <description language="en">When this bit is high, the timer counts pclk cycles during the low level duration of ext_clk; when low, the event timer counts the high level duration of ext_clk.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="E_En">
                    <gui_name language="en">E_En</gui_name>
                    <description language="en">Enable timer: when this bit is high, the event timer is enabled.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_EVENT_REGISTER_1" offset="0xf8002078" size="0x2">
                <gui_name language="en">Event_Register_1</gui_name>
                <description language="en">pclk cycle count for event</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Event">
                    <gui_name language="en">Event</gui_name>
                    <description language="en">This register stores the result of the pclk count during the ext_clk high or low pulse.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_EVENT_REGISTER_2" offset="0xf800207c" size="0x2">
                <gui_name language="en">Event_Register_2</gui_name>
                <description language="en">pclk cycle count for event</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Event">
                    <gui_name language="en">Event</gui_name>
                    <description language="en">This register stores the result of the pclk count during the ext_clk high or low pulse.</description>
                </bitField>
            </register>
            <register access="Read Only" name="TTC1_EVENT_REGISTER_3" offset="0xf8002080" size="0x2">
                <gui_name language="en">Event_Register_3</gui_name>
                <description language="en">pclk cycle count for event</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="Event">
                    <gui_name language="en">Event</gui_name>
                    <description language="en">This register stores the result of the pclk count during the ext_clk high or low pulse.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_UART0" name="UART0" offset="0xe0000000">
            <gui_name language="en">uart0</gui_name>
            <description language="en">uart0</description>
            <register name="UART0_CONTROL_REG0" offset="0xe0000000" size="0x4">
                <gui_name language="en">Control_reg0</gui_name>
                <description language="en">UART Control register</description>
                <bitField access="Read Write" enumerationId="Control_reg0_STPBRK_ENUM" high_bit="8" low_bit="8" name="STPBRK">
                    <gui_name language="en">STPBRK</gui_name>
                    <description language="en">Stop transmitter break.
1 = stop transmission of the break.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_STTBRK_ENUM" high_bit="7" low_bit="7" name="STTBRK">
                    <gui_name language="en">STTBRK</gui_name>
                    <description language="en">Start transmitter break
1 = start to transmit a break. Can only be set if
STPBRK (Stop transmitter break) is not high.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_RSTTO_ENUM" high_bit="6" low_bit="6" name="RSTTO">
                    <gui_name language="en">RSTTO</gui_name>
                    <description language="en">Restart receiver timeout counter
1 = receiver timeout counter is restarted</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="TXDIS">
                    <gui_name language="en">TXDIS</gui_name>
                    <description language="en">Transmit disable.
1, the transmitter is disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TXEN">
                    <gui_name language="en">TXEN</gui_name>
                    <description language="en">Transmit enable.
1, the transmitter is enabled, provided the TXDIS field is set to 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_RXDIS_ENUM" high_bit="3" low_bit="3" name="RXDIS">
                    <gui_name language="en">RXDIS</gui_name>
                    <description language="en">Receive disable.
1= receiver is enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="RXEN">
                    <gui_name language="en">RXEN</gui_name>
                    <description language="en">Receive enable.
1=the receiver logic is enabled, provided RXDIS field is set to 0</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TXRES">
                    <gui_name language="en">TXRES</gui_name>
                    <description language="en">Software reset for TX data path.
1=the transmitter logic is reset and all pending transmitter data is discarded
self clear</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXRES">
                    <gui_name language="en">RXRES</gui_name>
                    <description language="en">Software reset for RX data path
1=receiver logic is reset and all pending receiver data is discarded
self clear</description>
                </bitField>
            </register>
            <register name="UART0_MODE_REG0" offset="0xe0000004" size="0x4">
                <gui_name language="en">mode_reg0</gui_name>
                <description language="en">UART Mode register</description>
                <bitField access="Read Write" enumerationId="mode_reg0_IRMODE_ENUM" high_bit="11" low_bit="11" name="IRMODE">
                    <gui_name language="en">IRMODE</gui_name>
                    <description language="en">Enable IrDA mode
0 : Default UART mode
1 : Enable IrDA mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_UCLKEN_ENUM" high_bit="10" low_bit="10" name="UCLKEN">
                    <gui_name language="en">UCLKEN</gui_name>
                    <description language="en">External uart_clk source select
0 : APB clock, pclk
1 : a user-defined clock</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_CHMODE_ENUM" high_bit="9" low_bit="8" name="CHMODE">
                    <gui_name language="en">CHMODE</gui_name>
                    <description language="en">Channel mode
00 = normal
01 = automatic cho
10 = local loopback
11 = remote loopback</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_NBSTOP_ENUM" high_bit="7" low_bit="6" name="NBSTOP">
                    <gui_name language="en">NBSTOP</gui_name>
                    <description language="en">Number of stop bits
00 = 1 stop bit
01 = 1.5 stop bits
10 = 2 stop bits
11 = reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_PAR_ENUM" high_bit="5" low_bit="3" name="PAR">
                    <gui_name language="en">PAR</gui_name>
                    <description language="en">Parity type select.
000 = even parity
001 = odd parity
010 = forced to 0 parity (space)
011 = forced to 1 parity (mark)
1xx = no parity</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_CHRL_ENUM" high_bit="2" low_bit="1" name="CHRL">
                    <gui_name language="en">CHRL</gui_name>
                    <description language="en">Character length select
11 = 6 bits
10 = 7 bits
01 / 00 = 8 bits</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_CLKS_ENUM" high_bit="0" low_bit="0" name="CLKS">
                    <gui_name language="en">CLKS</gui_name>
                    <description language="en">clock source select
1 = clock source is uart_clk/8
0 = clock source is uart_clk</description>
                </bitField>
            </register>
            <register name="UART0_INTRPT_EN_REG0" offset="0xe0000008" size="0x4">
                <gui_name language="en">Intrpt_en_reg0</gui_name>
                <description language="en">Interrupt Enable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt
1 = enable</description>
                </bitField>
            </register>
            <register name="UART0_INTRPT_DIS_REG0" offset="0xe000000c" size="0x4">
                <gui_name language="en">Intrpt_dis_reg0</gui_name>
                <description language="en">Interrupt disable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt
1 = disable</description>
                </bitField>
            </register>
            <register access="Read Only" name="UART0_INTRPT_MASK_REG0" offset="0xe0000010" size="0x4">
                <gui_name language="en">Intrpt_mask_reg0</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
            </register>
            <register name="UART0_CHNL_INT_STS_REG0" offset="0xe0000014" size="0x4">
                <gui_name language="en">Chnl_int_sts_reg0</gui_name>
                <description language="en">Channel interrupt Status register</description>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
            </register>
            <register name="UART0_BAUD_RATE_GEN_REG0" offset="0xe0000018" size="0x4">
                <gui_name language="en">Baud_rate_gen_reg0</gui_name>
                <description language="en">Baud rate divider register</description>
                <bitField access="Read Write" enumerationId="Baud_rate_gen_reg0_CD_ENUM" high_bit="15" low_bit="0" name="CD">
                    <gui_name language="en">CD</gui_name>
                    <description language="en">Baud Rate Clock Divisor Value
0 = Disables baud_sample
1 = Clock divisor bypass
2 - 65535 = baud_sample value</description>
                </bitField>
            </register>
            <register name="UART0_RCVR_TIMEOUT_REG0" offset="0xe000001c" size="0x4">
                <gui_name language="en">Rcvr_timeout_reg0</gui_name>
                <description language="en">Receiver timeout register</description>
                <bitField access="Read Write" enumerationId="Rcvr_timeout_reg0_RTO_ENUM" high_bit="7" low_bit="0" name="RTO">
                    <gui_name language="en">RTO</gui_name>
                    <description language="en">Receiver timeout value
0 = Disables receiver timeout counter
1 - 255 = Receiver timeout</description>
                </bitField>
            </register>
            <register name="UART0_RCVR_FIFO_TRIGGER_LEVEL0" offset="0xe0000020" size="0x4">
                <gui_name language="en">Rcvr_FIFO_trigger_level0</gui_name>
                <description language="en">Receiver FIFO trigger level register</description>
                <bitField access="Read Write" enumerationId="Rcvr_FIFO_trigger_level0_RTRIG_ENUM" high_bit="5" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO trigger level value
0 = Disables receiver timeout counter
1 - 63 = Receiver timeout</description>
                </bitField>
            </register>
            <register name="UART0_MODEM_CTRL_REG0" offset="0xe0000024" size="0x4">
                <gui_name language="en">Modem_ctrl_reg0</gui_name>
                <description language="en">Modem control register</description>
                <bitField access="Read Write" enumerationId="Modem_ctrl_reg0_FCM_ENUM" high_bit="5" low_bit="5" name="FCM">
                    <gui_name language="en">FCM</gui_name>
                    <description language="en">Automatic flow control mode
1 = enable
0 = disable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Modem_ctrl_reg0_RTS_ENUM" high_bit="1" low_bit="1" name="RTS">
                    <gui_name language="en">RTS</gui_name>
                    <description language="en">Request to send output control
1 = forced to logic 0
0 = forced to logic 1</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Modem_ctrl_reg0_DTR_ENUM" high_bit="0" low_bit="0" name="DTR">
                    <gui_name language="en">DTR</gui_name>
                    <description language="en">Data Terminal Ready
1 = forced to logic 0
0 = forced to logic 1</description>
                </bitField>
            </register>
            <register access="Read Only" name="UART0_MODEM_STS_REG0" offset="0xe0000028" size="0x4">
                <gui_name language="en">Modem_sts_reg0</gui_name>
                <description language="en">Modem status register</description>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_FCMS_ENUM" high_bit="8" low_bit="8" name="FCMS">
                    <gui_name language="en">FCMS</gui_name>
                    <description language="en">Flow Control Mode
1 = enabled
0 = disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DCD_ENUM" high_bit="7" low_bit="7" name="DCD">
                    <gui_name language="en">DCD</gui_name>
                    <description language="en">Data Carrier Detect Input Status
1 = ua_ndcd input is low
0 = ua_ndcd input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_RI_ENUM" high_bit="6" low_bit="6" name="RI">
                    <gui_name language="en">RI</gui_name>
                    <description language="en">Ring Indicator input status
1 = ua_nri input is low
0 = ua_nri input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DSR_ENUM" high_bit="5" low_bit="5" name="DSR">
                    <gui_name language="en">DSR</gui_name>
                    <description language="en">Data Set Ready input status
1 = ua_ndsr input is low
0 = ua_ndsr input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_CTS_ENUM" high_bit="4" low_bit="4" name="CTS">
                    <gui_name language="en">CTS</gui_name>
                    <description language="en">Clear to Send input status
1 = ua_ncts input is low
0 = ua_ncts input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DDCD_ENUM" high_bit="3" low_bit="3" name="DDCD">
                    <gui_name language="en">DDCD</gui_name>
                    <description language="en">Delta Data Carrier Detect Status
1 = Change has occurred
0 = No change has occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_TERI_ENUM" high_bit="2" low_bit="2" name="TERI">
                    <gui_name language="en">TERI</gui_name>
                    <description language="en">Trailing Edge Ring Indicator Status
1 = Trailing edge has occurred
0 = No trailing edge has occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DDSR_ENUM" high_bit="1" low_bit="1" name="DDSR">
                    <gui_name language="en">DDSR</gui_name>
                    <description language="en">Delta Data Set Ready status
1 = Change has occurred
0 = No change has occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DCTS_ENUM" high_bit="0" low_bit="0" name="DCTS">
                    <gui_name language="en">DCTS</gui_name>
                    <description language="en">Delta Clear To Send Status
1 = Change has occurred
0 = No change has occurred</description>
                </bitField>
            </register>
            <register access="Read Only" name="UART0_CHANNEL_STS_REG0" offset="0xe000002c" size="0x4">
                <gui_name language="en">Channel_sts_reg0</gui_name>
                <description language="en">Channel Status register</description>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TNFUL_ENUM" high_bit="14" low_bit="14" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full continuous status
1 = Only one byte is free in the TX FIFO
0 = More than one byte is unused in the TX FIFO</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TTRIG_ENUM" high_bit="13" low_bit="13" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger continuous status
1 = TX FIFO fill level is greater than or equal to TTRIG
0 = TX FIFO fill level is less than TTRIG</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_FDELT_ENUM" high_bit="12" low_bit="12" name="FDELT">
                    <gui_name language="en">FDELT</gui_name>
                    <description language="en">Receiver flow delay trigger continuous status.
1 = RX FIFO fill level is greater than or equal to FDEL
0 = RX FIFO fill level is less than FDEL</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TACTIVE_ENUM" high_bit="11" low_bit="11" name="TACTIVE">
                    <gui_name language="en">TACTIVE</gui_name>
                    <description language="en">Transmitter state machine active status.
1 = active state
0 = inactive state</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_RACTIVE_ENUM" high_bit="10" low_bit="10" name="RACTIVE">
                    <gui_name language="en">RACTIVE</gui_name>
                    <description language="en">Receiver state machine active status.
1 = active state
0 = inactive state</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Frame Error status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full continuous status
1= TX FIFO is full
0 = TX FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty continuous status
1 = TX FIFO is empty
0 = TX FIFO is not empty</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full continuous status
1 = RX FIFO is full
0 = RX FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Full continuous status.
1 : RX FIFO is empty
0 : RX FIFO is not empty</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger continuous status
1 : RX FIFO fill level is greater than or equal to RTRIG
0 : RX FIFO fill level is less than RTRIG</description>
                </bitField>
            </register>
            <register name="UART0_TX_RX_FIFO0" offset="0xe0000030" size="0x4">
                <gui_name language="en">TX_RX_FIFO0</gui_name>
                <description language="en">Transmit and Receive FIFO</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="FIFO">
                    <gui_name language="en">FIFO</gui_name>
                    <description language="en">operates as TX FIFO and RX FIFO</description>
                </bitField>
            </register>
            <register name="UART0_BAUD_RATE_DIVIDER_REG0" offset="0xe0000034" size="0x4">
                <gui_name language="en">Baud_rate_divider_reg0</gui_name>
                <description language="en">baud rate divider register</description>
                <bitField access="Read Write" enumerationId="Baud_rate_divider_reg0_BDIV_ENUM" high_bit="7" low_bit="0" name="BDIV">
                    <gui_name language="en">BDIV</gui_name>
                    <description language="en">Baud rate divider value
0 - 3: ignored
4 - 255: Baud rate</description>
                </bitField>
            </register>
            <register name="UART0_FLOW_DELAY_REG0" offset="0xe0000038" size="0x4">
                <gui_name language="en">Flow_delay_reg0</gui_name>
                <description language="en">Flow Control Delay Register</description>
                <bitField access="Read Write" enumerationId="Flow_delay_reg0_FDEL_ENUM" high_bit="5" low_bit="0" name="FDEL">
                    <gui_name language="en">FDEL</gui_name>
                    <description language="en">RX FIFO trigger level for ua_nrts de-assertion
0 - 3 = disabled
4 to 65535 = ua_nrts is driven high when RX FIFO fill level equals FDEL</description>
                </bitField>
            </register>
            <register name="UART0_IR_MIN_RCV_PULSE_WDTH0" offset="0xe000003c" size="0x4">
                <gui_name language="en">IR_min_rcv_pulse_wdth0</gui_name>
                <description language="en">IR Minimum Received Pulse Width Register</description>
                <bitField access="Read Write" enumerationId="IR_min_rcv_pulse_wdth0_PMN_ENUM" high_bit="15" low_bit="0" name="PMN">
                    <gui_name language="en">PMN</gui_name>
                    <description language="en">Number of uart_clk periods
0 to 65535 : minimum width</description>
                </bitField>
            </register>
            <register name="UART0_IR_TRANSMITTED_PULSE_WDTH0" offset="0xe0000040" size="0x4">
                <gui_name language="en">IR_transmitted_pulse_wdth0</gui_name>
                <description language="en">IR Transmitted Pulse Width Register</description>
                <bitField access="Read Write" enumerationId="IR_transmitted_pulse_wdth0_PWID_ENUM" high_bit="7" low_bit="0" name="PWID">
                    <gui_name language="en">PWID</gui_name>
                    <description language="en">Pulse width
0 - 255 : width</description>
                </bitField>
            </register>
            <register name="UART0_TX_FIFO_TRIGGER_LEVEL0" offset="0xe0000044" size="0x4">
                <gui_name language="en">Tx_FIFO_trigger_level0</gui_name>
                <description language="en">Transmitter FIFO Trigger Level Register</description>
                <bitField access="Read Write" enumerationId="Tx_FIFO_trigger_level0_TTRIG_ENUM" high_bit="5" low_bit="0" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO trigger level
0 = Disables transmitter FIFO trigger level function
1 - 63 = Trigger set when transmitter FIFO fills to TTRIG bytes</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_UART1" name="UART1" offset="0xe0001000">
            <gui_name language="en">uart1</gui_name>
            <description language="en">uart1</description>
            <register name="UART1_CONTROL_REG0" offset="0xe0001000" size="0x4">
                <gui_name language="en">Control_reg0</gui_name>
                <description language="en">UART Control register</description>
                <bitField access="Read Write" enumerationId="Control_reg0_STPBRK_ENUM" high_bit="8" low_bit="8" name="STPBRK">
                    <gui_name language="en">STPBRK</gui_name>
                    <description language="en">Stop transmitter break.
1 = stop transmission of the break.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_STTBRK_ENUM" high_bit="7" low_bit="7" name="STTBRK">
                    <gui_name language="en">STTBRK</gui_name>
                    <description language="en">Start transmitter break
1 = start to transmit a break. Can only be set if
STPBRK (Stop transmitter break) is not high.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_RSTTO_ENUM" high_bit="6" low_bit="6" name="RSTTO">
                    <gui_name language="en">RSTTO</gui_name>
                    <description language="en">Restart receiver timeout counter
1 = receiver timeout counter is restarted</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="TXDIS">
                    <gui_name language="en">TXDIS</gui_name>
                    <description language="en">Transmit disable.
1, the transmitter is disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="TXEN">
                    <gui_name language="en">TXEN</gui_name>
                    <description language="en">Transmit enable.
1, the transmitter is enabled, provided the TXDIS field is set to 0.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Control_reg0_RXDIS_ENUM" high_bit="3" low_bit="3" name="RXDIS">
                    <gui_name language="en">RXDIS</gui_name>
                    <description language="en">Receive disable.
1= receiver is enabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="RXEN">
                    <gui_name language="en">RXEN</gui_name>
                    <description language="en">Receive enable.
1=the receiver logic is enabled, provided RXDIS field is set to 0</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TXRES">
                    <gui_name language="en">TXRES</gui_name>
                    <description language="en">Software reset for TX data path.
1=the transmitter logic is reset and all pending transmitter data is discarded
self clear</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXRES">
                    <gui_name language="en">RXRES</gui_name>
                    <description language="en">Software reset for RX data path
1=receiver logic is reset and all pending receiver data is discarded
self clear</description>
                </bitField>
            </register>
            <register name="UART1_MODE_REG0" offset="0xe0001004" size="0x4">
                <gui_name language="en">mode_reg0</gui_name>
                <description language="en">UART Mode register</description>
                <bitField access="Read Write" enumerationId="mode_reg0_IRMODE_ENUM" high_bit="11" low_bit="11" name="IRMODE">
                    <gui_name language="en">IRMODE</gui_name>
                    <description language="en">Enable IrDA mode
0 : Default UART mode
1 : Enable IrDA mode</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_UCLKEN_ENUM" high_bit="10" low_bit="10" name="UCLKEN">
                    <gui_name language="en">UCLKEN</gui_name>
                    <description language="en">External uart_clk source select
0 : APB clock, pclk
1 : a user-defined clock</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_CHMODE_ENUM" high_bit="9" low_bit="8" name="CHMODE">
                    <gui_name language="en">CHMODE</gui_name>
                    <description language="en">Channel mode
00 = normal
01 = automatic cho
10 = local loopback
11 = remote loopback</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_NBSTOP_ENUM" high_bit="7" low_bit="6" name="NBSTOP">
                    <gui_name language="en">NBSTOP</gui_name>
                    <description language="en">Number of stop bits
00 = 1 stop bit
01 = 1.5 stop bits
10 = 2 stop bits
11 = reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_PAR_ENUM" high_bit="5" low_bit="3" name="PAR">
                    <gui_name language="en">PAR</gui_name>
                    <description language="en">Parity type select.
000 = even parity
001 = odd parity
010 = forced to 0 parity (space)
011 = forced to 1 parity (mark)
1xx = no parity</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_CHRL_ENUM" high_bit="2" low_bit="1" name="CHRL">
                    <gui_name language="en">CHRL</gui_name>
                    <description language="en">Character length select
11 = 6 bits
10 = 7 bits
01 / 00 = 8 bits</description>
                </bitField>
                <bitField access="Read Write" enumerationId="mode_reg0_CLKS_ENUM" high_bit="0" low_bit="0" name="CLKS">
                    <gui_name language="en">CLKS</gui_name>
                    <description language="en">clock source select
1 = clock source is uart_clk/8
0 = clock source is uart_clk</description>
                </bitField>
            </register>
            <register name="UART1_INTRPT_EN_REG0" offset="0xe0001008" size="0x4">
                <gui_name language="en">Intrpt_en_reg0</gui_name>
                <description language="en">Interrupt Enable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
1 = enable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_en_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt
1 = enable</description>
                </bitField>
            </register>
            <register name="UART1_INTRPT_DIS_REG0" offset="0xe000100c" size="0x4">
                <gui_name language="en">Intrpt_dis_reg0</gui_name>
                <description language="en">Interrupt disable register</description>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
1 = disable</description>
                </bitField>
                <bitField access="Write Only" enumerationId="Intrpt_dis_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt
1 = disable</description>
                </bitField>
            </register>
            <register access="Read Only" name="UART1_INTRPT_MASK_REG0" offset="0xe0001010" size="0x4">
                <gui_name language="en">Intrpt_mask_reg0</gui_name>
                <description language="en">Interrupt mask register</description>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Intrpt_mask_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt mask status
1 = interrupt is enabled
0 = interrupt is disabled</description>
                </bitField>
            </register>
            <register name="UART1_CHNL_INT_STS_REG0" offset="0xe0001014" size="0x4">
                <gui_name language="en">Chnl_int_sts_reg0</gui_name>
                <description language="en">Channel interrupt Status register</description>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TOVR_ENUM" high_bit="12" low_bit="12" name="TOVR">
                    <gui_name language="en">TOVR</gui_name>
                    <description language="en">Transmitter FIFO Overflow interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TNFUL_ENUM" high_bit="11" low_bit="11" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TTRIG_ENUM" high_bit="10" low_bit="10" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Framing Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Empty interrupt
mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Chnl_int_sts_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger interrupt mask status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
            </register>
            <register name="UART1_BAUD_RATE_GEN_REG0" offset="0xe0001018" size="0x4">
                <gui_name language="en">Baud_rate_gen_reg0</gui_name>
                <description language="en">Baud rate divider register</description>
                <bitField access="Read Write" enumerationId="Baud_rate_gen_reg0_CD_ENUM" high_bit="15" low_bit="0" name="CD">
                    <gui_name language="en">CD</gui_name>
                    <description language="en">Baud Rate Clock Divisor Value
0 = Disables baud_sample
1 = Clock divisor bypass
2 - 65535 = baud_sample value</description>
                </bitField>
            </register>
            <register name="UART1_RCVR_TIMEOUT_REG0" offset="0xe000101c" size="0x4">
                <gui_name language="en">Rcvr_timeout_reg0</gui_name>
                <description language="en">Receiver timeout register</description>
                <bitField access="Read Write" enumerationId="Rcvr_timeout_reg0_RTO_ENUM" high_bit="7" low_bit="0" name="RTO">
                    <gui_name language="en">RTO</gui_name>
                    <description language="en">Receiver timeout value
0 = Disables receiver timeout counter
1 - 255 = Receiver timeout</description>
                </bitField>
            </register>
            <register name="UART1_RCVR_FIFO_TRIGGER_LEVEL0" offset="0xe0001020" size="0x4">
                <gui_name language="en">Rcvr_FIFO_trigger_level0</gui_name>
                <description language="en">Receiver FIFO trigger level register</description>
                <bitField access="Read Write" enumerationId="Rcvr_FIFO_trigger_level0_RTRIG_ENUM" high_bit="5" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO trigger level value
0 = Disables receiver timeout counter
1 - 63 = Receiver timeout</description>
                </bitField>
            </register>
            <register name="UART1_MODEM_CTRL_REG0" offset="0xe0001024" size="0x4">
                <gui_name language="en">Modem_ctrl_reg0</gui_name>
                <description language="en">Modem control register</description>
                <bitField access="Read Write" enumerationId="Modem_ctrl_reg0_FCM_ENUM" high_bit="5" low_bit="5" name="FCM">
                    <gui_name language="en">FCM</gui_name>
                    <description language="en">Automatic flow control mode
1 = enable
0 = disable</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Modem_ctrl_reg0_RTS_ENUM" high_bit="1" low_bit="1" name="RTS">
                    <gui_name language="en">RTS</gui_name>
                    <description language="en">Request to send output control
1 = forced to logic 0
0 = forced to logic 1</description>
                </bitField>
                <bitField access="Read Write" enumerationId="Modem_ctrl_reg0_DTR_ENUM" high_bit="0" low_bit="0" name="DTR">
                    <gui_name language="en">DTR</gui_name>
                    <description language="en">Data Terminal Ready
1 = forced to logic 0
0 = forced to logic 1</description>
                </bitField>
            </register>
            <register access="Read Only" name="UART1_MODEM_STS_REG0" offset="0xe0001028" size="0x4">
                <gui_name language="en">Modem_sts_reg0</gui_name>
                <description language="en">Modem status register</description>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_FCMS_ENUM" high_bit="8" low_bit="8" name="FCMS">
                    <gui_name language="en">FCMS</gui_name>
                    <description language="en">Flow Control Mode
1 = enabled
0 = disabled</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DCD_ENUM" high_bit="7" low_bit="7" name="DCD">
                    <gui_name language="en">DCD</gui_name>
                    <description language="en">Data Carrier Detect Input Status
1 = ua_ndcd input is low
0 = ua_ndcd input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_RI_ENUM" high_bit="6" low_bit="6" name="RI">
                    <gui_name language="en">RI</gui_name>
                    <description language="en">Ring Indicator input status
1 = ua_nri input is low
0 = ua_nri input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DSR_ENUM" high_bit="5" low_bit="5" name="DSR">
                    <gui_name language="en">DSR</gui_name>
                    <description language="en">Data Set Ready input status
1 = ua_ndsr input is low
0 = ua_ndsr input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_CTS_ENUM" high_bit="4" low_bit="4" name="CTS">
                    <gui_name language="en">CTS</gui_name>
                    <description language="en">Clear to Send input status
1 = ua_ncts input is low
0 = ua_ncts input is high</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DDCD_ENUM" high_bit="3" low_bit="3" name="DDCD">
                    <gui_name language="en">DDCD</gui_name>
                    <description language="en">Delta Data Carrier Detect Status
1 = Change has occurred
0 = No change has occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_TERI_ENUM" high_bit="2" low_bit="2" name="TERI">
                    <gui_name language="en">TERI</gui_name>
                    <description language="en">Trailing Edge Ring Indicator Status
1 = Trailing edge has occurred
0 = No trailing edge has occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DDSR_ENUM" high_bit="1" low_bit="1" name="DDSR">
                    <gui_name language="en">DDSR</gui_name>
                    <description language="en">Delta Data Set Ready status
1 = Change has occurred
0 = No change has occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Modem_sts_reg0_DCTS_ENUM" high_bit="0" low_bit="0" name="DCTS">
                    <gui_name language="en">DCTS</gui_name>
                    <description language="en">Delta Clear To Send Status
1 = Change has occurred
0 = No change has occurred</description>
                </bitField>
            </register>
            <register access="Read Only" name="UART1_CHANNEL_STS_REG0" offset="0xe000102c" size="0x4">
                <gui_name language="en">Channel_sts_reg0</gui_name>
                <description language="en">Channel Status register</description>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TNFUL_ENUM" high_bit="14" low_bit="14" name="TNFUL">
                    <gui_name language="en">TNFUL</gui_name>
                    <description language="en">Transmitter FIFO Nearly Full continuous status
1 = Only one byte is free in the TX FIFO
0 = More than one byte is unused in the TX FIFO</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TTRIG_ENUM" high_bit="13" low_bit="13" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO Trigger continuous status
1 = TX FIFO fill level is greater than or equal to TTRIG
0 = TX FIFO fill level is less than TTRIG</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_FDELT_ENUM" high_bit="12" low_bit="12" name="FDELT">
                    <gui_name language="en">FDELT</gui_name>
                    <description language="en">Receiver flow delay trigger continuous status.
1 = RX FIFO fill level is greater than or equal to FDEL
0 = RX FIFO fill level is less than FDEL</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TACTIVE_ENUM" high_bit="11" low_bit="11" name="TACTIVE">
                    <gui_name language="en">TACTIVE</gui_name>
                    <description language="en">Transmitter state machine active status.
1 = active state
0 = inactive state</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_RACTIVE_ENUM" high_bit="10" low_bit="10" name="RACTIVE">
                    <gui_name language="en">RACTIVE</gui_name>
                    <description language="en">Receiver state machine active status.
1 = active state
0 = inactive state</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_DMSI_ENUM" high_bit="9" low_bit="9" name="DMSI">
                    <gui_name language="en">DMSI</gui_name>
                    <description language="en">Delta Modem Status Indicator status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TIMEOUT_ENUM" high_bit="8" low_bit="8" name="TIMEOUT">
                    <gui_name language="en">TIMEOUT</gui_name>
                    <description language="en">Receiver Timeout status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_PARE_ENUM" high_bit="7" low_bit="7" name="PARE">
                    <gui_name language="en">PARE</gui_name>
                    <description language="en">Receiver Parity Error status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_FRAME_ENUM" high_bit="6" low_bit="6" name="FRAME">
                    <gui_name language="en">FRAME</gui_name>
                    <description language="en">Receiver Frame Error status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_ROVR_ENUM" high_bit="5" low_bit="5" name="ROVR">
                    <gui_name language="en">ROVR</gui_name>
                    <description language="en">Receiver Overflow Error status
1 = interrupt occurred
0 = no interrupt occurred</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TFUL_ENUM" high_bit="4" low_bit="4" name="TFUL">
                    <gui_name language="en">TFUL</gui_name>
                    <description language="en">Transmitter FIFO Full continuous status
1= TX FIFO is full
0 = TX FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_TEMPTY_ENUM" high_bit="3" low_bit="3" name="TEMPTY">
                    <gui_name language="en">TEMPTY</gui_name>
                    <description language="en">Transmitter FIFO Empty continuous status
1 = TX FIFO is empty
0 = TX FIFO is not empty</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_RFUL_ENUM" high_bit="2" low_bit="2" name="RFUL">
                    <gui_name language="en">RFUL</gui_name>
                    <description language="en">Receiver FIFO Full continuous status
1 = RX FIFO is full
0 = RX FIFO is not full</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_REMPTY_ENUM" high_bit="1" low_bit="1" name="REMPTY">
                    <gui_name language="en">REMPTY</gui_name>
                    <description language="en">Receiver FIFO Full continuous status.
1 : RX FIFO is empty
0 : RX FIFO is not empty</description>
                </bitField>
                <bitField access="Read Only" enumerationId="Channel_sts_reg0_RTRIG_ENUM" high_bit="0" low_bit="0" name="RTRIG">
                    <gui_name language="en">RTRIG</gui_name>
                    <description language="en">Receiver FIFO Trigger continuous status
1 : RX FIFO fill level is greater than or equal to RTRIG
0 : RX FIFO fill level is less than RTRIG</description>
                </bitField>
            </register>
            <register name="UART1_TX_RX_FIFO0" offset="0xe0001030" size="0x4">
                <gui_name language="en">TX_RX_FIFO0</gui_name>
                <description language="en">Transmit and Receive FIFO</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="FIFO">
                    <gui_name language="en">FIFO</gui_name>
                    <description language="en">operates as TX FIFO and RX FIFO</description>
                </bitField>
            </register>
            <register name="UART1_BAUD_RATE_DIVIDER_REG0" offset="0xe0001034" size="0x4">
                <gui_name language="en">Baud_rate_divider_reg0</gui_name>
                <description language="en">baud rate divider register</description>
                <bitField access="Read Write" enumerationId="Baud_rate_divider_reg0_BDIV_ENUM" high_bit="7" low_bit="0" name="BDIV">
                    <gui_name language="en">BDIV</gui_name>
                    <description language="en">Baud rate divider value
0 - 3: ignored
4 - 255: Baud rate</description>
                </bitField>
            </register>
            <register name="UART1_FLOW_DELAY_REG0" offset="0xe0001038" size="0x4">
                <gui_name language="en">Flow_delay_reg0</gui_name>
                <description language="en">Flow Control Delay Register</description>
                <bitField access="Read Write" enumerationId="Flow_delay_reg0_FDEL_ENUM" high_bit="5" low_bit="0" name="FDEL">
                    <gui_name language="en">FDEL</gui_name>
                    <description language="en">RX FIFO trigger level for ua_nrts de-assertion
0 - 3 = disabled
4 to 65535 = ua_nrts is driven high when RX FIFO fill level equals FDEL</description>
                </bitField>
            </register>
            <register name="UART1_IR_MIN_RCV_PULSE_WDTH0" offset="0xe000103c" size="0x4">
                <gui_name language="en">IR_min_rcv_pulse_wdth0</gui_name>
                <description language="en">IR Minimum Received Pulse Width Register</description>
                <bitField access="Read Write" enumerationId="IR_min_rcv_pulse_wdth0_PMN_ENUM" high_bit="15" low_bit="0" name="PMN">
                    <gui_name language="en">PMN</gui_name>
                    <description language="en">Number of uart_clk periods
0 to 65535 : minimum width</description>
                </bitField>
            </register>
            <register name="UART1_IR_TRANSMITTED_PULSE_WDTH0" offset="0xe0001040" size="0x4">
                <gui_name language="en">IR_transmitted_pulse_wdth0</gui_name>
                <description language="en">IR Transmitted Pulse Width Register</description>
                <bitField access="Read Write" enumerationId="IR_transmitted_pulse_wdth0_PWID_ENUM" high_bit="7" low_bit="0" name="PWID">
                    <gui_name language="en">PWID</gui_name>
                    <description language="en">Pulse width
0 - 255 : width</description>
                </bitField>
            </register>
            <register name="UART1_TX_FIFO_TRIGGER_LEVEL0" offset="0xe0001044" size="0x4">
                <gui_name language="en">Tx_FIFO_trigger_level0</gui_name>
                <description language="en">Transmitter FIFO Trigger Level Register</description>
                <bitField access="Read Write" enumerationId="Tx_FIFO_trigger_level0_TTRIG_ENUM" high_bit="5" low_bit="0" name="TTRIG">
                    <gui_name language="en">TTRIG</gui_name>
                    <description language="en">Transmitter FIFO trigger level
0 = Disables transmitter FIFO trigger level function
1 - 63 = Trigger set when transmitter FIFO fills to TTRIG bytes</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_USB0" name="USB0" offset="0xe0002000">
            <gui_name language="en">usb0</gui_name>
            <description language="en">usb0</description>
            <register access="Read Only" name="USB0_ID" offset="0xe0002000" size="0x4">
                <gui_name language="en">ID</gui_name>
                <description language="en">The ID register identifies the USB-HS 2.0 core and its revision</description>
                <bitField access="Read Only" high_bit="31" low_bit="29" name="CIVERSION">
                    <gui_name language="en">CIVERSION</gui_name>
                    <description language="en">Identifies the CI version</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="25" name="VERSION">
                    <gui_name language="en">VERSION</gui_name>
                    <description language="en">Identifies the version of the core</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="21" name="REVISION">
                    <gui_name language="en">REVISION</gui_name>
                    <description language="en">Revision number of the core</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="16" name="TAG">
                    <gui_name language="en">TAG</gui_name>
                    <description language="en">Identifies the tag of the core ; Current 2.20a version</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="8" name="NID">
                    <gui_name language="en">NID</gui_name>
                    <description language="en">NID Complement of ID; Ones complement version of ID</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="0" name="ID">
                    <gui_name language="en">ID</gui_name>
                    <description language="en">ID Configuration number ; This number indicates the type of the USB-HS 2.0 core.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HWGENERAL" offset="0xe0002004" size="0x2">
                <gui_name language="en">HWGENERAL</gui_name>
                <description language="en">General hardware parameters as defined in configuration file.</description>
                <bitField access="Read Only" enumerationId="HWGENERAL_SM_ENUM" high_bit="11" low_bit="10" name="SM">
                    <gui_name language="en">SM</gui_name>
                    <description language="en">VUSB_HS_PHY_SERIAL - This constant selects that the serial engine is used or not.
0 - No Serial Engine- Always use parallel signalling</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_PHYM_ENUM" high_bit="9" low_bit="6" name="PHYM">
                    <gui_name language="en">PHYM</gui_name>
                    <description language="en">VUSB_HS_PHY_TYPE
- PHY interface type.
2 = ULPI</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_PHYW_ENUM" high_bit="5" low_bit="4" name="PHYW">
                    <gui_name language="en">PHYW</gui_name>
                    <description language="en">VUSB_HS_PHY16_8 - This constant selects which phy is being used.
0 = 8 bit wide data bus [60MHz clock from the transciever]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="BWT">
                    <gui_name language="en">BWT</gui_name>
                    <description language="en">RESERVED.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_CLKC_ENUM" high_bit="2" low_bit="1" name="CLKC">
                    <gui_name language="en">CLKC</gui_name>
                    <description language="en">VUSB_HS_CLOCK_CONFIGURATION - constant determines the clocking used in the core.
1 = xcvr_clk_0 &lt; pe_clk = clk</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_RT_ENUM" high_bit="0" low_bit="0" name="RT">
                    <gui_name language="en">RT</gui_name>
                    <description language="en">VUSB_HS_RESET_TYPE - Reset Type.
1 = Use Asynchronous Resets</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HWHOST" offset="0xe0002008" size="0x4">
                <gui_name language="en">HWHOST</gui_name>
                <description language="en">Host hardware parameters as defined in configuration file</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="TTPER">
                    <gui_name language="en">TTPER</gui_name>
                    <description language="en">VUSB_HS_TT_PERIODIC_CONTEXTS</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="TTASY">
                    <gui_name language="en">TTASY</gui_name>
                    <description language="en">VUSB_HS_TT_ASYNC_CONTEXTS</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="4" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="1" name="NPORT">
                    <gui_name language="en">NPORT</gui_name>
                    <description language="en">VUSB_HS_NUM_PORT-1.
1- The VUSB_HS_NUM_PORT constant specifies the number of downstream ports by host port</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="HC">
                    <gui_name language="en">HC</gui_name>
                    <description language="en">VUSB_HS_HOST</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HWDEVICE" offset="0xe000200c" size="0x2">
                <gui_name language="en">HWDEVICE</gui_name>
                <description language="en">Device hardware parameters as defined in configuration file.</description>
                <bitField access="Read Only" high_bit="5" low_bit="1" name="DEVEP">
                    <gui_name language="en">DEVEP</gui_name>
                    <description language="en">VUSB_HS_DEV_EP - Number of endpoints.
12 = VUSB_HS_DEV_EP constant represents the 12 number of endpoints</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="DC">
                    <gui_name language="en">DC</gui_name>
                    <description language="en">Device capable</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HWTXBUF" offset="0xe0002010" size="0x4">
                <gui_name language="en">HWTXBUF</gui_name>
                <description language="en">TX buffer hardware parameters as defined in configuration file</description>
                <bitField access="Read Only" enumerationId="HWTXBUF_TXCHANADD_ENUM" high_bit="23" low_bit="16" name="TXCHANADD">
                    <gui_name language="en">TXCHANADD</gui_name>
                    <description language="en">VUSB_HS_TX_CHAN_ADD - Address bits for each Endpoint; 64 words buffer for each end point.
6 - To address 64 depth TX buffer for each end point</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="TXADD">
                    <gui_name language="en">TXADD</gui_name>
                    <description language="en">VUSB_HS_TX_ADD ; 768 Depth TX buffer.
10- Address of the depoth of TX buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="TXBURST">
                    <gui_name language="en">TXBURST</gui_name>
                    <description language="en">VUSB_HS_TX_BURST. Burst size for Memory To TX Buffer Transfers</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HWRXBUF" offset="0xe0002014" size="0x4">
                <gui_name language="en">HWRXBUF</gui_name>
                <description language="en">RX buffer hardware parameters as defined in configuration file</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="RXADD">
                    <gui_name language="en">RXADD</gui_name>
                    <description language="en">VUSB_HS_RX_ADD ; 768 Depth TX buffer.
10- Address of the depoth of TX buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="RXBURST">
                    <gui_name language="en">RXBURST</gui_name>
                    <description language="en">VUSB_HS_RX_BURST.
16 = Burst size of 16 for Memory To TX Buffer Transfers</description>
                </bitField>
            </register>
            <register name="USB0_GPTIMER0LD" offset="0xe0002080" size="0x4">
                <gui_name language="en">GPTIMER0LD</gui_name>
                <description language="en">This register contains the timer duration or load value. See the GPTIMER0CTRL for a description of the
timer functions</description>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTLD">
                    <gui_name language="en">GPTLD</gui_name>
                    <description language="en">General Purpose Timer Load Value register.
This field is the value to be loaded into the GPTCNT countdown timer on a reset action. The value in this register represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
Note: Max value is 0xFFFFFF or 16.777215 seconds</description>
                </bitField>
            </register>
            <register name="USB0_GPTIMER0CTRL" offset="0xe0002084" size="0x4">
                <gui_name language="en">GPTIMER0CTRL</gui_name>
                <description language="en">This register contains the control for the timer and a data field, which can be queried to determine the running
count value.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="GPTRUN">
                    <gui_name language="en">GPTRUN</gui_name>
                    <description language="en">General Purpose Timer Run. This bit enables the general-purpose timer to run. Setting or clearing this bit will not have an effect on the GPTCNT counter value.</description>
                </bitField>
                <bitField access="Write Only" high_bit="30" low_bit="30" name="GPTRST">
                    <gui_name language="en">GPTRST</gui_name>
                    <description language="en">General Purpose Timer Reset. Writing a one to this bit will reload the GPTCNT with the value in GPTLD.</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="25" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="GPTMODE">
                    <gui_name language="en">GPTMODE</gui_name>
                    <description language="en">0b' - One Shot; '1b' - Repeat. This bit selects between a single timer countdown and a looped countdown. In one-shot mode, the timer will count down to zero, generate an interrupt and stop until the counter is reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter to begin again.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTCNT">
                    <gui_name language="en">GPTCNT</gui_name>
                    <description language="en">General Purpose Timer Counter.
This field is the value of the running timer.</description>
                </bitField>
            </register>
            <register name="USB0_GPTIMER1LD" offset="0xe0002088" size="0x4">
                <gui_name language="en">GPTIMER1LD</gui_name>
                <description language="en">This register contains the timer duration or load value. See the GPTIMER0CTRL for a description of the
timer functions</description>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTLD">
                    <gui_name language="en">GPTLD</gui_name>
                    <description language="en">General Purpose Timer Load Value register.
This field is the value to be loaded into the GPTCNT countdown timer on a reset action. The value in this register represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
Note: Max value is 0xFFFFFF or 16.777215 seconds</description>
                </bitField>
            </register>
            <register name="USB0_GPTIMER1CTRL" offset="0xe000208c" size="0x4">
                <gui_name language="en">GPTIMER1CTRL</gui_name>
                <description language="en">This register contains the control for the timer and a data field, which can be queried to determine the running
count value.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="GPTRUN">
                    <gui_name language="en">GPTRUN</gui_name>
                    <description language="en">General Purpose Timer Run. This bit enables the general-purpose timer to run. Setting or clearing this bit will not have an effect on the GPTCNT counter value.</description>
                </bitField>
                <bitField access="Write Only" high_bit="30" low_bit="30" name="GPTRST">
                    <gui_name language="en">GPTRST</gui_name>
                    <description language="en">General Purpose Timer Reset. Writing a one to this bit will reload the GPTCNT with the value in GPTLD.</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="25" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="GPTMODE">
                    <gui_name language="en">GPTMODE</gui_name>
                    <description language="en">0b' - One Shot; '1b' - Repeat. This bit selects between a single timer countdown and a looped countdown. In one-shot mode, the timer will count down to zero, generate an interrupt and stop until the counter is reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter to begin again.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTCNT">
                    <gui_name language="en">GPTCNT</gui_name>
                    <description language="en">General Purpose Timer Counter.
This field is the value of the running timer.</description>
                </bitField>
            </register>
            <register name="USB0_SBUSCFG" offset="0xe0002090" size="0x2">
                <gui_name language="en">SBUSCFG</gui_name>
                <description language="en">This register contains the control for the system bus interface (such as AMBA / BVCI Master / Slave
interfaces).</description>
                <bitField access="Read Write" enumerationId="SBUSCFG_AHBBRST_ENUM" high_bit="2" low_bit="0" name="AHBBRST">
                    <gui_name language="en">AHBBRST</gui_name>
                    <description language="en">VUSB_HS_RX_BURST
0: incremental bursts of unspecified length
1: INCR4, non multiple transfers of 4 are decomposed to singles
2: INCR8, non multiple transfers of 8 are decomposed to INCR4 or singles
3: INCR16, non multiple transfers of 16 are decomposed to INCR8, INCR4 or singles
4: Do not use this value!
5: INCR4, non multiple transfers of 4 are decomposed to INCR of unspecifed length
6: INCR8, non multiple transfers of 8 are decomposed to INCR4 or INCR of unspecifed length
7: INCR16, non multiple transfers of 16 are decomposed to INCR8, INCR4 or INCR of unspecifed length</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_CAPLENGTH_HCIVERSION" offset="0xe0002100" size="0x4">
                <gui_name language="en">CAPLENGTH_HCIVERSION</gui_name>
                <description language="en">Device/Host Capability registers specify the software limits, restrictions, and capabilities of the host/device
controller implementation.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="HCIVERSION">
                    <gui_name language="en">HCIVERSION</gui_name>
                    <description language="en">This is a two-byte register containing a BCD encoding of the EHCI revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="CAPLENGTH">
                    <gui_name language="en">CAPLENGTH</gui_name>
                    <description language="en">This register indicates capability register length. This register is used to indicate which offset to add to the register base address at the beginning of the Operational Register</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HCSPARAMS" offset="0xe0002104" size="0x4">
                <gui_name language="en">HCSPARAMS</gui_name>
                <description language="en">Port steering logic capabilities are described in this register.</description>
                <bitField access="Read Only" high_bit="27" low_bit="24" name="N_TT">
                    <gui_name language="en">N_TT</gui_name>
                    <description language="en">This field indicates the number of embedded transaction translators associated with the USB2.0 host controller. For Multi-Port Host this field will always be equal to '0001b'. For all other implementation, N_TT = '0000b'.
This field will always be '0'</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="N_PTT">
                    <gui_name language="en">N_PTT</gui_name>
                    <description language="en">Number of Ports per Transaction Translator. This field indicates the number of ports assigned to each transaction translator within the USB2.0 host controller.
For Multi-Port Host this field will always equal N_PORTS. For all other implementations, N_PTT = '0000b'.
This in a non-EHCI field to support embedded TT.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="PI">
                    <gui_name language="en">PI</gui_name>
                    <description language="en">Port indicator. This bit indicates whether the ports support port indicator control. When set to one, the
port status and control registers include a read/writable field for controlling the state of
the port indicator. This field will always be '1'</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="12" name="N_CC">
                    <gui_name language="en">N_CC</gui_name>
                    <description language="en">This field indicates the number of companion controllers associated with this USB2.0 host controller. A zero in this field indicates there are no internal Companion Controllers. Portownership
hand-off is not supported. A value larger than zero in this field indicates there are companion USB1.1 host controller(s). Port-ownership hand-offs are supported. High, Full and Low speed devices are supported on the host controller root ports.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="N_PCC">
                    <gui_name language="en">N_PCC</gui_name>
                    <description language="en">This field indicates the number of ports supported per internal Companion Controller. It is used to indicate the port routing configuration to the system software.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HCSPARAMS_PPC_ENUM" high_bit="4" low_bit="4" name="PPC">
                    <gui_name language="en">PPC</gui_name>
                    <description language="en">Port Power Control. This field indicates whether the host controller implementation includes port power control.
1 =indicates the ports have port power switches.
0 = indicates the ports do not have port power switches.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="N_PORTS">
                    <gui_name language="en">N_PORTS</gui_name>
                    <description language="en">Number of downstream ports supported by the host controller</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_HCCPARAMS" offset="0xe0002108" size="0x2">
                <gui_name language="en">HCCPARAMS</gui_name>
                <description language="en">This register identifies multiple mode control (time-base bit functionality) addressing capability</description>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="EECP">
                    <gui_name language="en">EECP</gui_name>
                    <description language="en">No Description</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="IST">
                    <gui_name language="en">IST</gui_name>
                    <description language="en">Isochronous Scheduling Threshold.
This field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. When bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures (one or more) before flushing the state. When bit [7] is a one, then host software assumes the host controller may cache an isochronous data structure for an entire frame.
This field will always be 4'b0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="ASP">
                    <gui_name language="en">ASP</gui_name>
                    <description language="en">Asynchronous Schedule Park Capability. If this bit is set to a one, then the host controller supports the park feature for highspeed queue heads in the Asynchronous Schedule. The feature can be disabled or enabled and set to a specific level by using the Asynchronous Schedule Park Mode
Enable and Asynchronous Schedule Park Mode Count fields in the USBCMD register.
This field will always be '1'</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="PFL">
                    <gui_name language="en">PFL</gui_name>
                    <description language="en">If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller. The USBCMD register Frame List Size field is a read-only register and must be set to zero.
If set to a one, then the system software can specify and use a smaller frame list and configure the host controller via the USBCMD register Frame List Size field. The frame list must always be aligned on a 4K-page boundary. This field will always be '1'</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ADC">
                    <gui_name language="en">ADC</gui_name>
                    <description language="en">64-bit Addressing Capability. For thi scontroller its always 0</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_DCIVERSION" offset="0xe0002120" size="0x2">
                <gui_name language="en">DCIVERSION</gui_name>
                <description language="en">The device controller interface conforms to the two-byte BCD encoding of the interface version number
contained in this register.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="DCIVERSION">
                    <gui_name language="en">DCIVERSION</gui_name>
                    <description language="en">The device controller interface conforms to the two-byte BCD encoding of the interface version number
contained in this register</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_DCCPARAMS" offset="0xe0002124" size="0x2">
                <gui_name language="en">DCCPARAMS</gui_name>
                <description language="en">These fields describe the overall host/device capability of the controller</description>
                <bitField access="Read Only" enumerationId="DCCPARAMS_HC_ENUM" high_bit="8" low_bit="8" name="HC">
                    <gui_name language="en">HC</gui_name>
                    <description language="en">Host Capable. When this bit is 1, this controller is capable of operating as an EHCI compatible USB
2.0 host controller
1= The controller is USB 2.0 host controller capable</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DCCPARAMS_DC_ENUM" high_bit="7" low_bit="7" name="DC">
                    <gui_name language="en">DC</gui_name>
                    <description language="en">Device Capable register. When this bit is 1, this controller is capable of operating as a USB 2.0 device.
1= The controller is USB 2.0 device capable</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="5" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="DEN">
                    <gui_name language="en">DEN</gui_name>
                    <description language="en">This field indicates the number of endpoints built into the device controller.
12 = 12 endpoints are supported</description>
                </bitField>
            </register>
            <register name="USB0_USBCMD" offset="0xe0002140" size="0x4">
                <gui_name language="en">USBCMD</gui_name>
                <description language="en">The serial bus host/device controller executes the command indicated in this register</description>
                <bitField access="Read Write" enumerationId="USBCMD_ITC_ENUM" high_bit="23" low_bit="16" name="ITC">
                    <gui_name language="en">ITC</gui_name>
                    <description language="en">Interrupt Threshold Control. The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts.
00h Immediate (no threshold)
01h 1 micro-frame
02h 2 micro-frames
04h 4 micro-frames
08h 8 micro-frames
10h 16 micro-frames
20h 32 micro-frames
40h 64 micro-frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="FS2">
                    <gui_name language="en">FS2</gui_name>
                    <description language="en">MSB bit of FS field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="ATDTW">
                    <gui_name language="en">ATDTW</gui_name>
                    <description language="en">This bit is used as a semaphore to ensure the proper addition of a new dTD to an active (primed) endpoint's linked list.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="SUTW">
                    <gui_name language="en">SUTW</gui_name>
                    <description language="en">Setup TripWir. This bit is used as a semaphore to ensure that the setup data payload of 8 bytes is
extracted from a QH by the DCD without being corrupted. If the setup lockout mode is off (See USBMODE register) then there exists a hazard when new setup data arrives while the DCD is copying the setup data payload from the QH for a previous setup packet. This bit is set and cleared by software and will be cleared by hardware when a hazard exists.
Used only in device Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="ASPE">
                    <gui_name language="en">ASPE</gui_name>
                    <description language="en">If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1b and is R/W. Otherwise the bit must be a zero and is RO. Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.
This field is set to '1'b in this implementation. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ASP">
                    <gui_name language="en">ASP</gui_name>
                    <description language="en">If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this field defaults to 3h and is R/W. Otherwise it defaults to zero and is RO. It contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the Asynchronous schedule before
continuing traversal of the Asynchronous schedule.
This field is set to 3h in this implementation.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="LR">
                    <gui_name language="en">LR</gui_name>
                    <description language="en">Light Host/Device Controller Reset. This field will always be '0b'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="IAA">
                    <gui_name language="en">IAA</gui_name>
                    <description language="en">This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances the asynchronous schedule. Software must write a '1b' to this bit to ring the doorbell. This is used only in Host mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="ASE">
                    <gui_name language="en">ASE</gui_name>
                    <description language="en">This bit controls whether the host controller skips processing the Asynchronous Schedule.
Values Meaning :
0- Do not process the Asynchronous Schedule.
1- Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USBCMD_PSE_ENUM" high_bit="4" low_bit="4" name="PSE">
                    <gui_name language="en">PSE</gui_name>
                    <description language="en">This bit controls whether the host controller skips processing the Periodic Schedule. Values Meaning
0 -&gt; Do not process the Periodic Schedule
1 -&gt; Use the PERIODICLISTBASE register to access the Periodic Schedule.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USBCMD_FS0_ENUM" high_bit="3" low_bit="2" name="FS0">
                    <gui_name language="en">FS0</gui_name>
                    <description language="en">reserved
0 -&gt; 1024 elements (4096 bytes)
1 -&gt; 512 elements (2048 bytes)
2 -&gt; 256 elements (1024 bytes)
3 -&gt; 128 elements (512 bytes)
4 -&gt; 64 elements (256 bytes)
5 -&gt; 32 elements (128 bytes)
6 -&gt;16 elements (64 bytes)
7 -&gt; 8 elements (32 bytes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Software uses this bit to reset the controller. This bit is set to zero by the Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RS">
                    <gui_name language="en">RS</gui_name>
                    <description language="en">Run/Stop bit , When set to a 1, the Controller proceeds with the execution of the schedule.</description>
                </bitField>
            </register>
            <register name="USB0_USBSTS" offset="0xe0002144" size="0x4">
                <gui_name language="en">USBSTS</gui_name>
                <description language="en">This register indicates various states of the Controller and any pending interrupts. This register does not indicate status resulting from a transaction on the serial bus.</description>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TI1">
                    <gui_name language="en">TI1</gui_name>
                    <description language="en">This bit is set when the counter in the GPTIMER1CTRL register transitions to zero. Writing a one to this bit will clear it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TI0">
                    <gui_name language="en">TI0</gui_name>
                    <description language="en">This bit is set when the counter in the GPTIMER0CTRL register transitions to zero.
Writing a one to this bit will clear it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="UPI">
                    <gui_name language="en">UPI</gui_name>
                    <description language="en">This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule.
This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule. A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="UAI">
                    <gui_name language="en">UAI</gui_name>
                    <description language="en">USB Host Asynchronous Interrupt . This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule.
This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule. A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="NAKI">
                    <gui_name language="en">NAKI</gui_name>
                    <description language="en">NAK Interrupt. This bit is read-only. It is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and the corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware when the all the enabled TX/RX Endpoint NAK bits are cleared. This bit is not used by the host controller and will always be zero.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="AS">
                    <gui_name language="en">AS</gui_name>
                    <description language="en">This bit reports the current real status of the Asynchronous Schedule. When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.
The Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register. When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="PS">
                    <gui_name language="en">PS</gui_name>
                    <description language="en">Periodic Schedule Status. This bit reports the current real status of the Periodic Schedule. When set to zero the
periodic schedule is disabled, and if set to one the status is enabled. The Controller is not required to immediately disable or enable the Periodic Schedule when software
transitions the Periodic Schedule Enable bit in the USBCMD register. When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="RCL">
                    <gui_name language="en">RCL</gui_name>
                    <description language="en">Reclamation. This is a read-only status bit used to detect an empty asynchronous schedule. Used in Host mode only</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="HCH">
                    <gui_name language="en">HCH</gui_name>
                    <description language="en">HCHaIted. This bit is a zero whenever the Run/Stop bit is a one. The Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0, either by software or by the Controller hardware (e.g. internal error).
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ULPII">
                    <gui_name language="en">ULPII</gui_name>
                    <description language="en">ULPI Interrupt. When the ULPI Viewport is present in the design, an event completion will set this interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="SLI">
                    <gui_name language="en">SLI</gui_name>
                    <description language="en">DCSuspend. When a device controller enters a suspend state from an active state, this bit will be set to a one. This bit is only cleared by software writing a 1 to it.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="SRI">
                    <gui_name language="en">SRI</gui_name>
                    <description language="en">SOF Received. When the device controller detects a Start Of (u)Frame, this bit will be set to a one.
When a SOF is extremely late, the Controller, when in device mode, will automatically set this bit to indicate that an SOF was expected. Therefore, this bit will be set roughly every 1ms in FS mode and every 125us in HS mode and will be synchronized to the actual SOF that is received.
Since the Controller when in device mode is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.
Software writes a 1 to this bit to clear it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="URI">
                    <gui_name language="en">URI</gui_name>
                    <description language="en">USB Reset Received. When the Controller detects a USB Reset and enters the default state, this bit will be set to a one. Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="AAI">
                    <gui_name language="en">AAI</gui_name>
                    <description language="en">Interrupt on Async Advance. System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the
assertion of that interrupt source.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SEI">
                    <gui_name language="en">SEI</gui_name>
                    <description language="en">System Error. In the BVCI implementation of the USBHS core, this bit is not used, and will always be
cleared to '0b'. In the AMBA implementation, this bit will be set to '1b' when an Error response is seen by the master interface</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="FRI">
                    <gui_name language="en">FRI</gui_name>
                    <description language="en">Frame List Rollover
The Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Size field of the USBCMD register) is 1024, the Frame Index Register rolls over every time FRINDEX[13] toggles. Similarly, if the size is 512, the Controller sets this bit to a one every time FRINDEX[12] toggles. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PCI">
                    <gui_name language="en">PCI</gui_name>
                    <description language="en">Port Change Detect. The Controller in host mode sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
The Controller in device mode sets this bit to a one when it detects resume signaling or the port controller enters the full or high-speed operational state. When the port controller exits the full or high-speed operation states due to Reset or Suspend events, the notification mechanisms are the USB Reset Received bit and the DCSuspend bits respectively.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="UEI">
                    <gui_name language="en">UEI</gui_name>
                    <description language="en">USB Error Interrupt. When completion of a USB transaction results in an error condition, this bit is set by the Controller</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="UI">
                    <gui_name language="en">UI</gui_name>
                    <description language="en">This bit is set by the Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set.
This bit is also set by the Host Controller when a short packet is detected. A short packet is when the actual number of bytes received was less than expected.</description>
                </bitField>
            </register>
            <register name="USB0_USBINTR" offset="0xe0002148" size="0x4">
                <gui_name language="en">USBINTR</gui_name>
                <description language="en">The interrupts to software are enabled with this register. An interrupt is generated when a bit is set and the corresponding interrupt is active. The USB Status register (USBSTS) still shows interrupt sources even if they are disabled by the USBINTR register, allowing polling of interrupt events by the software.</description>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TIE1">
                    <gui_name language="en">TIE1</gui_name>
                    <description language="en">General Purpose Timer Interrupt Enable 1
When this bit is a one, and the TI1 bit in the EXTSTS register is a one, the controller will issue an interrupt. The interrupt is acknowledged by software clearing the TI1 bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TIE0">
                    <gui_name language="en">TIE0</gui_name>
                    <description language="en">General Purpose Timer Interrupt Enable 0
When this bit is a one, and the TI1 bit in the EXTSTS register is a one, the controller will issue an interrupt. The interrupt is acknowledged by software clearing the TI0 bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="UPEI">
                    <gui_name language="en">UPEI</gui_name>
                    <description language="en">USB Host Periodic Interrupt Enable.
When this bit is a one, and the UPI bit in the EXTSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the UPI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="UAEI">
                    <gui_name language="en">UAEI</gui_name>
                    <description language="en">USB Host Asynchronous Interrupt Enable
When this bit is a one, and the UAI bit in the EXTSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the UAI bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="NAKEI">
                    <gui_name language="en">NAKEI</gui_name>
                    <description language="en">NAK Interrupt Enable
when this bit is a one, and the NAKI bit in the EXTSTS register is a one, the controller will issue an interrupt. The interrupt is acknowledged by software clearing the NAKI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ULPIE">
                    <gui_name language="en">ULPIE</gui_name>
                    <description language="en">ULPI Interrupt enable. When this bit is a one, and the ULPI Interrupt bit in the USBSTS register transitions, the Controller will issue and interrupt. The interrupt is acknowledged by software writing a one to the ULPI Interrupt bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="SLE">
                    <gui_name language="en">SLE</gui_name>
                    <description language="en">DCSuspend Interrupt Enable.
When this bit is a one, and the SLI bit in the USBSTS register transitions, the Controller will issue an interrupt. The interrupt is acknowledged by software writing a one to the SLI bit.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="SRE">
                    <gui_name language="en">SRE</gui_name>
                    <description language="en">USB Reset Received Interrupt Enable
When this bit is a one, and the SRI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the SRI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="URE">
                    <gui_name language="en">URE</gui_name>
                    <description language="en">USB Reset Received. When the Controller detects a USB Reset and enters the default state, this bit will be set to a one. Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="AAE">
                    <gui_name language="en">AAE</gui_name>
                    <description language="en">Interrupt on Async Advance Enable. When this bit is a one, and the AAI bit in the USBSTS register is a one, the Controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the Interrupt on AAI bit.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SEE">
                    <gui_name language="en">SEE</gui_name>
                    <description language="en">System Error Interrupt Enable. When this bit is a one, and the SEI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the SSI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="FRE">
                    <gui_name language="en">FRE</gui_name>
                    <description language="en">Frame List Rollover Interrupt Enable
When this bit is a one, and the FRI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the FRI bit. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PCE">
                    <gui_name language="en">PCE</gui_name>
                    <description language="en">Port Change Detect Interrupt Enable
When this bit is a one, and the PCI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the PCI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="UEE">
                    <gui_name language="en">UEE</gui_name>
                    <description language="en">USB Error Interrupt
When this bit is a one, and the UEI bit in the USBSTS register is a one, the Controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by
software clearing the UEI bit in the USBSTS register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="UE">
                    <gui_name language="en">UE</gui_name>
                    <description language="en">When this bit is a one, and the UI bit in the USBSTS register is a one, the Controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by
software clearing the UI bit.</description>
                </bitField>
            </register>
            <register name="USB0_FRINDEX" offset="0xe000214c" size="0x2">
                <gui_name language="en">FRINDEX</gui_name>
                <description language="en">This register is used by the host controller to index the periodic frame list. The register updates every 125 us (once each micro-frame).</description>
                <bitField access="Read Write" enumerationId="FRINDEX_FRINDEX_ENUM" high_bit="13" low_bit="0" name="FRINDEX">
                    <gui_name language="en">FRINDEX</gui_name>
                    <description language="en">The value, in this register, increments at the end of each time frame (e.g. micro-frame). Bits [N:3] are used for the Frame List current index. This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index. The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.
usbcmd-&gt; FrameList-&gt; Size
000b -&gt;(1024) -&gt; 12
001b -&gt;(512) -&gt;11
010b -&gt;(256)-&gt;10
011b -&gt;(128) -&gt; 9
100b -&gt;(64) -&gt; 8
101b -&gt;(32) -&gt; 7
110b -&gt;(16) -&gt;6
111b -&gt;(8) -&gt;5
In device mode the value is the current frame number of the last frame transmitted. It is not used as an index.
This register is read-only in device mode.</description>
                </bitField>
            </register>
            <register name="USB0_PERIODICLISTBASE_DEVICEADDR" offset="0xe0002154" size="0x4">
                <gui_name language="en">PERIODICLISTBASE_DEVICEADDR</gui_name>
                <description language="en">This register is has two different uses when working in device or host mode.</description>
                <bitField access="Read Write" high_bit="31" low_bit="25" name="PERBASE_USBADRA">
                    <gui_name language="en">PERBASE_USBADRA</gui_name>
                    <description language="en">In host mode: Periodic List Base Address:
These bits correspond to memory address signals [31:12], respectively.
In Device Mode:
Device address advance
When this bit is '0b', any writes to USBADR are instantaneous. When this bit is written to a '1' at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register. After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the hidden register.
Hardware will automatically clear this bit on the following conditions:
1) IN is ACKed to endpoint 0. (USBADR is updated from hidden register).
2) OUT/SETUP occur to endpoint 0. (USBADR is not updated).
3) Device Reset occurs (USBADR is reset to 0).</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="PERBASE_USBADR">
                    <gui_name language="en">PERBASE_USBADR</gui_name>
                    <description language="en">In host mode: Periodic List Base Address:
These bits correspond to memory address signals [31:12], respectively.
In device Mode: USB Device address
These bits correspond to the USB device address</description>
                </bitField>
            </register>
            <register name="USB0_ASYNCLISTADDR_ENDPOINTLISTADDR" offset="0xe0002158" size="0x4">
                <gui_name language="en">ASYNCLISTADDR_ENDPOINTLISTADDR</gui_name>
                <description language="en">This register is has two different uses when working in device or host mode.</description>
                <bitField access="Read Write" high_bit="31" low_bit="11" name="ASYBASE_EPBASE">
                    <gui_name language="en">ASYBASE_EPBASE</gui_name>
                    <description language="en">In host mode: Asynchronous List Base Address:
These bits correspond to memory address signals [31:5], respectively. This field may only reference a Queue Head (QH).
In Device Mode:
Endpoint List Base Address
These bits correspond to memory address signals [31:11], respectively. This field will reference a list of up to 32 Queue Heads (QH). (i.e. one queue head per endpoint ANDdirection).</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="5" name="ASYBASE">
                    <gui_name language="en">ASYBASE</gui_name>
                    <description language="en">In host mode: Asynchronous List Base Address:
These bits correspond to memory address signals [31:5], respectively. This field may only reference a Queue Head (QH).
In Device Mode: Reserved</description>
                </bitField>
            </register>
            <register name="USB0_TTCTRL" offset="0xe000215c" size="0x4">
                <gui_name language="en">TTCTRL</gui_name>
                <description language="en">This register contains parameters needed for internal TT operations.</description>
                <bitField access="Read Write" high_bit="30" low_bit="24" name="TTHA">
                    <gui_name language="en">TTHA</gui_name>
                    <description language="en">Internal TT Hub Address Representation.
This field is used to match against the Hub Address field in QH AND siTD to determine if the packet is routed to the internal TT for directly attached FS/LS devices. If the Hub
Address in the QH or siTD does not match this address then the packet will be broadcast on the High Speed ports destined for a downstream High Speed hub with the
address in the QH/siTD.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TTAS">
                    <gui_name language="en">TTAS</gui_name>
                    <description language="en">Embedded TT Asynchronous Buffers Clear. This field will clear all pending transactions in the embedded TT Asynchronous Buffer(s). The clear will take as much time as necessary to clear buffer without
interfering with a transaction in progress. TTAC will return to zero after being set by software only after the actual clear occurs.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="TTAC">
                    <gui_name language="en">TTAC</gui_name>
                    <description language="en">Embedded TT Async Buffers Status. This read only bit will be '1' if one or more transactions are being held in the embedded TT Asynchronous Buffers. When this bit is a zero, then all outstanding transactions in the embedded TT have been flushed.</description>
                </bitField>
            </register>
            <register name="USB0_BURSTSIZE" offset="0xe0002160" size="0x4">
                <gui_name language="en">BURSTSIZE</gui_name>
                <description language="en">This register controls the burst size used during data movement on the initiator/master interface.</description>
                <bitField access="Read Write" high_bit="16" low_bit="8" name="TXPBURST">
                    <gui_name language="en">TXPBURST</gui_name>
                    <description language="en">Programmable TX Burst Length.
Default is the constant VUSB_HS_TX_BURST. This register represents the maximum length of a the burst in 32-bit words while moving data from system memory to the USB bus.
If field AHBBRST of register SBUSCFG is different from zero, this field TXPBRUST will return the value of the INCRx length.
Supported values are integer values from 4 to 128. It is recommended to set this value to a integer sub-multiple of VUSB_HS_TX_CHAN. Different values will not use all the available buffer space, preventing proper TX endpoint priming in stream disable mode (SDIS bit of USBMODE register set to '1').</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="RXPBURST">
                    <gui_name language="en">RXPBURST</gui_name>
                    <description language="en">Programmable RX Burst Length. Default is the constant VUSB_HS_RX_BURST. This register represents the maximum length of a the burst in 32-bit words while moving data from the USB bus to system memory. If field AHBBRST of register SBUSCFG is different from zero, this field RXPBRUST will return the value of the INCRx length.
The supported values are integer values from 4 to 128. It is recommended to set this value to a integer sub-multiple of VUSB_HS_RX_DEPTH.</description>
                </bitField>
            </register>
            <register name="USB0_TXFILLTUNING" offset="0xe0002164" size="0x4">
                <gui_name language="en">TXFILLTUNING</gui_name>
                <description language="en">The fields in this register control performance tuning associated with how the Controller posts data to the TX latency FIFO before moving the data onto the USB bus.</description>
                <bitField access="Read Write" high_bit="21" low_bit="16" name="TXFIFOTHRES">
                    <gui_name language="en">TXFIFOTHRES</gui_name>
                    <description language="en">FIFO Burst Threshold:
This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus. The minimum value is 2 and this value should be a low as possible to maximize USB performance. A higher value can be used in systems with unpredictable latency and/or insufficient bandwidth, where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory. This value is ignored if the Stream Disable bit in USBMODE register is set (SDIS).</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="8" name="TXSCHEALTH">
                    <gui_name language="en">TXSCHEALTH</gui_name>
                    <description language="en">Scheduler Health Counter.
This register increments when the Controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES before running out of time to send the packet before the next Start-Of-Frame.
This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH. Writing to this register will clear the counter. This counter will max. at 31.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="TXSCHOH">
                    <gui_name language="en">TXSCHOH</gui_name>
                    <description language="en">Scheduler Overhead.
This register adds an additional fixed offset to the schedule time estimator described above as Tff. As an approximation, the value chosen for this register should limit the number of back-off events captured in the TXSCHHEALTH to less than 10 per second in a highly utilized bus. Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization.
The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode for OTG(on the go) AND SPH(single port host) implementations.
The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode for OTG AND SPH implementations. The time unit represented in this register is always 1.267us for the MPH implementation</description>
                </bitField>
            </register>
            <register name="USB0_TXTTFILLTUNING" offset="0xe0002168" size="0x2">
                <gui_name language="en">TXTTFILLTUNING</gui_name>
                <description language="en">This register provides a function similar to TXFILLTUNING except there is no equivalent to TXFIFOTHRES because the TT TX latency FIFO is always loaded in a single burst. Even</description>
                <bitField access="Read Write" high_bit="12" low_bit="8" name="TXTTSCHHEALTH">
                    <gui_name language="en">TXTTSCHHEALTH</gui_name>
                    <description language="en">TT Scheduler Health Counter
Same description as TXSCHHEALTH</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="0" name="TXTTSCHOH">
                    <gui_name language="en">TXTTSCHOH</gui_name>
                    <description language="en">TT Scheduler Overhead
Same description as TXSCHOH.
The time unit represented in this register is 6.333us.</description>
                </bitField>
            </register>
            <register name="USB0_IC_USB" offset="0xe000216c" size="0x4">
                <gui_name language="en">IC_USB</gui_name>
                <description language="en">This register enable and controls the IC_USB FS/LS transceiver.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="IC8">
                    <gui_name language="en">IC8</gui_name>
                    <description language="en">Inter-Chip transceiver enable 8. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC8. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="28" name="IC_VDD8">
                    <gui_name language="en">IC_VDD8</gui_name>
                    <description language="en">Inter-Chip voltage selection 8
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="IC7">
                    <gui_name language="en">IC7</gui_name>
                    <description language="en">Inter-Chip transceiver enable 7. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC7. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="24" name="IC_VDD7">
                    <gui_name language="en">IC_VDD7</gui_name>
                    <description language="en">Inter-Chip voltage selection 7
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="IC6">
                    <gui_name language="en">IC6</gui_name>
                    <description language="en">Inter-Chip transceiver enable 6. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC6. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="20" name="IC_VDD6">
                    <gui_name language="en">IC_VDD6</gui_name>
                    <description language="en">Inter-Chip voltage selection 6
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="IC5">
                    <gui_name language="en">IC5</gui_name>
                    <description language="en">Inter-Chip transceiver enable 5. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC5. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="16" name="IC_VDD5">
                    <gui_name language="en">IC_VDD5</gui_name>
                    <description language="en">Inter-Chip voltage selection 5
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="IC4">
                    <gui_name language="en">IC4</gui_name>
                    <description language="en">Inter-Chip transceiver enable 4. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC4. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="IC_VDD4">
                    <gui_name language="en">IC_VDD4</gui_name>
                    <description language="en">Inter-Chip voltage selection 4
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="IC3">
                    <gui_name language="en">IC3</gui_name>
                    <description language="en">Inter-Chip transceiver enable 3. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC3. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="IC_VDD3">
                    <gui_name language="en">IC_VDD3</gui_name>
                    <description language="en">Inter-Chip voltage selection 3
It selects which voltage is being supplied to the peripheral through each port. This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="IC2">
                    <gui_name language="en">IC2</gui_name>
                    <description language="en">Inter-Chip transceiver enable 2. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC2. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="4" name="IC_VDD2">
                    <gui_name language="en">IC_VDD2</gui_name>
                    <description language="en">Inter-Chip voltage selection 2
It selects which voltage is being supplied to the peripheral through each port. This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="IC1">
                    <gui_name language="en">IC1</gui_name>
                    <description language="en">Inter-Chip transceiver enable 1. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC1. Writing a '1' to each bit selects the IC_USB interface for that port. If the Controller is not a MPH
implementation, IC8 to IC2 will be '0' and Read-Only.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IC_USB_IC_VDD1_ENUM" high_bit="2" low_bit="0" name="IC_VDD1">
                    <gui_name language="en">IC_VDD1</gui_name>
                    <description language="en">Inter-Chip voltage selection 1
It selects which voltage is being supplied to the peripheral through each port
000 - No voltage
001 - 1.0V
010 - 1.2V
011 - 1.5V
100 - 1.8V
101 - 3.0V
110 - Reserved
111 - Reserved
This field is read-only and set to '000b' in case of device mode operation.
The voltage negotiation should happen between enabling port power (PP) in PORTSC1 register and asserting the run/stop bit in USBCMD register.</description>
                </bitField>
            </register>
            <register name="USB0_ULPI_VIEWPORT" offset="0xe0002170" size="0x4">
                <gui_name language="en">ULPI_VIEWPORT</gui_name>
                <description language="en">The register provides indirect access to the ULPI PHY register set. Although the core performs access to the
ULPI PHY register set, there may be extraordinary circumstances where software may need direct access.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="ULPIWU">
                    <gui_name language="en">ULPIWU</gui_name>
                    <description language="en">ULPI Wakeup.
Writing the '1' to this bit will begin the wakeup operation. The bit will automatically transition to '0' after the wakeup is complete. Once this bit is set, the driver can not set it back to '0'.
Note: The driver must never execute a wakeup and a read/write operation at the same time.</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="ULPIRUN">
                    <gui_name language="en">ULPIRUN</gui_name>
                    <description language="en">ULPIRUN
Writing the '1' to this bit will begin the read/write operation. The bit will automatically transition to '0' after the read/write is complete. Once this bit is set, the driver can not set it back to '0'.
Note: The driver must never execute a wakeup and a read/write operation at the same time.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="ULPIRW">
                    <gui_name language="en">ULPIRW</gui_name>
                    <description language="en">ULPI Read/Write Control'0' - Read.'1' - Write.
This bit selects between running a read or write operation.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ULPISS">
                    <gui_name language="en">ULPISS</gui_name>
                    <description language="en">ULPI Data Address. When a read or write operation is commanded, the address of the operation is written to this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="ULPIPORT">
                    <gui_name language="en">ULPIPORT</gui_name>
                    <description language="en">ULPI Port Number.
For the wakeup or read/write operation to be executed, this value selects the port number to which a ULPI PHY is attached. The range is 0 to 7. This field should always be written '000b' for non MPH implementations.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ULPIADDR">
                    <gui_name language="en">ULPIADDR</gui_name>
                    <description language="en">ULPI Data Address. When a read or write operation is commanded, the address of the operation is written to this field.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="ULPIDATRD">
                    <gui_name language="en">ULPIDATRD</gui_name>
                    <description language="en">ULPI Data Read.
After a read operation completes, the result is placed in this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ULPIDATWR">
                    <gui_name language="en">ULPIDATWR</gui_name>
                    <description language="en">ULPI Data Write. When a write operation is commanded, the data to be sent is written to this field</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTNAK" offset="0xe0002178" size="0x4">
                <gui_name language="en">ENDPTNAK</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Write" enumerationId="ENDPTNAK_EPTN_ENUM" high_bit="31" low_bit="16" name="EPTN">
                    <gui_name language="en">EPTN</gui_name>
                    <description language="en">TX Endpoint NAK
Each TX endpoint has 1 bit in this field. The bit is set when the Controller sends a NAK handshake on a received IN token for the corresponding endpoint.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTNAK_EPRN_ENUM" high_bit="15" low_bit="0" name="EPRN">
                    <gui_name language="en">EPRN</gui_name>
                    <description language="en">RX Endpoint NAK
Each RX endpoint has 1 bit in this field. The bit is set when the Controller sends a NAK handshake on a received OUT or PING token for the corresponding endpoint.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTNAKEN" offset="0xe000217c" size="0x4">
                <gui_name language="en">ENDPTNAKEN</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Write" enumerationId="ENDPTNAKEN_EPTNE_ENUM" high_bit="31" low_bit="16" name="EPTNE">
                    <gui_name language="en">EPTNE</gui_name>
                    <description language="en">TX Endpoint NAK enable
Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the corresponding TX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTNAKEN_EPRNE_ENUM" high_bit="15" low_bit="0" name="EPRNE">
                    <gui_name language="en">EPRNE</gui_name>
                    <description language="en">RX Endpoint NAK enable
Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the corresponding RX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_CONFIGFLAG" offset="0xe0002180" size="0x4">
                <gui_name language="en">CONFIGFLAG</gui_name>
                <description language="en">This register is not used in this implementation. A read from this register returns a constant of a 00000001h to indicate that all port routings default to this host controller.</description>
            </register>
            <register name="USB0_PORTSC1" offset="0xe0002184" size="0x4">
                <gui_name language="en">PORTSC1</gui_name>
                <description language="en">The Controller implement one The number of port registers implemented by a particular instantiation is documented in the HCSPARAM register. Software uses this information as an input parameter to determine how many ports need service. This implement contains only 1 host port.</description>
                <bitField access="Read Write" high_bit="31" low_bit="30" name="PTS">
                    <gui_name language="en">PTS</gui_name>
                    <description language="en">This register bit pair is used in conjunction with the configuration constant VUSB_HS_PHY_TYPE to control which parallel transceiver interface is selected'010b' -&gt; 2, 6 - ULPI
Note that this field is made up from PORTSCx bits 25, 30 and 31.</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="STS">
                    <gui_name language="en">STS</gui_name>
                    <description language="en">Serial Transceiver Select
This register bit is used in conjunction with the configuration constant VUSB_HS_PHY_SERIAL to control whether the parallel or serial transceiver interface is selected for FS and LS operation. The Serial Interface Engine can be used in
combination with the UTMI+ physical interface to provide FS/LS signaling instead of the parallel interface. If VUSB_HS_PHY_SERIAL is set for 0 or 1 then this bit is read only. If VUSB_HS_PHY_SERIAL is 2 or 3 then this bit is read/write.
This bit has no effect unless Parallel Transceiver Select is set to UTMI+. The Serial/1.1 and IC_USB physical interface will use the Serial Interface Engine for FS/LS signaling
regardless of this bit value.</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="PTW">
                    <gui_name language="en">PTW</gui_name>
                    <description language="en">Parallel Transceiver Width. Writing this bit to '0' selects the 8-bit [60MHz] UTMI+ interface.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="26" name="PSPD">
                    <gui_name language="en">PSPD</gui_name>
                    <description language="en">Port Speed - RO. Default = 11b.
This register field indicates the speed at which the port is operating.'00b' -&gt; Full Speed'01b' -&gt; Low Speed'10b' -&gt; High Speed'11b' -&gt; Not connected</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="PTS2">
                    <gui_name language="en">PTS2</gui_name>
                    <description language="en">Parallel Transceiver Select - RW. Default = Implementation dependent.
MSB bit of PTS field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="PFSC">
                    <gui_name language="en">PFSC</gui_name>
                    <description language="en">Port Force Full Speed Connect - RW. Default = 0b.
Writing this bit to a '1b' will force the port to only connect at Full Speed. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device. This bit is for debugging purposes.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="PHCD">
                    <gui_name language="en">PHCD</gui_name>
                    <description language="en">PHY Low Power Clock Disable - RW. Default = 0b.
Writing this bit to a '1b' will disable the PHY clock. Writing a '0b' enables it. Reading this bit will indicate the status of the PHY clock. NOTE: The PHY clock cannot be disabled if it is being used as the system clock. In device mode, the PHY can be put into Low Power Clock Disable when the device is not running (USBCMD RS=0b) or the host has signaled suspend (PORTSCx SUSP=1b).
Low Power Clock Disable will be cleared automatically when the host has signaled resume. Before forcing a resume from the device, the Controller driver must clear this bit.
In host mode, the PHY can be put into Low Power Suspend Clock Disable when the downstream device has been put into suspend mode or when no downstream device is
connected. Low Power Clock Disable is completely under the control of software.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="WKOC">
                    <gui_name language="en">WKOC</gui_name>
                    <description language="en">Wake on Over-current Enable
Writing '1' to this bit enables the port to be sensitive to over-current conditions as wakeup events.
This field is zero if Port Power (PP) is '0' or in device mode.
This bit is output from the controller as signal pwrctl_wake_ovrcurr_en for use by an external power control circuit. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="WKDS">
                    <gui_name language="en">WKDS</gui_name>
                    <description language="en">Wake on Disconnect Enable
Writing this bit to a one enables the port to be sensitive to device disconnects as wakeup events. This field is zero if Port Power (PP) is '0' or in device mode. This bit is output from the controller as signal pwrctl_wake_dscnnt_en for use by an external power control circuit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="WKCN">
                    <gui_name language="en">WKCN</gui_name>
                    <description language="en">Wake on Connect Enable
Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. This field is zero if Port Power(PP) is '0' or in device mode. This bit is output from the controller as signal pwrctl_wake_cnnt_en for use by an external power control circuit. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PTC_ENUM" high_bit="19" low_bit="16" name="PTC">
                    <gui_name language="en">PTC</gui_name>
                    <description language="en">Port Test Control
Any other value than zero indicates that the port is operating in test mode.
Value Specific Test
0000b -&gt; TEST_MODE_DISABLE
0001b -&gt; J_ STATE
0010b -&gt; K_STATE
0011b -&gt; SE0 (host) / NAK (device)
0100b -&gt; Packet
0101b -&gt; FORCE_ENABLE_HS
0110b -&gt; FORCE_ENABLE_FS
0111b -&gt; FORCE_ENABLE_LS
1000b -&gt; Reserved
... Reserved
1111b
-&gt; Reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PIC_ENUM" high_bit="15" low_bit="14" name="PIC">
                    <gui_name language="en">PIC</gui_name>
                    <description language="en">Port Indicator Control
Writing to this field has no effect if the P_INDICATOR bit in the HCSPARAMS register is
a zero. If P_INDICATOR bit is a one, then the bits are:
Value Meaning
00b -&gt; Port indicators are off
01b -&gt; Amber
10b -&gt; Green
11b -&gt; Undefined
Refer to the USB Specification Revision 2.0 for a description on how these bits are to be used.This field is output from the controller as signals port_ind_ctl_1 and port_ind_ctl_0 for</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="PO">
                    <gui_name language="en">PO</gui_name>
                    <description language="en">Port Owner
Port owner hand off is not implemented in this design, therefore this bit will always read
back as 0b.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PP_ENUM" high_bit="12" low_bit="12" name="PP">
                    <gui_name language="en">PP</gui_name>
                    <description language="en">Port Power
The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:
PPC -&gt; PP -&gt; Operation
0b -&gt; 0b -&gt; Read Only. A Controller in device mode does not have port power control switches.
1b -&gt; 1b/0b -&gt; Read/Write. A Controller in host mode requires port power control switches.
This bit represents the current setting of the switch ('0'=off, '1'=on). When power is not available on a port (i.e. PP equals to '0'), the port is non-functional and will not report attaches, detaches, etc. When an over-current condition is detected on a powered port and PPC is a one, the PP bit in each affected port may be transitioned by the Controller driver from '1' to '0'(removing power from the port).
In device mode port power control is not necessary, thus PPC and PP = 0.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="PORTSC1_LS_ENUM" high_bit="11" low_bit="10" name="LS">
                    <gui_name language="en">LS</gui_name>
                    <description language="en">Line Status
These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines.
The encoding of the bits are:
00b -&gt; SE0
10b -&gt; J-state
01b -&gt; K-state
11b -&gt; Undefined
In host mode, the use of linestate by the Controller driver is not necessary (unlike EHCI), because the port controller state machine and the port routing manage the connection of LS and FS.
In device mode, the use of linestate by the Controller driver is not necessary.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="HSP">
                    <gui_name language="en">HSP</gui_name>
                    <description language="en">High-Speed Port
When the bit is one, the port is in high-speed mode and if set to zero, the port is not in a high-speed mode.
Note: HSP is redundant with PSPD but will remain in the design for compatibility.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="PR">
                    <gui_name language="en">PR</gui_name>
                    <description language="en">Port Reset - RW. Default = 0b.
This field is zero if Port Power(PP) is '0'.
Host mode: 1=Port is in Reset. 0=Port is not in Reset.
Device Mode: This bit is a read only status bit. Device reset from the USB bus is also indicated in the USBSTS register</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_SUSP_ENUM" high_bit="7" low_bit="7" name="SUSP">
                    <gui_name language="en">SUSP</gui_name>
                    <description language="en">Suspend
Host mode: 1=Port in suspend state. 0=Port not in suspend state. Port Enabled bit and Suspend bit of this register define the port states as follows:
Bits [Port Enabled, Suspend] Port State
0x Disable
10 Enable
11 Suspend
Device mode: Read Only. 1=Port in suspend state. 0=Port not in suspend state. In device mode this bit is a read only status bit.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_FPR_ENUM" high_bit="6" low_bit="6" name="FPR">
                    <gui_name language="en">FPR</gui_name>
                    <description language="en">Force Port Resume
1= Resume detected/driven on port.
0=No resume (K-state) detected/driven on port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="OCC">
                    <gui_name language="en">OCC</gui_name>
                    <description language="en">Over-current Change
This bit gets set to '1' when there is a change to Over-current Active. Software clears this bit by writing a '1' to this bit position.
When in host mode implementations the user can provide over-current detection to the vbus_pwr_fault input for this condition.
For device mode this bit shall always be '0'.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="OCA">
                    <gui_name language="en">OCA</gui_name>
                    <description language="en">Over-current Active
Value Meaning'1b' -&gt; This port currently has an over-current condition.'0b' -&gt; This port does not have an over-current condition.
This bit will automatically transition from '1' to '0' when the over current condition is removed.
For host mode implementations the user can provide over-current detection to the vbus_pwr_fault input for this condition.
For device mode implementations this bit shall always be '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PEC">
                    <gui_name language="en">PEC</gui_name>
                    <description language="en">Port Enabled Change
If set to '1' indicates a Port Enabled/Disabled status change.
Host mode:
For the root hub, this bit gets set to a '1' only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification). Software clears this by writing a '1' to it. This field is '0' if Port Power(PP) is '0'.
Device mode:
The device port is always enabled. (This bit will be '0').</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PE_ENUM" high_bit="2" low_bit="2" name="PE">
                    <gui_name language="en">PE</gui_name>
                    <description language="en">Port Enabled
1 -&gt; Enable
0-&gt; Disable
Host mode:
Ports can only be enabled by Controller as a part of the reset and enable. Software cannot enable a port by writing a '1' to this field. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the software.This field is '0' if Port Power(PP) is '0' in host mode.
Device mode:
The device port is always enabled. (This bit will be always '1').</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CSC">
                    <gui_name language="en">CSC</gui_name>
                    <description language="en">Connect Status Change
If set to '1' indicates a change in Current Connect Status (CCS).
Host mode:
Indicates a change has occurred in the port's Current Connect Status. The Controller sets this bit for all changes to the port device connect status, even if system software
has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be 'setting' an already-set bit (i.e., the bit will remain set). Software clears this bit by writing a '1' to it. This field is '0' if Port Power(PP) is '0' in host mode.
Device mode:
This bit is undefined in device mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="CCS">
                    <gui_name language="en">CCS</gui_name>
                    <description language="en">Current Connect Status.
Host mode:
1 -&gt; Device is present on port.
0 -&gt; No device is present.
Device mode:
1 -&gt; Attached.
0 -&gt; Not Attached.</description>
                </bitField>
            </register>
            <register name="USB0_OTGSC" offset="0xe00021a4" size="0x4">
                <gui_name language="en">OTGSC</gui_name>
                <description language="en">The Controller implements one On-The-Go (OTG) Status and Control register.
The OTGSC register has four sections:
OTG Interrupt enables (Read/Write)
OTG Interrupt status (Read/Write to Clear)
OTG Status inputs (Read Only)
OTG Controls (Read/Write)</description>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="DPIE">
                    <gui_name language="en">DPIE</gui_name>
                    <description language="en">Data Pulse Interrupt Enable
This bit enables the generation of an interrupt if bit DPIS is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OTGSC_n1msE_ENUM" high_bit="29" low_bit="29" name="n1msE">
                    <gui_name language="en">n1msE</gui_name>
                    <description language="en">1 millisecond timer Interrupt Enable
This bit enables the generation of an interrupt if bit 1msS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="BSEIE">
                    <gui_name language="en">BSEIE</gui_name>
                    <description language="en">B Session End Interrupt Enable
This bit enables the generation of an interrupt if bit BSEIS is set</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="BSVIE">
                    <gui_name language="en">BSVIE</gui_name>
                    <description language="en">B Session Valid Interrupt Enable
This bit enables the generation of an interrupt if bit BSVIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="ASVIE">
                    <gui_name language="en">ASVIE</gui_name>
                    <description language="en">A Session Valid Interrupt Enable
This bit enables the generation of an interrupt if bit ASVIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="AVVIE">
                    <gui_name language="en">AVVIE</gui_name>
                    <description language="en">A VBus Valid Interrupt Enable
This bit enables the generation of an interrupt if bit AVVIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="IDIE">
                    <gui_name language="en">IDIE</gui_name>
                    <description language="en">USB ID Interrupt Enable
This bit enables the generation of an interrupt if bit IDIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="DPIS">
                    <gui_name language="en">DPIS</gui_name>
                    <description language="en">Data Pulse Interrupt Status
This bit is set when data bus pulsing occurs on DP or DM. Data bus pulsing is only detected when USBMODE.CM = Host ('11b') and PORTSC0.PP = Off ('0b').
Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OTGSC_n1msS_ENUM" high_bit="21" low_bit="21" name="n1msS">
                    <gui_name language="en">n1msS</gui_name>
                    <description language="en">1 millisecond timer Interrupt Status.
This bit is set once every millisecond. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="BSEIS">
                    <gui_name language="en">BSEIS</gui_name>
                    <description language="en">B Session End Interrupt Status
This bit is set when VBus has fallen below the B session end threshold. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="BSVIS">
                    <gui_name language="en">BSVIS</gui_name>
                    <description language="en">B Session Valid Interrupt Status
This bit is set when VBus has either risen above or fallen below the B session valid threshold (0.8 VDC).
Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="ASVIS">
                    <gui_name language="en">ASVIS</gui_name>
                    <description language="en">A Session Valid Interrupt Status
This bit is set when VBus has either risen above or fallen below the A session valid threshold (0.8 VDC).
Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="AVVIS">
                    <gui_name language="en">AVVIS</gui_name>
                    <description language="en">Frame IndexThis bit is set when VBus has either risen above or fallen below the VBus valid threshold
(4.4 VDC) on an A device. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="IDIS">
                    <gui_name language="en">IDIS</gui_name>
                    <description language="en">USB ID Interrupt Status
This bit is set when a change on the ID input has been detected. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="DPS">
                    <gui_name language="en">DPS</gui_name>
                    <description language="en">Data Bus Pulsing Status
A '1' indicates data bus pulsing is being detected on the port.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="OTGSC_n1msT_ENUM" high_bit="13" low_bit="13" name="n1msT">
                    <gui_name language="en">n1msT</gui_name>
                    <description language="en">1 millisecond timer toggle
This bit toggles once per millisecond.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="BSE">
                    <gui_name language="en">BSE</gui_name>
                    <description language="en">B Session End
Indicates VBus is below the B session end threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="BSV">
                    <gui_name language="en">BSV</gui_name>
                    <description language="en">B Session Valid
Indicates VBus is above the B session valid threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="ASV">
                    <gui_name language="en">ASV</gui_name>
                    <description language="en">A Session Valid
Indicates VBus is above the A session valid threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="AVV">
                    <gui_name language="en">AVV</gui_name>
                    <description language="en">A VBus Valid.
Indicates VBus is above the A VBus valid threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="ID">
                    <gui_name language="en">ID</gui_name>
                    <description language="en">USB ID'0' = A device, '1' = B device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="HABA">
                    <gui_name language="en">HABA</gui_name>
                    <description language="en">Hardware Assist B-Disconnect to A-connect'0' = Disabled, '1' = Enable automatic B-disconnect to A-connect sequence.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="HADP">
                    <gui_name language="en">HADP</gui_name>
                    <description language="en">Hardware Assist Data-Pulse
If set, the hardware assist data pulsing sequence starts.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="IDPU">
                    <gui_name language="en">IDPU</gui_name>
                    <description language="en">ID Pullup
This bit provide control over the ID pull-up resister.'0' = off, '1' = on. When this bit is '0' the ID input will not be sampled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="DP">
                    <gui_name language="en">DP</gui_name>
                    <description language="en">Data Pulsing
Setting this bit causes the pullup on DP to be asserted for data pulsing during SRP.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="OT">
                    <gui_name language="en">OT</gui_name>
                    <description language="en">OTG Termination
This bit must be set when the Controller is in device mode. It controls the pulldown on DM.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="HAAR">
                    <gui_name language="en">HAAR</gui_name>
                    <description language="en">Hardware Assist Auto-Reset'0' = Disabled, '1' = Enable automatic reset after connect on host port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="VC">
                    <gui_name language="en">VC</gui_name>
                    <description language="en">VBUS Charge
Setting this bit causes the VBus line to be charged. This is used for VBus pulsing during SRP.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="VD">
                    <gui_name language="en">VD</gui_name>
                    <description language="en">VBUS Discharge.
Setting this bit causes VBus to discharge through a resistor.</description>
                </bitField>
            </register>
            <register name="USB0_USBMODE" offset="0xe00021a8" size="0x4">
                <gui_name language="en">USBMODE</gui_name>
                <description language="en">USB Mode Selection register</description>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="SRT">
                    <gui_name language="en">SRT</gui_name>
                    <description language="en">Shorten Reset Time
When the Controller is in host mode, this bit enables a bypass of the Chirp J/K reset handshake, saving 6-7ms in simulation time for each reset sequence. This bit should only be used for initial system integration simulations, and should always be set to 0 for
normal operation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="VBPS">
                    <gui_name language="en">VBPS</gui_name>
                    <description language="en">Vbus Power Select'0' -&gt; Output is '0''1' -&gt; Output is '1'This bit is connected to the vbus_pwr_select output and can be used for any generic control but is named to be used by logic that selects between an on-chip Vbus power source (charge pump) and an off-chip source in systems when both are available.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SDIS">
                    <gui_name language="en">SDIS</gui_name>
                    <description language="en">Stream Disable Mode'0' -&gt; Inactive'1' -&gt; Active
Device mode:
Setting to a '1' disables double priming on both RX and TX for low bandwidth systems.
Host Mode:
Setting to a '1' ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems where the RX and TX buffers are sufficient to contain the entire packet.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="SLOM">
                    <gui_name language="en">SLOM</gui_name>
                    <description language="en">Setup Lockout Mode
This bit controls behavior of the setup lock mechanism.'0' -&gt; Setup Lockouts On.'1' -&gt; Setup Lockouts Off (DCD requires use of Setup Data Buffer Tripwire in USBCMD).
Only used in device mode</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="ES">
                    <gui_name language="en">ES</gui_name>
                    <description language="en">Endian Select
This bit can change the byte ordering of the transfer buffers to match the host microprocessor bus architecture. The bit fields in the microprocessor interface and the DMA data structures (including the setup buffer within the device QH) are unaffected by the value of this bit, because they are based upon 32-bit words.'0' Little Endian -&gt; first byte referenced in least significant byte of 32-bit word.'1' Big Endian -&gt; first byte referenced in most significant byte of 32-bit word.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="CM">
                    <gui_name language="en">CM</gui_name>
                    <description language="en">Controller Mode
Controller mode is defaulted to the proper mode for host only and device only implementations. For those designs that contain both host AND device capability (OTG),
the Controller will default to an idle state and will need to be initialized to the desired operating mode after reset. For combination host/device controllers, this register can
only be written once after reset. If it is necessary to switch modes, software must reset the controller by writing to the RST bit in the USBCMD register before reprogramming
this register.
Value Meaning'00b' -&gt; Idle (Default for combination host/device).'01b' -&gt; Reserved.'10b' -&gt; Controller in device mode (Default for device only controller).'11b' -&gt; Controller in host mode (Default for host only controller).</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTSETUPSTAT" offset="0xe00021ac" size="0x2">
                <gui_name language="en">ENDPTSETUPSTAT</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="ENDPTSETUPSTAT">
                    <gui_name language="en">ENDPTSETUPSTAT</gui_name>
                    <description language="en">ENDPTSETUPSTATSetup Endpoint Status
For every setup transaction that is received, the corresponding bit in this register is set to '1'. Software must clear to acknowledge the setup transfer by writing a '1' to the respective bit after it has read the setup data from Queue Head. The response to a setup packet as in the order of operations and total response time is crucial to limit bus timeouts if the setup lockout mechanism is engaged.
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTPRIME" offset="0xe00021b0" size="0x4">
                <gui_name language="en">ENDPTPRIME</gui_name>
                <description language="en">Only implemented in device mode</description>
                <bitField access="Read Write" high_bit="31" low_bit="16" name="PETB">
                    <gui_name language="en">PETB</gui_name>
                    <description language="en">Prime Endpoint Transmit Buffer - RWS. Default = 0000h.
For each endpoint a corresponding bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction. Software
should write a '1' to the corresponding bit when posting a new transfer descriptor to an endpoint. Hardware will automatically use this bit to begin parsing for a new transfer
descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when the associated endpoint(s) is (are) successfully primed.
Note: These bits will be momentarily set by hardware during hardware re-priming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="PERB">
                    <gui_name language="en">PERB</gui_name>
                    <description language="en">Prime Endpoint Receive Buffer
For each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a USB host initiates a USB OUT transaction. Software should write a '1' to the corresponding bit whenever posting a new transfer descriptor to an endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when the associated endpoint(s) is (are) successfully primed.
Note: These bits will be momentarily set by hardware during hardware re-priming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTFLUSH" offset="0xe00021b4" size="0x4">
                <gui_name language="en">ENDPTFLUSH</gui_name>
                <description language="en">The Flush operation for an endpoint will clear the Ready status of that endpoint and re-align the Latency Buffer pointers, but not clear the actual data that resides in the Latency Buffers.</description>
                <bitField access="Read Write" high_bit="31" low_bit="16" name="FETB">
                    <gui_name language="en">FETB</gui_name>
                    <description language="en">Flush Endpoint Transmit Buffer
Writing a '1' to a bit(s) in this register will cause the associated endpoint(s) to clear any primed buffers. If a packet is in progress for one of the associated endpoints, then that
transfer will continue until completion. Hardware will clear this register after the endpoint flush operation is successful.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="FERB">
                    <gui_name language="en">FERB</gui_name>
                    <description language="en">Flush Endpoint Receive Buffer
Writing a '1' to a bit(s) will cause the associated endpoint(s) to clear any primed buffers. If a packet is in progress for one of the associated endpoints, then that transfer will
continue until completion. Hardware will clear this register after the endpoint flush operation is successful.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_ENDPTSTAT" offset="0xe00021b8" size="0x4">
                <gui_name language="en">ENDPTSTAT</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="ETBR">
                    <gui_name language="en">ETBR</gui_name>
                    <description language="en">Endpoint Transmit Buffer Ready
One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a '1' by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay time varies based upon the current USB traffic and the number of bits set in the
ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
Note: These bits will be momentarily cleared by hardware during hardware endpoint repriming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="ERBR">
                    <gui_name language="en">ERBR</gui_name>
                    <description language="en">Endpoint Receive Buffer Ready
One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a '1' by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay time varies based upon the current USB traffic and the number of bits set in the
ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
Note: These bits will be momentarily cleared by hardware during hardware endpoint repriming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB0_ENDPTCOMPLETE" offset="0xe00021bc" size="0x4">
                <gui_name language="en">ENDPTCOMPLETE</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Only" enumerationId="ENDPTCOMPLETE_ETCE_ENUM" high_bit="31" low_bit="16" name="ETCE">
                    <gui_name language="en">ETCE</gui_name>
                    <description language="en">Endpoint Transmit Complete Event
Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the
corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a '1' will clear the corresponding bit in this register.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ENDPTCOMPLETE_ERCE_ENUM" high_bit="15" low_bit="0" name="ERCE">
                    <gui_name language="en">ERCE</gui_name>
                    <description language="en">Endpoint Receive Complete Event
Each bit indicates a received event (OUT) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a '1' will clear the corresponding bit in this register.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL0" offset="0xe00021c0" size="0x4">
                <gui_name language="en">ENDPTCTRL0</gui_name>
                <description language="en">Every device will implement Endpoint0 as a control endpoint. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Endpoint0 is always enabled and this bit always set to '1'.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable
Endpoint0 is always enabled and this bit always set to '1'.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL1" offset="0xe00021c4" size="0x4">
                <gui_name language="en">ENDPTCTRL1</gui_name>
                <description language="en">This is an ENDPTCTRL1 register for the endpoint 1 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL1_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL1_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL2" offset="0xe00021c8" size="0x4">
                <gui_name language="en">ENDPTCTRL2</gui_name>
                <description language="en">This is an ENDPTCTRL2 register for the endpoint 2 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL2_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL2_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL3" offset="0xe00021cc" size="0x4">
                <gui_name language="en">ENDPTCTRL3</gui_name>
                <description language="en">This is an ENDPTCTRL3 register for the endpoint 3 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL3_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL3_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL4" offset="0xe00021d0" size="0x4">
                <gui_name language="en">ENDPTCTRL4</gui_name>
                <description language="en">This is an ENDPTCTRL4 register for the endpoint 4 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL4_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL4_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL5" offset="0xe00021d4" size="0x4">
                <gui_name language="en">ENDPTCTRL5</gui_name>
                <description language="en">This is an ENDPTCTRL5 register for the endpoint 5 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL5_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL5_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL6" offset="0xe00021d8" size="0x4">
                <gui_name language="en">ENDPTCTRL6</gui_name>
                <description language="en">This is an ENDPTCTRL6 register for the endpoint 6 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL6_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL6_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL7" offset="0xe00021dc" size="0x4">
                <gui_name language="en">ENDPTCTRL7</gui_name>
                <description language="en">This is an ENDPTCTRL7 register for the endpoint 7 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL7_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL7_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL8" offset="0xe00021e0" size="0x4">
                <gui_name language="en">ENDPTCTRL8</gui_name>
                <description language="en">This is an ENDPTCTRL8 register for the endpoint 8 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL8_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL8_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL9" offset="0xe00021e4" size="0x4">
                <gui_name language="en">ENDPTCTRL9</gui_name>
                <description language="en">This is an ENDPTCTRL9 register for the endpoint 9 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL9_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL9_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL10" offset="0xe00021e8" size="0x4">
                <gui_name language="en">ENDPTCTRL10</gui_name>
                <description language="en">This is an ENDPTCTRL10 register for the endpoint 10 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL10_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL10_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL11" offset="0xe00021ec" size="0x4">
                <gui_name language="en">ENDPTCTRL11</gui_name>
                <description language="en">This is an ENDPTCTRL11 register for the endpoint 11 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL11_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL11_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB0_ENDPTCTRL12" offset="0xe00021f0" size="0x4">
                <gui_name language="en">ENDPTCTRL12</gui_name>
                <description language="en">This is an ENDPTCTRL12 register for the endpoint 12 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL12_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL12_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
        </peripheral>
        <peripheral address_type="Non-Secure" base_addr="M_USB1" name="USB1" offset="0xe0003000">
            <gui_name language="en">usb1</gui_name>
            <description language="en">usb1</description>
            <register access="Read Only" name="USB1_ID" offset="0xe0003000" size="0x4">
                <gui_name language="en">ID</gui_name>
                <description language="en">The ID register identifies the USB-HS 2.0 core and its revision</description>
                <bitField access="Read Only" high_bit="31" low_bit="29" name="CIVERSION">
                    <gui_name language="en">CIVERSION</gui_name>
                    <description language="en">Identifies the CI version</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="25" name="VERSION">
                    <gui_name language="en">VERSION</gui_name>
                    <description language="en">Identifies the version of the core</description>
                </bitField>
                <bitField access="Read Only" high_bit="24" low_bit="21" name="REVISION">
                    <gui_name language="en">REVISION</gui_name>
                    <description language="en">Revision number of the core</description>
                </bitField>
                <bitField access="Read Only" high_bit="20" low_bit="16" name="TAG">
                    <gui_name language="en">TAG</gui_name>
                    <description language="en">Identifies the tag of the core ; Current 2.20a version</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="8" name="NID">
                    <gui_name language="en">NID</gui_name>
                    <description language="en">NID Complement of ID; Ones complement version of ID</description>
                </bitField>
                <bitField access="Read Only" high_bit="5" low_bit="0" name="ID">
                    <gui_name language="en">ID</gui_name>
                    <description language="en">ID Configuration number ; This number indicates the type of the USB-HS 2.0 core.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HWGENERAL" offset="0xe0003004" size="0x2">
                <gui_name language="en">HWGENERAL</gui_name>
                <description language="en">General hardware parameters as defined in configuration file.</description>
                <bitField access="Read Only" enumerationId="HWGENERAL_SM_ENUM" high_bit="11" low_bit="10" name="SM">
                    <gui_name language="en">SM</gui_name>
                    <description language="en">VUSB_HS_PHY_SERIAL - This constant selects that the serial engine is used or not.
0 - No Serial Engine- Always use parallel signalling</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_PHYM_ENUM" high_bit="9" low_bit="6" name="PHYM">
                    <gui_name language="en">PHYM</gui_name>
                    <description language="en">VUSB_HS_PHY_TYPE
- PHY interface type.
2 = ULPI</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_PHYW_ENUM" high_bit="5" low_bit="4" name="PHYW">
                    <gui_name language="en">PHYW</gui_name>
                    <description language="en">VUSB_HS_PHY16_8 - This constant selects which phy is being used.
0 = 8 bit wide data bus [60MHz clock from the transciever]</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="BWT">
                    <gui_name language="en">BWT</gui_name>
                    <description language="en">RESERVED.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_CLKC_ENUM" high_bit="2" low_bit="1" name="CLKC">
                    <gui_name language="en">CLKC</gui_name>
                    <description language="en">VUSB_HS_CLOCK_CONFIGURATION - constant determines the clocking used in the core.
1 = xcvr_clk_0 &lt; pe_clk = clk</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HWGENERAL_RT_ENUM" high_bit="0" low_bit="0" name="RT">
                    <gui_name language="en">RT</gui_name>
                    <description language="en">VUSB_HS_RESET_TYPE - Reset Type.
1 = Use Asynchronous Resets</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HWHOST" offset="0xe0003008" size="0x4">
                <gui_name language="en">HWHOST</gui_name>
                <description language="en">Host hardware parameters as defined in configuration file</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="TTPER">
                    <gui_name language="en">TTPER</gui_name>
                    <description language="en">VUSB_HS_TT_PERIODIC_CONTEXTS</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="16" name="TTASY">
                    <gui_name language="en">TTASY</gui_name>
                    <description language="en">VUSB_HS_TT_ASYNC_CONTEXTS</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="4" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="1" name="NPORT">
                    <gui_name language="en">NPORT</gui_name>
                    <description language="en">VUSB_HS_NUM_PORT-1.
1- The VUSB_HS_NUM_PORT constant specifies the number of downstream ports by host port</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="HC">
                    <gui_name language="en">HC</gui_name>
                    <description language="en">VUSB_HS_HOST</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HWDEVICE" offset="0xe000300c" size="0x2">
                <gui_name language="en">HWDEVICE</gui_name>
                <description language="en">Device hardware parameters as defined in configuration file.</description>
                <bitField access="Read Only" high_bit="5" low_bit="1" name="DEVEP">
                    <gui_name language="en">DEVEP</gui_name>
                    <description language="en">VUSB_HS_DEV_EP - Number of endpoints.
12 = VUSB_HS_DEV_EP constant represents the 12 number of endpoints</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="DC">
                    <gui_name language="en">DC</gui_name>
                    <description language="en">Device capable</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HWTXBUF" offset="0xe0003010" size="0x4">
                <gui_name language="en">HWTXBUF</gui_name>
                <description language="en">TX buffer hardware parameters as defined in configuration file</description>
                <bitField access="Read Only" enumerationId="HWTXBUF_TXCHANADD_ENUM" high_bit="23" low_bit="16" name="TXCHANADD">
                    <gui_name language="en">TXCHANADD</gui_name>
                    <description language="en">VUSB_HS_TX_CHAN_ADD - Address bits for each Endpoint; 64 words buffer for each end point.
6 - To address 64 depth TX buffer for each end point</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="TXADD">
                    <gui_name language="en">TXADD</gui_name>
                    <description language="en">VUSB_HS_TX_ADD ; 768 Depth TX buffer.
10- Address of the depoth of TX buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="TXBURST">
                    <gui_name language="en">TXBURST</gui_name>
                    <description language="en">VUSB_HS_TX_BURST. Burst size for Memory To TX Buffer Transfers</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HWRXBUF" offset="0xe0003014" size="0x4">
                <gui_name language="en">HWRXBUF</gui_name>
                <description language="en">RX buffer hardware parameters as defined in configuration file</description>
                <bitField access="Read Only" high_bit="31" low_bit="24" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">RESERVED</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="RXADD">
                    <gui_name language="en">RXADD</gui_name>
                    <description language="en">VUSB_HS_RX_ADD ; 768 Depth TX buffer.
10- Address of the depoth of TX buffer</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="0" name="RXBURST">
                    <gui_name language="en">RXBURST</gui_name>
                    <description language="en">VUSB_HS_RX_BURST.
16 = Burst size of 16 for Memory To TX Buffer Transfers</description>
                </bitField>
            </register>
            <register name="USB1_GPTIMER0LD" offset="0xe0003080" size="0x4">
                <gui_name language="en">GPTIMER0LD</gui_name>
                <description language="en">This register contains the timer duration or load value. See the GPTIMER0CTRL for a description of the
timer functions</description>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTLD">
                    <gui_name language="en">GPTLD</gui_name>
                    <description language="en">General Purpose Timer Load Value register.
This field is the value to be loaded into the GPTCNT countdown timer on a reset action. The value in this register represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
Note: Max value is 0xFFFFFF or 16.777215 seconds</description>
                </bitField>
            </register>
            <register name="USB1_GPTIMER0CTRL" offset="0xe0003084" size="0x4">
                <gui_name language="en">GPTIMER0CTRL</gui_name>
                <description language="en">This register contains the control for the timer and a data field, which can be queried to determine the running
count value.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="GPTRUN">
                    <gui_name language="en">GPTRUN</gui_name>
                    <description language="en">General Purpose Timer Run. This bit enables the general-purpose timer to run. Setting or clearing this bit will not have an effect on the GPTCNT counter value.</description>
                </bitField>
                <bitField access="Write Only" high_bit="30" low_bit="30" name="GPTRST">
                    <gui_name language="en">GPTRST</gui_name>
                    <description language="en">General Purpose Timer Reset. Writing a one to this bit will reload the GPTCNT with the value in GPTLD.</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="25" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="GPTMODE">
                    <gui_name language="en">GPTMODE</gui_name>
                    <description language="en">0b' - One Shot; '1b' - Repeat. This bit selects between a single timer countdown and a looped countdown. In one-shot mode, the timer will count down to zero, generate an interrupt and stop until the counter is reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter to begin again.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTCNT">
                    <gui_name language="en">GPTCNT</gui_name>
                    <description language="en">General Purpose Timer Counter.
This field is the value of the running timer.</description>
                </bitField>
            </register>
            <register name="USB1_GPTIMER1LD" offset="0xe0003088" size="0x4">
                <gui_name language="en">GPTIMER1LD</gui_name>
                <description language="en">This register contains the timer duration or load value. See the GPTIMER0CTRL for a description of the
timer functions</description>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTLD">
                    <gui_name language="en">GPTLD</gui_name>
                    <description language="en">General Purpose Timer Load Value register.
This field is the value to be loaded into the GPTCNT countdown timer on a reset action. The value in this register represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
Note: Max value is 0xFFFFFF or 16.777215 seconds</description>
                </bitField>
            </register>
            <register name="USB1_GPTIMER1CTRL" offset="0xe000308c" size="0x4">
                <gui_name language="en">GPTIMER1CTRL</gui_name>
                <description language="en">This register contains the control for the timer and a data field, which can be queried to determine the running
count value.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="GPTRUN">
                    <gui_name language="en">GPTRUN</gui_name>
                    <description language="en">General Purpose Timer Run. This bit enables the general-purpose timer to run. Setting or clearing this bit will not have an effect on the GPTCNT counter value.</description>
                </bitField>
                <bitField access="Write Only" high_bit="30" low_bit="30" name="GPTRST">
                    <gui_name language="en">GPTRST</gui_name>
                    <description language="en">General Purpose Timer Reset. Writing a one to this bit will reload the GPTCNT with the value in GPTLD.</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="25" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="GPTMODE">
                    <gui_name language="en">GPTMODE</gui_name>
                    <description language="en">0b' - One Shot; '1b' - Repeat. This bit selects between a single timer countdown and a looped countdown. In one-shot mode, the timer will count down to zero, generate an interrupt and stop until the counter is reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter to begin again.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="0" name="GPTCNT">
                    <gui_name language="en">GPTCNT</gui_name>
                    <description language="en">General Purpose Timer Counter.
This field is the value of the running timer.</description>
                </bitField>
            </register>
            <register name="USB1_SBUSCFG" offset="0xe0003090" size="0x2">
                <gui_name language="en">SBUSCFG</gui_name>
                <description language="en">This register contains the control for the system bus interface (such as AMBA / BVCI Master / Slave
interfaces).</description>
                <bitField access="Read Write" enumerationId="SBUSCFG_AHBBRST_ENUM" high_bit="2" low_bit="0" name="AHBBRST">
                    <gui_name language="en">AHBBRST</gui_name>
                    <description language="en">VUSB_HS_RX_BURST
0: incremental bursts of unspecified length
1: INCR4, non multiple transfers of 4 are decomposed to singles
2: INCR8, non multiple transfers of 8 are decomposed to INCR4 or singles
3: INCR16, non multiple transfers of 16 are decomposed to INCR8, INCR4 or singles
4: Do not use this value!
5: INCR4, non multiple transfers of 4 are decomposed to INCR of unspecifed length
6: INCR8, non multiple transfers of 8 are decomposed to INCR4 or INCR of unspecifed length
7: INCR16, non multiple transfers of 16 are decomposed to INCR8, INCR4 or INCR of unspecifed length</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_CAPLENGTH_HCIVERSION" offset="0xe0003100" size="0x4">
                <gui_name language="en">CAPLENGTH_HCIVERSION</gui_name>
                <description language="en">Device/Host Capability registers specify the software limits, restrictions, and capabilities of the host/device
controller implementation.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="HCIVERSION">
                    <gui_name language="en">HCIVERSION</gui_name>
                    <description language="en">This is a two-byte register containing a BCD encoding of the EHCI revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="CAPLENGTH">
                    <gui_name language="en">CAPLENGTH</gui_name>
                    <description language="en">This register indicates capability register length. This register is used to indicate which offset to add to the register base address at the beginning of the Operational Register</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HCSPARAMS" offset="0xe0003104" size="0x4">
                <gui_name language="en">HCSPARAMS</gui_name>
                <description language="en">Port steering logic capabilities are described in this register.</description>
                <bitField access="Read Only" high_bit="27" low_bit="24" name="N_TT">
                    <gui_name language="en">N_TT</gui_name>
                    <description language="en">This field indicates the number of embedded transaction translators associated with the USB2.0 host controller. For Multi-Port Host this field will always be equal to '0001b'. For all other implementation, N_TT = '0000b'.
This field will always be '0'</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="20" name="N_PTT">
                    <gui_name language="en">N_PTT</gui_name>
                    <description language="en">Number of Ports per Transaction Translator. This field indicates the number of ports assigned to each transaction translator within the USB2.0 host controller.
For Multi-Port Host this field will always equal N_PORTS. For all other implementations, N_PTT = '0000b'.
This in a non-EHCI field to support embedded TT.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="PI">
                    <gui_name language="en">PI</gui_name>
                    <description language="en">Port indicator. This bit indicates whether the ports support port indicator control. When set to one, the
port status and control registers include a read/writable field for controlling the state of
the port indicator. This field will always be '1'</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="12" name="N_CC">
                    <gui_name language="en">N_CC</gui_name>
                    <description language="en">This field indicates the number of companion controllers associated with this USB2.0 host controller. A zero in this field indicates there are no internal Companion Controllers. Portownership
hand-off is not supported. A value larger than zero in this field indicates there are companion USB1.1 host controller(s). Port-ownership hand-offs are supported. High, Full and Low speed devices are supported on the host controller root ports.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="8" name="N_PCC">
                    <gui_name language="en">N_PCC</gui_name>
                    <description language="en">This field indicates the number of ports supported per internal Companion Controller. It is used to indicate the port routing configuration to the system software.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="HCSPARAMS_PPC_ENUM" high_bit="4" low_bit="4" name="PPC">
                    <gui_name language="en">PPC</gui_name>
                    <description language="en">Port Power Control. This field indicates whether the host controller implementation includes port power control.
1 =indicates the ports have port power switches.
0 = indicates the ports do not have port power switches.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="0" name="N_PORTS">
                    <gui_name language="en">N_PORTS</gui_name>
                    <description language="en">Number of downstream ports supported by the host controller</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_HCCPARAMS" offset="0xe0003108" size="0x2">
                <gui_name language="en">HCCPARAMS</gui_name>
                <description language="en">This register identifies multiple mode control (time-base bit functionality) addressing capability</description>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="EECP">
                    <gui_name language="en">EECP</gui_name>
                    <description language="en">No Description</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="4" name="IST">
                    <gui_name language="en">IST</gui_name>
                    <description language="en">Isochronous Scheduling Threshold.
This field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. When bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures (one or more) before flushing the state. When bit [7] is a one, then host software assumes the host controller may cache an isochronous data structure for an entire frame.
This field will always be 4'b0</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="3" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="ASP">
                    <gui_name language="en">ASP</gui_name>
                    <description language="en">Asynchronous Schedule Park Capability. If this bit is set to a one, then the host controller supports the park feature for highspeed queue heads in the Asynchronous Schedule. The feature can be disabled or enabled and set to a specific level by using the Asynchronous Schedule Park Mode
Enable and Asynchronous Schedule Park Mode Count fields in the USBCMD register.
This field will always be '1'</description>
                </bitField>
                <bitField access="Read Only" high_bit="1" low_bit="1" name="PFL">
                    <gui_name language="en">PFL</gui_name>
                    <description language="en">If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller. The USBCMD register Frame List Size field is a read-only register and must be set to zero.
If set to a one, then the system software can specify and use a smaller frame list and configure the host controller via the USBCMD register Frame List Size field. The frame list must always be aligned on a 4K-page boundary. This field will always be '1'</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="ADC">
                    <gui_name language="en">ADC</gui_name>
                    <description language="en">64-bit Addressing Capability. For thi scontroller its always 0</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_DCIVERSION" offset="0xe0003120" size="0x2">
                <gui_name language="en">DCIVERSION</gui_name>
                <description language="en">The device controller interface conforms to the two-byte BCD encoding of the interface version number
contained in this register.</description>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="DCIVERSION">
                    <gui_name language="en">DCIVERSION</gui_name>
                    <description language="en">The device controller interface conforms to the two-byte BCD encoding of the interface version number
contained in this register</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_DCCPARAMS" offset="0xe0003124" size="0x2">
                <gui_name language="en">DCCPARAMS</gui_name>
                <description language="en">These fields describe the overall host/device capability of the controller</description>
                <bitField access="Read Only" enumerationId="DCCPARAMS_HC_ENUM" high_bit="8" low_bit="8" name="HC">
                    <gui_name language="en">HC</gui_name>
                    <description language="en">Host Capable. When this bit is 1, this controller is capable of operating as an EHCI compatible USB
2.0 host controller
1= The controller is USB 2.0 host controller capable</description>
                </bitField>
                <bitField access="Read Only" enumerationId="DCCPARAMS_DC_ENUM" high_bit="7" low_bit="7" name="DC">
                    <gui_name language="en">DC</gui_name>
                    <description language="en">Device Capable register. When this bit is 1, this controller is capable of operating as a USB 2.0 device.
1= The controller is USB 2.0 device capable</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="5" name="a">
                    <gui_name language="en">a</gui_name>
                    <description language="en">reserved</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="0" name="DEN">
                    <gui_name language="en">DEN</gui_name>
                    <description language="en">This field indicates the number of endpoints built into the device controller.
12 = 12 endpoints are supported</description>
                </bitField>
            </register>
            <register name="USB1_USBCMD" offset="0xe0003140" size="0x4">
                <gui_name language="en">USBCMD</gui_name>
                <description language="en">The serial bus host/device controller executes the command indicated in this register</description>
                <bitField access="Read Write" enumerationId="USBCMD_ITC_ENUM" high_bit="23" low_bit="16" name="ITC">
                    <gui_name language="en">ITC</gui_name>
                    <description language="en">Interrupt Threshold Control. The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts.
00h Immediate (no threshold)
01h 1 micro-frame
02h 2 micro-frames
04h 4 micro-frames
08h 8 micro-frames
10h 16 micro-frames
20h 32 micro-frames
40h 64 micro-frames</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="FS2">
                    <gui_name language="en">FS2</gui_name>
                    <description language="en">MSB bit of FS field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="14" low_bit="14" name="ATDTW">
                    <gui_name language="en">ATDTW</gui_name>
                    <description language="en">This bit is used as a semaphore to ensure the proper addition of a new dTD to an active (primed) endpoint's linked list.</description>
                </bitField>
                <bitField access="Read Write" high_bit="13" low_bit="13" name="SUTW">
                    <gui_name language="en">SUTW</gui_name>
                    <description language="en">Setup TripWir. This bit is used as a semaphore to ensure that the setup data payload of 8 bytes is
extracted from a QH by the DCD without being corrupted. If the setup lockout mode is off (See USBMODE register) then there exists a hazard when new setup data arrives while the DCD is copying the setup data payload from the QH for a previous setup packet. This bit is set and cleared by software and will be cleared by hardware when a hazard exists.
Used only in device Mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="11" low_bit="11" name="ASPE">
                    <gui_name language="en">ASPE</gui_name>
                    <description language="en">If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1b and is R/W. Otherwise the bit must be a zero and is RO. Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.
This field is set to '1'b in this implementation. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="9" low_bit="8" name="ASP">
                    <gui_name language="en">ASP</gui_name>
                    <description language="en">If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this field defaults to 3h and is R/W. Otherwise it defaults to zero and is RO. It contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the Asynchronous schedule before
continuing traversal of the Asynchronous schedule.
This field is set to 3h in this implementation.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="LR">
                    <gui_name language="en">LR</gui_name>
                    <description language="en">Light Host/Device Controller Reset. This field will always be '0b'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="IAA">
                    <gui_name language="en">IAA</gui_name>
                    <description language="en">This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances the asynchronous schedule. Software must write a '1b' to this bit to ring the doorbell. This is used only in Host mode</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="ASE">
                    <gui_name language="en">ASE</gui_name>
                    <description language="en">This bit controls whether the host controller skips processing the Asynchronous Schedule.
Values Meaning :
0- Do not process the Asynchronous Schedule.
1- Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USBCMD_PSE_ENUM" high_bit="4" low_bit="4" name="PSE">
                    <gui_name language="en">PSE</gui_name>
                    <description language="en">This bit controls whether the host controller skips processing the Periodic Schedule. Values Meaning
0 -&gt; Do not process the Periodic Schedule
1 -&gt; Use the PERIODICLISTBASE register to access the Periodic Schedule.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="USBCMD_FS0_ENUM" high_bit="3" low_bit="2" name="FS0">
                    <gui_name language="en">FS0</gui_name>
                    <description language="en">reserved
0 -&gt; 1024 elements (4096 bytes)
1 -&gt; 512 elements (2048 bytes)
2 -&gt; 256 elements (1024 bytes)
3 -&gt; 128 elements (512 bytes)
4 -&gt; 64 elements (256 bytes)
5 -&gt; 32 elements (128 bytes)
6 -&gt;16 elements (64 bytes)
7 -&gt; 8 elements (32 bytes)</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="RST">
                    <gui_name language="en">RST</gui_name>
                    <description language="en">Software uses this bit to reset the controller. This bit is set to zero by the Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RS">
                    <gui_name language="en">RS</gui_name>
                    <description language="en">Run/Stop bit , When set to a 1, the Controller proceeds with the execution of the schedule.</description>
                </bitField>
            </register>
            <register name="USB1_USBSTS" offset="0xe0003144" size="0x4">
                <gui_name language="en">USBSTS</gui_name>
                <description language="en">This register indicates various states of the Controller and any pending interrupts. This register does not indicate status resulting from a transaction on the serial bus.</description>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TI1">
                    <gui_name language="en">TI1</gui_name>
                    <description language="en">This bit is set when the counter in the GPTIMER1CTRL register transitions to zero. Writing a one to this bit will clear it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TI0">
                    <gui_name language="en">TI0</gui_name>
                    <description language="en">This bit is set when the counter in the GPTIMER0CTRL register transitions to zero.
Writing a one to this bit will clear it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="UPI">
                    <gui_name language="en">UPI</gui_name>
                    <description language="en">This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule.
This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule. A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="UAI">
                    <gui_name language="en">UAI</gui_name>
                    <description language="en">USB Host Asynchronous Interrupt . This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule.
This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule. A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="NAKI">
                    <gui_name language="en">NAKI</gui_name>
                    <description language="en">NAK Interrupt. This bit is read-only. It is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and the corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware when the all the enabled TX/RX Endpoint NAK bits are cleared. This bit is not used by the host controller and will always be zero.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="AS">
                    <gui_name language="en">AS</gui_name>
                    <description language="en">This bit reports the current real status of the Asynchronous Schedule. When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.
The Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register. When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="PS">
                    <gui_name language="en">PS</gui_name>
                    <description language="en">Periodic Schedule Status. This bit reports the current real status of the Periodic Schedule. When set to zero the
periodic schedule is disabled, and if set to one the status is enabled. The Controller is not required to immediately disable or enable the Periodic Schedule when software
transitions the Periodic Schedule Enable bit in the USBCMD register. When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="RCL">
                    <gui_name language="en">RCL</gui_name>
                    <description language="en">Reclamation. This is a read-only status bit used to detect an empty asynchronous schedule. Used in Host mode only</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="HCH">
                    <gui_name language="en">HCH</gui_name>
                    <description language="en">HCHaIted. This bit is a zero whenever the Run/Stop bit is a one. The Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0, either by software or by the Controller hardware (e.g. internal error).
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ULPII">
                    <gui_name language="en">ULPII</gui_name>
                    <description language="en">ULPI Interrupt. When the ULPI Viewport is present in the design, an event completion will set this interrupt.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="SLI">
                    <gui_name language="en">SLI</gui_name>
                    <description language="en">DCSuspend. When a device controller enters a suspend state from an active state, this bit will be set to a one. This bit is only cleared by software writing a 1 to it.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="SRI">
                    <gui_name language="en">SRI</gui_name>
                    <description language="en">SOF Received. When the device controller detects a Start Of (u)Frame, this bit will be set to a one.
When a SOF is extremely late, the Controller, when in device mode, will automatically set this bit to indicate that an SOF was expected. Therefore, this bit will be set roughly every 1ms in FS mode and every 125us in HS mode and will be synchronized to the actual SOF that is received.
Since the Controller when in device mode is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.
Software writes a 1 to this bit to clear it.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="URI">
                    <gui_name language="en">URI</gui_name>
                    <description language="en">USB Reset Received. When the Controller detects a USB Reset and enters the default state, this bit will be set to a one. Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="AAI">
                    <gui_name language="en">AAI</gui_name>
                    <description language="en">Interrupt on Async Advance. System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the
assertion of that interrupt source.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SEI">
                    <gui_name language="en">SEI</gui_name>
                    <description language="en">System Error. In the BVCI implementation of the USBHS core, this bit is not used, and will always be
cleared to '0b'. In the AMBA implementation, this bit will be set to '1b' when an Error response is seen by the master interface</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="FRI">
                    <gui_name language="en">FRI</gui_name>
                    <description language="en">Frame List Rollover
The Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Size field of the USBCMD register) is 1024, the Frame Index Register rolls over every time FRINDEX[13] toggles. Similarly, if the size is 512, the Controller sets this bit to a one every time FRINDEX[12] toggles. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PCI">
                    <gui_name language="en">PCI</gui_name>
                    <description language="en">Port Change Detect. The Controller in host mode sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
The Controller in device mode sets this bit to a one when it detects resume signaling or the port controller enters the full or high-speed operational state. When the port controller exits the full or high-speed operation states due to Reset or Suspend events, the notification mechanisms are the USB Reset Received bit and the DCSuspend bits respectively.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="UEI">
                    <gui_name language="en">UEI</gui_name>
                    <description language="en">USB Error Interrupt. When completion of a USB transaction results in an error condition, this bit is set by the Controller</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="UI">
                    <gui_name language="en">UI</gui_name>
                    <description language="en">This bit is set by the Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set.
This bit is also set by the Host Controller when a short packet is detected. A short packet is when the actual number of bytes received was less than expected.</description>
                </bitField>
            </register>
            <register name="USB1_USBINTR" offset="0xe0003148" size="0x4">
                <gui_name language="en">USBINTR</gui_name>
                <description language="en">The interrupts to software are enabled with this register. An interrupt is generated when a bit is set and the corresponding interrupt is active. The USB Status register (USBSTS) still shows interrupt sources even if they are disabled by the USBINTR register, allowing polling of interrupt events by the software.</description>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="TIE1">
                    <gui_name language="en">TIE1</gui_name>
                    <description language="en">General Purpose Timer Interrupt Enable 1
When this bit is a one, and the TI1 bit in the EXTSTS register is a one, the controller will issue an interrupt. The interrupt is acknowledged by software clearing the TI1 bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="TIE0">
                    <gui_name language="en">TIE0</gui_name>
                    <description language="en">General Purpose Timer Interrupt Enable 0
When this bit is a one, and the TI1 bit in the EXTSTS register is a one, the controller will issue an interrupt. The interrupt is acknowledged by software clearing the TI0 bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="UPEI">
                    <gui_name language="en">UPEI</gui_name>
                    <description language="en">USB Host Periodic Interrupt Enable.
When this bit is a one, and the UPI bit in the EXTSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the UPI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="UAEI">
                    <gui_name language="en">UAEI</gui_name>
                    <description language="en">USB Host Asynchronous Interrupt Enable
When this bit is a one, and the UAI bit in the EXTSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the UAI bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="16" low_bit="16" name="NAKEI">
                    <gui_name language="en">NAKEI</gui_name>
                    <description language="en">NAK Interrupt Enable
when this bit is a one, and the NAKI bit in the EXTSTS register is a one, the controller will issue an interrupt. The interrupt is acknowledged by software clearing the NAKI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="10" name="ULPIE">
                    <gui_name language="en">ULPIE</gui_name>
                    <description language="en">ULPI Interrupt enable. When this bit is a one, and the ULPI Interrupt bit in the USBSTS register transitions, the Controller will issue and interrupt. The interrupt is acknowledged by software writing a one to the ULPI Interrupt bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="SLE">
                    <gui_name language="en">SLE</gui_name>
                    <description language="en">DCSuspend Interrupt Enable.
When this bit is a one, and the SLI bit in the USBSTS register transitions, the Controller will issue an interrupt. The interrupt is acknowledged by software writing a one to the SLI bit.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="SRE">
                    <gui_name language="en">SRE</gui_name>
                    <description language="en">USB Reset Received Interrupt Enable
When this bit is a one, and the SRI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the SRI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="URE">
                    <gui_name language="en">URE</gui_name>
                    <description language="en">USB Reset Received. When the Controller detects a USB Reset and enters the default state, this bit will be set to a one. Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="AAE">
                    <gui_name language="en">AAE</gui_name>
                    <description language="en">Interrupt on Async Advance Enable. When this bit is a one, and the AAI bit in the USBSTS register is a one, the Controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the Interrupt on AAI bit.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SEE">
                    <gui_name language="en">SEE</gui_name>
                    <description language="en">System Error Interrupt Enable. When this bit is a one, and the SEI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the SSI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="FRE">
                    <gui_name language="en">FRE</gui_name>
                    <description language="en">Frame List Rollover Interrupt Enable
When this bit is a one, and the FRI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the FRI bit. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="PCE">
                    <gui_name language="en">PCE</gui_name>
                    <description language="en">Port Change Detect Interrupt Enable
When this bit is a one, and the PCI bit in the USBSTS register is a one, the Controller will issue an interrupt. The interrupt is acknowledged by software clearing the PCI bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="UEE">
                    <gui_name language="en">UEE</gui_name>
                    <description language="en">USB Error Interrupt
When this bit is a one, and the UEI bit in the USBSTS register is a one, the Controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by
software clearing the UEI bit in the USBSTS register.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="UE">
                    <gui_name language="en">UE</gui_name>
                    <description language="en">When this bit is a one, and the UI bit in the USBSTS register is a one, the Controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by
software clearing the UI bit.</description>
                </bitField>
            </register>
            <register name="USB1_FRINDEX" offset="0xe000314c" size="0x2">
                <gui_name language="en">FRINDEX</gui_name>
                <description language="en">This register is used by the host controller to index the periodic frame list. The register updates every 125 us (once each micro-frame).</description>
                <bitField access="Read Write" enumerationId="FRINDEX_FRINDEX_ENUM" high_bit="13" low_bit="0" name="FRINDEX">
                    <gui_name language="en">FRINDEX</gui_name>
                    <description language="en">The value, in this register, increments at the end of each time frame (e.g. micro-frame). Bits [N:3] are used for the Frame List current index. This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index. The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.
usbcmd-&gt; FrameList-&gt; Size
000b -&gt;(1024) -&gt; 12
001b -&gt;(512) -&gt;11
010b -&gt;(256)-&gt;10
011b -&gt;(128) -&gt; 9
100b -&gt;(64) -&gt; 8
101b -&gt;(32) -&gt; 7
110b -&gt;(16) -&gt;6
111b -&gt;(8) -&gt;5
In device mode the value is the current frame number of the last frame transmitted. It is not used as an index.
This register is read-only in device mode.</description>
                </bitField>
            </register>
            <register name="USB1_PERIODICLISTBASE_DEVICEADDR" offset="0xe0003154" size="0x4">
                <gui_name language="en">PERIODICLISTBASE_DEVICEADDR</gui_name>
                <description language="en">This register is has two different uses when working in device or host mode.</description>
                <bitField access="Read Write" high_bit="31" low_bit="25" name="PERBASE_USBADRA">
                    <gui_name language="en">PERBASE_USBADRA</gui_name>
                    <description language="en">In host mode: Periodic List Base Address:
These bits correspond to memory address signals [31:12], respectively.
In Device Mode:
Device address advance
When this bit is '0b', any writes to USBADR are instantaneous. When this bit is written to a '1' at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register. After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the hidden register.
Hardware will automatically clear this bit on the following conditions:
1) IN is ACKed to endpoint 0. (USBADR is updated from hidden register).
2) OUT/SETUP occur to endpoint 0. (USBADR is not updated).
3) Device Reset occurs (USBADR is reset to 0).</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="PERBASE_USBADR">
                    <gui_name language="en">PERBASE_USBADR</gui_name>
                    <description language="en">In host mode: Periodic List Base Address:
These bits correspond to memory address signals [31:12], respectively.
In device Mode: USB Device address
These bits correspond to the USB device address</description>
                </bitField>
            </register>
            <register name="USB1_ASYNCLISTADDR_ENDPOINTLISTADDR" offset="0xe0003158" size="0x4">
                <gui_name language="en">ASYNCLISTADDR_ENDPOINTLISTADDR</gui_name>
                <description language="en">This register is has two different uses when working in device or host mode.</description>
                <bitField access="Read Write" high_bit="31" low_bit="11" name="ASYBASE_EPBASE">
                    <gui_name language="en">ASYBASE_EPBASE</gui_name>
                    <description language="en">In host mode: Asynchronous List Base Address:
These bits correspond to memory address signals [31:5], respectively. This field may only reference a Queue Head (QH).
In Device Mode:
Endpoint List Base Address
These bits correspond to memory address signals [31:11], respectively. This field will reference a list of up to 32 Queue Heads (QH). (i.e. one queue head per endpoint ANDdirection).</description>
                </bitField>
                <bitField access="Read Write" high_bit="10" low_bit="5" name="ASYBASE">
                    <gui_name language="en">ASYBASE</gui_name>
                    <description language="en">In host mode: Asynchronous List Base Address:
These bits correspond to memory address signals [31:5], respectively. This field may only reference a Queue Head (QH).
In Device Mode: Reserved</description>
                </bitField>
            </register>
            <register name="USB1_TTCTRL" offset="0xe000315c" size="0x4">
                <gui_name language="en">TTCTRL</gui_name>
                <description language="en">This register contains parameters needed for internal TT operations.</description>
                <bitField access="Read Write" high_bit="30" low_bit="24" name="TTHA">
                    <gui_name language="en">TTHA</gui_name>
                    <description language="en">Internal TT Hub Address Representation.
This field is used to match against the Hub Address field in QH AND siTD to determine if the packet is routed to the internal TT for directly attached FS/LS devices. If the Hub
Address in the QH or siTD does not match this address then the packet will be broadcast on the High Speed ports destined for a downstream High Speed hub with the
address in the QH/siTD.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="TTAS">
                    <gui_name language="en">TTAS</gui_name>
                    <description language="en">Embedded TT Asynchronous Buffers Clear. This field will clear all pending transactions in the embedded TT Asynchronous Buffer(s). The clear will take as much time as necessary to clear buffer without
interfering with a transaction in progress. TTAC will return to zero after being set by software only after the actual clear occurs.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="TTAC">
                    <gui_name language="en">TTAC</gui_name>
                    <description language="en">Embedded TT Async Buffers Status. This read only bit will be '1' if one or more transactions are being held in the embedded TT Asynchronous Buffers. When this bit is a zero, then all outstanding transactions in the embedded TT have been flushed.</description>
                </bitField>
            </register>
            <register name="USB1_BURSTSIZE" offset="0xe0003160" size="0x4">
                <gui_name language="en">BURSTSIZE</gui_name>
                <description language="en">This register controls the burst size used during data movement on the initiator/master interface.</description>
                <bitField access="Read Write" high_bit="16" low_bit="8" name="TXPBURST">
                    <gui_name language="en">TXPBURST</gui_name>
                    <description language="en">Programmable TX Burst Length.
Default is the constant VUSB_HS_TX_BURST. This register represents the maximum length of a the burst in 32-bit words while moving data from system memory to the USB bus.
If field AHBBRST of register SBUSCFG is different from zero, this field TXPBRUST will return the value of the INCRx length.
Supported values are integer values from 4 to 128. It is recommended to set this value to a integer sub-multiple of VUSB_HS_TX_CHAN. Different values will not use all the available buffer space, preventing proper TX endpoint priming in stream disable mode (SDIS bit of USBMODE register set to '1').</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="RXPBURST">
                    <gui_name language="en">RXPBURST</gui_name>
                    <description language="en">Programmable RX Burst Length. Default is the constant VUSB_HS_RX_BURST. This register represents the maximum length of a the burst in 32-bit words while moving data from the USB bus to system memory. If field AHBBRST of register SBUSCFG is different from zero, this field RXPBRUST will return the value of the INCRx length.
The supported values are integer values from 4 to 128. It is recommended to set this value to a integer sub-multiple of VUSB_HS_RX_DEPTH.</description>
                </bitField>
            </register>
            <register name="USB1_TXFILLTUNING" offset="0xe0003164" size="0x4">
                <gui_name language="en">TXFILLTUNING</gui_name>
                <description language="en">The fields in this register control performance tuning associated with how the Controller posts data to the TX latency FIFO before moving the data onto the USB bus.</description>
                <bitField access="Read Write" high_bit="21" low_bit="16" name="TXFIFOTHRES">
                    <gui_name language="en">TXFIFOTHRES</gui_name>
                    <description language="en">FIFO Burst Threshold:
This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus. The minimum value is 2 and this value should be a low as possible to maximize USB performance. A higher value can be used in systems with unpredictable latency and/or insufficient bandwidth, where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory. This value is ignored if the Stream Disable bit in USBMODE register is set (SDIS).</description>
                </bitField>
                <bitField access="Read Write" high_bit="12" low_bit="8" name="TXSCHEALTH">
                    <gui_name language="en">TXSCHEALTH</gui_name>
                    <description language="en">Scheduler Health Counter.
This register increments when the Controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES before running out of time to send the packet before the next Start-Of-Frame.
This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH. Writing to this register will clear the counter. This counter will max. at 31.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="0" name="TXSCHOH">
                    <gui_name language="en">TXSCHOH</gui_name>
                    <description language="en">Scheduler Overhead.
This register adds an additional fixed offset to the schedule time estimator described above as Tff. As an approximation, the value chosen for this register should limit the number of back-off events captured in the TXSCHHEALTH to less than 10 per second in a highly utilized bus. Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization.
The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode for OTG(on the go) AND SPH(single port host) implementations.
The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode for OTG AND SPH implementations. The time unit represented in this register is always 1.267us for the MPH implementation</description>
                </bitField>
            </register>
            <register name="USB1_TXTTFILLTUNING" offset="0xe0003168" size="0x2">
                <gui_name language="en">TXTTFILLTUNING</gui_name>
                <description language="en">This register provides a function similar to TXFILLTUNING except there is no equivalent to TXFIFOTHRES because the TT TX latency FIFO is always loaded in a single burst. Even</description>
                <bitField access="Read Write" high_bit="12" low_bit="8" name="TXTTSCHHEALTH">
                    <gui_name language="en">TXTTSCHHEALTH</gui_name>
                    <description language="en">TT Scheduler Health Counter
Same description as TXSCHHEALTH</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="0" name="TXTTSCHOH">
                    <gui_name language="en">TXTTSCHOH</gui_name>
                    <description language="en">TT Scheduler Overhead
Same description as TXSCHOH.
The time unit represented in this register is 6.333us.</description>
                </bitField>
            </register>
            <register name="USB1_IC_USB" offset="0xe000316c" size="0x4">
                <gui_name language="en">IC_USB</gui_name>
                <description language="en">This register enable and controls the IC_USB FS/LS transceiver.</description>
                <bitField access="Read Only" high_bit="31" low_bit="31" name="IC8">
                    <gui_name language="en">IC8</gui_name>
                    <description language="en">Inter-Chip transceiver enable 8. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC8. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="30" low_bit="28" name="IC_VDD8">
                    <gui_name language="en">IC_VDD8</gui_name>
                    <description language="en">Inter-Chip voltage selection 8
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="IC7">
                    <gui_name language="en">IC7</gui_name>
                    <description language="en">Inter-Chip transceiver enable 7. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC7. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="26" low_bit="24" name="IC_VDD7">
                    <gui_name language="en">IC_VDD7</gui_name>
                    <description language="en">Inter-Chip voltage selection 7
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="IC6">
                    <gui_name language="en">IC6</gui_name>
                    <description language="en">Inter-Chip transceiver enable 6. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC6. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="20" name="IC_VDD6">
                    <gui_name language="en">IC_VDD6</gui_name>
                    <description language="en">Inter-Chip voltage selection 6
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="19" name="IC5">
                    <gui_name language="en">IC5</gui_name>
                    <description language="en">Inter-Chip transceiver enable 5. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC5. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="18" low_bit="16" name="IC_VDD5">
                    <gui_name language="en">IC_VDD5</gui_name>
                    <description language="en">Inter-Chip voltage selection 5
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="15" name="IC4">
                    <gui_name language="en">IC4</gui_name>
                    <description language="en">Inter-Chip transceiver enable 4. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC4. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="12" name="IC_VDD4">
                    <gui_name language="en">IC_VDD4</gui_name>
                    <description language="en">Inter-Chip voltage selection 4
It selects which voltage is being supplied to the peripheral through each port This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="IC3">
                    <gui_name language="en">IC3</gui_name>
                    <description language="en">Inter-Chip transceiver enable 3. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC3. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="8" name="IC_VDD3">
                    <gui_name language="en">IC_VDD3</gui_name>
                    <description language="en">Inter-Chip voltage selection 3
It selects which voltage is being supplied to the peripheral through each port. This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="IC2">
                    <gui_name language="en">IC2</gui_name>
                    <description language="en">Inter-Chip transceiver enable 2. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC2. Writing a '1' to each bit selects the IC_USB interface for that port.</description>
                </bitField>
                <bitField access="Read Only" high_bit="6" low_bit="4" name="IC_VDD2">
                    <gui_name language="en">IC_VDD2</gui_name>
                    <description language="en">Inter-Chip voltage selection 2
It selects which voltage is being supplied to the peripheral through each port. This field is read-only and set to '000b' in case of device mode operation.
This field is read-only and set to '000b' in case of Single port host controller.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="IC1">
                    <gui_name language="en">IC1</gui_name>
                    <description language="en">Inter-Chip transceiver enable 1. These bits enables the Inter-Chip transceiver for each port (for the MPH case). To enable the interface, the bits PTS must be set to '011b' in the PORTSC1. Writing a '1' to each bit selects the IC_USB interface for that port. If the Controller is not a MPH
implementation, IC8 to IC2 will be '0' and Read-Only.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="IC_USB_IC_VDD1_ENUM" high_bit="2" low_bit="0" name="IC_VDD1">
                    <gui_name language="en">IC_VDD1</gui_name>
                    <description language="en">Inter-Chip voltage selection 1
It selects which voltage is being supplied to the peripheral through each port
000 - No voltage
001 - 1.0V
010 - 1.2V
011 - 1.5V
100 - 1.8V
101 - 3.0V
110 - Reserved
111 - Reserved
This field is read-only and set to '000b' in case of device mode operation.
The voltage negotiation should happen between enabling port power (PP) in PORTSC1 register and asserting the run/stop bit in USBCMD register.</description>
                </bitField>
            </register>
            <register name="USB1_ULPI_VIEWPORT" offset="0xe0003170" size="0x4">
                <gui_name language="en">ULPI_VIEWPORT</gui_name>
                <description language="en">The register provides indirect access to the ULPI PHY register set. Although the core performs access to the
ULPI PHY register set, there may be extraordinary circumstances where software may need direct access.</description>
                <bitField access="Read Write" high_bit="31" low_bit="31" name="ULPIWU">
                    <gui_name language="en">ULPIWU</gui_name>
                    <description language="en">ULPI Wakeup.
Writing the '1' to this bit will begin the wakeup operation. The bit will automatically transition to '0' after the wakeup is complete. Once this bit is set, the driver can not set it back to '0'.
Note: The driver must never execute a wakeup and a read/write operation at the same time.</description>
                </bitField>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="ULPIRUN">
                    <gui_name language="en">ULPIRUN</gui_name>
                    <description language="en">ULPIRUN
Writing the '1' to this bit will begin the read/write operation. The bit will automatically transition to '0' after the read/write is complete. Once this bit is set, the driver can not set it back to '0'.
Note: The driver must never execute a wakeup and a read/write operation at the same time.</description>
                </bitField>
                <bitField access="Read Write" high_bit="29" low_bit="29" name="ULPIRW">
                    <gui_name language="en">ULPIRW</gui_name>
                    <description language="en">ULPI Read/Write Control'0' - Read.'1' - Write.
This bit selects between running a read or write operation.</description>
                </bitField>
                <bitField access="Read Only" high_bit="27" low_bit="27" name="ULPISS">
                    <gui_name language="en">ULPISS</gui_name>
                    <description language="en">ULPI Data Address. When a read or write operation is commanded, the address of the operation is written to this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="24" name="ULPIPORT">
                    <gui_name language="en">ULPIPORT</gui_name>
                    <description language="en">ULPI Port Number.
For the wakeup or read/write operation to be executed, this value selects the port number to which a ULPI PHY is attached. The range is 0 to 7. This field should always be written '000b' for non MPH implementations.</description>
                </bitField>
                <bitField access="Read Write" high_bit="23" low_bit="16" name="ULPIADDR">
                    <gui_name language="en">ULPIADDR</gui_name>
                    <description language="en">ULPI Data Address. When a read or write operation is commanded, the address of the operation is written to this field.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="8" name="ULPIDATRD">
                    <gui_name language="en">ULPIDATRD</gui_name>
                    <description language="en">ULPI Data Read.
After a read operation completes, the result is placed in this field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="0" name="ULPIDATWR">
                    <gui_name language="en">ULPIDATWR</gui_name>
                    <description language="en">ULPI Data Write. When a write operation is commanded, the data to be sent is written to this field</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTNAK" offset="0xe0003178" size="0x4">
                <gui_name language="en">ENDPTNAK</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Write" enumerationId="ENDPTNAK_EPTN_ENUM" high_bit="31" low_bit="16" name="EPTN">
                    <gui_name language="en">EPTN</gui_name>
                    <description language="en">TX Endpoint NAK
Each TX endpoint has 1 bit in this field. The bit is set when the Controller sends a NAK handshake on a received IN token for the corresponding endpoint.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTNAK_EPRN_ENUM" high_bit="15" low_bit="0" name="EPRN">
                    <gui_name language="en">EPRN</gui_name>
                    <description language="en">RX Endpoint NAK
Each RX endpoint has 1 bit in this field. The bit is set when the Controller sends a NAK handshake on a received OUT or PING token for the corresponding endpoint.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTNAKEN" offset="0xe000317c" size="0x4">
                <gui_name language="en">ENDPTNAKEN</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Write" enumerationId="ENDPTNAKEN_EPTNE_ENUM" high_bit="31" low_bit="16" name="EPTNE">
                    <gui_name language="en">EPTNE</gui_name>
                    <description language="en">TX Endpoint NAK enable
Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the corresponding TX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTNAKEN_EPRNE_ENUM" high_bit="15" low_bit="0" name="EPRNE">
                    <gui_name language="en">EPRNE</gui_name>
                    <description language="en">RX Endpoint NAK enable
Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the corresponding RX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_CONFIGFLAG" offset="0xe0003180" size="0x4">
                <gui_name language="en">CONFIGFLAG</gui_name>
                <description language="en">This register is not used in this implementation. A read from this register returns a constant of a 00000001h to indicate that all port routings default to this host controller.</description>
            </register>
            <register name="USB1_PORTSC1" offset="0xe0003184" size="0x4">
                <gui_name language="en">PORTSC1</gui_name>
                <description language="en">The Controller implement one The number of port registers implemented by a particular instantiation is documented in the HCSPARAM register. Software uses this information as an input parameter to determine how many ports need service. This implement contains only 1 host port.</description>
                <bitField access="Read Write" high_bit="31" low_bit="30" name="PTS">
                    <gui_name language="en">PTS</gui_name>
                    <description language="en">This register bit pair is used in conjunction with the configuration constant VUSB_HS_PHY_TYPE to control which parallel transceiver interface is selected'010b' -&gt; 2, 6 - ULPI
Note that this field is made up from PORTSCx bits 25, 30 and 31.</description>
                </bitField>
                <bitField access="Read Only" high_bit="29" low_bit="29" name="STS">
                    <gui_name language="en">STS</gui_name>
                    <description language="en">Serial Transceiver Select
This register bit is used in conjunction with the configuration constant VUSB_HS_PHY_SERIAL to control whether the parallel or serial transceiver interface is selected for FS and LS operation. The Serial Interface Engine can be used in
combination with the UTMI+ physical interface to provide FS/LS signaling instead of the parallel interface. If VUSB_HS_PHY_SERIAL is set for 0 or 1 then this bit is read only. If VUSB_HS_PHY_SERIAL is 2 or 3 then this bit is read/write.
This bit has no effect unless Parallel Transceiver Select is set to UTMI+. The Serial/1.1 and IC_USB physical interface will use the Serial Interface Engine for FS/LS signaling
regardless of this bit value.</description>
                </bitField>
                <bitField access="Read Only" high_bit="28" low_bit="28" name="PTW">
                    <gui_name language="en">PTW</gui_name>
                    <description language="en">Parallel Transceiver Width. Writing this bit to '0' selects the 8-bit [60MHz] UTMI+ interface.</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="26" name="PSPD">
                    <gui_name language="en">PSPD</gui_name>
                    <description language="en">Port Speed - RO. Default = 11b.
This register field indicates the speed at which the port is operating.'00b' -&gt; Full Speed'01b' -&gt; Low Speed'10b' -&gt; High Speed'11b' -&gt; Not connected</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="PTS2">
                    <gui_name language="en">PTS2</gui_name>
                    <description language="en">Parallel Transceiver Select - RW. Default = Implementation dependent.
MSB bit of PTS field.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="PFSC">
                    <gui_name language="en">PFSC</gui_name>
                    <description language="en">Port Force Full Speed Connect - RW. Default = 0b.
Writing this bit to a '1b' will force the port to only connect at Full Speed. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device. This bit is for debugging purposes.</description>
                </bitField>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="PHCD">
                    <gui_name language="en">PHCD</gui_name>
                    <description language="en">PHY Low Power Clock Disable - RW. Default = 0b.
Writing this bit to a '1b' will disable the PHY clock. Writing a '0b' enables it. Reading this bit will indicate the status of the PHY clock. NOTE: The PHY clock cannot be disabled if it is being used as the system clock. In device mode, the PHY can be put into Low Power Clock Disable when the device is not running (USBCMD RS=0b) or the host has signaled suspend (PORTSCx SUSP=1b).
Low Power Clock Disable will be cleared automatically when the host has signaled resume. Before forcing a resume from the device, the Controller driver must clear this bit.
In host mode, the PHY can be put into Low Power Suspend Clock Disable when the downstream device has been put into suspend mode or when no downstream device is
connected. Low Power Clock Disable is completely under the control of software.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="WKOC">
                    <gui_name language="en">WKOC</gui_name>
                    <description language="en">Wake on Over-current Enable
Writing '1' to this bit enables the port to be sensitive to over-current conditions as wakeup events.
This field is zero if Port Power (PP) is '0' or in device mode.
This bit is output from the controller as signal pwrctl_wake_ovrcurr_en for use by an external power control circuit. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="21" low_bit="21" name="WKDS">
                    <gui_name language="en">WKDS</gui_name>
                    <description language="en">Wake on Disconnect Enable
Writing this bit to a one enables the port to be sensitive to device disconnects as wakeup events. This field is zero if Port Power (PP) is '0' or in device mode. This bit is output from the controller as signal pwrctl_wake_dscnnt_en for use by an external power control circuit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="WKCN">
                    <gui_name language="en">WKCN</gui_name>
                    <description language="en">Wake on Connect Enable
Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. This field is zero if Port Power(PP) is '0' or in device mode. This bit is output from the controller as signal pwrctl_wake_cnnt_en for use by an external power control circuit. Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PTC_ENUM" high_bit="19" low_bit="16" name="PTC">
                    <gui_name language="en">PTC</gui_name>
                    <description language="en">Port Test Control
Any other value than zero indicates that the port is operating in test mode.
Value Specific Test
0000b -&gt; TEST_MODE_DISABLE
0001b -&gt; J_ STATE
0010b -&gt; K_STATE
0011b -&gt; SE0 (host) / NAK (device)
0100b -&gt; Packet
0101b -&gt; FORCE_ENABLE_HS
0110b -&gt; FORCE_ENABLE_FS
0111b -&gt; FORCE_ENABLE_LS
1000b -&gt; Reserved
... Reserved
1111b
-&gt; Reserved</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PIC_ENUM" high_bit="15" low_bit="14" name="PIC">
                    <gui_name language="en">PIC</gui_name>
                    <description language="en">Port Indicator Control
Writing to this field has no effect if the P_INDICATOR bit in the HCSPARAMS register is
a zero. If P_INDICATOR bit is a one, then the bits are:
Value Meaning
00b -&gt; Port indicators are off
01b -&gt; Amber
10b -&gt; Green
11b -&gt; Undefined
Refer to the USB Specification Revision 2.0 for a description on how these bits are to be used.This field is output from the controller as signals port_ind_ctl_1 and port_ind_ctl_0 for</description>
                </bitField>
                <bitField access="Read Only" high_bit="13" low_bit="13" name="PO">
                    <gui_name language="en">PO</gui_name>
                    <description language="en">Port Owner
Port owner hand off is not implemented in this design, therefore this bit will always read
back as 0b.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PP_ENUM" high_bit="12" low_bit="12" name="PP">
                    <gui_name language="en">PP</gui_name>
                    <description language="en">Port Power
The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:
PPC -&gt; PP -&gt; Operation
0b -&gt; 0b -&gt; Read Only. A Controller in device mode does not have port power control switches.
1b -&gt; 1b/0b -&gt; Read/Write. A Controller in host mode requires port power control switches.
This bit represents the current setting of the switch ('0'=off, '1'=on). When power is not available on a port (i.e. PP equals to '0'), the port is non-functional and will not report attaches, detaches, etc. When an over-current condition is detected on a powered port and PPC is a one, the PP bit in each affected port may be transitioned by the Controller driver from '1' to '0'(removing power from the port).
In device mode port power control is not necessary, thus PPC and PP = 0.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="PORTSC1_LS_ENUM" high_bit="11" low_bit="10" name="LS">
                    <gui_name language="en">LS</gui_name>
                    <description language="en">Line Status
These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines.
The encoding of the bits are:
00b -&gt; SE0
10b -&gt; J-state
01b -&gt; K-state
11b -&gt; Undefined
In host mode, the use of linestate by the Controller driver is not necessary (unlike EHCI), because the port controller state machine and the port routing manage the connection of LS and FS.
In device mode, the use of linestate by the Controller driver is not necessary.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="HSP">
                    <gui_name language="en">HSP</gui_name>
                    <description language="en">High-Speed Port
When the bit is one, the port is in high-speed mode and if set to zero, the port is not in a high-speed mode.
Note: HSP is redundant with PSPD but will remain in the design for compatibility.</description>
                </bitField>
                <bitField access="Read Write" high_bit="8" low_bit="8" name="PR">
                    <gui_name language="en">PR</gui_name>
                    <description language="en">Port Reset - RW. Default = 0b.
This field is zero if Port Power(PP) is '0'.
Host mode: 1=Port is in Reset. 0=Port is not in Reset.
Device Mode: This bit is a read only status bit. Device reset from the USB bus is also indicated in the USBSTS register</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_SUSP_ENUM" high_bit="7" low_bit="7" name="SUSP">
                    <gui_name language="en">SUSP</gui_name>
                    <description language="en">Suspend
Host mode: 1=Port in suspend state. 0=Port not in suspend state. Port Enabled bit and Suspend bit of this register define the port states as follows:
Bits [Port Enabled, Suspend] Port State
0x Disable
10 Enable
11 Suspend
Device mode: Read Only. 1=Port in suspend state. 0=Port not in suspend state. In device mode this bit is a read only status bit.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_FPR_ENUM" high_bit="6" low_bit="6" name="FPR">
                    <gui_name language="en">FPR</gui_name>
                    <description language="en">Force Port Resume
1= Resume detected/driven on port.
0=No resume (K-state) detected/driven on port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="OCC">
                    <gui_name language="en">OCC</gui_name>
                    <description language="en">Over-current Change
This bit gets set to '1' when there is a change to Over-current Active. Software clears this bit by writing a '1' to this bit position.
When in host mode implementations the user can provide over-current detection to the vbus_pwr_fault input for this condition.
For device mode this bit shall always be '0'.</description>
                </bitField>
                <bitField access="Read Only" high_bit="4" low_bit="4" name="OCA">
                    <gui_name language="en">OCA</gui_name>
                    <description language="en">Over-current Active
Value Meaning'1b' -&gt; This port currently has an over-current condition.'0b' -&gt; This port does not have an over-current condition.
This bit will automatically transition from '1' to '0' when the over current condition is removed.
For host mode implementations the user can provide over-current detection to the vbus_pwr_fault input for this condition.
For device mode implementations this bit shall always be '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="PEC">
                    <gui_name language="en">PEC</gui_name>
                    <description language="en">Port Enabled Change
If set to '1' indicates a Port Enabled/Disabled status change.
Host mode:
For the root hub, this bit gets set to a '1' only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification). Software clears this by writing a '1' to it. This field is '0' if Port Power(PP) is '0'.
Device mode:
The device port is always enabled. (This bit will be '0').</description>
                </bitField>
                <bitField access="Read Write" enumerationId="PORTSC1_PE_ENUM" high_bit="2" low_bit="2" name="PE">
                    <gui_name language="en">PE</gui_name>
                    <description language="en">Port Enabled
1 -&gt; Enable
0-&gt; Disable
Host mode:
Ports can only be enabled by Controller as a part of the reset and enable. Software cannot enable a port by writing a '1' to this field. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the software.This field is '0' if Port Power(PP) is '0' in host mode.
Device mode:
The device port is always enabled. (This bit will be always '1').</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="CSC">
                    <gui_name language="en">CSC</gui_name>
                    <description language="en">Connect Status Change
If set to '1' indicates a change in Current Connect Status (CCS).
Host mode:
Indicates a change has occurred in the port's Current Connect Status. The Controller sets this bit for all changes to the port device connect status, even if system software
has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be 'setting' an already-set bit (i.e., the bit will remain set). Software clears this bit by writing a '1' to it. This field is '0' if Port Power(PP) is '0' in host mode.
Device mode:
This bit is undefined in device mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="0" low_bit="0" name="CCS">
                    <gui_name language="en">CCS</gui_name>
                    <description language="en">Current Connect Status.
Host mode:
1 -&gt; Device is present on port.
0 -&gt; No device is present.
Device mode:
1 -&gt; Attached.
0 -&gt; Not Attached.</description>
                </bitField>
            </register>
            <register name="USB1_OTGSC" offset="0xe00031a4" size="0x4">
                <gui_name language="en">OTGSC</gui_name>
                <description language="en">The Controller implements one On-The-Go (OTG) Status and Control register.
The OTGSC register has four sections:
OTG Interrupt enables (Read/Write)
OTG Interrupt status (Read/Write to Clear)
OTG Status inputs (Read Only)
OTG Controls (Read/Write)</description>
                <bitField access="Read Write" high_bit="30" low_bit="30" name="DPIE">
                    <gui_name language="en">DPIE</gui_name>
                    <description language="en">Data Pulse Interrupt Enable
This bit enables the generation of an interrupt if bit DPIS is set.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OTGSC_n1msE_ENUM" high_bit="29" low_bit="29" name="n1msE">
                    <gui_name language="en">n1msE</gui_name>
                    <description language="en">1 millisecond timer Interrupt Enable
This bit enables the generation of an interrupt if bit 1msS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="28" low_bit="28" name="BSEIE">
                    <gui_name language="en">BSEIE</gui_name>
                    <description language="en">B Session End Interrupt Enable
This bit enables the generation of an interrupt if bit BSEIS is set</description>
                </bitField>
                <bitField access="Read Write" high_bit="27" low_bit="27" name="BSVIE">
                    <gui_name language="en">BSVIE</gui_name>
                    <description language="en">B Session Valid Interrupt Enable
This bit enables the generation of an interrupt if bit BSVIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="26" low_bit="26" name="ASVIE">
                    <gui_name language="en">ASVIE</gui_name>
                    <description language="en">A Session Valid Interrupt Enable
This bit enables the generation of an interrupt if bit ASVIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="25" low_bit="25" name="AVVIE">
                    <gui_name language="en">AVVIE</gui_name>
                    <description language="en">A VBus Valid Interrupt Enable
This bit enables the generation of an interrupt if bit AVVIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="24" low_bit="24" name="IDIE">
                    <gui_name language="en">IDIE</gui_name>
                    <description language="en">USB ID Interrupt Enable
This bit enables the generation of an interrupt if bit IDIS is set.</description>
                </bitField>
                <bitField access="Read Write" high_bit="22" low_bit="22" name="DPIS">
                    <gui_name language="en">DPIS</gui_name>
                    <description language="en">Data Pulse Interrupt Status
This bit is set when data bus pulsing occurs on DP or DM. Data bus pulsing is only detected when USBMODE.CM = Host ('11b') and PORTSC0.PP = Off ('0b').
Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="OTGSC_n1msS_ENUM" high_bit="21" low_bit="21" name="n1msS">
                    <gui_name language="en">n1msS</gui_name>
                    <description language="en">1 millisecond timer Interrupt Status.
This bit is set once every millisecond. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="20" low_bit="20" name="BSEIS">
                    <gui_name language="en">BSEIS</gui_name>
                    <description language="en">B Session End Interrupt Status
This bit is set when VBus has fallen below the B session end threshold. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="19" name="BSVIS">
                    <gui_name language="en">BSVIS</gui_name>
                    <description language="en">B Session Valid Interrupt Status
This bit is set when VBus has either risen above or fallen below the B session valid threshold (0.8 VDC).
Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="18" low_bit="18" name="ASVIS">
                    <gui_name language="en">ASVIS</gui_name>
                    <description language="en">A Session Valid Interrupt Status
This bit is set when VBus has either risen above or fallen below the A session valid threshold (0.8 VDC).
Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="17" low_bit="17" name="AVVIS">
                    <gui_name language="en">AVVIS</gui_name>
                    <description language="en">Frame IndexThis bit is set when VBus has either risen above or fallen below the VBus valid threshold
(4.4 VDC) on an A device. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="IDIS">
                    <gui_name language="en">IDIS</gui_name>
                    <description language="en">USB ID Interrupt Status
This bit is set when a change on the ID input has been detected. Software must write a '1' to clear this bit.</description>
                </bitField>
                <bitField access="Read Only" high_bit="14" low_bit="14" name="DPS">
                    <gui_name language="en">DPS</gui_name>
                    <description language="en">Data Bus Pulsing Status
A '1' indicates data bus pulsing is being detected on the port.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="OTGSC_n1msT_ENUM" high_bit="13" low_bit="13" name="n1msT">
                    <gui_name language="en">n1msT</gui_name>
                    <description language="en">1 millisecond timer toggle
This bit toggles once per millisecond.</description>
                </bitField>
                <bitField access="Read Only" high_bit="12" low_bit="12" name="BSE">
                    <gui_name language="en">BSE</gui_name>
                    <description language="en">B Session End
Indicates VBus is below the B session end threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="11" low_bit="11" name="BSV">
                    <gui_name language="en">BSV</gui_name>
                    <description language="en">B Session Valid
Indicates VBus is above the B session valid threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="10" low_bit="10" name="ASV">
                    <gui_name language="en">ASV</gui_name>
                    <description language="en">A Session Valid
Indicates VBus is above the A session valid threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="9" low_bit="9" name="AVV">
                    <gui_name language="en">AVV</gui_name>
                    <description language="en">A VBus Valid.
Indicates VBus is above the A VBus valid threshold.</description>
                </bitField>
                <bitField access="Read Only" high_bit="8" low_bit="8" name="ID">
                    <gui_name language="en">ID</gui_name>
                    <description language="en">USB ID'0' = A device, '1' = B device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="HABA">
                    <gui_name language="en">HABA</gui_name>
                    <description language="en">Hardware Assist B-Disconnect to A-connect'0' = Disabled, '1' = Enable automatic B-disconnect to A-connect sequence.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="HADP">
                    <gui_name language="en">HADP</gui_name>
                    <description language="en">Hardware Assist Data-Pulse
If set, the hardware assist data pulsing sequence starts.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="IDPU">
                    <gui_name language="en">IDPU</gui_name>
                    <description language="en">ID Pullup
This bit provide control over the ID pull-up resister.'0' = off, '1' = on. When this bit is '0' the ID input will not be sampled.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="DP">
                    <gui_name language="en">DP</gui_name>
                    <description language="en">Data Pulsing
Setting this bit causes the pullup on DP to be asserted for data pulsing during SRP.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="OT">
                    <gui_name language="en">OT</gui_name>
                    <description language="en">OTG Termination
This bit must be set when the Controller is in device mode. It controls the pulldown on DM.</description>
                </bitField>
                <bitField access="Read Write" high_bit="2" low_bit="2" name="HAAR">
                    <gui_name language="en">HAAR</gui_name>
                    <description language="en">Hardware Assist Auto-Reset'0' = Disabled, '1' = Enable automatic reset after connect on host port.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="1" name="VC">
                    <gui_name language="en">VC</gui_name>
                    <description language="en">VBUS Charge
Setting this bit causes the VBus line to be charged. This is used for VBus pulsing during SRP.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="VD">
                    <gui_name language="en">VD</gui_name>
                    <description language="en">VBUS Discharge.
Setting this bit causes VBus to discharge through a resistor.</description>
                </bitField>
            </register>
            <register name="USB1_USBMODE" offset="0xe00031a8" size="0x4">
                <gui_name language="en">USBMODE</gui_name>
                <description language="en">USB Mode Selection register</description>
                <bitField access="Read Write" high_bit="15" low_bit="15" name="SRT">
                    <gui_name language="en">SRT</gui_name>
                    <description language="en">Shorten Reset Time
When the Controller is in host mode, this bit enables a bypass of the Chirp J/K reset handshake, saving 6-7ms in simulation time for each reset sequence. This bit should only be used for initial system integration simulations, and should always be set to 0 for
normal operation.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="VBPS">
                    <gui_name language="en">VBPS</gui_name>
                    <description language="en">Vbus Power Select'0' -&gt; Output is '0''1' -&gt; Output is '1'This bit is connected to the vbus_pwr_select output and can be used for any generic control but is named to be used by logic that selects between an on-chip Vbus power source (charge pump) and an off-chip source in systems when both are available.
Only used in host mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="4" low_bit="4" name="SDIS">
                    <gui_name language="en">SDIS</gui_name>
                    <description language="en">Stream Disable Mode'0' -&gt; Inactive'1' -&gt; Active
Device mode:
Setting to a '1' disables double priming on both RX and TX for low bandwidth systems.
Host Mode:
Setting to a '1' ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems where the RX and TX buffers are sufficient to contain the entire packet.</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="3" name="SLOM">
                    <gui_name language="en">SLOM</gui_name>
                    <description language="en">Setup Lockout Mode
This bit controls behavior of the setup lock mechanism.'0' -&gt; Setup Lockouts On.'1' -&gt; Setup Lockouts Off (DCD requires use of Setup Data Buffer Tripwire in USBCMD).
Only used in device mode</description>
                </bitField>
                <bitField access="Read Only" high_bit="2" low_bit="2" name="ES">
                    <gui_name language="en">ES</gui_name>
                    <description language="en">Endian Select
This bit can change the byte ordering of the transfer buffers to match the host microprocessor bus architecture. The bit fields in the microprocessor interface and the DMA data structures (including the setup buffer within the device QH) are unaffected by the value of this bit, because they are based upon 32-bit words.'0' Little Endian -&gt; first byte referenced in least significant byte of 32-bit word.'1' Big Endian -&gt; first byte referenced in most significant byte of 32-bit word.</description>
                </bitField>
                <bitField access="Read Write" high_bit="1" low_bit="0" name="CM">
                    <gui_name language="en">CM</gui_name>
                    <description language="en">Controller Mode
Controller mode is defaulted to the proper mode for host only and device only implementations. For those designs that contain both host AND device capability (OTG),
the Controller will default to an idle state and will need to be initialized to the desired operating mode after reset. For combination host/device controllers, this register can
only be written once after reset. If it is necessary to switch modes, software must reset the controller by writing to the RST bit in the USBCMD register before reprogramming
this register.
Value Meaning'00b' -&gt; Idle (Default for combination host/device).'01b' -&gt; Reserved.'10b' -&gt; Controller in device mode (Default for device only controller).'11b' -&gt; Controller in host mode (Default for host only controller).</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTSETUPSTAT" offset="0xe00031ac" size="0x2">
                <gui_name language="en">ENDPTSETUPSTAT</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="ENDPTSETUPSTAT">
                    <gui_name language="en">ENDPTSETUPSTAT</gui_name>
                    <description language="en">ENDPTSETUPSTATSetup Endpoint Status
For every setup transaction that is received, the corresponding bit in this register is set to '1'. Software must clear to acknowledge the setup transfer by writing a '1' to the respective bit after it has read the setup data from Queue Head. The response to a setup packet as in the order of operations and total response time is crucial to limit bus timeouts if the setup lockout mechanism is engaged.
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTPRIME" offset="0xe00031b0" size="0x4">
                <gui_name language="en">ENDPTPRIME</gui_name>
                <description language="en">Only implemented in device mode</description>
                <bitField access="Read Write" high_bit="31" low_bit="16" name="PETB">
                    <gui_name language="en">PETB</gui_name>
                    <description language="en">Prime Endpoint Transmit Buffer - RWS. Default = 0000h.
For each endpoint a corresponding bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction. Software
should write a '1' to the corresponding bit when posting a new transfer descriptor to an endpoint. Hardware will automatically use this bit to begin parsing for a new transfer
descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when the associated endpoint(s) is (are) successfully primed.
Note: These bits will be momentarily set by hardware during hardware re-priming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="PERB">
                    <gui_name language="en">PERB</gui_name>
                    <description language="en">Prime Endpoint Receive Buffer
For each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a USB host initiates a USB OUT transaction. Software should write a '1' to the corresponding bit whenever posting a new transfer descriptor to an endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when the associated endpoint(s) is (are) successfully primed.
Note: These bits will be momentarily set by hardware during hardware re-priming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTFLUSH" offset="0xe00031b4" size="0x4">
                <gui_name language="en">ENDPTFLUSH</gui_name>
                <description language="en">The Flush operation for an endpoint will clear the Ready status of that endpoint and re-align the Latency Buffer pointers, but not clear the actual data that resides in the Latency Buffers.</description>
                <bitField access="Read Write" high_bit="31" low_bit="16" name="FETB">
                    <gui_name language="en">FETB</gui_name>
                    <description language="en">Flush Endpoint Transmit Buffer
Writing a '1' to a bit(s) in this register will cause the associated endpoint(s) to clear any primed buffers. If a packet is in progress for one of the associated endpoints, then that
transfer will continue until completion. Hardware will clear this register after the endpoint flush operation is successful.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Write" high_bit="15" low_bit="0" name="FERB">
                    <gui_name language="en">FERB</gui_name>
                    <description language="en">Flush Endpoint Receive Buffer
Writing a '1' to a bit(s) will cause the associated endpoint(s) to clear any primed buffers. If a packet is in progress for one of the associated endpoints, then that transfer will
continue until completion. Hardware will clear this register after the endpoint flush operation is successful.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_ENDPTSTAT" offset="0xe00031b8" size="0x4">
                <gui_name language="en">ENDPTSTAT</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="31" low_bit="16" name="ETBR">
                    <gui_name language="en">ETBR</gui_name>
                    <description language="en">Endpoint Transmit Buffer Ready
One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a '1' by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay time varies based upon the current USB traffic and the number of bits set in the
ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
Note: These bits will be momentarily cleared by hardware during hardware endpoint repriming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Only" high_bit="15" low_bit="0" name="ERBR">
                    <gui_name language="en">ERBR</gui_name>
                    <description language="en">Endpoint Receive Buffer Ready
One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a '1' by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay time varies based upon the current USB traffic and the number of bits set in the
ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
Note: These bits will be momentarily cleared by hardware during hardware endpoint repriming operations when a dTD is retired, and the dQH is updated.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register access="Read Only" name="USB1_ENDPTCOMPLETE" offset="0xe00031bc" size="0x4">
                <gui_name language="en">ENDPTCOMPLETE</gui_name>
                <description language="en">Only implemented in device mode.</description>
                <bitField access="Read Only" enumerationId="ENDPTCOMPLETE_ETCE_ENUM" high_bit="31" low_bit="16" name="ETCE">
                    <gui_name language="en">ETCE</gui_name>
                    <description language="en">Endpoint Transmit Complete Event
Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the
corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a '1' will clear the corresponding bit in this register.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
                <bitField access="Read Only" enumerationId="ENDPTCOMPLETE_ERCE_ENUM" high_bit="15" low_bit="0" name="ERCE">
                    <gui_name language="en">ERCE</gui_name>
                    <description language="en">Endpoint Receive Complete Event
Each bit indicates a received event (OUT) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a '1' will clear the corresponding bit in this register.
Bit 15 - Endpoint #15
...
Bit 1 - Endpoint #1
Bit 0 - Endpoint #0
Only used in device mode.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL0" offset="0xe00031c0" size="0x4">
                <gui_name language="en">ENDPTCTRL0</gui_name>
                <description language="en">Every device will implement Endpoint0 as a control endpoint. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Endpoint0 is always enabled and this bit always set to '1'.</description>
                </bitField>
                <bitField access="Read Only" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Only" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable
Endpoint0 is always enabled and this bit always set to '1'.</description>
                </bitField>
                <bitField access="Read Only" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL1" offset="0xe00031c4" size="0x4">
                <gui_name language="en">ENDPTCTRL1</gui_name>
                <description language="en">This is an ENDPTCTRL1 register for the endpoint 1 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL1_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL1_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL2" offset="0xe00031c8" size="0x4">
                <gui_name language="en">ENDPTCTRL2</gui_name>
                <description language="en">This is an ENDPTCTRL2 register for the endpoint 2 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL2_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL2_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL3" offset="0xe00031cc" size="0x4">
                <gui_name language="en">ENDPTCTRL3</gui_name>
                <description language="en">This is an ENDPTCTRL3 register for the endpoint 3 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL3_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL3_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL4" offset="0xe00031d0" size="0x4">
                <gui_name language="en">ENDPTCTRL4</gui_name>
                <description language="en">This is an ENDPTCTRL4 register for the endpoint 4 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL4_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL4_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL5" offset="0xe00031d4" size="0x4">
                <gui_name language="en">ENDPTCTRL5</gui_name>
                <description language="en">This is an ENDPTCTRL5 register for the endpoint 5 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL5_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL5_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL6" offset="0xe00031d8" size="0x4">
                <gui_name language="en">ENDPTCTRL6</gui_name>
                <description language="en">This is an ENDPTCTRL6 register for the endpoint 6 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL6_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL6_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL7" offset="0xe00031dc" size="0x4">
                <gui_name language="en">ENDPTCTRL7</gui_name>
                <description language="en">This is an ENDPTCTRL7 register for the endpoint 7 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL7_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL7_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL8" offset="0xe00031e0" size="0x4">
                <gui_name language="en">ENDPTCTRL8</gui_name>
                <description language="en">This is an ENDPTCTRL8 register for the endpoint 8 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL8_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL8_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL9" offset="0xe00031e4" size="0x4">
                <gui_name language="en">ENDPTCTRL9</gui_name>
                <description language="en">This is an ENDPTCTRL9 register for the endpoint 9 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL9_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL9_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL10" offset="0xe00031e8" size="0x4">
                <gui_name language="en">ENDPTCTRL10</gui_name>
                <description language="en">This is an ENDPTCTRL10 register for the endpoint 10 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL10_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL10_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL11" offset="0xe00031ec" size="0x4">
                <gui_name language="en">ENDPTCTRL11</gui_name>
                <description language="en">This is an ENDPTCTRL11 register for the endpoint 11 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL11_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL11_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
            <register name="USB1_ENDPTCTRL12" offset="0xe00031f0" size="0x4">
                <gui_name language="en">ENDPTCTRL12</gui_name>
                <description language="en">This is an ENDPTCTRL12 register for the endpoint 12 device. Only implemented in device mode.</description>
                <bitField access="Read Only" high_bit="23" low_bit="23" name="TXE">
                    <gui_name language="en">TXE</gui_name>
                    <description language="en">TX Endpoint Enable
Value Meaning'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Only" high_bit="22" low_bit="22" name="TXR">
                    <gui_name language="en">TXR</gui_name>
                    <description language="en">TX Data Toggle Reset
Write '1' will reset the PID sequence. Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Only" high_bit="21" low_bit="21" name="TXI">
                    <gui_name language="en">TXI</gui_name>
                    <description language="en">TX Data Toggle Inhibit
Value Meaning'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="19" low_bit="18" name="TXT">
                    <gui_name language="en">TXT</gui_name>
                    <description language="en">TX Endpoint Type'00' -&gt; Control'01' -&gt; Isochronous'10' -&gt; Bulk'11' -&gt; Interrupt</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL12_TXD_ENUM" high_bit="17" low_bit="17" name="TXD">
                    <gui_name language="en">TXD</gui_name>
                    <description language="en">TX Endpoint Data
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="16" low_bit="16" name="TXS">
                    <gui_name language="en">TXS</gui_name>
                    <description language="en">TX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled</description>
                </bitField>
                <bitField access="Read Write" high_bit="7" low_bit="7" name="RXE">
                    <gui_name language="en">RXE</gui_name>
                    <description language="en">RX Endpoint Enable'0' -&gt; Disabled'1' -&gt; Enabled
An endpoint should be enabled only after it has been configured.</description>
                </bitField>
                <bitField access="Read Write" high_bit="6" low_bit="6" name="RXR">
                    <gui_name language="en">RXR</gui_name>
                    <description language="en">RX Data Toggle Reset
Write '1' will reset the PID sequence.
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device.</description>
                </bitField>
                <bitField access="Read Write" high_bit="5" low_bit="5" name="RXI">
                    <gui_name language="en">RXI</gui_name>
                    <description language="en">RX Data Toggle Inhibit'0' -&gt; PID Sequencing Enabled'1' -&gt; PID Sequencing Disabled</description>
                </bitField>
                <bitField access="Read Write" high_bit="3" low_bit="2" name="RXT">
                    <gui_name language="en">RXT</gui_name>
                    <description language="en">RX Endpoint Type
Endpoint0 is fixed as a Control End Point and this field always set to '00'.</description>
                </bitField>
                <bitField access="Read Write" enumerationId="ENDPTCTRL12_RXD_ENUM" high_bit="1" low_bit="1" name="RXD">
                    <gui_name language="en">RXD</gui_name>
                    <description language="en">RX Endpoint Data Sink
Value Meaning
0 Dual Port Memory Buffer/DMA Engine
Should always be written as '0'.</description>
                </bitField>
                <bitField access="Read Write" high_bit="0" low_bit="0" name="RXS">
                    <gui_name language="en">RXS</gui_name>
                    <description language="en">RX Endpoint Stall
Value Meaning'0' -&gt; Endpoint OK.'1' -&gt; Endpoint Stalled
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software or it will automatically be cleared upon receipt of a new SETUP request.</description>
                </bitField>
            </register>
        </peripheral>
        <enumeration name="AFI_RDCHAN_CTRL_FabricOutCmdEn_ENUM">
            <enumItem name="The_maximum_number_of_outstanding_read_commands_is_always_taken_from_APB_register_field_rdIssueCap0" number="0x0"/>
            <enumItem name="The_maximum_outstanding_number_of" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_RDCHAN_CTRL_FabricQosEn_ENUM">
            <enumItem name="The_qos_bits_are_derived_from_APB_register_AFI_RDQOSstaticQos" number="0x0"/>
            <enumItem name="The_qos_bits_are_dynamically_driven_from_the_fabric_input_axds_arqos_3_0" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_RDCHAN_CTRL_n32BitEn_ENUM">
            <enumItem name="_64_bit_enabled" number="0x0"/>
            <enumItem name="_32_bit_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_RDCHAN_ISSUINGCAP_rdIssueCap1_ENUM">
            <enumItem name="_1_command" number="0x0"/>
            <enumItem name="_2_commands__3b111" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_RDCHAN_ISSUINGCAP_rdIssueCap0_ENUM">
            <enumItem name="_1_command" number="0x0"/>
            <enumItem name="_2_commands__3b111" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_RDQOS_staticQos_ENUM">
            <enumItem name="Lowest_Priority__4b1111" number="0x0"/>
        </enumeration>
        <enumeration name="AFI_RDDATAFIFO_LEVEL_FifoLevel_ENUM">
            <enumItem name="_0_Entries" number="0x0"/>
            <enumItem name="_1_Entry__8h8F" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_RDDEBUG_OutRdCmds_ENUM">
            <enumItem name="_0" number="0x0"/>
            <enumItem name="_1" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_CTRL_WrDataThreshold_ENUM">
            <enumItem name="Send_Write_Command_When_1_data_beat_is_pushed_into_the_Write_Data_FIFO" number="0x0"/>
            <enumItem name="Send_Write_Command_When_2_data_beats_are_pushed_into_the_Write_Data_FIFO__4b1111" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_CTRL_WrCmdReleaseMode_ENUM">
            <enumItem name="Release_Wr_Command_on_Wlast_enqueue_into_Write_Data_FIFO" number="0x0"/>
            <enumItem name="Release_Wr_Command_on_a_particular_threshold_being_reached_on_the_enqueue_into_Write_Data_FIFO_The_WrDataThreshold_field_is_used_to_program_the_actual_threshold" number="0x1"/>
            <enumItem name="Release_Wr_Command_immediately_it_is_received" number="0x2"/>
            <enumItem name="Reserved" number="0x3"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_CTRL_FabricOutCmdEn_ENUM">
            <enumItem name="The_maximum_number_of_outstanding_write_commands_is_always_taken_from_APB_register_field_wrIssueCap01" number="0x0"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_CTRL_FabricQosEn_ENUM">
            <enumItem name="The_qos_bits_are_derived_from_APB_register_AFI_WRQOSstaticQos1" number="0x0"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_CTRL_n32BitEn_ENUM">
            <enumItem name="_64_bit_enabled" number="0x0"/>
            <enumItem name="_32_bit_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_ISSUINGCAP_wrIssueCap1_ENUM">
            <enumItem name="_1_command" number="0x0"/>
            <enumItem name="_2_commands__3b111" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_WRCHAN_ISSUINGCAP_wrIssueCap0_ENUM">
            <enumItem name="_1_command" number="0x0"/>
            <enumItem name="_2_commands__3b111" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_WRQOS_staticQos_ENUM">
            <enumItem name="Lowest_Priority__4b1111" number="0x0"/>
        </enumeration>
        <enumeration name="AFI_WRDATAFIFO_LEVEL_FifoLevel_ENUM">
            <enumItem name="_0_Entries" number="0x0"/>
            <enumItem name="_1_Entry__8h8F" number="0x1"/>
        </enumeration>
        <enumeration name="AFI_WRDEBUG_OutWrCmds_ENUM">
            <enumItem name="_0" number="0x0"/>
            <enumItem name="_1" number="0x1"/>
        </enumeration>
        <enumeration name="ADDR0_MISC_AWADDR_TRIG_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR0_MISC_AWADDR_FILT_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR0_MISC_ARADDR_TRIG_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR0_MISC_ARADDR_FILT_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR1_MISC_AWADDR_TRIG_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR1_MISC_AWADDR_FILT_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR1_MISC_ARADDR_TRIG_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR1_MISC_ARADDR_FILT_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR2_MISC_AWADDR_TRIG_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR2_MISC_AWADDR_FILT_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR2_MISC_ARADDR_TRIG_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR2_MISC_ARADDR_FILT_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR3_MISC_AWADDR_TRIG_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR3_MISC_AWADDR_FILT_EXCINC_ENUM">
            <enumItem name="awaddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awaddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR3_MISC_ARADDR_TRIG_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ADDR3_MISC_ARADDR_FILT_EXCINC_ENUM">
            <enumItem name="araddr_range_detector_sets_up_an_inclusion_range" number="0x2"/>
            <enumItem name="araddr_range_detector_sets_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID0_MISC_WRID_TRIG_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID0_MISC_WRID_FILT_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID0_MISC_RDID_TRIG_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID0_MISC_RDID_FILT_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID1_MISC_WRID_TRIG_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID1_MISC_WRID_FILT_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID1_MISC_RDID_TRIG_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID1_MISC_RDID_FILT_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID2_MISC_WRID_TRIG_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID2_MISC_WRID_FILT_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID2_MISC_RDID_TRIG_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID2_MISC_RDID_FILT_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID3_MISC_WRID_TRIG_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID3_MISC_WRID_FILT_EXCINC_ENUM">
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="awid_wid_bid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID3_MISC_RDID_TRIG_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="ID3_MISC_RDID_FILT_EXCINC_ENUM">
            <enumItem name="arid_rid_range_detectors_set_up_an_inclusion_range" number="0x2"/>
            <enumItem name="arid_rid_range_detectors_set_up_an_exclusion_range" number="0x3"/>
        </enumeration>
        <enumeration name="AXI_SEL_SEL_ENUM">
            <enumItem name="AXI_bus_to_DDR_slave_port_0" number="0x4"/>
            <enumItem name="AXI_bus_to_DDR_slave_port_1" number="0x5"/>
            <enumItem name="AXI_bus_to_DDR_slave_port_2" number="0x6"/>
            <enumItem name="AXI_bus_to_DDR_slave_port_3" number="0x7"/>
        </enumeration>
        <enumeration name="SRR_CEN_ENUM">
            <enumItem name="The_CAN_controller_is_in_the_Configuration_mode" number="0x0"/>
            <enumItem name="The_CAN_controller_is_in_Loop_Back_Sleep_or_Normal_mode_depending_on_the_LBACK_and_SLEEP_bits_in_the_MSR" number="0x1"/>
        </enumeration>
        <enumeration name="SRR_SRST_ENUM">
            <enumItem name="CAN_controller_is_reset" number="0x1"/>
        </enumeration>
        <enumeration name="MSR_SNOOP_ENUM">
            <enumItem name="CAN_controller_is_in_Normal_Loop_Back_Configuration_or_Sleep_mode" number="0x0"/>
            <enumItem name="CAN_controller_is_in_Snoop_mode" number="0x1"/>
        </enumeration>
        <enumeration name="MSR_LBACK_ENUM">
            <enumItem name="CAN_controller_is_in_Normal_Snoop_Configuration_or_Sleep_mode" number="0x0"/>
            <enumItem name="CAN_controller_is_in_Loop_Back_mode" number="0x1"/>
        </enumeration>
        <enumeration name="MSR_SLEEP_ENUM">
            <enumItem name="CAN_controller_is_in_Normal_Snoop_Configuration_or_Loop_Back_mode" number="0x0"/>
            <enumItem name="CAN_controller_is_in_Sleep_mode" number="0x1"/>
        </enumeration>
        <enumeration name="ESR_ACKER_ENUM">
            <enumItem name="Indicates_an_acknowledgement_error_has_not" number="0x0"/>
            <enumItem name="Indicates_an_acknowledgement_error_has" number="0x1"/>
        </enumeration>
        <enumeration name="ESR_BERR_ENUM">
            <enumItem name="Indicates_a_bit_error_has_not_occurred_on_the_bus" number="0x0"/>
            <enumItem name="Indicates_a_bit_error_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="ESR_STER_ENUM">
            <enumItem name="Indicates_a_stuff_error_has_not_occurred_on_the" number="0x0"/>
            <enumItem name="Indicates_a_stuff_error_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="ESR_FMER_ENUM">
            <enumItem name="Indicates_a_form_error_has_not_occurred_on_the" number="0x0"/>
            <enumItem name="Indicates_a_form_error_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="ESR_CRCER_ENUM">
            <enumItem name="Indicates_a_CRC_error_has_not_occurred_on_the" number="0x0"/>
            <enumItem name="Indicates_a_CRC_error_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="SR_SNOOP_ENUM">
            <enumItem name="Indicates_the_CAN_controller_is_not_in_Snoop_mode" number="0x0"/>
            <enumItem name="Indicates_the_CAN_controller_is_in_Snoop_Mode" number="0x1"/>
        </enumeration>
        <enumeration name="SR_ACFBSY_ENUM">
            <enumItem name="Acceptance_Filter_Mask_Registers_and_the" number="0x0"/>
            <enumItem name="Acceptance_Filter_Mask_Registers_and" number="0x1"/>
        </enumeration>
        <enumeration name="SR_TXFLL_ENUM">
            <enumItem name="Indicates_the_TX_FIFO_is_not_full" number="0x0"/>
            <enumItem name="Indicates_the_TX_FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="SR_TXBFLL_ENUM">
            <enumItem name="Indicates_the_High_Priority_Transmit_Buffer_is_not_full" number="0x0"/>
            <enumItem name="Indicates_the_High_Priority_Transmit_Buffer_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="SR_ESTAT_ENUM">
            <enumItem name="Indicates_Configuration_Mode_CONFIG" number="0x0"/>
            <enumItem name="Indicates_Error_Active_State" number="0x1"/>
            <enumItem name="Indicates_Bus_Off_State" number="0x2"/>
            <enumItem name="Indicates_Error_Passive_State" number="0x3"/>
        </enumeration>
        <enumeration name="SR_ERRWRN_ENUM">
            <enumItem name="Neither_of_the_error_counters_has_a_value_greater" number="0x0"/>
            <enumItem name="One_or_more_error_counters_have_a_value_greater" number="0x1"/>
        </enumeration>
        <enumeration name="SR_BBSY_ENUM">
            <enumItem name="Indicates_that_the_CAN_controller_is_either_in" number="0x0"/>
            <enumItem name="Indicates_that_the_CAN_controller_is_either" number="0x1"/>
        </enumeration>
        <enumeration name="SR_BIDLE_ENUM">
            <enumItem name="Indicates_the_CAN_controller_is_either_in" number="0x0"/>
            <enumItem name="Indicates_no_bus_communication_is_taking_place" number="0x1"/>
        </enumeration>
        <enumeration name="SR_NORMAL_ENUM">
            <enumItem name="Indicates_the_CAN_controller_is_not_in_Normal" number="0x0"/>
            <enumItem name="Indicates_the_CAN_controller_is_in_Normal_Mode" number="0x1"/>
        </enumeration>
        <enumeration name="SR_SLEEP_ENUM">
            <enumItem name="Indicates_the_CAN_controller_is_not_in_Sleep_mode" number="0x0"/>
            <enumItem name="Indicates_the_CAN_controller_is_in_Sleep_mode" number="0x1"/>
        </enumeration>
        <enumeration name="SR_LBACK_ENUM">
            <enumItem name="Indicates_the_CAN_controller_is_not_in_Loop_Back" number="0x0"/>
            <enumItem name="Indicates_the_CAN_controller_is_in_Loop_Back" number="0x1"/>
        </enumeration>
        <enumeration name="SR_CONFIG_ENUM">
            <enumItem name="Indicates_the_CAN_controller_is_not_in" number="0x0"/>
            <enumItem name="Indicates_the_CAN_controller_is_in_Configuration" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ETXFEMP_ENUM">
            <enumItem name="Disable_interrupt_generation_if_TXFEMP_bit_in_ISR_is_set" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_TXFEMP_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ETXFWMEMP_ENUM">
            <enumItem name="Disable_interrupt_generation_if_TXFWMEMP_bit_in_ISR_is_set" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_TXFWMEMP_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ERXFWMFLL_ENUM">
            <enumItem name="Disable_interrupt_generation_if_RXFWMFLL_bit_in_ISR_is_set" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_RXFWMFLL_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_EWKUP_ENUM">
            <enumItem name="Disable_interrupt_generation_if_WKUP_bit_in_ISR_is_set" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_WKUP_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ESLP_ENUM">
            <enumItem name="Disable_interrupt_generation_if_SLP_bit_in_ISR_is_set" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_SLP_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_EBSOFF_ENUM">
            <enumItem name="Disable_interrupt_generation_if_BSOFF_bit_in_ISR_is_set" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_BSOFF_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_EERROR_ENUM">
            <enumItem name="Disable_interrupt_generation_if_ERROR_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_ERROR_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ERXNEMP_ENUM">
            <enumItem name="Disable_interrupt_generation_if_RXNEMP_bit_in_ISR" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_RXNEMP_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ERXOFLW_ENUM">
            <enumItem name="Disable_interrupt_generation_if_RXOFLW_bit_in_ISR" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_RXOFLW_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ERXUFLW_ENUM">
            <enumItem name="Disable_interrupt_generation_if_RXUFLW_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_RXUFLW_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ERXOK_ENUM">
            <enumItem name="Disable_interrupt_generation_if_RXOK_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_RXOK_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ETXBFLL_ENUM">
            <enumItem name="Disable_interrupt_generation_if_TXBFLL_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_TXBFLL_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ETXFLL_ENUM">
            <enumItem name="Disable_interrupt_generation_if_TXFLL_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_TXFLL_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="IER_ETXOK_ENUM">
            <enumItem name="Disable_interrupt_generation_if_TXOK_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_TXOK_bit_in_ISR_is_set" number="0x1"/>
        </enumeration>
        <enumeration name="IER_EARBLST_ENUM">
            <enumItem name="Disable_interrupt_generation_if_ARBLST_bit_in_ISR_is" number="0x0"/>
            <enumItem name="Enable_interrupt_generation_if_ARBLST_bit_in_ISR_is" number="0x1"/>
        </enumeration>
        <enumeration name="TXFIFO_ID_SRRRTR_ENUM">
            <enumItem name="Indicates_that_the_message_frame_is_a_Data" number="0x0"/>
            <enumItem name="Indicates_that_the_message_frame_is_a_Remote" number="0x1"/>
        </enumeration>
        <enumeration name="TXFIFO_ID_IDE_ENUM">
            <enumItem name="Indicates_the_use_of_a_Standard_Message" number="0x0"/>
            <enumItem name="Indicates_the_use_of_an_Extended_Message" number="0x1"/>
        </enumeration>
        <enumeration name="TXFIFO_ID_RTR_ENUM">
            <enumItem name="Indicates_the_message_object_is_a_Data_Frame" number="0x0"/>
            <enumItem name="Indicates_the_message_object_is_a_Remote_Frame" number="0x1"/>
        </enumeration>
        <enumeration name="TXHPB_ID_SRRRTR_ENUM">
            <enumItem name="Indicates_that_the_message_frame_is_a_Data" number="0x0"/>
            <enumItem name="Indicates_that_the_message_frame_is_a_Remote" number="0x1"/>
        </enumeration>
        <enumeration name="TXHPB_ID_IDE_ENUM">
            <enumItem name="Indicates_the_use_of_a_Standard_Message" number="0x0"/>
            <enumItem name="Indicates_the_use_of_an_Extended_Message" number="0x1"/>
        </enumeration>
        <enumeration name="TXHPB_ID_RTR_ENUM">
            <enumItem name="Indicates_the_message_object_is_a_Data_Frame" number="0x0"/>
            <enumItem name="Indicates_the_message_object_is_a_Remote_Frame" number="0x1"/>
        </enumeration>
        <enumeration name="RXFIFO_ID_SRRRTR_ENUM">
            <enumItem name="Indicates_that_the_message_frame_is_a_Data" number="0x0"/>
            <enumItem name="Indicates_that_the_message_frame_is_a_Remote" number="0x1"/>
        </enumeration>
        <enumeration name="RXFIFO_ID_IDE_ENUM">
            <enumItem name="Indicates_the_use_of_a_Standard_Message" number="0x0"/>
            <enumItem name="Indicates_the_use_of_an_Extended_Message" number="0x1"/>
        </enumeration>
        <enumeration name="RXFIFO_ID_RTR_ENUM">
            <enumItem name="Indicates_the_message_object_is_a_Data_Frame" number="0x0"/>
            <enumItem name="Indicates_the_message_object_is_a_Remote_Frame" number="0x1"/>
        </enumeration>
        <enumeration name="AFR_UAF4_ENUM">
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_4_and_0" number="0x0"/>
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_4_and" number="0x1"/>
        </enumeration>
        <enumeration name="AFR_UAF3_ENUM">
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_3_and_0" number="0x0"/>
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_3_and" number="0x1"/>
        </enumeration>
        <enumeration name="AFR_UAF2_ENUM">
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_2_and_0" number="0x0"/>
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_2_and" number="0x1"/>
        </enumeration>
        <enumeration name="AFR_UAF1_ENUM">
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_1_and_0" number="0x0"/>
            <enumItem name="Indicates_Acceptance_Filter_Mask_Register_1_and" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR1_AMIDH_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR1_AMSRR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR1_AMIDE_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR1_AMIDL_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR1_AMRTR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR2_AMIDH_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR2_AMSRR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR2_AMIDE_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR2_AMIDL_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR2_AMRTR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR3_AMIDH_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR3_AMSRR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR3_AMIDE_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR3_AMIDL_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR3_AMRTR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR4_AMIDH_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR4_AMSRR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR4_AMIDE_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR4_AMIDL_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="AFMR4_AMRTR_ENUM">
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance_0" number="0x0"/>
            <enumItem name="Indicates_the_corresponding_bit_in_Acceptance" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINTACK_INTACK_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="CTITRIGOUT_is_acknowledged_and_is_cleared_when_MAPTRIGOUT_is_LOW" number="0x1"/>
        </enumeration>
        <enumeration name="CTIAPPCLEAR_APPCLEAR_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="application_trigger_disabled_in_the_CTIAPPSET_register" number="0x1"/>
        </enumeration>
        <enumeration name="CTIAPPPULSE_APPULSE_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="channel_event_pulse_generated_for_one_CTICLK_period" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN0_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN1_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN2_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN3_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN4_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN5_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN6_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIINEN7_TRIGINEN_ENUM">
            <enumItem name="disables_the_CTITRIGIN_signal_from_generating_an_event_on_the_respective_channel_of_the" number="0x0"/>
            <enumItem name="enables_the_CTITRIGIN_signal_to_generate_an_event_on_the_respective_channel_of_the_CTM" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN0_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN1_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN2_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN3_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN4_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN5_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN6_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTIOUTEN7_TRIGOUTEN_ENUM">
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_not_routed_to_the_CTITRIGOUT_output" number="0x0"/>
            <enumItem name="the_channel_input_CTICHIN_from_the_CTM_is_routed_to_the_CTITRIGOUT_output" number="0x1"/>
        </enumeration>
        <enumeration name="CTITRIGINSTATUS_TRIGINSTATUS_ENUM">
            <enumItem name="CTITRIGIN_is_inactive" number="0x0"/>
            <enumItem name="CTITRIGIN_is_active" number="0x1"/>
        </enumeration>
        <enumeration name="CTITRIGOUTSTATUS_TRIGOUTSTATUS_ENUM">
            <enumItem name="CTITRIGOUT_is_inactive_reset" number="0x0"/>
            <enumItem name="CTITRIGOUT_is_active" number="0x1"/>
        </enumeration>
        <enumeration name="CTICHINSTATUS_CTCHINSTATUS_ENUM">
            <enumItem name="CTICHIN_is_inactive" number="0x0"/>
            <enumItem name="CTICHIN_is_active" number="0x1"/>
        </enumeration>
        <enumeration name="CTICHOUTSTATUS_CTCHOUTSTATUS_ENUM">
            <enumItem name="CTICHOUT_is_inactive_reset" number="0x0"/>
            <enumItem name="CTICHOUT_is_active" number="0x1"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_dis_auto_refresh_ENUM">
            <enumItem name="do_not_disable_auto_refresh_generated_by_the_controller_This_input_is_changeable_on_the_fly" number="0x0"/>
            <enumItem name="disable_auto_refresh_generated_by_the_controller_This_input_is_changeable_on_the_fly" number="0x1"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_dis_act_bypass_ENUM">
            <enumItem name="Do_not_disable_bypass_path_for_high_priority_read_activates" number="0x0"/>
            <enumItem name="disable_bypass_path_for_high_priority_read_activates" number="0x1"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_dis_rd_bypass_ENUM">
            <enumItem name="Do_not_disable_bypass_path_for_high_priority_read_page_hits" number="0x0"/>
            <enumItem name="disable_bypass_path_for_high_priority_read_page_hits" number="0x1"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_burst8_refresh_ENUM">
            <enumItem name="single_refresh" number="0x0"/>
            <enumItem name="burst_of_2" number="0x1"/>
            <enumItem name="burst_of_8_refresh" number="0x7"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_data_bus_width_ENUM">
            <enumItem name="_32_bit_DDR_bus" number="0x0"/>
            <enumItem name="_16_bit_DDR_bus" number="0x1"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_powerdown_en_ENUM">
            <enumItem name="DDRC_powerdown_disabled" number="0x0"/>
            <enumItem name="the_controller_goes_into_power_down_after_a_programmable_number_of_cycles_Maximum_idle_clocks_before_power_down_reg_ddrc_powerdown_to_x32" number="0x1"/>
        </enumeration>
        <enumeration name="ddrc_ctrl_reg_ddrc_soft_rstb_ENUM">
            <enumItem name="Resets_the_controller" number="0x0"/>
            <enumItem name="Takes_the_controller_out_of_reset" number="0x1"/>
        </enumeration>
        <enumeration name="Two_rank_cfg_reg_ddrc_addrmap_4bank_ram_ENUM">
            <enumItem name="Set_the_address_map_for_4_Bank_RAMs" number="0x1"/>
        </enumeration>
        <enumeration name="Two_rank_cfg_reg_ddrc_addrmap_open_bank_ENUM">
            <enumItem name="Set_the_address_map_to_Open_Bank_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Two_rank_cfg_reg_ddrc_addrmap_cs_bit1_ENUM">
            <enumItem name="Internal_Base" number="0x2"/>
        </enumeration>
        <enumeration name="Two_rank_cfg_reg_ddrc_diff_rank_rd_2cycle_gap_ENUM">
            <enumItem name="schedule_a_1_cycle_gap_in_data_responses_when_performing_consecutive_reads_to_different_ranks" number="0x0"/>
            <enumItem name="schedule_2_cycle_gap_for_the_same" number="0x1"/>
        </enumeration>
        <enumeration name="Two_rank_cfg_reg_ddrc_wr_odt_block_ENUM">
            <enumItem name="block_read_write_scheduling_for_1_cycle_when" number="0x0"/>
            <enumItem name="block_read_write_scheduling_for_2_cycles_when_Write_requires_changing_ODT_settings" number="0x1"/>
            <enumItem name="block_read_write_scheduling_for_3_cycles_when_Write_requires_changing_ODT_settings" number="0x2"/>
            <enumItem name="Reserved" number="0x3"/>
        </enumeration>
        <enumeration name="Two_rank_cfg_reg_ddrc_active_ranks_ENUM">
            <enumItem name="One_Rank" number="0x1"/>
            <enumItem name="Two_Ranks" number="0x3"/>
            <enumItem name="bit_represents_one_rank" number="0xeac"/>
        </enumeration>
        <enumeration name="DRAM_param_reg2_reg_ddrc_rd2pre_ENUM">
            <enumItem name="LPDDR2____BL_2__tRTP" number="0x1"/>
            <enumItem name="DDR2____AL__BL_2__maxtRTP_2" number="0x2"/>
        </enumeration>
        <enumeration name="DRAM_param_reg2_reg_ddrc_write_latency_ENUM">
            <enumItem name="__" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg3_reg_ddrc_dis_pad_pd_ENUM">
            <enumItem name="Enable_the_pad_power_down_feature" number="0x0"/>
            <enumItem name="disable_the_pad_power_down_feature" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg3_reg_ddrc_mobile_ENUM">
            <enumItem name="mobile_LPDDR_DRAM_device_in_use" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg3_reg_ddrc_sdram_ENUM">
            <enumItem name="non_sdram_device" number="0x0"/>
            <enumItem name="sdram_device" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg4_reg_ddrc_mr_type_ENUM">
            <enumItem name="write" number="0x0"/>
            <enumItem name="read" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg4_ddrc_reg_mr_wr_busy_ENUM">
            <enumItem name="Indicates_that_the_core_can_initiate_a_mode_register_write___read_operation" number="0x0"/>
            <enumItem name="Indicates_that_mode_register_write___read_operation_is_in_progress" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg4_reg_ddrc_mr_addr_ENUM">
            <enumItem name="MR0" number="0x0"/>
            <enumItem name="MR1" number="0x1"/>
            <enumItem name="MR2" number="0x2"/>
            <enumItem name="MR3" number="0x3"/>
        </enumeration>
        <enumeration name="DRAM_param_reg4_reg_ddrc_prefer_write_ENUM">
            <enumItem name="Bank_selector_prefers_writes_over_reads" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_param_reg4_reg_ddrc_en_2t_timing_mode_ENUM">
            <enumItem name="DDRC_will_use_1T_timing" number="0x0"/>
            <enumItem name="DDRC_will_use_2T_timing" number="0x1"/>
        </enumeration>
        <enumeration name="DRAM_burst8_rdwr_reg_ddrc_burst_rdwr_ENUM">
            <enumItem name="Burst_length_of_4" number="0x2"/>
            <enumItem name="Burst_length_of_8" number="0x4"/>
            <enumItem name="Burst_length_of_16_only_supported_for_LPDDR_AND_LPDDR2" number="0x8"/>
        </enumeration>
        <enumeration name="DRAM_addr_map_bank_reg_ddrc_addrmap_col_b6_ENUM">
            <enumItem name="Internal_base" number="0x9"/>
        </enumeration>
        <enumeration name="DRAM_addr_map_bank_reg_ddrc_addrmap_col_b5_ENUM">
            <enumItem name="Internal_base" number="0x9"/>
        </enumeration>
        <enumeration name="DRAM_addr_map_col_reg_ddrc_addrmap_col_b8_ENUM">
            <enumItem name="Internal_Base" number="0x3"/>
        </enumeration>
        <enumeration name="DRAM_addr_map_col_reg_ddrc_addrmap_col_b3_ENUM">
            <enumItem name="Internal_Base" number="0x6"/>
        </enumeration>
        <enumeration name="phy_cmd_timeout_rddata_cpt_reg_phy_clk_stall_level_ENUM">
            <enumItem name="stall_clock_for_DLL_aging_control" number="0x1"/>
        </enumeration>
        <enumeration name="phy_cmd_timeout_rddata_cpt_reg_phy_rdc_fifo_rst_err_cnt_clr_ENUM">
            <enumItem name="no_clear_1" number="0x0"/>
        </enumeration>
        <enumeration name="mode_sts_reg_ddrc_reg_dbg_stall_ENUM">
            <enumItem name="indicates_that_commands_are_being_accepted" number="0x0"/>
            <enumItem name="indicates_that_no_commands_are_accepted_by_the_controller" number="0x1"/>
        </enumeration>
        <enumeration name="mode_sts_reg_ddrc_reg_operating_mode_ENUM">
            <enumItem name="DDRC_Init" number="0x0"/>
            <enumItem name="Normal_operation" number="0x1"/>
            <enumItem name="Power_down_mode" number="0x2"/>
            <enumItem name="Self_refresh_mode" number="0x3"/>
            <enumItem name="and_above___deep_power_down_mode_LPDDR2_only" number="0x4"/>
        </enumeration>
        <enumeration name="ctrl_reg2_reg_arb_go2critical_en_ENUM">
            <enumItem name="Set_reg_ddrc_go2critical_wr_and_reg_ddrc_go2critical_rd_signals_going_to_DDRC_based_on_urgent_input_coming_from_AXI_master_0" number="0x1"/>
        </enumeration>
        <enumeration name="deep_pwrdwn_reg_deeppowerdown_en_ENUM">
            <enumItem name="Controller_puts_the_DRAM_into_Deep_Powerdown_mode_when_the_transaction_store_is_empty_0" number="0x1"/>
        </enumeration>
        <enumeration name="reg_2c_reg_ddrc_dfi_rd_data_eye_train_ENUM">
            <enumItem name="Read_Data_Eye_training_mode_has_been_enabled_as_part_of_init_sequence_Only_present_in_designs_that_support_DDR3_or_LPDDR2_devices" number="0x1"/>
        </enumeration>
        <enumeration name="reg_2c_reg_ddrc_dfi_rd_dqs_gate_level_ENUM">
            <enumItem name="Read_DQS_Gate_Leveling_mode_has_been_enabled_as_part_of_init_sequence_Valid_only_for_DDR3_DFI_designs_0__Read_DQS_gate_leveling_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg_2c_reg_ddrc_dfi_wr_level_en_ENUM">
            <enumItem name="Write_leveling_mode_has_been_enabled_as_part_of_init_sequence_Valid_only_for_DDR3_DFI_designs_0" number="0x1"/>
        </enumeration>
        <enumeration name="ECC_scrub_reg_ddrc_dis_scrub_ENUM">
            <enumItem name="Enable_ECC_scrubs_Valid_only_when_reg_ddrc_ecc_mode___3b100" number="0x0"/>
            <enumItem name="Disable_ECC_scrubs" number="0x1"/>
        </enumeration>
        <enumeration name="ECC_scrub_reg_ddrc_ecc_mode_ENUM">
            <enumItem name="No_ECC" number="0x0"/>
            <enumItem name="Reserved" number="0x1"/>
            <enumItem name="Parity" number="0x2"/>
            <enumItem name="Reserved_3" number="0x3"/>
            <enumItem name="SEC_DED_over_1_beat" number="0x4"/>
            <enumItem name="SEC_DED_over_multiple_beats" number="0x5"/>
            <enumItem name="Device_Correction" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="PHY_Config0_reg_phy_board_lpbk_rx_ENUM">
            <enumItem name="This_Slice_behaves_as_Receiver_for_board_loopback_0" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config0_reg_phy_data_slice_in_use_ENUM">
            <enumItem name="read_data_responses_are_ignored" number="0x0"/>
            <enumItem name="data_slice_is_valid" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config1_reg_phy_board_lpbk_rx_ENUM">
            <enumItem name="This_Slice_behaves_as_Receiver_for_board_loopback_0" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config1_reg_phy_data_slice_in_use_ENUM">
            <enumItem name="read_data_responses_are_ignored" number="0x0"/>
            <enumItem name="data_slice_is_valid" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config2_reg_phy_board_lpbk_rx_ENUM">
            <enumItem name="This_Slice_behaves_as_Receiver_for_board_loopback_0" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config2_reg_phy_data_slice_in_use_ENUM">
            <enumItem name="read_data_responses_are_ignored" number="0x0"/>
            <enumItem name="data_slice_is_valid" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config3_reg_phy_board_lpbk_rx_ENUM">
            <enumItem name="This_Slice_behaves_as_Receiver_for_board_loopback_0" number="0x1"/>
        </enumeration>
        <enumeration name="PHY_Config3_reg_phy_data_slice_in_use_ENUM">
            <enumItem name="read_data_responses_are_ignored" number="0x0"/>
            <enumItem name="data_slice_is_valid" number="0x1"/>
        </enumeration>
        <enumeration name="phy_rd_dqs_cfg0_reg_phy_rd_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_read_DQS_slave_DLL_with_the_value_of_the_debug_rd_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_rd_dqs_cfg1_reg_phy_rd_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_read_DQS_slave_DLL_with_the_value_of_the_debug_rd_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_rd_dqs_cfg2_reg_phy_rd_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_read_DQS_slave_DLL_with_the_value_of_the_debug_rd_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_rd_dqs_cfg3_reg_phy_rd_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_read_DQS_slave_DLL_with_the_value_of_the_debug_rd_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_wr_dqs_cfg0_reg_phy_wr_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_DQS_slave_DLL_with_the_value_of_the_reg_phy_wr_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_wr_dqs_cfg1_reg_phy_wr_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_DQS_slave_DLL_with_the_value_of_the_reg_phy_wr_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_wr_dqs_cfg2_reg_phy_wr_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_DQS_slave_DLL_with_the_value_of_the_reg_phy_wr_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_wr_dqs_cfg3_reg_phy_wr_dqs_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_DQS_slave_DLL_with_the_value_of_the_reg_phy_wr_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_we_cfg0_reg_phy_fifo_we_in_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_fifo_we_X_slave_DLL_with_the_value_of_the_debug_fifo_we_in_delayX_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_we_cfg1_reg_phy_fifo_we_in_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_fifo_we_X_slave_DLL_with_the_value_of_the_debug_fifo_we_in_delayX_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_we_cfg2_reg_phy_fifo_we_in_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_fifo_we_X_slave_DLL_with_the_value_of_the_debug_fifo_we_in_delayX_bus" number="0x1"/>
        </enumeration>
        <enumeration name="phy_we_cfg3_reg_phy_fifo_we_in_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_fifo_we_X_slave_DLL_with_the_value_of_the_debug_fifo_we_in_delayX_bus" number="0x1"/>
        </enumeration>
        <enumeration name="wr_data_slv0_reg_phy_wr_data_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_data_slave_DLL_with_the_value_of_the_reg_phy_wr_data_slave_force_bus" number="0x1"/>
        </enumeration>
        <enumeration name="wr_data_slv1_reg_phy_wr_data_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_data_slave_DLL_with_the_value_of_the_reg_phy_wr_data_slave_force_bus" number="0x1"/>
        </enumeration>
        <enumeration name="wr_data_slv2_reg_phy_wr_data_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_data_slave_DLL_with_the_value_of_the_reg_phy_wr_data_slave_force_bus" number="0x1"/>
        </enumeration>
        <enumeration name="wr_data_slv3_reg_phy_wr_data_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_write_data_slave_DLL_with_the_value_of_the_reg_phy_wr_data_slave_force_bus" number="0x1"/>
        </enumeration>
        <enumeration name="reg_64_reg_phy_lpddr_ENUM">
            <enumItem name="mobile_LPDDR_DRAM_device_in_use_0_non_LPDDR_DRAM_device_in_use" number="0x1"/>
        </enumeration>
        <enumeration name="reg_64_reg_phy_ctrl_slave_force_ENUM">
            <enumItem name="overwrite_the_delay_tap_value_for_address_command_timing_slave_DLL_with_the_value_of_the_reg_phy_rd_dqs_slave_delay_bus" number="0x1"/>
        </enumeration>
        <enumeration name="reg_64_reg_phy_invert_clkout_ENUM">
            <enumItem name="core_clock_is_passed_on_to_DRAM" number="0x0"/>
            <enumItem name="inverted_core_clock_is_passed_on_to_DRAM" number="0x1"/>
        </enumeration>
        <enumeration name="reg_64_reg_phy_bist_mode_ENUM">
            <enumItem name="constant_pattern_0_repeated_on_each_DQ_bit" number="0x0"/>
            <enumItem name="low_freq_pattern_00001111_repeated_on_each_DQ_bit" number="0x1"/>
            <enumItem name="PRBS_pattern_27_1_PRBS_pattern_repeated_on_each_DQ_bit_Each_DQ_bit_always_has_same_data_value_except_when_early_shifting_in_PRBS_mode_is_requested" number="0x2"/>
        </enumeration>
        <enumeration name="reg_64_reg_phy_at_spd_atpg_ENUM">
            <enumItem name="run_scan_test_at_slow_clock_speed_but_with_high_coverage" number="0x0"/>
            <enumItem name="run_scan_test_at_full_clock_speed_but_with_less_coverage" number="0x1"/>
        </enumeration>
        <enumeration name="reg_65_reg_phy_use_rd_data_eye_level_ENUM">
            <enumItem name="Use_register_programmed_ratio_values" number="0x0"/>
            <enumItem name="Use_ratio_for_delay_line_calculated_by_data_eye_leveling" number="0x1"/>
        </enumeration>
        <enumeration name="reg_65_reg_phy_use_rd_dqs_gate_level_ENUM">
            <enumItem name="Use_register_programmed_ratio_values" number="0x0"/>
            <enumItem name="Use_ratio_for_delay_line_calculated_by_DQS_gate_leveling" number="0x1"/>
        </enumeration>
        <enumeration name="reg_65_reg_phy_use_wr_level_ENUM">
            <enumItem name="Use_register_programmed_ratio_values" number="0x0"/>
            <enumItem name="Use_ratio_for_delay_line_calculated_by_write_leveling" number="0x1"/>
        </enumeration>
        <enumeration name="lpddr_ctrl0_reg_ddrc_derate_enable_ENUM">
            <enumItem name="Timing_parameter_derating_is_disabled_1" number="0x0"/>
        </enumeration>
        <enumeration name="CTRL_PCFG_POR_CNT_4K_ENUM">
            <enumItem name="use_64K_timer" number="0x0"/>
            <enumItem name="use_4K_timer" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_PCAP_PR_ENUM">
            <enumItem name="ICAP_as_Internal_FPGA_Partial_Reconfiguration_Path" number="0x0"/>
            <enumItem name="PCAP_as_Internal" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_MULTIBOOT_EN_ENUM">
            <enumItem name="Boot_from_default_boot_image_base_address" number="0x0"/>
            <enumItem name="Boot_from_multi_boot_offset_address" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_USER_MODE_ENUM">
            <enumItem name="CPU_is_running_in_ROM_Mode" number="0x0"/>
            <enumItem name="CPU_is_running_in_User_Mode" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_PCFG_AES_FUSE_ENUM">
            <enumItem name="BBRAM" number="0x0"/>
            <enumItem name="eFuse" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_PCFG_AES_EN_ENUM">
            <enumItem name="Disable_AES_engine" number="0x0"/>
        </enumeration>
        <enumeration name="CTRL_SEU_EN_ENUM">
            <enumItem name="Ignore_SEU_signal_from_FPGA" number="0x0"/>
            <enumItem name="Reset_PS_when_SEU_is_on" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_SEC_EN_ENUM">
            <enumItem name="PS_is_non_secured" number="0x0"/>
            <enumItem name="PS_is_secured" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_SPNIDEN_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_SPIDEN_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_NIDEN_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_DBGEN_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="CTRL_DAP_EN_ENUM">
            <enumItem name="Enable_ARM_DAP" number="0x7"/>
        </enumeration>
        <enumeration name="LOCK_AES_FUSE_LOCK_ENUM">
            <enumItem name="Open" number="0x0"/>
            <enumItem name="Lock" number="0x1"/>
        </enumeration>
        <enumeration name="LOCK_AES_EN_LOCK_ENUM">
            <enumItem name="Open" number="0x0"/>
            <enumItem name="Lock" number="0x1"/>
        </enumeration>
        <enumeration name="LOCK_SEU_LOCK_ENUM">
            <enumItem name="Open" number="0x0"/>
            <enumItem name="Lock" number="0x1"/>
        </enumeration>
        <enumeration name="LOCK_SEC_LOCK_ENUM">
            <enumItem name="Open" number="0x0"/>
            <enumItem name="Locked" number="0x1"/>
        </enumeration>
        <enumeration name="LOCK_DBG_LOCK_ENUM">
            <enumItem name="Open" number="0x0"/>
            <enumItem name="Locked" number="0x1"/>
        </enumeration>
        <enumeration name="CFG_RFIFO_TH_ENUM">
            <enumItem name="One_fourth" number="0x0"/>
            <enumItem name="Half_full_for_read" number="0x1"/>
            <enumItem name="Three_fourth_full_for_read" number="0x2"/>
            <enumItem name="Full_for_readUser_could_use_this_signal_to_trigger_interrupt_when_read_FIFO_overflow" number="0x3"/>
        </enumeration>
        <enumeration name="CFG_WFIFO_TH_ENUM">
            <enumItem name="One_fourth_empty_for_write" number="0x0"/>
            <enumItem name="Half_empty_for_write" number="0x1"/>
            <enumItem name="Three_fourth_empty_for_write" number="0x2"/>
            <enumItem name="empty_for_write" number="0x3"/>
        </enumeration>
        <enumeration name="CFG_RCLK_EDGE_ENUM">
            <enumItem name="falling_edge" number="0x0"/>
            <enumItem name="rising_edge" number="0x1"/>
        </enumeration>
        <enumeration name="CFG_WCLK_EDGE_ENUM">
            <enumItem name="falling_edge" number="0x0"/>
            <enumItem name="rising_edge" number="0x1"/>
        </enumeration>
        <enumeration name="CFG_RD_ISSUE_ENUM">
            <enumItem name="_4" number="0x0"/>
            <enumItem name="_8" number="0x1"/>
        </enumeration>
        <enumeration name="CFG_WR_ISSUE_ENUM">
            <enumItem name="_2" number="0x0"/>
            <enumItem name="_4" number="0x1"/>
        </enumeration>
        <enumeration name="CFG_RDLEN_ENUM">
            <enumItem name="burst_of_8" number="0x0"/>
            <enumItem name="burst_of_16" number="0x1"/>
        </enumeration>
        <enumeration name="CFG_WRLEN_ENUM">
            <enumItem name="burst_of_8" number="0x0"/>
            <enumItem name="burst_of_16" number="0x1"/>
        </enumeration>
        <enumeration name="STATUS_DMA_DONE_CNT_ENUM">
            <enumItem name="all_finished_transfers_have_been_acknowledged" number="0x0"/>
            <enumItem name="one_finished_transfer_outstanding" number="0x1"/>
            <enumItem name="two_finished_transfers_outstanding" number="0x2"/>
            <enumItem name="three_or_more_finished_transfers_outstanding" number="0x3"/>
        </enumeration>
        <enumeration name="XADCIF_CFG_TCKRATE_ENUM">
            <enumItem name="_1_2_of_pcap_2x_clock_frequency" number="0x0"/>
            <enumItem name="_1_4" number="0x1"/>
            <enumItem name="_1_8_of_pcap_2x_clock_frequency" number="0x2"/>
            <enumItem name="_1_16_of_pcap_2x_clock_frequency" number="0x3"/>
        </enumeration>
        <enumeration name="DSR_DNS_ENUM">
            <enumItem name="DMA_manager_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_manager_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="DSR_Wakeup_event_ENUM">
            <enumItem name="event_0" number="0x0"/>
            <enumItem name="event_1" number="0x1"/>
            <enumItem name="event_2" number="0x2"/>
            <enumItem name="event_31" number="0x1f"/>
        </enumeration>
        <enumeration name="DSR_DMA_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="FSRD_fs_mgr_ENUM">
            <enumItem name="the_DMA_manager_thread_is_not_in_the_Faulting_state" number="0x0"/>
            <enumItem name="the_DMA_manager_thread_is_in_the_Faulting_state" number="0x1"/>
        </enumeration>
        <enumeration name="FSRC_fault_status_ENUM">
            <enumItem name="bit_provides_the_fault_status_of_the_corresponding_channel_Read_as_" number="0xeac"/>
        </enumeration>
        <enumeration name="FTRD_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTRD_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTRD_mgr_evnt_err_ENUM">
            <enumItem name="the_DMA_manager_has_appropriate_security_to_execute_DMAWFE_or_DMASEV" number="0x0"/>
            <enumItem name="a_DMA_manager_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTRD_dmago_err_ENUM">
            <enumItem name="the_DMA_manager_has_appropriate_security_to_execute_DMAGO" number="0x0"/>
            <enumItem name="a_DMA_manager_thread_in_the_Non_secure_state_attempted_to_execute_DMAGO_to_create_a_DMA_channel" number="0x1"/>
        </enumeration>
        <enumeration name="FTRD_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTRD_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR0_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR1_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR2_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR3_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR4_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR5_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR6_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_lockup_err_ENUM">
            <enumItem name="DMA_channel_has_adequate_resources" number="0x0"/>
            <enumItem name="DMA_channel_has_locked_up_because_of_insufficient_resources" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_dbg_instr_ENUM">
            <enumItem name="instruction_that_generated_an_abort_was_read_from_system_memory" number="0x0"/>
            <enumItem name="instruction_that_generated_an_abort_was_read_from_the_debug_interface" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_data_read_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_data_write_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_instr_fetch_err_ENUM">
            <enumItem name="OKAY_response" number="0x0"/>
            <enumItem name="EXOKAY_SLVERR_or_DECERR_response" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_st_data_unavailable_ENUM">
            <enumItem name="MFIFO_contains_all_the_data_to_enable_the_DMAST_to_complete" number="0x0"/>
            <enumItem name="previous_DMALDs_have_not_put_enough_data_in_the_MFIFO_to_enable_the_DMAST_to_complete" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_ch_rdwr_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_perform_a_secure_read_or_secure_write" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_ch_periph_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_ch_evnt_err_ENUM">
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_is_not_violating_the_security_permissions" number="0x0"/>
            <enumItem name="a_DMA_channel_thread_in_the_Non_secure_state_attempted_to_execute_either_" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_operand_invalid_ENUM">
            <enumItem name="valid_operand" number="0x0"/>
            <enumItem name="invalid_operand" number="0x1"/>
        </enumeration>
        <enumeration name="FTR7_undef_instr_ENUM">
            <enumItem name="defined_instruction" number="0x0"/>
            <enumItem name="undefined_instruction" number="0x1"/>
        </enumeration>
        <enumeration name="CSR0_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR0_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR0_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR0_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR0_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR1_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR1_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR1_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR1_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR1_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR2_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR2_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR2_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR2_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR2_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR3_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR3_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR3_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR3_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR3_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR4_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR4_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR4_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR4_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR4_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR5_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR5_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR5_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR5_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR5_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR6_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR6_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR6_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR6_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR6_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CSR7_CNS_ENUM">
            <enumItem name="DMA_channel_operates_in_the_Secure_state" number="0x0"/>
            <enumItem name="DMA_channel_operates_in_the_Non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="CSR7_dmawfp_periph_ENUM">
            <enumItem name="DMAWFP_executed_with_the_periph_operand_not_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_periph_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR7_dmawfp_b_ns_ENUM">
            <enumItem name="DMAWFP_executed_with_the_single_operand_set" number="0x0"/>
            <enumItem name="DMAWFP_executed_with_the_burst_operand_set" number="0x1"/>
        </enumeration>
        <enumeration name="CSR7_wakeup_num_ENUM">
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_0" number="0x0"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_1" number="0x1"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_2" number="0x2"/>
            <enumItem name="DMA_channel_is_waiting_for_event_or_peripheral_31" number="0x1f"/>
        </enumeration>
        <enumeration name="CSR7_channel_status_ENUM">
            <enumItem name="Stopped" number="0x0"/>
            <enumItem name="Executing" number="0x1"/>
            <enumItem name="Cache_miss" number="0x2"/>
            <enumItem name="Updating_PC" number="0x3"/>
            <enumItem name="Waiting_for_event" number="0x4"/>
            <enumItem name="At_barrier" number="0x5"/>
            <enumItem name="reserved" number="0x6"/>
            <enumItem name="Waiting_for_peripheral" number="0x7"/>
            <enumItem name="Killing" number="0x8"/>
            <enumItem name="Completing" number="0x9"/>
            <enumItem name="Faulting_completing" number="0xe"/>
            <enumItem name="Faulting" number="0xf"/>
        </enumeration>
        <enumeration name="CCR0_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR0_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR0_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR0_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR0_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR0_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR0_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR1_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR1_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR1_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR1_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR1_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR1_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR1_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR2_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR2_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR2_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR2_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR2_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR2_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR2_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR3_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR3_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR3_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR3_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR3_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR3_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR3_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR4_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR4_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR4_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR4_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR4_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR4_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR4_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR5_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR5_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR5_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR5_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR5_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR5_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR5_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR6_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR6_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR6_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR6_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR6_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR6_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR6_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR7_endian_swap_size_ENUM">
            <enumItem name="No_swap_8_bit_data" number="0x0"/>
            <enumItem name="Swap_bytes_within_16_bit_data" number="0x1"/>
            <enumItem name="Swap_bytes_within_32_bit_data" number="0x2"/>
            <enumItem name="Swap_bytes_within_64_bit_data" number="0x3"/>
            <enumItem name="Swap_bytes_within_128_bit_data" number="0x4"/>
            <enumItem name="Reserved" number="0x5"/>
            <enumItem name="Reserved_6" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="CCR7_dst_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR7_dst_burst_size_ENUM">
            <enumItem name="writes_1_byte_per_beat" number="0x0"/>
            <enumItem name="writes_2_bytes_per_beat" number="0x1"/>
            <enumItem name="writes_4_bytes_per_beat" number="0x2"/>
            <enumItem name="writes_8_bytes_per_beat" number="0x3"/>
            <enumItem name="writes_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR7_dst_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_AWBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_AWBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CCR7_src_burst_len_ENUM">
            <enumItem name="_1_data_transfer" number="0x0"/>
            <enumItem name="_2_data_transfers" number="0x1"/>
            <enumItem name="_3_data_transfers" number="0x2"/>
            <enumItem name="_16_data_transfers" number="0xf"/>
        </enumeration>
        <enumeration name="CCR7_src_burst_size_ENUM">
            <enumItem name="reads_1_byte_per_beat" number="0x0"/>
            <enumItem name="reads_2_bytes_per_beat" number="0x1"/>
            <enumItem name="reads_4_bytes_per_beat" number="0x2"/>
            <enumItem name="reads_8_bytes_per_beat" number="0x3"/>
            <enumItem name="reads_16_bytes_per_beat" number="0x4"/>
        </enumeration>
        <enumeration name="CCR7_src_inc_ENUM">
            <enumItem name="Fixed_address_burst_The_DMAC_signals_ARBURST_0_LOW" number="0x0"/>
            <enumItem name="Incrementing_address_burst_The_DMAC_signals_ARBURST_0_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="DBGSTATUS_dbgstatus_ENUM">
            <enumItem name="Idle" number="0x0"/>
            <enumItem name="Busy" number="0x1"/>
        </enumeration>
        <enumeration name="DBGCMD_dbgcmd_ENUM">
            <enumItem name="execute_the_instruction_that_the_DBGINST__1_0_Registers_contain" number="0x0"/>
            <enumItem name="reserved" number="0x1"/>
            <enumItem name="reserved_2" number="0x2"/>
            <enumItem name="reserved_3" number="0x3"/>
        </enumeration>
        <enumeration name="DBGINST0_channel_num_ENUM">
            <enumItem name="DMA_channel_0" number="0x0"/>
            <enumItem name="DMA_channel_1" number="0x1"/>
            <enumItem name="DMA_channel_2" number="0x2"/>
            <enumItem name="DMA_channel_7" number="0x7"/>
        </enumeration>
        <enumeration name="DBGINST0_debug_thread_ENUM">
            <enumItem name="DMA_manager_thread" number="0x0"/>
            <enumItem name="DMA_channel" number="0x1"/>
        </enumeration>
        <enumeration name="CR0_num_events_ENUM">
            <enumItem name="_1_interrupt_output_irq_0" number="0x0"/>
            <enumItem name="_2_interrupt_outputs_irq_1_0" number="0x1"/>
            <enumItem name="_3_interrupt_outputs_irq_2_0" number="0x2"/>
            <enumItem name="_32_interrupt_outputs_irq_31_0" number="0x1f"/>
        </enumeration>
        <enumeration name="CR0_num_periph_req_ENUM">
            <enumItem name="_1_peripheral_request_interface" number="0x0"/>
            <enumItem name="_2_peripheral_request_interfaces" number="0x1"/>
            <enumItem name="_3_peripheral_request_interfaces" number="0x2"/>
            <enumItem name="_32_peripheral_request_interfaces" number="0x1f"/>
        </enumeration>
        <enumeration name="CR0_num_chnls_ENUM">
            <enumItem name="_1_DMA_channel" number="0x0"/>
            <enumItem name="_2_DMA_channels" number="0x1"/>
            <enumItem name="_3_DMA_channels" number="0x2"/>
            <enumItem name="_8_DMA_channels" number="0x7"/>
        </enumeration>
        <enumeration name="CR0_mgr_ns_at_rst_ENUM">
            <enumItem name="boot_manager_ns_was_LOW" number="0x0"/>
            <enumItem name="boot_manager_ns_was_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CR0_boot_en_ENUM">
            <enumItem name="boot_from_pc_was_LOW" number="0x0"/>
            <enumItem name="boot_from_pc_was_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CR0_periph_req_ENUM">
            <enumItem name="the_DMAC_does_not_provide_a_peripheral_request_interface" number="0x0"/>
            <enumItem name="the_DMAC_provides_the_number_of_peripheral_request_interfaces_that_the_num_periph_req_field" number="0x1"/>
        </enumeration>
        <enumeration name="CR1_num_icache_lines_ENUM">
            <enumItem name="_1_i_cache_line" number="0x0"/>
            <enumItem name="_2_i_cache_lines" number="0x1"/>
            <enumItem name="_3_i_cache_lines" number="0x2"/>
            <enumItem name="_16_i_cache_lines" number="0xf"/>
        </enumeration>
        <enumeration name="CR1_icache_len_ENUM">
            <enumItem name="_4_bytes" number="0x2"/>
            <enumItem name="_8_bytes" number="0x3"/>
            <enumItem name="_16_bytes" number="0x4"/>
            <enumItem name="_32_bytes" number="0x5"/>
        </enumeration>
        <enumeration name="CRD_data_buffer_dep_ENUM">
            <enumItem name="_1_line" number="0x0"/>
            <enumItem name="_2_lines" number="0x1"/>
            <enumItem name="_1024_lines" number="0x1ff"/>
        </enumeration>
        <enumeration name="CRD_rd_q_dep_ENUM">
            <enumItem name="_1_line" number="0x0"/>
            <enumItem name="_2_lines" number="0x1"/>
            <enumItem name="_16_lines" number="0xf"/>
        </enumeration>
        <enumeration name="CRD_rd_cap_ENUM">
            <enumItem name="_1" number="0x0"/>
            <enumItem name="_2" number="0x1"/>
            <enumItem name="_8" number="0x7"/>
        </enumeration>
        <enumeration name="CRD_wr_q_dep_ENUM">
            <enumItem name="_1_line" number="0x0"/>
            <enumItem name="_2_lines" number="0x1"/>
            <enumItem name="_16_lines" number="0xf"/>
        </enumeration>
        <enumeration name="CRD_wr_cap_ENUM">
            <enumItem name="_1" number="0x0"/>
            <enumItem name="_2" number="0x1"/>
            <enumItem name="_8" number="0x7"/>
        </enumeration>
        <enumeration name="CRD_data_width_ENUM">
            <enumItem name="reserved" number="0x0"/>
            <enumItem name="reserved_1" number="0x1"/>
            <enumItem name="_32_bit" number="0x2"/>
            <enumItem name="_64_bit" number="0x3"/>
            <enumItem name="_128_bit" number="0x4"/>
        </enumeration>
        <enumeration name="WD_wd_irq_only_ENUM">
            <enumItem name="the_DMAC_aborts_all_of_the_contributing_DMA_channels_and_sets_irq_abort_HIGH" number="0x0"/>
            <enumItem name="the_DMAC_sets_irq_abort_HIGH" number="0x1"/>
        </enumeration>
        <enumeration name="CTL_TraceCaptEn_ENUM">
            <enumItem name="disable_trace_capture" number="0x0"/>
            <enumItem name="enable_trace_capture" number="0x1"/>
        </enumeration>
        <enumeration name="FTMSTATUS_FIFOFULL_ENUM">
            <enumItem name="FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="FTMSTATUS_FIFOEMPTY_ENUM">
            <enumItem name="FIFO_is_empty" number="0x1"/>
        </enumeration>
        <enumeration name="LOCK_STATUS_LOCKSTATUS_ENUM">
            <enumItem name="Access_Locked_0" number="0x1"/>
        </enumeration>
        <enumeration name="LOCK_STATUS_LOCKIMP_ENUM">
            <enumItem name="Lock_exists_if_PADDRDBG31_is_low_else_0" number="0x1"/>
        </enumeration>
        <enumeration name="net_cfg_dbus_width_ENUM">
            <enumItem name="_32_bit_AMBA_AHB_data_bus_width" number="0x0"/>
            <enumItem name="_64_bit_AMBA_AHB_data_bus_width" number="0x1"/>
            <enumItem name="_128_bit_AMBA_AHB_data_bus_width" number="0x2"/>
            <enumItem name="_128_bit_AMBA_AHB_data_bus_width_3" number="0x3"/>
        </enumeration>
        <enumeration name="net_cfg_mdc_clk_div_ENUM">
            <enumItem name="divide_pclk_by_8_pclk_up_to_20_MHz" number="0x0"/>
            <enumItem name="divide_pclk_by_16_pclk_up_to_40_MHz" number="0x1"/>
            <enumItem name="divide_pclk_by_32_pclk_up_to_80_MHz" number="0x2"/>
            <enumItem name="divide_pclk_by_48_pclk_up_to_120MHz" number="0x3"/>
            <enumItem name="divide_pclk_by_64_pclk_up_to_160_MHz" number="0x4"/>
            <enumItem name="divide_pclk_by_96_pclk_up_to_240_MHz" number="0x5"/>
            <enumItem name="divide_pclk_by_128_pclk_up_to_320_MHz" number="0x6"/>
            <enumItem name="divide_pclk_by_224_pclk_up_to_540_MHz" number="0x7"/>
        </enumeration>
        <enumeration name="net_cfg_pcs_sel_ENUM">
            <enumItem name="GMII_MII_interface_enabled_TBI_disabled" number="0x0"/>
            <enumItem name="TBI_enabled_GMII_MII_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="net_cfg_gige_en_ENUM">
            <enumItem name="_10_100_operation_using_MII_or_TBI_interface" number="0x0"/>
            <enumItem name="Gigabit_operation_using_GMII_or_TBI_interface" number="0x1"/>
        </enumeration>
        <enumeration name="dma_cfg_tx_pktbuf_memsz_sel_ENUM">
            <enumItem name="Do_not_use_top_address_bit_2_Kb" number="0x0"/>
            <enumItem name="Use_full_configured_addressable_space_4_Kb" number="0x1"/>
        </enumeration>
        <enumeration name="dma_cfg_rx_pktbuf_memsz_sel_ENUM">
            <enumItem name="Do_not_use_top_three_address_bits_1_Kb" number="0x0"/>
            <enumItem name="Do_not_use_top_two_address_bits_2_Kb" number="0x1"/>
            <enumItem name="Do_not_use_top_address_bit_4_Kb" number="0x2"/>
            <enumItem name="Use_full_configured_addressable_space_8_Kb" number="0x3"/>
        </enumeration>
        <enumeration name="dma_cfg_ahb_fixed_burst_len_ENUM">
            <enumItem name="Always_use_SINGLE_AHB_bursts" number="0x1"/>
        </enumeration>
        <enumeration name="ip_hdr_csum_errors_ip_hdr_csum_errors_ENUM">
            <enumItem name="IP_header_checksum_errors___an_8_bit_register" number="0x0"/>
        </enumeration>
        <enumeration name="timer_incr_alt_ct_ns_delta_ENUM">
            <enumItem name="clock_cycle" number="0xeac"/>
        </enumeration>
        <enumeration name="design_cfg1_gem_dma_bus_width_ENUM">
            <enumItem name="__32_bit" number="0x1"/>
            <enumItem name="__64_bit" number="0x2"/>
            <enumItem name="__128_bit" number="0x4"/>
        </enumeration>
        <enumeration name="design_cfg5_gem_rx_pbuf_size_def_ENUM">
            <enumItem name="kB_Rx_packet_buffer_size___dedicated_memory_resource_in_Pele" number="0x4"/>
        </enumeration>
        <enumeration name="MASK_DATA_0_LSW_MASK_0_LSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_0_LSW_DATA_0_LSW_ENUM">
            <enumItem name="Each_bit_controls_the_corresponding_pin_within_the_16_bit_half_bank_Note__Bit_6_bit_7_default_value" number="0x0"/>
        </enumeration>
        <enumeration name="MASK_DATA_0_MSW_MASK_0_MSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_0_MSW_DATA_0_MSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_1_LSW_MASK_1_LSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_1_LSW_DATA_1_LSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_1_MSW_MASK_1_MSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_1_MSW_DATA_1_MSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_2_LSW_MASK_2_LSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_2_LSW_DATA_2_LSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_2_MSW_MASK_2_MSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_2_MSW_DATA_2_MSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_3_LSW_MASK_3_LSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_3_LSW_DATA_3_LSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_3_MSW_MASK_3_MSW_ENUM">
            <enumItem name="pin_value_is_updated" number="0x0"/>
            <enumItem name="pin_is_masked" number="0x1"/>
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="MASK_DATA_3_MSW_DATA_3_MSW_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_16_bit_half_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DATA_0_DATA_0_ENUM">
            <enumItem name="Each_bit_controls_the_corresponding_pin_within_the_32_bit_bank_Note__Bit_6_bit_7_default_value" number="0x0"/>
        </enumeration>
        <enumeration name="DATA_1_DATA_1_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DATA_2_DATA_2_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DATA_3_DATA_3_ENUM">
            <enumItem name="bit_controls_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DATA_0_RO_DATA_0_RO_ENUM">
            <enumItem name="Each_bit_provides_a_pin_value_within_the_32_bit_bank_Note__Bit_6_bit_7_default_value" number="0x0"/>
        </enumeration>
        <enumeration name="DATA_1_RO_DATA_1_RO_ENUM">
            <enumItem name="bit_provides_a_pin_value_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DATA_2_RO_DATA_2_RO_ENUM">
            <enumItem name="bit_provides_a_pin_value_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DATA_3_RO_DATA_3_RO_ENUM">
            <enumItem name="bit_provides_a_pin_value_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="BYPM_0_BYPASS_MODE_0_ENUM">
            <enumItem name="software_controlled_mode" number="0x0"/>
            <enumItem name="bypass_mode" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DIRM_0_DIRECTION_0_ENUM">
            <enumItem name="input" number="0x0"/>
            <enumItem name="output" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="OEN_0_OP_ENABLE_0_ENUM">
            <enumItem name="disabled" number="0x0"/>
            <enumItem name="enabled" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_MASK_0_INT_MASK_0_ENUM">
            <enumItem name="interrupt_source_enabled" number="0x0"/>
            <enumItem name="interrupt_source_masked" number="0x1"/>
            <enumItem name="bit_reports_the_status_for_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_EN_0_INT_ENABLE_0_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="clear_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_DIS_0_INT_DISABLE_0_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="set_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_TYPE_0_INT_TYPE_0_ENUM">
            <enumItem name="level_sensitive" number="0x0"/>
            <enumItem name="edge_sensitive" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_POLARITY_0_INT_POL_0_ENUM">
            <enumItem name="active_low_or_falling_edge" number="0x0"/>
            <enumItem name="active_high_or_rising_edge" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_ANY_0_INT_ON_ANY_0_ENUM">
            <enumItem name="trigger_on_single_edge_using_configured_interrupt_polarity" number="0x0"/>
            <enumItem name="trigger_on_both_edges" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="BYPM_1_BYPASS_MODE_1_ENUM">
            <enumItem name="software_controlled_mode" number="0x0"/>
            <enumItem name="bypass_mode" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DIRM_1_DIRECTION_1_ENUM">
            <enumItem name="input" number="0x0"/>
            <enumItem name="output" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="OEN_1_OP_ENABLE_1_ENUM">
            <enumItem name="disabled" number="0x0"/>
            <enumItem name="enabled" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_MASK_1_INT_MASK_1_ENUM">
            <enumItem name="interrupt_source_enabled" number="0x0"/>
            <enumItem name="interrupt_source_masked" number="0x1"/>
            <enumItem name="bit_reports_the_status_for_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_EN_1_INT_ENABLE_1_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="clear_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_DIS_1_INT_DISABLE_1_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="set_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_TYPE_1_INT_TYPE_1_ENUM">
            <enumItem name="level_sensitive" number="0x0"/>
            <enumItem name="edge_sensitive" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_POLARITY_1_INT_POL_1_ENUM">
            <enumItem name="active_low_or_falling_edge" number="0x0"/>
            <enumItem name="active_high_or_rising_edge" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_ANY_1_INT_ON_ANY_1_ENUM">
            <enumItem name="trigger_on_single_edge_using_configured_interrupt_polarity" number="0x0"/>
            <enumItem name="trigger_on_both_edges" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="BYPM_2_BYPASS_MODE_2_ENUM">
            <enumItem name="software_controlled_mode" number="0x0"/>
            <enumItem name="bypass_mode" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DIRM_2_DIRECTION_2_ENUM">
            <enumItem name="input" number="0x0"/>
            <enumItem name="output" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="OEN_2_OP_ENABLE_2_ENUM">
            <enumItem name="disabled" number="0x0"/>
            <enumItem name="enabled" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_MASK_2_INT_MASK_2_ENUM">
            <enumItem name="interrupt_source_enabled" number="0x0"/>
            <enumItem name="interrupt_source_masked" number="0x1"/>
            <enumItem name="bit_reports_the_status_for_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_EN_2_INT_ENABLE_2_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="clear_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_DIS_2_INT_DISABLE_2_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="set_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_TYPE_2_INT_TYPE_2_ENUM">
            <enumItem name="level_sensitive" number="0x0"/>
            <enumItem name="edge_sensitive" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_POLARITY_2_INT_POL_2_ENUM">
            <enumItem name="active_low_or_falling_edge" number="0x0"/>
            <enumItem name="active_high_or_rising_edge" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_ANY_2_INT_ON_ANY_2_ENUM">
            <enumItem name="trigger_on_single_edge_using_configured_interrupt_polarity" number="0x0"/>
            <enumItem name="trigger_on_both_edges" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="BYPM_3_BYPASS_MODE_3_ENUM">
            <enumItem name="software_controlled_mode" number="0x0"/>
            <enumItem name="bypass_mode" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="DIRM_3_DIRECTION_3_ENUM">
            <enumItem name="input" number="0x0"/>
            <enumItem name="output" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="OEN_3_OP_ENABLE_3_ENUM">
            <enumItem name="disabled" number="0x0"/>
            <enumItem name="enabled" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_MASK_3_INT_MASK_3_ENUM">
            <enumItem name="interrupt_source_enabled" number="0x0"/>
            <enumItem name="interrupt_source_masked" number="0x1"/>
            <enumItem name="bit_reports_the_status_for_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_EN_3_INT_ENABLE_3_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="clear_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_DIS_3_INT_DISABLE_3_ENUM">
            <enumItem name="no_change" number="0x0"/>
            <enumItem name="set_interrupt_mask" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_TYPE_3_INT_TYPE_3_ENUM">
            <enumItem name="level_sensitive" number="0x0"/>
            <enumItem name="edge_sensitive" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_POLARITY_3_INT_POL_3_ENUM">
            <enumItem name="active_low_or_falling_edge" number="0x0"/>
            <enumItem name="active_high_or_rising_edge" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="INT_ANY_3_INT_ON_ANY_3_ENUM">
            <enumItem name="trigger_on_single_edge_using_configured_interrupt_polarity" number="0x0"/>
            <enumItem name="trigger_on_both_edges" number="0x1"/>
            <enumItem name="bit_configures_the_corresponding_pin_within_the_32_bit_bank" number="0xeac"/>
        </enumeration>
        <enumeration name="Control_reg0_divisor_a_ENUM">
            <enumItem name="_3__Divides_the_input_pclk_frequency_by_divisor_a__1" number="0x0"/>
        </enumeration>
        <enumeration name="Control_reg0_divisor_b_ENUM">
            <enumItem name="_31___Divides_the_output_frequency_from_divisor_a_by_divisor_b__1" number="0x0"/>
        </enumeration>
        <enumeration name="Control_reg0_CLR_FIFO_ENUM">
            <enumItem name="initializes_the_FIFO_to_all_zeros_and_clears_the_transfer_size_register_Automatically_gets_cleared_on_the_next_APB_clock_after" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_SLVMON_ENUM">
            <enumItem name="normal_operation" number="0x0"/>
            <enumItem name="monitor_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_HOLD_ENUM">
            <enumItem name="allow_the_transfer_to_terminate_as_soon_as_all_the_data_has_been_transmitted_or_received" number="0x0"/>
            <enumItem name="when_no_more_data_is_available_for_transmit_or_no_more_data_can_be_received_hold_the_sclk_line_low_until_serviced_by_the_host" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_ACKEN_ENUM">
            <enumItem name="acknowledge_disabled_NACK_transmitted" number="0x0"/>
            <enumItem name="acknowledge_enabled_ACK_transmitted" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_NEA_ENUM">
            <enumItem name="reserved" number="0x0"/>
            <enumItem name="normal_7_bit_address" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_MS_ENUM">
            <enumItem name="slave" number="0x0"/>
            <enumItem name="master" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_RW_ENUM">
            <enumItem name="master_transmitter" number="0x0"/>
            <enumItem name="master_receiver" number="0x1"/>
        </enumeration>
        <enumeration name="Status_reg0_BA_ENUM">
            <enumItem name="ongoing_transfer_on_the_I2C_bus" number="0x1"/>
        </enumeration>
        <enumeration name="Status_reg0_RXOVF_ENUM">
            <enumItem name="when_the_receiver_receives_a_byte_of_data_before_the_previous_byte_has_been_read_by_the_host" number="0x1"/>
        </enumeration>
        <enumeration name="Status_reg0_TXDV_ENUM">
            <enumItem name="still_a_byte_of_data_to_be_transmitted_by_the_interface" number="0x1"/>
        </enumeration>
        <enumeration name="Status_reg0_RXDV_ENUM">
            <enumItem name="valid_new_data_to_be_read_from_the_interface" number="0x1"/>
        </enumeration>
        <enumeration name="Status_reg0_RXRW_ENUM">
            <enumItem name="mode_of_the_transmission_received_from_a_master" number="0x1"/>
        </enumeration>
        <enumeration name="I2C_address_reg0_ADD_ENUM">
            <enumItem name="_1024__Normal_addressing_mode_uses_add_6_0_Extended_addressing_mode_uses_add_9_0" number="0x0"/>
        </enumeration>
        <enumeration name="I2C_data_reg0_DATA_ENUM">
            <enumItem name="_255__When_written_to_the_data_register_sets_data_to_transmit_When_read_from_the_data_register" number="0x0"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_ARB_LOST_ENUM">
            <enumItem name="master_loses_bus_ownership_during_a_transfer_due_to_ongoing_arbitration" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_RX_UNF_ENUM">
            <enumItem name="host_attempts_to_read_from_the_I2C_data_register_more_times_than_the_value_of_the_transfer_size_register_plus_one" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_TX_OVF_ENUM">
            <enumItem name="host_attempts_to_write_to_the_I2C_data_register_more_times_than_the_FIFO_depth" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_RX_OVF_ENUM">
            <enumItem name="_" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_SLV_RDY_ENUM">
            <enumItem name="_" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_TO_ENUM">
            <enumItem name="_" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_NACK_ENUM">
            <enumItem name="slave_responds_with_a_NACK_or_master_terminates_the_transfer_before_all_data_is_supplied" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_DATA_ENUM">
            <enumItem name="_" number="0x1"/>
        </enumeration>
        <enumeration name="Interrupt_status_reg0_COMP_ENUM">
            <enumItem name="_" number="0x1"/>
        </enumeration>
        <enumeration name="Slave_mon_pause_reg0_Pause_ENUM">
            <enumItem name="_7__pause_interval" number="0x0"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_ARB_LOST_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RX_UNF_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TX_OVF_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RX_OVF_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_SLV_RDY_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TO_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_NACK_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_DATA_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_COMP_ENUM">
            <enumItem name="unmask_this_interrupt" number="0x0"/>
            <enumItem name="Mask_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_ARB_LOST_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_RX_UNF_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_TX_OVF_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_RX_OVF_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_SLV_RDY_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_TO_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_NACK_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_DATA_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_enable_reg0_COMP_ENUM">
            <enumItem name="enable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_ARB_LOST_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_RX_UNF_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_TX_OVF_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_RX_OVF_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_SLV_RDY_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_TO_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_NACK_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_DATA_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_disable_reg0_COMP_ENUM">
            <enumItem name="disable_this_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="StimPort00_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort01_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort02_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort03_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort04_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort05_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort06_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort07_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort08_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort09_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort10_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort11_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort12_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort13_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort14_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort15_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort16_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort17_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort18_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort19_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort20_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort21_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort22_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort23_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort24_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort25_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort26_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort27_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort28_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort29_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort30_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="StimPort31_a_ENUM">
            <enumItem name="of_the_32_stimulus_ports_is_represented_by_a_virtual_address_creating_32_stimulus_registers_A_write_to_one_of_these_locations_causes_data_to_be_written_into_the_FIFO_if_the_corresponding_bit_in_the_Trace_Enable_Register_is_set_and_ITM_is_enabled_Reading_from_any_of_the_stimulus_ports_returns_the_FIFO_status_notFull1___Full0_only_if_the_ITM_is_enabled_This_enables_more_efficient_core_register_allocation_because_the_stimulus" number="0xeac"/>
        </enumeration>
        <enumeration name="reg0_cache_type_data_banking_ENUM">
            <enumItem name="Data_banking_not_implemented" number="0x0"/>
            <enumItem name="Data_banking_implemented" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_control_l2_enable_ENUM">
            <enumItem name="L2_Cache_is_disabled_This_is_the_default_value" number="0x0"/>
            <enumItem name="L2_Cache_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_early_bresp_en_ENUM">
            <enumItem name="Early_BRESP_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Early_BRESP_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_instr_prefetch_en_ENUM">
            <enumItem name="Instruction_prefetching_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Instruction_prefetching_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_data_prefetch_en_ENUM">
            <enumItem name="Data_prefetching_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Data_prefetching_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_nonsec_inte_access_ctrl_ENUM">
            <enumItem name="Interrupt_Clear_0x220_and_Interrupt_Mask_0x214_can_be_modified_or_read_with" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_nonsec_lockdown_en_ENUM">
            <enumItem name="Lockdown_registers_cannot_be_modified_using_non_secure_accesses_This_is_the" number="0x0"/>
            <enumItem name="Non_secure_accesses_can_write_to_the_lockdown_registers" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_cache_replace_policy_ENUM">
            <enumItem name="pseudo_random_replacement_using_lfsr" number="0x0"/>
            <enumItem name="round_robin_replacement_This_is_the_default" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_force_write_alloc_ENUM">
            <enumItem name="Use_AWCACHE_attributes_for_WA_This_is_the_default" number="0x0"/>
            <enumItem name="Force_no_allocate_set_WA_bit_always_0" number="0x1"/>
            <enumItem name="Override_AWCACHE_attributes_set_WA_bit_always_1_all_cacheable_write" number="0x2"/>
            <enumItem name="Internally_mapped_to_00_See_Cache_operation_on_page_2_11_for_more" number="0x3"/>
        </enumeration>
        <enumeration name="reg1_aux_control_shared_attr_override_en_ENUM">
            <enumItem name="Treats_shared_accesses_as_specified_in_Shareable_attribute_on_page_2_15_This" number="0x0"/>
            <enumItem name="Shared_attribute_internally_ignored" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_parity_en_ENUM">
            <enumItem name="Disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_event_mon_bus_en_ENUM">
            <enumItem name="Disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_way_size_ENUM">
            <enumItem name="Reserved_internally_mapped_to_16KB" number="0x0"/>
            <enumItem name="_16KB" number="0x1"/>
            <enumItem name="_32KB" number="0x2"/>
            <enumItem name="_64KB" number="0x3"/>
            <enumItem name="_128KB" number="0x4"/>
            <enumItem name="_256KB" number="0x5"/>
            <enumItem name="_512KB" number="0x6"/>
            <enumItem name="Reserved_internally_mapped_to_512_KB" number="0x7"/>
        </enumeration>
        <enumeration name="reg1_aux_control_associativity_ENUM">
            <enumItem name="_8_way" number="0x0"/>
            <enumItem name="_16_way" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_shared_attr_inva_en_ENUM">
            <enumItem name="Shared_invalidate_behavior_enabled_if_Shared_Attribute_Override_Enable_bit" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_ex_cache_config_ENUM">
            <enumItem name="Disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_store_buff_dev_lim_en_ENUM">
            <enumItem name="Store_buffer_device_limitation_disabled_Device_writes_can_take_all_slots_in_store" number="0x0"/>
            <enumItem name="Store_buffer_device_limitation_enabled_Device_writes_cannot_take_all_slots_in" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_high_pr_so_dev_rd_en_ENUM">
            <enumItem name="Strongly_Ordered_and_Device_reads_have_lower_priority_than_cacheable" number="0x0"/>
            <enumItem name="Strongly_Ordered_and_Device_reads_get_the_highest_priority_when_arbitrated_in" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_aux_control_full_line_zero_enable_ENUM">
            <enumItem name="Full_line_of_write_zero_behavior_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Full_line_of_write_zero_behavior_Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg1_tag_ram_control_ram_wr_access_lat_ENUM">
            <enumItem name="_1_cycle_of_latency_there_is_no_additional_latency" number="0x0"/>
            <enumItem name="_2_cycles_of_latency" number="0x1"/>
            <enumItem name="_3_cycles_of_latency" number="0x2"/>
            <enumItem name="_4_cycles_of_latency" number="0x3"/>
            <enumItem name="_5_cycles_of_latency" number="0x4"/>
            <enumItem name="_6_cycles_of_latency" number="0x5"/>
            <enumItem name="_7_cycles_of_latency" number="0x6"/>
            <enumItem name="_8_cycles_of_latency" number="0x7"/>
        </enumeration>
        <enumeration name="reg1_tag_ram_control_ram_rd_access_lat_ENUM">
            <enumItem name="_1_cycle_of_latency_there_is_no_additional_latency" number="0x0"/>
            <enumItem name="_2_cycles_of_latency" number="0x1"/>
            <enumItem name="_3_cycles_of_latency" number="0x2"/>
            <enumItem name="_4_cycles_of_latency" number="0x3"/>
            <enumItem name="_5_cycles_of_latency" number="0x4"/>
            <enumItem name="_6_cycles_of_latency" number="0x5"/>
            <enumItem name="_7_cycles_of_latency" number="0x6"/>
            <enumItem name="_8_cycles_of_latency" number="0x7"/>
        </enumeration>
        <enumeration name="reg1_tag_ram_control_ram_setup_lat_ENUM">
            <enumItem name="_1_cycle_of_latency_there_is_no_additional_latency" number="0x0"/>
            <enumItem name="_2_cycles_of_latency" number="0x1"/>
            <enumItem name="_3_cycles_of_latency" number="0x2"/>
            <enumItem name="_4_cycles_of_latency" number="0x3"/>
            <enumItem name="_5_cycles_of_latency" number="0x4"/>
            <enumItem name="_6_cycles_of_latency" number="0x5"/>
            <enumItem name="_7_cycles_of_latency" number="0x6"/>
            <enumItem name="_8_cycles_of_latency" number="0x7"/>
        </enumeration>
        <enumeration name="reg1_data_ram_control_ram_wr_access_lat_ENUM">
            <enumItem name="_1_cycle_of_latency_there_is_no_additional_latency" number="0x0"/>
            <enumItem name="_2_cycles_of_latency" number="0x1"/>
            <enumItem name="_3_cycles_of_latency" number="0x2"/>
            <enumItem name="_4_cycles_of_latency" number="0x3"/>
            <enumItem name="_5_cycles_of_latency" number="0x4"/>
            <enumItem name="_6_cycles_of_latency" number="0x5"/>
            <enumItem name="_7_cycles_of_latency" number="0x6"/>
            <enumItem name="_8_cycles_of_latency" number="0x7"/>
        </enumeration>
        <enumeration name="reg1_data_ram_control_ram_rd_access_lat_ENUM">
            <enumItem name="_1_cycle_of_latency_there_is_no_additional_latency" number="0x0"/>
            <enumItem name="_2_cycles_of_latency" number="0x1"/>
            <enumItem name="_3_cycles_of_latency" number="0x2"/>
            <enumItem name="_4_cycles_of_latency" number="0x3"/>
            <enumItem name="_5_cycles_of_latency" number="0x4"/>
            <enumItem name="_6_cycles_of_latency" number="0x5"/>
            <enumItem name="_7_cycles_of_latency" number="0x6"/>
            <enumItem name="_8_cycles_of_latency" number="0x7"/>
        </enumeration>
        <enumeration name="reg1_data_ram_control_ran_setup_lat_ENUM">
            <enumItem name="_1_cycle_of_latency_there_is_no_additional_latency" number="0x0"/>
            <enumItem name="_2_cycles_of_latency" number="0x1"/>
            <enumItem name="_3_cycles_of_latency" number="0x2"/>
            <enumItem name="_4_cycles_of_latency" number="0x3"/>
            <enumItem name="_5_cycles_of_latency" number="0x4"/>
            <enumItem name="_6_cycles_of_latency" number="0x5"/>
            <enumItem name="_7_cycles_of_latency" number="0x6"/>
            <enumItem name="_8_cycles_of_latency" number="0x7"/>
        </enumeration>
        <enumeration name="reg2_ev_counter_ctrl_ev_ctr_en_ENUM">
            <enumItem name="Event_Counting_Enable" number="0x1"/>
        </enumeration>
        <enumeration name="reg2_ev_counter1_cfg_ctr_ev_src_ENUM">
            <enumItem name="CO" number="0x1"/>
            <enumItem name="DRHIT" number="0x2"/>
            <enumItem name="DRREQ" number="0x3"/>
            <enumItem name="DWHIT" number="0x4"/>
            <enumItem name="DWREQ" number="0x5"/>
            <enumItem name="DWTREQ" number="0x6"/>
            <enumItem name="IRHIT" number="0x7"/>
            <enumItem name="IRREQ" number="0x8"/>
            <enumItem name="WA" number="0x9"/>
            <enumItem name="IPFALLOC" number="0xa"/>
            <enumItem name="EPFHIT" number="0xb"/>
            <enumItem name="EPFALLOC" number="0xc"/>
            <enumItem name="SRRCVD" number="0xd"/>
            <enumItem name="SRCONF" number="0xe"/>
            <enumItem name="EPFRCVD" number="0xf"/>
        </enumeration>
        <enumeration name="reg2_ev_counter1_cfg_ev_ctr_intr_gen_ENUM">
            <enumItem name="Enabled__Increment_condition" number="0x1"/>
            <enumItem name="Enabled__Overflow_condition" number="0x2"/>
            <enumItem name="Interrupt_generation_is_disabled" number="0x3"/>
        </enumeration>
        <enumeration name="reg2_ev_counter0_cfg_ctr_ev_src_ENUM">
            <enumItem name="CO" number="0x1"/>
            <enumItem name="DRHIT" number="0x2"/>
            <enumItem name="DRREQ" number="0x3"/>
            <enumItem name="DWHIT" number="0x4"/>
            <enumItem name="DWREQ" number="0x5"/>
            <enumItem name="DWTREQ" number="0x6"/>
            <enumItem name="IRHIT" number="0x7"/>
            <enumItem name="IRREQ" number="0x8"/>
            <enumItem name="WA" number="0x9"/>
            <enumItem name="IPFALLOC" number="0xa"/>
            <enumItem name="EPFHIT" number="0xb"/>
            <enumItem name="EPFALLOC" number="0xc"/>
            <enumItem name="SRRCVD" number="0xd"/>
            <enumItem name="SRCONF" number="0xe"/>
            <enumItem name="EPFRCVD" number="0xf"/>
        </enumeration>
        <enumeration name="reg2_ev_counter0_cfg_ev_ctr_intr_gen_ENUM">
            <enumItem name="Enabled__Increment_condition" number="0x1"/>
            <enumItem name="Enabled__Overflow_condition" number="0x2"/>
            <enumItem name="Interrupt_generation_is_disabled" number="0x3"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown0_DATALOCK000_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x0"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown0_INSTRLOCK000_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x0"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown1_DATALOCK001_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x1"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown1_INSTRLOCK001_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x1"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown2_DATALOCK010_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x2"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown2_INSTRLOCK010_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x2"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown3_DATALOCK011_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x3"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown3_INSTRLOCK011_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x3"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown4_DATALOCK100_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x4"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown4_INSTRLOCK100_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x4"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown5_DATALOCK101_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x5"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown5_INSTRLOCK101_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x5"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown6_DATALOCK110_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x6"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown6_INSTRLOCK110_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x6"/>
        </enumeration>
        <enumeration name="reg9_d_lockdown7_DATALOCK111_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x7"/>
        </enumeration>
        <enumeration name="reg9_i_lockdown7_INSTRLOCK111_ENUM">
            <enumItem name="Use_when_AR_WUSERSx_7_5" number="0x7"/>
        </enumeration>
        <enumeration name="reg9_lock_line_en_lock_down_by_line_enable_ENUM">
            <enumItem name="Lockdown_by_line_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Lockdown_by_line_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg9_unlock_way_unlock_all_lines_by_way_operation_ENUM">
            <enumItem name="Unlock_all_lines_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Unlock_all_lines_operation_in_progress_for_the_corresponding_way" number="0x1"/>
        </enumeration>
        <enumeration name="reg12_addr_filtering_start_addr_filtering_enable_ENUM">
            <enumItem name="Address_filtering_disabled" number="0x0"/>
            <enumItem name="Address_filtering_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_debug_ctrl_DWB_ENUM">
            <enumItem name="Force_write_through_behavior" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_debug_ctrl_DCL_ENUM">
            <enumItem name="Disable_cache_linefills" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_double_linefill_en_ENUM">
            <enumItem name="The_L2CC_always_issues_4x64_bit_read_bursts_to_L3_on_reads" number="0x0"/>
            <enumItem name="The_L2CC_issues_8x64_bit_read_bursts_to_L3_on_reads_that" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_inst_pref_en_ENUM">
            <enumItem name="Instruction_prefetching_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Instruction_prefetching_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_data_pref_en_ENUM">
            <enumItem name="Data_prefetching_disabled_This_is_the_default" number="0x0"/>
            <enumItem name="Data_prefetching_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_double_linefill_on_wrapread_en_ENUM">
            <enumItem name="Double_linefill_on_WRAP_read_enabled_This_is_the_default" number="0x0"/>
            <enumItem name="Double_linefill_on_WRAP_read_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_pref_drop_en_ENUM">
            <enumItem name="The_L2CC_does_not_discard_prefetch_reads_issued_to_L3_This" number="0x0"/>
            <enumItem name="The_L2CC_discards_prefetch_reads_issued_to_L3_when_there_is" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_incr_double_linefill_en_ENUM">
            <enumItem name="The_L2CC_does_not_issue_INCR_8x64_bit_read_bursts_to_L3_on" number="0x0"/>
            <enumItem name="The_L2CC_can_issue_INCR_8x64_bit_read_bursts_to_L3_on" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_prefetch_ctrl_not_same_id_on_excl_seq_en_ENUM">
            <enumItem name="Read_and_write_portions_of_a_non_cacheable_exclusive" number="0x0"/>
            <enumItem name="Read_and_write_portions_of_a_non_cacheable_exclusive_1" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_power_ctrl_dynamic_clk_gating_en_ENUM">
            <enumItem name="Masked_This_is_the_default" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="reg15_power_ctrl_standby_mode_en_ENUM">
            <enumItem name="Masked_This_is_the_default" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_CONTROL_REGISTER_SCU_RAMs_Parity_enable_ENUM">
            <enumItem name="Parity_off_This_is_the_default_setting" number="0x0"/>
            <enumItem name="Parity_on" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_CONTROL_REGISTER_Address_filtering_enable_ENUM">
            <enumItem name="Addressing_filtering_off" number="0x0"/>
            <enumItem name="Addressing_filtering_on" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_CONTROL_REGISTER_SCU_enable_ENUM">
            <enumItem name="SCU_disable_This_is_the_default_setting" number="0x0"/>
            <enumItem name="SCU_enable" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_CONFIGURATION_REGISTER_Tag_RAM_sizes_ENUM">
            <enumItem name="_16KB_cache_64_indexes_per_tag_RAM" number="0x0"/>
            <enumItem name="_32KB_cache_128_indexes_per_tag_RAM" number="0x1"/>
            <enumItem name="_64KB_cache_256_indexes_per_tag_RAM" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="SCU_CONFIGURATION_REGISTER_CPUs_SMP_ENUM">
            <enumItem name="this_Cortex_A9_processor_is_in_AMP_mode_not_taking_part_in_coherency_or_not_present" number="0x0"/>
            <enumItem name="this_Cortex_A9_processor_is_in_SMP_mode_taking_part_in_coherency" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_CONFIGURATION_REGISTER_CPU_number_ENUM">
            <enumItem name="one_Cortex_A9_processor_CPU0" number="0x0"/>
            <enumItem name="two_Cortex_A9_processors_CPU0_and_CPU1" number="0x1"/>
            <enumItem name="three_Cortex_A9_processors_CPU0_CPU1_and_CPU2" number="0x2"/>
            <enumItem name="four_Cortex_A9_processors_CPU0_CPU1_CPU2_and_CPU3" number="0x3"/>
        </enumeration>
        <enumeration name="SCU_CPU_Power_Status_Register_CPU3_status_ENUM">
            <enumItem name="Normal_mode" number="0x0"/>
            <enumItem name="Reserved" number="0x1"/>
            <enumItem name="the_Cortex_A9_processor_is_about_to_enter_or_is_in_dormant_mode_No_coherency" number="0x2"/>
            <enumItem name="the_Cortex_A9_processor_is_about_to_enter_or_is_in_powered_off_mode_or_is_nonpresent" number="0x3"/>
        </enumeration>
        <enumeration name="SCU_Access_Control_Register_SAC_CPU3_ENUM">
            <enumItem name="CPU3_cannot_access_the_components" number="0x0"/>
            <enumItem name="CPU3_can_access_the_components_This_is_the_default" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_Access_Control_Register_SAC_CPU2_ENUM">
            <enumItem name="CPU2_cannot_access_the_components" number="0x0"/>
            <enumItem name="CPU2_can_access_the_components_This_is_the_default" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_Access_Control_Register_SAC_CPU1_ENUM">
            <enumItem name="CPU1_cannot_access_the_components" number="0x0"/>
            <enumItem name="CPU1_can_access_the_components_This_is_the_default" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_Access_Control_Register_SAC_CPU0_ENUM">
            <enumItem name="CPU0_cannot_access_the_components" number="0x0"/>
            <enumItem name="CPU0_can_access_the_components_This_is_the_default" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_Non_secure_Access_Control_Register_CPU0_global_timer_ENUM">
            <enumItem name="Secure_accesses_only_This_is_the_default_value" number="0x0"/>
            <enumItem name="Secure_accesses_and_Non_Secure_accesses" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_Non_secure_Access_Control_Register_Private_timers_for_CPU0_ENUM">
            <enumItem name="Secure_accesses_only_Non_secure_reads_return_0_This_is_the_default_value" number="0x0"/>
            <enumItem name="Secure_accesses_and_Non_secure_accesses" number="0x1"/>
        </enumeration>
        <enumeration name="SCU_Non_secure_Access_Control_Register_Component_access_for_CPU0_ENUM">
            <enumItem name="CPU_cannot_write_the_componentsa" number="0x0"/>
            <enumItem name="CPU_can_access_the_componentsa" number="0x1"/>
        </enumeration>
        <enumeration name="ICCICR_SBPR_ENUM">
            <enumItem name="use_the_Secure_Binary_Point_Register_for_Secure_interrupts_and_use_the_Non_secure_Binary_Point_Register_for_Non_secure_interrupts" number="0x0"/>
            <enumItem name="use_the_Secure_Binary_Point_Register_for_both_Secure_and_Non_secure_interrupts" number="0x1"/>
        </enumeration>
        <enumeration name="ICCICR_FIQEn_ENUM">
            <enumItem name="using_IRQ_1" number="0x0"/>
        </enumeration>
        <enumeration name="ICCIDR_Implementer_ENUM">
            <enumItem name="_7" number="0x0"/>
        </enumeration>
        <enumeration name="Global_Timer_Control_Register_a_ENUM">
            <enumItem name="single_shot_mode" number="0x0"/>
            <enumItem name="auto_increment_mode" number="0x1"/>
            <enumItem name="time_the_counter_reaches_the_comparator_value_the_comparator_register_is" number="0xeac"/>
        </enumeration>
        <enumeration name="Global_Timer_Control_Register_Timer_Enable_ENUM">
            <enumItem name="Timer_is_disabled_and_the_counter_does_not_increment" number="0x0"/>
            <enumItem name="Timer_is_enabled_and_the_counter_increments_normally" number="0x1"/>
        </enumeration>
        <enumeration name="Private_Timer_Control_Register_Auto_reload_ENUM">
            <enumItem name="Single_shot_mode" number="0x0"/>
            <enumItem name="Auto_reload_mode" number="0x1"/>
            <enumItem name="time_the_Counter_Register_reaches_zero_it_is_reloaded_with_the_value_contained_in_the" number="0xeac"/>
        </enumeration>
        <enumeration name="Private_Timer_Control_Register_Timer_Enable_ENUM">
            <enumItem name="Timer_is_disabled_and_the_counter_does_not_decrement" number="0x0"/>
            <enumItem name="Timer_is_enabled_and_the_counter_decrements_normally" number="0x1"/>
        </enumeration>
        <enumeration name="Watchdog_Control_Register_Watchdog_mode_ENUM">
            <enumItem name="Timer_mode_default" number="0x0"/>
            <enumItem name="Watchdog_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Watchdog_Control_Register_Auto_reload_ENUM">
            <enumItem name="Single_shot_mode" number="0x0"/>
            <enumItem name="Auto_reload_mode" number="0x1"/>
            <enumItem name="time_the_Counter_Register_reaches_zero_it_is_reloaded_with_the_value_contained_in_the" number="0xeac"/>
        </enumeration>
        <enumeration name="Watchdog_Control_Register_Watchdog_Enable_ENUM">
            <enumItem name="Watchdog_is_disabled_and_the_counter_does_not_decrement_All_registers_can_still_be" number="0x0"/>
            <enumItem name="Watchdog_is_enabled_and_the_counter_decrements_normally" number="0x1"/>
        </enumeration>
        <enumeration name="ICDDCR_Enable_Non_secure_ENUM">
            <enumItem name="disables_all_Non_secure_interrupts_control_bits_in_the_distributor_from_changing_state" number="0x0"/>
            <enumItem name="enables_the_distributor_to_update_register_locations_for_Non_secure_interrupts" number="0x1"/>
        </enumeration>
        <enumeration name="ICDICTR_LSPI_ENUM">
            <enumItem name="_31_LSPIs_which_are_the_interrupts_of_IDs_32_62" number="0x1f"/>
        </enumeration>
        <enumeration name="ICDICTR_SecurityExtn_ENUM">
            <enumItem name="the_controller_contains_two_security_domains" number="0x1"/>
        </enumeration>
        <enumeration name="ICDICTR_CPU_Number_ENUM">
            <enumItem name="the_Cortex_A9_MPCore_configuration_contains_one_Cortex_A9_processor" number="0x0"/>
            <enumItem name="the_Cortex_A9_MPCore_configuration_contains_two_Cortex_A9_processors" number="0x1"/>
            <enumItem name="the_Cortex_A9_MPCore_configuration_contains_three_Cortex_A9_processors" number="0x2"/>
            <enumItem name="the_Cortex_A9_MPCore_configuration_contains_four_Cortex_A9_processors" number="0x3"/>
        </enumeration>
        <enumeration name="ICDICTR_IT_Lines_Number_ENUM">
            <enumItem name="the_distributor_provides_32_interruptsa_no_external_interrupt_lines" number="0x0"/>
            <enumItem name="the_distributor_provides_64_interrupts_32_external_interrupt_lines" number="0x1"/>
            <enumItem name="the_distributor_provides_96_interrupts_64_external_interrupt_lines" number="0x2"/>
            <enumItem name="the_distributor_provide_128_interrupts_96_external_interrupt_lines" number="0x3"/>
            <enumItem name="the_distributor_provides_160_interrupts_128_external_interrupt_lines" number="0x4"/>
            <enumItem name="the_distributor_provides_192_interrupts_160_external_interrupt_lines" number="0x5"/>
            <enumItem name="the_distributor_provides_224_interrupts_192_external_interrupt_lines" number="0x6"/>
            <enumItem name="the_distributor_provides_256_interrupts_224_external_interrupt_lines" number="0x7"/>
        </enumeration>
        <enumeration name="ICDISR0_Security_Status_ENUM">
            <enumItem name="bit_controls_the_security_status_of_the_corresponding_interrupt" number="0xeac"/>
        </enumeration>
        <enumeration name="ICDISR1_Security_Status_ENUM">
            <enumItem name="bit_controls_the_security_status_of_the_corresponding_interrupt" number="0xeac"/>
        </enumeration>
        <enumeration name="ICDISR2_Security_Status_ENUM">
            <enumItem name="bit_controls_the_security_status_of_the_corresponding_interrupt" number="0xeac"/>
        </enumeration>
        <enumeration name="ICDSGIR_CPUTargetList_ENUM">
            <enumItem name="bit_refers_to_the_corresponding_CPU_interface" number="0xeac"/>
        </enumeration>
        <enumeration name="ICDSGIR_SATT_ENUM">
            <enumItem name="only_if_the_SGI_is_configured_as_Secure_on_that_interface" number="0x0"/>
            <enumItem name="only_if_the_SGI_is_configured_as_Non_secure_on_that_interface" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_PARITY_CTRL_OddParityEn_ENUM">
            <enumItem name="Even_Parity_generated" number="0x0"/>
            <enumItem name="Odd" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_PARITY_CTRL_MultipleParityErrIrqEn_ENUM">
            <enumItem name="IRQ_is_not_generated_when_parity_error_detected_and_ParityCheckDis_0" number="0x0"/>
            <enumItem name="IRQ_is_generated_when_parity_error_detected_and_ParityCheckDis_0" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_PARITY_CTRL_SingleParityErrIrqEn_ENUM">
            <enumItem name="IRQ_is_not_generated_when_parity_error_detected_and_ParityCheckDis_0" number="0x0"/>
            <enumItem name="IRQ_is_generated_when_parity_error_detected_and_ParityCheckDis_0" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_PARITY_CTRL_RdRespParityErrEn_ENUM">
            <enumItem name="Error_will_not_be_sent_on_AXI_read_channel_when_parity_error_detected" number="0x0"/>
            <enumItem name="Error_will_be_sent_on_AXI_read_channel_when_parity_error_detected_and_ParityCheckDis_0" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_PARITY_CTRL_ParityCheckDis_ENUM">
            <enumItem name="RAM_Parity_checking_is_enabled" number="0x0"/>
            <enumItem name="RAM_Parity_checking_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_IRQ_STS_MultipleParityErr_ENUM">
            <enumItem name="Multiple_OCM_parity_Errors_have_not_occurred" number="0x0"/>
            <enumItem name="Multiple_OCM_parity_Errors_have_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="OCM_IRQ_STS_SingleParityErr_ENUM">
            <enumItem name="Single_OCM_parity_Error_has_not_occurred" number="0x0"/>
            <enumItem name="Single_OCM_parity_Error_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="memc_status_state_ENUM">
            <enumItem name="SMC_is_in_the_ready_state" number="0x0"/>
            <enumItem name="SMC_is_in_the_low_power_state" number="0x1"/>
        </enumeration>
        <enumeration name="memif_cfg_exclusive_monitors_ENUM">
            <enumItem name="_0_monitors" number="0x0"/>
            <enumItem name="_1_monitor" number="0x1"/>
            <enumItem name="_2_monitors" number="0x2"/>
            <enumItem name="_4_monitors" number="0x3"/>
        </enumeration>
        <enumeration name="memif_cfg_memory_width1_ENUM">
            <enumItem name="_8_bits" number="0x0"/>
            <enumItem name="_16_bits" number="0x1"/>
            <enumItem name="_32_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="memif_cfg_memory_chips1_ENUM">
            <enumItem name="_1_chip" number="0x0"/>
            <enumItem name="_2_chips" number="0x1"/>
            <enumItem name="_3_chips" number="0x2"/>
            <enumItem name="_4_chips" number="0x3"/>
        </enumeration>
        <enumeration name="memif_cfg_memory_type1_ENUM">
            <enumItem name="SRAM_non_multiplexed" number="0x1"/>
            <enumItem name="NAND" number="0x2"/>
            <enumItem name="SRAM_multiplexed" number="0x3"/>
        </enumeration>
        <enumeration name="memif_cfg_memory_width0_ENUM">
            <enumItem name="_8_bits" number="0x0"/>
            <enumItem name="_16_bits" number="0x1"/>
            <enumItem name="_32_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="memif_cfg_memory_chips0_ENUM">
            <enumItem name="_1_chip" number="0x0"/>
            <enumItem name="_2_chips" number="0x1"/>
            <enumItem name="_3_chips" number="0x2"/>
            <enumItem name="_4_chips" number="0x3"/>
        </enumeration>
        <enumeration name="memif_cfg_memory_type0_ENUM">
            <enumItem name="_reserved" number="0x0"/>
            <enumItem name="SRAM_non_multiplexed" number="0x1"/>
            <enumItem name="NAND" number="0x2"/>
            <enumItem name="SRAM_multiplexed" number="0x3"/>
        </enumeration>
        <enumeration name="memc_cfg_set_ecc_int_enable1_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="ECC_interrupt_enable_memory_interface_1" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_set_ecc_int_enable0_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="ECC_interrupt_enable_memory_interface_0" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_set_low_power_req_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Request_the_SMC_to_enter_low_power_state_when_it_next_becomes_idle" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_set_int_enable1_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Interrupt_enable_memory_interface_1" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_set_int_enable0_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Interrupt_enable_memory_interface_0" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_ecc_int_disable1_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Disable_ECC_Interrupt_on_IF1" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_ecc_int_disable0_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Disable_ECC_Interrupt_on_IF0" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_int_clr_1_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Clear_SMC_Interrupt_1_as_an_alternative_to_an_AXI_read" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_int_clr_0_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Clear_SMC_Interrupt_0_as_an_alternative_to_an_AXI_read" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_low_power_exit_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Request_the_SMC_to_exit_low_power_state" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_int_disable1_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Interrupt_disable_memory_interface_1" number="0x1"/>
        </enumeration>
        <enumeration name="memc_cfg_clr_int_disable0_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Interrupt_disable_memory_interface_0" number="0x1"/>
        </enumeration>
        <enumeration name="direct_cmd_cmd_type_ENUM">
            <enumItem name="UpdateRegs_and_AXI" number="0x0"/>
            <enumItem name="ModeReg" number="0x1"/>
            <enumItem name="UpdateRegs" number="0x2"/>
            <enumItem name="ModeReg_and_UpdateRegs" number="0x3"/>
        </enumeration>
        <enumeration name="direct_cmd_set_cre_ENUM">
            <enumItem name="cre_is_LOW" number="0x0"/>
            <enumItem name="cre_is_HIGH_when_ModeReg_write_occurs" number="0x1"/>
        </enumeration>
        <enumeration name="set_opmode_set_burst_align_ENUM">
            <enumItem name="bursts_can_cross_any_address_boundary" number="0x0"/>
            <enumItem name="burst_split_on_memory_burst_boundary_that_is_32_beats_for_continuous" number="0x1"/>
            <enumItem name="burst_split_on_64_beat_boundary" number="0x2"/>
            <enumItem name="burst_split_on_128_beat_boundary" number="0x3"/>
            <enumItem name="burst_split_on_256_beat_boundary" number="0x4"/>
        </enumeration>
        <enumeration name="set_opmode_set_bls_ENUM">
            <enumItem name="bls_timing_equals_chip_select_timing_This_is_the_default_setting" number="0x0"/>
            <enumItem name="bls_timing_equals_we_n_timing_This_setting_is_used_for_eight_memories_that_have_no_bls_n_inputs_In_this_case_the_bls_n_output_of_the_SMC_is_connected_to_the_we_n_memory_input" number="0x1"/>
        </enumeration>
        <enumeration name="set_opmode_set_wr_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="set_opmode_set_rd_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="set_opmode_set_mw_ENUM">
            <enumItem name="_8_bitsb" number="0x0"/>
            <enumItem name="_16_bitsb" number="0x1"/>
            <enumItem name="_32_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="refresh_period_0_period_ENUM">
            <enumItem name="disables_the_insertion_of_idle_cycles_between_consecutive_bursts" number="0x0"/>
            <enumItem name="an_idle_cycle_occurs_after_each_burst" number="0x1"/>
            <enumItem name="an_idle_cycle_occurs_after_2_consecutive_bursts" number="0x2"/>
            <enumItem name="an_idle_cycle_occurs_after_3_consecutive_bursts" number="0x3"/>
            <enumItem name="an_idle_cycle_occurs_after_4_consecutive_bursts" number="0x4"/>
            <enumItem name="an_idle_cycle_occurs_after_15_consecutive_bursts" number="0xf"/>
        </enumeration>
        <enumeration name="refresh_period_1_period_ENUM">
            <enumItem name="disables_the_insertion_of_idle_cycles_between_consecutive_bursts" number="0x0"/>
            <enumItem name="an_idle_cycle_occurs_after_each_burst" number="0x1"/>
            <enumItem name="an_idle_cycle_occurs_after_2_consecutive_bursts" number="0x2"/>
            <enumItem name="an_idle_cycle_occurs_after_3_consecutive_bursts" number="0x3"/>
            <enumItem name="an_idle_cycle_occurs_after_4_consecutive_bursts" number="0x4"/>
            <enumItem name="an_idle_cycle_occurs_after_15_consecutive_bursts" number="0xf"/>
        </enumeration>
        <enumeration name="sram_cycles0_0_we_time_ENUM">
            <enumItem name="SMC_asserts_we_n_two_mclk_cycles_after_asserting_cs_n" number="0x0"/>
            <enumItem name="SMC_asserts_we_n_and_cs_n_together" number="0x1"/>
        </enumeration>
        <enumeration name="opmode0_0_burst_align_ENUM">
            <enumItem name="bursts_can_cross_any_address_boundary" number="0x0"/>
            <enumItem name="burst_split_on_memory_burst_boundary_that_is_32_beats_for_continuous" number="0x1"/>
            <enumItem name="burst_split_on_64_beat_boundary" number="0x2"/>
            <enumItem name="burst_split_on_128_beat_boundary" number="0x3"/>
            <enumItem name="burst_split_on_256_beat_boundary" number="0x4"/>
        </enumeration>
        <enumeration name="opmode0_0_bls_ENUM">
            <enumItem name="bls_timing_equals_chip_select_timing_This_is_the_default_setting" number="0x0"/>
            <enumItem name="bls_timing_equals_we_n_timing_This_setting_is_used_for_8_bit_memories_that_have_no_bls_inputs_In_this_case_the_bls_n_output_of_the_SMC_is_connected_to_the_we_n_memory_input" number="0x1"/>
        </enumeration>
        <enumeration name="opmode0_0_wr_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="opmode0_0_rd_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="opmode0_0_mw_ENUM">
            <enumItem name="_8_bits" number="0x0"/>
            <enumItem name="_16_bits" number="0x1"/>
            <enumItem name="_32_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="sram_cycles0_1_we_time_ENUM">
            <enumItem name="SMC_asserts_we_n_two_mclk_cycles_after_asserting_cs_n" number="0x0"/>
            <enumItem name="SMC_asserts_we_n_and_cs_n_together" number="0x1"/>
        </enumeration>
        <enumeration name="opmode0_1_burst_align_ENUM">
            <enumItem name="bursts_can_cross_any_address_boundary" number="0x0"/>
            <enumItem name="burst_split_on_memory_burst_boundary_that_is_32_beats_for_continuous" number="0x1"/>
            <enumItem name="burst_split_on_64_beat_boundary" number="0x2"/>
            <enumItem name="burst_split_on_128_beat_boundary" number="0x3"/>
            <enumItem name="burst_split_on_256_beat_boundary" number="0x4"/>
        </enumeration>
        <enumeration name="opmode0_1_bls_ENUM">
            <enumItem name="bls_timing_equals_chip_select_timing_This_is_the_default_setting" number="0x0"/>
            <enumItem name="bls_timing_equals_we_n_timing_This_setting_is_used_for_8_bit_memories_that_have_no_bls_inputs_In_this_case_the_bls_n_output_of_the_SMC_is_connected_to_the_we_n_memory_input" number="0x1"/>
        </enumeration>
        <enumeration name="opmode0_1_wr_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="opmode0_1_rd_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="opmode0_1_mw_ENUM">
            <enumItem name="_8_bits" number="0x0"/>
            <enumItem name="_16_bits" number="0x1"/>
            <enumItem name="_32_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="opmode1_0_burst_align_ENUM">
            <enumItem name="bursts_can_cross_any_address_boundary" number="0x0"/>
            <enumItem name="burst_split_on_memory_burst_boundary_that_is_32_beats_for_continuous" number="0x1"/>
            <enumItem name="burst_split_on_64_beat_boundary" number="0x2"/>
            <enumItem name="burst_split_on_128_beat_boundary" number="0x3"/>
            <enumItem name="burst_split_on_256_beat_boundary" number="0x4"/>
        </enumeration>
        <enumeration name="opmode1_0_bls_ENUM">
            <enumItem name="bls_timing_equals_chip_select_timing_This_is_the_default_setting" number="0x0"/>
            <enumItem name="bls_timing_equals_we_n_timing_This_setting_is_used_for_8_bit_memories_that_have_no_bls_inputs_In_this_case_the_bls_n_output_of_the_SMC_is_connected_to_the_we_n_memory_input" number="0x1"/>
        </enumeration>
        <enumeration name="opmode1_0_wr_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="opmode1_0_rd_bl_ENUM">
            <enumItem name="_1_beat" number="0x0"/>
            <enumItem name="_4_beats" number="0x1"/>
            <enumItem name="_8_beats" number="0x2"/>
            <enumItem name="_16_beats" number="0x3"/>
            <enumItem name="_32_beats" number="0x4"/>
            <enumItem name="continuous" number="0x5"/>
        </enumeration>
        <enumeration name="opmode1_0_mw_ENUM">
            <enumItem name="_8_bits" number="0x0"/>
            <enumItem name="_16_bits" number="0x1"/>
            <enumItem name="_32_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_status_0_ecc_read_ENUM">
            <enumItem name="not_read" number="0x0"/>
            <enumItem name="read" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_status_0_ecc_can_correct_ENUM">
            <enumItem name="not_correctable" number="0x0"/>
            <enumItem name="correctable" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_status_0_ecc_read_not_write_ENUM">
            <enumItem name="write" number="0x0"/>
            <enumItem name="read" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_status_0_ecc_last_status_ENUM">
            <enumItem name="Completed_successfully" number="0x0"/>
            <enumItem name="Unaligned_Address_or_out_of_range" number="0x1"/>
            <enumItem name="Data_stop_after_incomplete_block" number="0x2"/>
            <enumItem name="Data_stopped_but_values_not_read_written_because_of_ecc_jump_value" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_status_0_ecc_status_ENUM">
            <enumItem name="idle" number="0x0"/>
            <enumItem name="busy" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_memcfg_0_ecc_extra_block_size_ENUM">
            <enumItem name="_4_bytes" number="0x0"/>
            <enumItem name="_8_bytes" number="0x1"/>
            <enumItem name="_16_bytes" number="0x2"/>
            <enumItem name="_32_bytes" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_memcfg_0_ecc_ignore_add_eight_ENUM">
            <enumItem name="A8_is_output" number="0x0"/>
            <enumItem name="A8_is_not_output" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_memcfg_0_ecc_jump_ENUM">
            <enumItem name="no_jumping_reads_and_writes_only_occur_at_end_of_page" number="0x0"/>
            <enumItem name="jump_using_column_change_commands" number="0x1"/>
            <enumItem name="jump_using_full_command" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_memcfg_0_ecc_read_end_ENUM">
            <enumItem name="the_ECC_value_for_a_block_must_be_read_immediately_after_the_block_Data_access_must_stop_on_a_512_byte_boundary" number="0x0"/>
            <enumItem name="ECC_values_for_all_blocks_are_read_at_the_end_of_the_page" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_memcfg_0_ecc_mode_ENUM">
            <enumItem name="bypassed" number="0x0"/>
            <enumItem name="ECC_values_are_calculated_and_made_available_on_the_APB_interface_But_they_are_not_read_to_or_written_from_memory" number="0x1"/>
            <enumItem name="ECC_values_and_calculated_and_read_written_to_memory_For_a_read_the_ECC_value_is_checked_and_the_result_of_the_check_is_made_available_on_the_APB_interface" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_memcfg_0_page_size_ENUM">
            <enumItem name="No_512_byte_blocks_Reserved_if_an_ecc_extra_block_is_not_configured_and_enabled" number="0x0"/>
            <enumItem name="One_512_byte_block" number="0x1"/>
            <enumItem name="Two_512_byte_blocks" number="0x2"/>
            <enumItem name="Four_512_byte_blocks" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_status_1_ecc_read_ENUM">
            <enumItem name="not_read" number="0x0"/>
            <enumItem name="read" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_status_1_ecc_can_correct_ENUM">
            <enumItem name="not_correctable" number="0x0"/>
            <enumItem name="correctable" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_status_1_ecc_read_not_write_ENUM">
            <enumItem name="write" number="0x0"/>
            <enumItem name="read" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_status_1_ecc_last_status_ENUM">
            <enumItem name="Completed_successfully" number="0x0"/>
            <enumItem name="Unaligned_Address_or_out_of_range" number="0x1"/>
            <enumItem name="Data_stop_after_incomplete_block" number="0x2"/>
            <enumItem name="Data_stopped_but_values_not_read_written_because_of_ecc_jump_value" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_status_1_ecc_status_ENUM">
            <enumItem name="idle" number="0x0"/>
            <enumItem name="busy" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_memcfg_1_ecc_extra_block_size_ENUM">
            <enumItem name="_4_bytes" number="0x0"/>
            <enumItem name="_8_bytes" number="0x1"/>
            <enumItem name="_16_bytes" number="0x2"/>
            <enumItem name="_32_bytes" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_memcfg_1_ecc_ignore_add_eight_ENUM">
            <enumItem name="A8_is_output" number="0x0"/>
            <enumItem name="A8_is_not_output" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_memcfg_1_ecc_jump_ENUM">
            <enumItem name="no_jumping_reads_and_writes_only_occur_at_end_of_page" number="0x0"/>
            <enumItem name="jump_using_column_change_commands" number="0x1"/>
            <enumItem name="jump_using_full_command" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_memcfg_1_ecc_read_end_ENUM">
            <enumItem name="the_ECC_value_for_a_block_must_be_read_immediately_after_the_block_Data_access_must_stop_on_a_512_byte_boundary" number="0x0"/>
            <enumItem name="ECC_values_for_all_blocks_are_read_at_the_end_of_the_page" number="0x1"/>
        </enumeration>
        <enumeration name="ecc_memcfg_1_ecc_mode_ENUM">
            <enumItem name="bypassed" number="0x0"/>
            <enumItem name="ECC_values_are_calculated_and_made_available_on_the_APB_interface_But_they_are_not_read_to_or_written_from_memory" number="0x1"/>
            <enumItem name="ECC_values_and_calculated_and_read_written_to_memory_For_a_read_the_ECC_value_is_checked_and_the_result_of_the_check_is_made_available_on_the_APB_interface" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="ecc_memcfg_1_page_size_ENUM">
            <enumItem name="No_512_byte_blocks_Reserved_if_an_ecc_extra_block_is_not_configured_and_enabled" number="0x0"/>
            <enumItem name="One_512_byte_block" number="0x1"/>
            <enumItem name="Two_512_byte_blocks" number="0x2"/>
            <enumItem name="Four_512_byte_blocks" number="0x3"/>
        </enumeration>
        <enumeration name="ETMTECR1_TraceSSEn_ENUM">
            <enumItem name="Tracing_is_unaffected_by_the_trace_start_stop_logic" number="0x0"/>
            <enumItem name="Tracing_is_controlled_by_the_trace_on_and_off_addresses_configured_for_the_trace_start_stop_logic" number="0x1"/>
        </enumeration>
        <enumeration name="ETMTECR1_ExcIncFlag_ENUM">
            <enumItem name="Include_The_specified_address_range_comparators_indicate_the_regions_where_tracing_can_occur" number="0x0"/>
            <enumItem name="Exclude_The_specified_address_range_comparators_indicate_regions_to_be_excluded_from_the" number="0x1"/>
        </enumeration>
        <enumeration name="ETMAUXCR_ForceSyncInsert_ENUM">
            <enumItem name="Synchronization_packets_delayed_when_trace_activity_is_high_This_is_the_reset_value" number="0x0"/>
            <enumItem name="Synchronization_packets_inserted_regardless_of_trace_activity" number="0x1"/>
        </enumeration>
        <enumeration name="ETMAUXCR_DisableWPUpdate_ENUM">
            <enumItem name="PTM_always_issues_update_packets_if_there_are_more_than_4096_bytes_between_waypoints_This_is_the_reset_value" number="0x0"/>
            <enumItem name="PTM_does_not_issue_waypoint_update_packets_unless_required_to_do_so_as_the_result_of_an_exception_or_debug_entry" number="0x1"/>
        </enumeration>
        <enumeration name="ETMAUXCR_DisableTSOnBarr_ENUM">
            <enumItem name="PTM_issues_timestamps_on_barrier_instructions_This_is_the_reset_value" number="0x0"/>
            <enumItem name="PTM_does_not_issue_timestamps_on_barriers" number="0x1"/>
        </enumeration>
        <enumeration name="ETMAUXCR_DisableForcedOF_ENUM">
            <enumItem name="Forced_overflow_enabled_This_is_the_reset_value" number="0x0"/>
            <enumItem name="Forced_overflow_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_leg_flsh_ENUM">
            <enumItem name="legacy_SPI_mode" number="0x0"/>
            <enumItem name="Flash_memory_interface_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_endian_ENUM">
            <enumItem name="for_little_endian_format_when_writing_to_the_transmit_data_register_0x1C_or_reading_from_the_receive_data_register_0x20" number="0x0"/>
            <enumItem name="for_big_endian_format_when_writing_to_the_transmit_data_register_0x1C_or_reading_from_the_receive_data_register_0x20" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_Man_start_com_ENUM">
            <enumItem name="dont_care" number="0x0"/>
            <enumItem name="start_transmission_of_data" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_Man_start_en_ENUM">
            <enumItem name="auto_mode" number="0x0"/>
            <enumItem name="enables_maual_start" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_Manual_CS_ENUM">
            <enumItem name="auto_mode" number="0x0"/>
            <enumItem name="manual_CS_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_REF_CLK_ENUM">
            <enumItem name="use_SPI_REFERENCE_CLOCK" number="0x0"/>
            <enumItem name="use_ext_clk" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_FIFO_WIDTH_ENUM">
            <enumItem name="_8bits" number="0x0"/>
            <enumItem name="_16bits" number="0x1"/>
            <enumItem name="_24bits" number="0x2"/>
            <enumItem name="_32bits" number="0x3"/>
        </enumeration>
        <enumeration name="Config_reg_BAUD_RATE_DIV_ENUM">
            <enumItem name="divide_by_2" number="0x0"/>
            <enumItem name="divide_by_4" number="0x1"/>
            <enumItem name="divide_by_8" number="0x2"/>
            <enumItem name="divide_by_16" number="0x3"/>
            <enumItem name="divide_by_32" number="0x4"/>
            <enumItem name="divide_by_64" number="0x5"/>
            <enumItem name="divide_by_128" number="0x6"/>
            <enumItem name="divide_by_256" number="0x7"/>
        </enumeration>
        <enumeration name="Config_reg_CLK_PH_ENUM">
            <enumItem name="the_SPI_clock_is_active_outside_the_word" number="0x0"/>
            <enumItem name="the_SPI_clock_is_inactive_outside_the_word" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_CLK_POL_ENUM">
            <enumItem name="the_SPI_clock_is_quiescent_low" number="0x0"/>
            <enumItem name="the_SPI_clock_is_quiescent_high" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg_MODE_SEL_ENUM">
            <enumItem name="the_SPI_is_in_slave_mode" number="0x0"/>
            <enumItem name="the_SPI_is_in_master_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_REG_TX_FIFO_underflow_ENUM">
            <enumItem name="no_underflow_has_been_detected" number="0x0"/>
            <enumItem name="underflow_is_detected" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_REG_RX_FIFO_full_ENUM">
            <enumItem name="FIFO_is_not_full" number="0x0"/>
            <enumItem name="FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_REG_RX_FIFO_not_empty_ENUM">
            <enumItem name="FIFO_has_less_than_RX_THRESHOLD_entries" number="0x0"/>
            <enumItem name="FIFO_has_more_than_or_equal_to_THRESHOLD_entries" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_REG_TX_FIFO_full_ENUM">
            <enumItem name="FIFO_is_not_full" number="0x0"/>
            <enumItem name="FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_REG_TX_FIFO_not_full_ENUM">
            <enumItem name="FIFO_has_more_than_or_equal_toTHRESHOLD_entries" number="0x0"/>
            <enumItem name="FIFO_has_less_than_THRESHOLD_entries" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_REG_RX_OVERFLOW_ENUM">
            <enumItem name="no_overflow_occurred" number="0x0"/>
            <enumItem name="overflow_occured" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_REG_TX_FIFO_underflow_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_REG_RX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_REG_RX_FIFO_not_empty_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_REG_TX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_REG_TX_FIFO_not_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_REG_RX_OVERFLOW_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_REG_TX_FIFO_underflow_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_REG_RX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_REG_RX_FIFO_not_empty_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_REG_TX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_REG_TX_FIFO_not_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_REG_RX_OVERFLOW_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_REG_TX_FIFO_underflow_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_REG_RX_FIFO_full_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_REG_RX_FIFO_not_empty_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_REG_TX_FIFO_full_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_REG_TX_FIFO_not_full_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_REG_RX_OVERFLOW_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="En_REG_SPI_EN_ENUM">
            <enumItem name="disable_the_SPI" number="0x0"/>
            <enumItem name="enable_the_SPI" number="0x1"/>
        </enumeration>
        <enumeration name="LPBK_DLY_ADJ_LPBK_SEL_ENUM">
            <enumItem name="loopback_at_pad" number="0x0"/>
            <enumItem name="loopback_through_external_connections" number="0x1"/>
        </enumeration>
        <enumeration name="LQSPI_CFG_INST_CODE_ENUM">
            <enumItem name="Read" number="0x3"/>
            <enumItem name="Fast_read" number="0xb"/>
            <enumItem name="Fast_read_dual_output" number="0x3b"/>
            <enumItem name="Fast_read_quad_output" number="0x6b"/>
            <enumItem name="Fast_read_dual_I_O" number="0xbb"/>
            <enumItem name="Fast_read_quad_I_O" number="0xeb"/>
        </enumeration>
        <enumeration name="Block_Size_Block_Count_Blocks_Count_for_Current_Transfer_ENUM">
            <enumItem name="Stop_Count" number="0x0"/>
            <enumItem name="_1_block" number="0x1"/>
            <enumItem name="_2_blocks" number="0x2"/>
            <enumItem name="_65535_blocks" number="0xffff"/>
        </enumeration>
        <enumeration name="Block_Size_Block_Count_Host_SDMA_Buffer_Size_ENUM">
            <enumItem name="pclk_divided_by_8" number="0x0"/>
            <enumItem name="pclk_divided_by_64" number="0x1"/>
            <enumItem name="pclk_divided_by_256" number="0x2"/>
            <enumItem name="pclk_divided_by_4096" number="0x3"/>
        </enumeration>
        <enumeration name="Block_Size_Block_Count_Transfer_Block_Size_ENUM">
            <enumItem name="No_Data_Transfer" number="0x0"/>
            <enumItem name="_1_Byte" number="0x1"/>
            <enumItem name="_2_Bytes" number="0x2"/>
            <enumItem name="_3_Bytes" number="0x3"/>
            <enumItem name="_4_Bytes" number="0x4"/>
            <enumItem name="_511_Bytes" number="0x1ff"/>
            <enumItem name="_512_Bytes" number="0x200"/>
            <enumItem name="_2048_Bytes" number="0x800"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Command_Type_ENUM">
            <enumItem name="Normal" number="0x0"/>
            <enumItem name="Suspend" number="0x1"/>
            <enumItem name="Resume" number="0x2"/>
            <enumItem name="Abort" number="0x3"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Data_Present_Select_ENUM">
            <enumItem name="No_Data_Present" number="0x0"/>
            <enumItem name="Data_Present" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Command_Index_Check_Enable_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Command_CRC_Check_Enable_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Response_Type_Select_ENUM">
            <enumItem name="No_Response" number="0x0"/>
            <enumItem name="Response_length_136" number="0x1"/>
            <enumItem name="Response_length_48" number="0x2"/>
            <enumItem name="Response_length_48_check" number="0x3"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Multi_Single_Block_Select_ENUM">
            <enumItem name="Single_Block" number="0x0"/>
            <enumItem name="Multiple_Block" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Data_Transfer_Direction_Select_ENUM">
            <enumItem name="Write_Host_to_Card" number="0x0"/>
            <enumItem name="Read_Card_to_Host" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Auto_CMD12_Enable_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_Block_Count_Enable_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Transfer_Mode_Command_DMA_Enable_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Write_Protect_Switch_Pin_Level_ENUM">
            <enumItem name="Write_protected_SDWP___1" number="0x0"/>
            <enumItem name="Write_enabled_SDWP___0" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Card_Detect_Pin_Level_ENUM">
            <enumItem name="No_Card_present_SDCD___1" number="0x0"/>
            <enumItem name="Card_present_SDCD___0" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Card_State_Stable_ENUM">
            <enumItem name="Reset_of_Debouncing" number="0x0"/>
            <enumItem name="No_Card_or_Inserted" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Card_Inserted_ENUM">
            <enumItem name="Reset_or_Debouncing_or_No_Card" number="0x0"/>
            <enumItem name="Card_Inserted" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Buffer_Read_Enable_ENUM">
            <enumItem name="Read_Disable" number="0x0"/>
            <enumItem name="Read_Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Buffer_Write_Enable_ENUM">
            <enumItem name="Write_Disable" number="0x0"/>
            <enumItem name="Write_Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Read_Transfer_Active_ENUM">
            <enumItem name="No_valid_data" number="0x0"/>
            <enumItem name="Transferring_data" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Write_Transfer_Active_ENUM">
            <enumItem name="No_valid_data" number="0x0"/>
            <enumItem name="transferring_data" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_DAT_Line_Active_ENUM">
            <enumItem name="DAT_line_inactive" number="0x0"/>
            <enumItem name="DAT_line_active" number="0x1"/>
        </enumeration>
        <enumeration name="Present_State_Command_Inhibit_DAT_ENUM">
            <enumItem name="Can_issue_command_which_uses_the_DAT_line" number="0x0"/>
            <enumItem name="cannot_issue_command_which_uses_the_DAT_line" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_SD_Card_Removal_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_SD_Card_Insertion_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Wakeup_Event_Enable_On_Card_Interrupt_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Read_Wait_Control_ENUM">
            <enumItem name="Disable_Read_Wait_Control" number="0x0"/>
            <enumItem name="Enable_Read_Wait_Control" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Continue_Request_ENUM">
            <enumItem name="Ignored" number="0x0"/>
            <enumItem name="Restart" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Stop_At_Block_Gap_Request_ENUM">
            <enumItem name="Transfer" number="0x0"/>
            <enumItem name="Stop" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_SD_Bus_Voltage_Select_ENUM">
            <enumItem name="_000b" number="0x4"/>
            <enumItem name="_18_VTyp" number="0x5"/>
            <enumItem name="_30_VTyp" number="0x6"/>
            <enumItem name="_33_Flattop" number="0x7"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_SD_Bus_Power_ENUM">
            <enumItem name="Power_off" number="0x0"/>
            <enumItem name="Power_on" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Card_detect_signal_detetction_ENUM">
            <enumItem name="SDCD_is_selected_for_normal_use" number="0x0"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Card_Detect_Test_Level_ENUM">
            <enumItem name="No_Card" number="0x0"/>
            <enumItem name="Card_Inserted" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_DMA_Select_ENUM">
            <enumItem name="SDMA_is_selected" number="0x0"/>
            <enumItem name="_32_bit_Address_ADMA1_is_selected" number="0x1"/>
            <enumItem name="_32_bit_Address_ADMA2_is_selected" number="0x2"/>
            <enumItem name="_64_bit_Address_ADMA2_is_selected" number="0x3"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_High_Speed_Enable_ENUM">
            <enumItem name="Normal_Speed_Mode" number="0x0"/>
            <enumItem name="High_Speed_Mode" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_Data_Transfer_Width_SD1_or_SD4_ENUM">
            <enumItem name="_1_bit_mode" number="0x0"/>
            <enumItem name="_4_bit_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Host_control_Power_control_Block_Gap_Control_Wakeup_control_LED_Control_ENUM">
            <enumItem name="LED_off" number="0x0"/>
            <enumItem name="LED_on" number="0x1"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_DAT_Line_ENUM">
            <enumItem name="Work" number="0x0"/>
            <enumItem name="Reset" number="0x1"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_CMD_Line_ENUM">
            <enumItem name="Work" number="0x0"/>
            <enumItem name="Reset" number="0x1"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_Software_Reset_for_All_ENUM">
            <enumItem name="Work" number="0x0"/>
            <enumItem name="Reset" number="0x1"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_Data_Timeout_Counter_Value__ENUM">
            <enumItem name="TMCLK__213" number="0x0"/>
            <enumItem name="TMCLK__214" number="0x1"/>
            <enumItem name="TMCLK__227" number="0xe"/>
            <enumItem name="Reserved" number="0xf"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_SDCLK_Frequency_Select_ENUM">
            <enumItem name="base_clock10MHz_63MHz" number="0x0"/>
            <enumItem name="base_clock_divided_by_2" number="0x1"/>
            <enumItem name="base_clock_divided_by_4" number="0x2"/>
            <enumItem name="base_clock_divided_by_8" number="0x4"/>
            <enumItem name="base_clock_divided_by_16" number="0x8"/>
            <enumItem name="base_clock_divided_by_32" number="0x10"/>
            <enumItem name="base_clock_divided_by_64" number="0x20"/>
            <enumItem name="base_clock_divided_by_128" number="0x40"/>
            <enumItem name="base_clock_divided_by_256" number="0x80"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_SD_Clock_Enable_ENUM">
            <enumItem name="Disable" number="0x0"/>
            <enumItem name="Enable" number="0x1"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_Internal_Clock_Stable_ENUM">
            <enumItem name="Not_Ready" number="0x0"/>
            <enumItem name="Ready" number="0x1"/>
        </enumeration>
        <enumeration name="Clock_Control_Timeout_control_Software_reset_Internal_Clock_Enable_ENUM">
            <enumItem name="Stop" number="0x0"/>
            <enumItem name="Oscillate" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Ceata_Error_Status_ENUM">
            <enumItem name="no_error" number="0x0"/>
            <enumItem name="error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Target_Response_error_ENUM">
            <enumItem name="no_error" number="0x0"/>
            <enumItem name="error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_ADMA_Error_ENUM">
            <enumItem name="No_error" number="0x0"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Auto_CMD12_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Current_Limit_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Power_Fail" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Data_End_Bit_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Data_CRC_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Data_Timeout_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Timeout" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Command_Index_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Command_End_Bit_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="End_Bit_Error_Generated" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Command_CRC_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="CRC_Error_Generated" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Command_Timeout_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Timeout" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Error_Interrupt_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Boot_terminate_Interrupt_ENUM">
            <enumItem name="Boot_operation_is_not_teminated" number="0x0"/>
            <enumItem name="Boot_operation_is_teminated" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Boot_ack_rcv_ENUM">
            <enumItem name="Boot_ack_is_not_received" number="0x0"/>
            <enumItem name="Boot_ack_is_received" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Card_Interrupt_ENUM">
            <enumItem name="No_Card_Interrupt" number="0x0"/>
            <enumItem name="Generate_Card_Interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Card_Removal_ENUM">
            <enumItem name="Card_State_Stable_or_Debouncing" number="0x0"/>
            <enumItem name="Card_Removed" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Card_Insertion_ENUM">
            <enumItem name="Card_State_Stable_or_Debouncing" number="0x0"/>
            <enumItem name="Card_Inserted" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Buffer_Read_Ready_ENUM">
            <enumItem name="Not_Ready_to_read_Buffer" number="0x0"/>
            <enumItem name="Ready_to_read_Buffer" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Buffer_Write_Ready_ENUM">
            <enumItem name="Not_Ready_to_Write_Buffer" number="0x0"/>
            <enumItem name="Ready_to_Write_Buffer" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_DMA_Interrupt_ENUM">
            <enumItem name="No_DMA_Interrupt" number="0x0"/>
            <enumItem name="DMA_Interrupt_is_Generated" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Block_Gap_Event_ENUM">
            <enumItem name="No_Block_Gap_Event" number="0x0"/>
            <enumItem name="Transaction_stopped_at_Block" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Transfer_Complete_ENUM">
            <enumItem name="No_Data_Transfer_Complete" number="0x0"/>
            <enumItem name="Data_Transfer_Complete" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_Error_interrupt_status_Command_Complete_ENUM">
            <enumItem name="No_Command_Complete" number="0x0"/>
            <enumItem name="Command_Complete" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Ceata_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Target_Response_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_ADMA_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Auto_CMD12_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Current_Limit_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_End_Bit_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_CRC_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Data_Timeout_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Index_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_End_Bit_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_CRC_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Timeout_Error_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Boot_terminate_Interrupt_enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Boot_ack_rcv_enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Interrupt_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Removal_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Card_Insertion_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Buffer_Read_Ready_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Buffer_Write_Ready_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_DMA_Interrupt_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Block_Gap_Event_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Transfer_Complete_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_status_enable_Error_interrupt_status_enable_Command_Complete_Status_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Ceata_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Target_Response_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_ADMA_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Auto_CMD12_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Current_Limit_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_End_Bit_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_CRC_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Data_Timeout_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Index_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_End_Bit_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_CRC_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Timeout_Error_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Boot_terminate_Interrupt_signal_enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Boot_ack_rcv_signal_enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Interrupt_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Removal_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Card_Insertion_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Buffer_Read_Ready_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Buffer_Write_Ready_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_DMA_Interrupt_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Block_Gap_Event_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Transfer_Complete_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Normal_interrupt_signal_enable_Error_interrupt_signal_enable_Command_Complete_Signal_Enable_ENUM">
            <enumItem name="Masked" number="0x0"/>
            <enumItem name="Enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Auto_CMD12_error_status_Command_Not_Issued_By_Auto_CMD12_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Not_Issued" number="0x1"/>
        </enumeration>
        <enumeration name="Auto_CMD12_error_status_Auto_CMD12_Index_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="Auto_CMD12_error_status_Auto_CMD12_End_Bit_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="End_Bit_Error_Generated" number="0x1"/>
        </enumeration>
        <enumeration name="Auto_CMD12_error_status_Auto_CMD12_CRC_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="CRC_Error_Generated" number="0x1"/>
        </enumeration>
        <enumeration name="Auto_CMD12_error_status_Auto_CMD12_Timeout_Error_ENUM">
            <enumItem name="No_Error" number="0x0"/>
            <enumItem name="Timeout" number="0x1"/>
        </enumeration>
        <enumeration name="Auto_CMD12_error_status_Auto_CMD12_not_Executed_ENUM">
            <enumItem name="Executed" number="0x0"/>
            <enumItem name="Not_Executed" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Spi_block_mode_ENUM">
            <enumItem name="Not_Supported" number="0x0"/>
            <enumItem name="Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Spi_mode_ENUM">
            <enumItem name="Not_Supported" number="0x0"/>
            <enumItem name="Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_n64_bit_System_Bus_Support_ENUM">
            <enumItem name="Does_not_support_64_bit_system" number="0x0"/>
            <enumItem name="supports_64_bit_system_address" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Interrupt_mode_ENUM">
            <enumItem name="Not_Supported" number="0x0"/>
            <enumItem name="Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Voltage_Support_1_8_V_ENUM">
            <enumItem name="_18_V_Not_Supported" number="0x0"/>
            <enumItem name="_18_V_Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Voltage_Support_3_0_V_ENUM">
            <enumItem name="_30_V_Not_Supported" number="0x0"/>
            <enumItem name="_30_V_Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Voltage_Support_3_3_V_ENUM">
            <enumItem name="_33_V_Not_Supported" number="0x0"/>
            <enumItem name="_33_V_Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Suspend_Resume_Support_ENUM">
            <enumItem name="Not_Supported" number="0x0"/>
            <enumItem name="Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_SDMA_Support_ENUM">
            <enumItem name="SDMA_Not_Supported" number="0x0"/>
            <enumItem name="SDMA_Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_High_Speed_Support_ENUM">
            <enumItem name="High_Speed_Not_Supported" number="0x0"/>
            <enumItem name="High_Speed_Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_ADMA2_Support_ENUM">
            <enumItem name="ADMA2_not_support" number="0x0"/>
            <enumItem name="ADMA2_support" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Extended_Media_Bus_Support_ENUM">
            <enumItem name="Extended_Media_Bus_not_Supported" number="0x0"/>
            <enumItem name="Extended_Media_Bus_Supported" number="0x1"/>
        </enumeration>
        <enumeration name="Capabilities_Max_Block_Length_ENUM">
            <enumItem name="_512_byte" number="0x0"/>
            <enumItem name="_1024_byte" number="0x1"/>
            <enumItem name="_2048_byte" number="0x2"/>
            <enumItem name="_4096_byte" number="0x3"/>
        </enumeration>
        <enumeration name="Capabilities_Base_Clock_Frequency_for_SD_Clock_ENUM">
            <enumItem name="Get_information_via_another_method" number="0x0"/>
        </enumeration>
        <enumeration name="Capabilities_Timeout_Clock_Unit_ENUM">
            <enumItem name="Khz" number="0x0"/>
            <enumItem name="Mhz" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Vendor_Specific_Error_Status_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Ceata_error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_event_for_Target_Response_error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_ADMA_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Current_Limit_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data_End_Bit_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data_CRC_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Data__Timeout_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_Index_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_End_Bit_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_CRC_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Command_Timeout_Error_ENUM">
            <enumItem name="No_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_command_not_issued_by_Auto_CMD12_Error_ENUM">
            <enumItem name="no_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_Index_Error_ENUM">
            <enumItem name="no_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_End_bit_Error_ENUM">
            <enumItem name="no_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_CRC_Error_ENUM">
            <enumItem name="no_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_timeout_Error_ENUM">
            <enumItem name="no_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="Force_event_for_AutoCmd12_Error_Status_Force_event_register_for_error_interrupt_status_Force_Event_for_Auto_CMD12_NOT_Executed_ENUM">
            <enumItem name="no_interrupt" number="0x0"/>
            <enumItem name="Interrupt_is_generated" number="0x1"/>
        </enumeration>
        <enumeration name="ADMA_error_status_ADMA_Length_Mismatch_Error_ENUM">
            <enumItem name="No_error" number="0x0"/>
            <enumItem name="Error" number="0x1"/>
        </enumeration>
        <enumeration name="ADMA_error_status_ADMA_Error_State_ENUM">
            <enumItem name="ST_STOP_Stop_DMA_Points_next_of_the_error" number="0x0"/>
            <enumItem name="ST_FDS_Fetch_Descriptor_Points_the_error" number="0x1"/>
            <enumItem name="Never_set_this_state_Not_used" number="0x2"/>
            <enumItem name="ST_TFR_Transfer_Data_Points_the_next_of_the" number="0x3"/>
        </enumeration>
        <enumeration name="Debug_Selection_Debug_sel_ENUM">
            <enumItem name="receiver_module_and_fifo_ctrl_module" number="0x0"/>
        </enumeration>
        <enumeration name="Slot_interrupt_status_Host_controller_version_Specification_Version_Number_ENUM">
            <enumItem name="SD_Host_Specification_version_200_including_only_the_feature_of_theTest_Register" number="0x1"/>
        </enumeration>
        <enumeration name="SCL_LOCK_ENUM">
            <enumItem name="locked_all_writes_to_Secure_configuration_registers_are_disabled_and_cannot_be_enabled_until_power_on_reset_is_asserted" number="0x1"/>
        </enumeration>
        <enumeration name="SLCR_LOCKSTA_LOCK_STATUS_ENUM">
            <enumItem name="Registers_are_writeable" number="0x0"/>
            <enumItem name="Registers_are_not_writeable_Any_attempted_writes_are_ignored_but_reads_will_complete_as_normal" number="0x1"/>
        </enumeration>
        <enumeration name="IO_PLL_CTRL_PLL_BYPASS_FORCE_ENUM">
            <enumItem name="PLL_forced_to_be_bypassed" number="0x1"/>
        </enumeration>
        <enumeration name="PLL_BG_CTRL_BG_PWRDWN_ENUM">
            <enumItem name="PLL_BandGap_powered_up" number="0x0"/>
            <enumItem name="PLL_BandGap_powered_down" number="0x1"/>
        </enumeration>
        <enumeration name="USB0_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL_top_level_USB0_MIO_ULPI_clock_is_an_output" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL_top_level_USB0_MIO_ULPI_clock_is_an_output" number="0x3"/>
        </enumeration>
        <enumeration name="USB1_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL_top_level_USB0_MIO_ULPI_clock_is_an_output" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL_top_level_USB0_MIO_ULPI_clock_is_an_output" number="0x3"/>
        </enumeration>
        <enumeration name="GEM0_RCLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_GEM_0_MIO_RX_clock" number="0x0"/>
            <enumItem name="Source_for_generated_clock_is_GEM_0_FMIO_RX_clock" number="0x1"/>
        </enumeration>
        <enumeration name="GEM1_RCLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_GEM_0_MIO_RX_clock" number="0x0"/>
            <enumItem name="Source_for_generated_clock_is_GEM_0_FMIO_RX_clock" number="0x1"/>
        </enumeration>
        <enumeration name="SDIO_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="UART_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="SPI_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="CAN_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="FPGA0_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="FPGA0_THR_CTRL_SYNC_ENUM">
            <enumItem name="fpga_stop_is_asynchronous_to_FPGA_clock" number="0x0"/>
            <enumItem name="fpga_stop_is_synchronous_to_FPGA_clock" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA0_THR_CTRL_EDGE_ENUM">
            <enumItem name="debug_level_stop_mode" number="0x0"/>
            <enumItem name="debug_edge_stop_mode" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA0_THR_CTRL_CNT_RST_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Causes_counter_to_be_reset_once_HALT_state_is_entered" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA0_THR_CTRL_CPU_START_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Start_count_or_restart_count_if_previous_value_was_0" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA0_THR_STA_RUNNING_ENUM">
            <enumItem name="Clock_is_stopped_or_in_normal_mode_OK_to_change_config" number="0x0"/>
            <enumItem name="Clock_is_runnnig_in_debug_mode_Keep_config_static" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA1_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="FPGA1_THR_CTRL_SYNC_ENUM">
            <enumItem name="fpga_stop_is_asynchronous_to_FPGA_clock" number="0x0"/>
            <enumItem name="fpga_stop_is_synchronous_to_FPGA_clock" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA1_THR_CTRL_EDGE_ENUM">
            <enumItem name="debug_level_stop_mode" number="0x0"/>
            <enumItem name="debug_edge_stop_mode" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA1_THR_CTRL_CNT_RST_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Causes_counter_to_be_reset_once_HALT_state_is_entered" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA1_THR_CTRL_CPU_START_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Start_count_or_restart_count_if_previous_value_was_0" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA1_THR_STA_RUNNING_ENUM">
            <enumItem name="Clock_is_stopped_or_in_normal_mode_OK_to_change_config" number="0x0"/>
            <enumItem name="Clock_is_runnnig_in_debug_mode_Keep_config_static" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA2_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="FPGA2_THR_CTRL_SYNC_ENUM">
            <enumItem name="fpga_stop_is_asynchronous_to_FPGA_clock" number="0x0"/>
            <enumItem name="fpga_stop_is_synchronous_to_FPGA_clock" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA2_THR_CTRL_EDGE_ENUM">
            <enumItem name="debug_level_stop_mode" number="0x0"/>
            <enumItem name="debug_edge_stop_mode" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA2_THR_CTRL_CNT_RST_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Causes_counter_to_be_reset_once_HALT_state_is_entered" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA2_THR_CTRL_CPU_START_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Start_count_or_restart_count_if_previous_value_was_0" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA2_THR_STA_RUNNING_ENUM">
            <enumItem name="Clock_is_stopped_or_in_normal_mode_OK_to_change_config" number="0x0"/>
            <enumItem name="Clock_is_runnnig_in_debug_mode_Keep_config_static" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA3_CLK_CTRL_SRCSEL_ENUM">
            <enumItem name="Source_for_generated_clock_is_ARM_PLL" number="0x2"/>
            <enumItem name="Source_for_generated_clock_is_DDR_PLL" number="0x3"/>
        </enumeration>
        <enumeration name="FPGA3_THR_CTRL_SYNC_ENUM">
            <enumItem name="fpga_stop_is_asynchronous_to_FPGA_clock" number="0x0"/>
            <enumItem name="fpga_stop_is_synchronous_to_FPGA_clock" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA3_THR_CTRL_EDGE_ENUM">
            <enumItem name="debug_level_stop_mode" number="0x0"/>
            <enumItem name="debug_edge_stop_mode" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA3_THR_CTRL_CNT_RST_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Causes_counter_to_be_reset_once_HALT_state_is_entered" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA3_THR_CTRL_CPU_START_ENUM">
            <enumItem name="No_effect" number="0x0"/>
            <enumItem name="Start_count_or_restart_count_if_previous_value_was_0" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA3_THR_STA_RUNNING_ENUM">
            <enumItem name="Clock_is_stopped_or_in_normal_mode_OK_to_change_config" number="0x0"/>
            <enumItem name="Clock_is_runnnig_in_debug_mode_Keep_config_static" number="0x1"/>
        </enumeration>
        <enumeration name="SYNC_CTRL_APU_DDR_1TO1_ENUM">
            <enumItem name="asynchronous_mode" number="0x0"/>
            <enumItem name="CPU_and_DDR_at_1_to_1_clock_ratio" number="0x1"/>
        </enumeration>
        <enumeration name="CLK_621_TRUE_CLK_621_TRUE_ENUM">
            <enumItem name="for_4_2_2_1" number="0x0"/>
            <enumItem name="for_6_3_2_1" number="0x1"/>
        </enumeration>
        <enumeration name="PICTURE_DBG_CLOCK_SEL_ENUM">
            <enumItem name="IO_PLL_clock" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="PICTURE_DBG_TRIGGER_SEL_ENUM">
            <enumItem name="SLCR_default" number="0x0"/>
            <enumItem name="Fabric_Not_implemented" number="0x1"/>
            <enumItem name="Address_match_AXIM_not_implemented" number="0x2"/>
        </enumeration>
        <enumeration name="PSS_RST_CTRL_SOFT_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="PSS_software_reset_initiated" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_RST_CTRL_DDR_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="DDR_subsystem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="DMAC_RST_CTRL_DMAC_RST_ENUM">
            <enumItem name="DMAC_not_in_reset_DMAC_TrustZone_register_is_read_only" number="0x0"/>
            <enumItem name="DMAC_held_in_reset_DMAC_TrustZone_register_is_now_programmable" number="0x1"/>
        </enumeration>
        <enumeration name="USB_RST_CTRL_USB1_ULPI_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="ULPI_clock_portion_of_USB_1_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="USB_RST_CTRL_USB0_ULPI_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="ULPI_clock_portion_of_USB_0_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="USB_RST_CTRL_USB1_CPU1X_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="master_and_slave_AMBA_clock_portion_of_USB_1_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="USB_RST_CTRL_USB0_CPU1X_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="master_and_slave_AMBA_clock_portion_of_USB_0_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="GEM_RST_CTRL_GEM1_REF_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="Reference_clock_portion_of_GEM_1_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="GEM_RST_CTRL_GEM0_REF_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="Reference_clock_portion_of_GEM_0_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="GEM_RST_CTRL_GEM1_RX_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="RX_clock_portion_of_GEM_1_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="GEM_RST_CTRL_GEM0_RX_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="RX_clock_portion_of_GEM_0_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="GEM_RST_CTRL_GEM1_CPU1X_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="Gigabit_Ethernet_MAC_1_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="GEM_RST_CTRL_GEM0_CPU1X_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="Gigabit_Ethernet_MAC_0_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="SDIO_RST_CTRL_SDIO1_CPU1X_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="master_and_slave_AMBA_clock_portion_of_SDIO_1_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="SDIO_RST_CTRL_SDIO0_CPU1X_RST_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="master_and_slave_AMBA_clock_portion_of_SDIO_0_subsytem_held_in_reset" number="0x1"/>
        </enumeration>
        <enumeration name="FPGA_RST_CTRL_FPGA_ACP_RST_ENUM">
            <enumItem name="No_reset_1" number="0x0"/>
        </enumeration>
        <enumeration name="A9_CPU_RST_CTRL_A9_RST1_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="reset_A9_core_1" number="0x1"/>
        </enumeration>
        <enumeration name="A9_CPU_RST_CTRL_A9_RST0_ENUM">
            <enumItem name="No_reset" number="0x0"/>
            <enumItem name="reset_A9_core_0" number="0x1"/>
        </enumeration>
        <enumeration name="RS_AWDT_CTRL_CTRL0_ENUM">
            <enumItem name="reset_Pele" number="0x0"/>
            <enumItem name="reset_ARM_core" number="0x1"/>
        </enumeration>
        <enumeration name="BOOT_MODE_PLL_BYPASS_ENUM">
            <enumItem name="All_PLL_outputs_are_by_default_routed_to_clock_distribution" number="0x0"/>
            <enumItem name="All_PLL_outputs_are_bypassed_and_reference_clock_input_will_feed_clock_distribution" number="0x1"/>
        </enumeration>
        <enumeration name="BOOT_MODE_BOOT_MODE_ENUM">
            <enumItem name="PSS_boots_from_JTAG_on_FPGA_side" number="0x4"/>
            <enumItem name="DFT_mode_special_mode_to_enable_FPGA_immediately_with_security_shut_down" number="0x7"/>
        </enumeration>
        <enumeration name="WDT_CLK_SEL_SEL_ENUM">
            <enumItem name="cpu_1xclk" number="0x0"/>
            <enumItem name="wdt_clk_in_from_FPGA" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DDR_RAM_TZ31_ENUM">
            <enumItem name="Secure_reset_value" number="0x0"/>
            <enumItem name="Non_secure" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DDR_RAM_TZ2_ENUM">
            <enumItem name="Secure_reset_value" number="0x0"/>
            <enumItem name="Non_secure" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DDR_RAM_TZ1_ENUM">
            <enumItem name="Secure_reset_value" number="0x0"/>
            <enumItem name="Non_secure" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DDR_RAM_TZ0_ENUM">
            <enumItem name="Secure_reset_value" number="0x0"/>
            <enumItem name="Non_secure" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DMA_NS_DMAC_NS_ENUM">
            <enumItem name="secure_DMAC_operates_in_the_secure_state" number="0x0"/>
            <enumItem name="non_secure_DMAC_operates_in_the_non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DMA_IRQ_NS_DMA_IRQ_NS_ENUM">
            <enumItem name="secure_DMAC_operates_in_the_secure_state" number="0x0"/>
            <enumItem name="non_secure_DMAC_interrupt_event_bit_is_in_the_non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="TZ_DMA_PERIPH_NS_DMAC_PERIPH_NS_ENUM">
            <enumItem name="secure_DMAC_operates_in_the_secure_state" number="0x0"/>
            <enumItem name="non_secure_reset_value__DMAC_peripheral_i_f_is_in_the_non_secure_state" number="0x1"/>
        </enumeration>
        <enumeration name="DBG_CTRL_SRST_B_TRI_B_ENUM">
            <enumItem name="SRST_B_pad_is_an_input_for_soft_reset_signal" number="0x0"/>
            <enumItem name="SRST_B_pad_is_an_output_dirven_by_UART0_TX" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_URGENT_S0_ARURGENT_ENUM">
            <enumItem name="DDRs_AXI_port_S0_read_not_requesting_urgent_prioritization" number="0x0"/>
            <enumItem name="DDRs_AXI_port_S0_read_is_requesting_urgent_prioritization" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_URGENT_S0_AWURGENT_ENUM">
            <enumItem name="DDRs_AXI_port_S0_write_not_requesting_urgent_prioritization" number="0x0"/>
            <enumItem name="DDRs_AXI_port_S0_write_is_requesting_urgent_prioritization" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_CAL_START_START_CAL_DLL_ENUM">
            <enumItem name="Do_nothing" number="0x0"/>
            <enumItem name="Start_DLL_calibration_command" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_CAL_START_START_CAL_SHORT_ENUM">
            <enumItem name="Do_nothing" number="0x0"/>
            <enumItem name="Start_ZQ_calibration_short_command" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_REF_START_START_REF_ENUM">
            <enumItem name="Do_nothing" number="0x0"/>
            <enumItem name="Start_refresh" number="0x1"/>
        </enumeration>
        <enumeration name="DDR_CMD_STA_CMD_Q_NEMPTY_ENUM">
            <enumItem name="indicates_DDRC_command_store_is_empty" number="0x0"/>
            <enumItem name="indicates_there_are_commands_pending_in_DDRC_command_store" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_00_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_00_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_00_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_00_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="smc_cs0_Output_smc_sram_cs_n_0__SRAM_CS0" number="0x1"/>
            <enumItem name="nand_cs_Output_smc_nand_cs_n__NAND_chip_select" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_00_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_00_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="qspi_sel_Output_qspi_n_ss_out_upper__QSPI_Upper_select" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_01_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_01_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_01_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_01_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="smc_a25_Output_smc_sram_add_25__SRAM_Address" number="0x1"/>
            <enumItem name="smc_cs1_Output_smc_sram_cs_n_1__SRAM_CS1" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_01_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_01_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="qspi_sel_Output_qspi_n_ss_out__QSPI_Select" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_02_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_02_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_02_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_02_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_clk__SRAM_Clock" number="0x1"/>
            <enumItem name="nand_Output_smc_nand_ale__NAND_Address_Latch_Enable" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_02_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_8__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_03_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_03_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_03_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_03_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_0__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Output_smc_nand_we_b__NAND_Write_Enable" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_03_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_9__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_04_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_04_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_04_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_04_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_1__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_2__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_04_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_10__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_05_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_05_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_05_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_05_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_2__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_0__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_05_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_11__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_06_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_06_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_06_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_06_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_3__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_1__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_06_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_12__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_06_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="qspi_Output_qspi_sclk_out__QSPI_Clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_L3_SEL_ENUM">
            <enumItem name="gpio0_Output_gpio_0_pin_out_7__GPIO_bank_0" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="Not_Used_3" number="0x3"/>
            <enumItem name="Not_Used_4" number="0x4"/>
            <enumItem name="Not_Used_5" number="0x5"/>
            <enumItem name="Not_Used_6" number="0x6"/>
            <enumItem name="Not_Used_7" number="0x7"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_oe_b__SRAM_Output_enable" number="0x1"/>
            <enumItem name="nand_Output_smc_nand_cle__NAND_Command_Latch_Enable" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_13__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_07_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_L3_SEL_ENUM">
            <enumItem name="gpio0_Output_gpio_0_pin_out_8__GPIO_bank_0" number="0x0"/>
            <enumItem name="can1_Output_can1_phy_tx__Can_TX_signal" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="Not_Used_3" number="0x3"/>
            <enumItem name="Not_Used_4" number="0x4"/>
            <enumItem name="Not_Used_5" number="0x5"/>
            <enumItem name="Not_Used_6" number="0x6"/>
            <enumItem name="ua1_Output_ua1_txd__UART_transmitter_serial_output" number="0x7"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_we_b__SRAM_Write_enable" number="0x1"/>
            <enumItem name="nand_Output_smc_nand_re_b__NAND_Read_Enable" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_14__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_08_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="qspi_Output_qspi_clk_for_lpbk__QSPI_Clock_to_be_fed_back" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_09_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_09_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_09_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_09_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_6__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_4__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_09_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_15__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_09_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="qspi_Output_qspi_sclk_out_upper__QSPI_Upper_Clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_10_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_10_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_10_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_10_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_7__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_5__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_10_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_2__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_11_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_11_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_11_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_11_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_4__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_6__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_11_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_3__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_12_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_12_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_12_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_12_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_wait__SRAM_Wait_State_indicator" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_7__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_12_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_ctl_Output_traceclk__Trace_Port_Clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_13_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_13_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_13_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_13_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_data_in_5__SRAM_Data" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_3__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_13_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_ctl_Output_tracectl__Trace_Port_Control_Signal" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_14_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_14_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_14_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_14_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Input_smc_sram_fbclk__SRAM_Feedback_Clock" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_busy__NAND_Busy" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_14_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_0__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_14_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_15_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_15_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_15_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_15_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_0__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_15_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_1__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_15_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_16_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_16_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_16_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_16_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_1__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_8__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_16_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_4__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_16_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Output_gem0_rgmii_tx_clk__TX_RGMII_clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_17_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_17_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_17_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_17_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_2__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_9__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_17_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_5__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_17_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Output_gem0_rgmii_txd_0__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_18_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_18_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_18_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_18_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_3__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_10__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_18_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_6__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_18_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Output_gem0_rgmii_txd_1__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_19_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_19_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_19_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_19_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_4__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_11__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_19_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_7__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_19_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Output_gem0_rgmii_txd_2__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_20_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_20_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_20_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_20_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_5__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_12__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_20_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_20_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Output_gem0_rgmii_txd_3__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_21_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_21_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_21_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_21_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_6__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_13__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_21_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_21_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Output_gem0_rgmii_tx_ctl__TX_RGMII_control" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_22_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_22_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_22_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_22_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_7__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_14__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_22_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_2__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_22_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Input_gem0_rgmii_rx_clk__RX_RGMII_clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_23_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_23_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_23_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_23_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_8__SRAM_Address" number="0x1"/>
            <enumItem name="nand_Input_smc_nand_data_in_15__NAND_Data_Bus" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_23_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_3__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_23_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Input_gem0_rgmii_rxd_0__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_24_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_24_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_24_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_24_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_9__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_24_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_ctl_Output_traceclk__Trace_Port_Clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_24_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Input_gem0_rgmii_rxd_1__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_25_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_25_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_25_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_25_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_10__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_25_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_ctl_Output_tracectl__Trace_Port_Control_Signal" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_25_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Input_gem0_rgmii_rxd_2__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_26_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_26_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_26_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_26_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_11__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_26_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_0__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_26_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Input_gem0_rgmii_rxd_3__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_27_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_27_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_27_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_27_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_12__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_27_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="trace_data_Output_tracedq_1__Trace_Port_Databus" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_27_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem0_Input_gem0_rgmii_rx_ctl__RX_RGMII_control_" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_28_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_28_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_28_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_28_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_13__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_28_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Output_gem1_rgmii_tx_clk__TX_RGMII_clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_29_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_29_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_29_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_29_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_14__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_29_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="usb0_Input_usb0_ulpi_dir__Data_bus_direction_control" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_29_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Output_gem1_rgmii_txd_0__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_30_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_30_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_30_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_30_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_15__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_30_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="usb0_Output_usb0_ulpi_stp__Asserted_to_end_or_interrupt_transfers" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_30_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Output_gem1_rgmii_txd_1__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_31_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_31_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_31_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_31_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_16__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_31_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="usb0_Input_usb0_ulpi_nxt__Data_flow_control_signal_from_the_PHY" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_31_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Output_gem1_rgmii_txd_2__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_32_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_32_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_32_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_32_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_17__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_32_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Output_gem1_rgmii_txd_3__TX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_33_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_33_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_33_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_33_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_18__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_33_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Output_gem1_rgmii_tx_ctl__TX_RGMII_control" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_34_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_34_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_34_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_34_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_19__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_34_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Input_gem1_rgmii_rx_clk__RX_RGMII_clock" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_35_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_35_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_35_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_35_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_20__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_35_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Input_gem1_rgmii_rxd_0__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_36_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_36_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_36_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_36_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_21__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_36_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Input_gem1_rgmii_rxd_1__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_37_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_37_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_37_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_37_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_22__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_37_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Input_gem1_rgmii_rxd_2__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_38_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_38_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_38_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_38_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_23__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_38_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Input_gem1_rgmii_rxd_3__RX_RGMII_data" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_39_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_39_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_39_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_39_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="sram_nor_Output_smc_sram_add_24__SRAM_Address" number="0x1"/>
            <enumItem name="Not_Used" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_39_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="gem1_Input_gem1_rgmii_rx_ctl__RX_RGMII_control_" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_40_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_40_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_40_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_40_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_40_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_41_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_41_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_41_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_41_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_41_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="usb1_Input_usb1_ulpi_dir__Data_bus_direction_control" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_41_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_42_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_42_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_42_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_42_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_42_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="usb1_Output_usb1_ulpi_stp__Asserted_to_end_or_interrupt_transfers" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_42_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_43_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_43_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_43_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_43_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_43_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="usb1_Input_usb1_ulpi_nxt__Data_flow_control_signal_from_the_PHY" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_43_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_44_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_44_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_44_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_44_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_44_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_45_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_45_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_45_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_45_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_45_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_46_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_46_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_46_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_46_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_46_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_47_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_47_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_47_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_47_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_47_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_48_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_48_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_48_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_48_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_48_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_49_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_49_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_49_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_49_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_49_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_50_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_50_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_50_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_50_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_50_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_51_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_51_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_51_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_51_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_51_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_52_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_52_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_52_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_52_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio0_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_52_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_52_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_53_DisableRcvr_ENUM">
            <enumItem name="Receiver_Enabled" number="0x0"/>
            <enumItem name="Receiver_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_53_PULLUP_ENUM">
            <enumItem name="Pull_up_disabled" number="0x0"/>
            <enumItem name="Pull_up_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_53_IO_Type_ENUM">
            <enumItem name="LVTTL" number="0x0"/>
            <enumItem name="LVCMOS18" number="0x1"/>
            <enumItem name="LVCMOS25" number="0x2"/>
            <enumItem name="LVCMOS33" number="0x3"/>
            <enumItem name="HSTL" number="0x4"/>
        </enumeration>
        <enumeration name="MIO_PIN_53_L2_SEL_ENUM">
            <enumItem name="Level_3_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
            <enumItem name="Not_Used_2" number="0x2"/>
            <enumItem name="sdio_pow_Output_sdio1_bus_pow__SD_card_bus_power" number="0x3"/>
        </enumeration>
        <enumeration name="MIO_PIN_53_L1_SEL_ENUM">
            <enumItem name="Level_2_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_PIN_53_L0_SEL_ENUM">
            <enumItem name="Level_1_Mux_Output" number="0x0"/>
            <enumItem name="Not_Used" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_LOOPBACK_I2C0_LOOP_I2C1_ENUM">
            <enumItem name="Connect_I2C_inputs_according_to_MIO_mapping" number="0x0"/>
            <enumItem name="Loop_I2C_0_outputs_to_I2C_1_inputs_and_I2C_1_outputs" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_LOOPBACK_CAN0_LOOP_CAN1_ENUM">
            <enumItem name="Connect_CAN_inputs_according_to_MIO_mapping" number="0x0"/>
            <enumItem name="Loop_CAN_0_TX_to_CAN_1_RX_and_CAN_1_TX_to_CAN_0_RX" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_LOOPBACK_UA0_LOOP_UA1_ENUM">
            <enumItem name="Connect_UART_inputs_according_to_MIO_mapping" number="0x0"/>
            <enumItem name="Loop_UART_0_outputs_to_UART_1_inputs_and_UART_1_outputs_to_UART_0_inputs" number="0x1"/>
        </enumeration>
        <enumeration name="MIO_LOOPBACK_SPI0_LOOP_SPI1_ENUM">
            <enumItem name="Connect_SPI_inputs_according_to_MIO_mapping" number="0x0"/>
            <enumItem name="Loop_SPI_0_outputs_to_SPI_1_inputs_and_SPI_1_outputs_to_SPI_0_inputs" number="0x1"/>
        </enumeration>
        <enumeration name="GPIOB_CTRL_VREF_SW_EN_ENUM">
            <enumItem name="internal" number="0x0"/>
            <enumItem name="external" number="0x1"/>
        </enumeration>
        <enumeration name="GPIOB_CTRL_VREF_EXT_ENUM">
            <enumItem name="normal_operation_should_be_sufficient" number="0x0"/>
            <enumItem name="higher_performance_more_power" number="0x1"/>
        </enumeration>
        <enumeration name="GPIOB_CTRL_VREF_SEL_ENUM">
            <enumItem name="VREF___test_mode" number="0x0"/>
            <enumItem name="VREF___test_mode_1" number="0x1"/>
            <enumItem name="VREF___test_mode_2" number="0x2"/>
            <enumItem name="VREF___test_mode_4" number="0x4"/>
            <enumItem name="VREF___test_mode_8" number="0x8"/>
            <enumItem name="VREF___test_mode_16" number="0x10"/>
            <enumItem name="VREF___test_mode_32" number="0x20"/>
        </enumeration>
        <enumeration name="DDRIOB_ADDR0_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_ADDR1_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_DATA0_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_DATA1_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_DIFF0_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_DIFF1_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_CLOCK_INP_TYPE_ENUM">
            <enumItem name="Input_off_reads_0" number="0x0"/>
            <enumItem name="Vref_based_differential_reciever_for_SSTL_HSTL" number="0x1"/>
            <enumItem name="Differential_input_reciever" number="0x2"/>
        </enumeration>
        <enumeration name="DDRIOB_DCI_CTRL_ENABLE_ENUM">
            <enumItem name="if_any_iobs_use_a_terminate_type_or_if_dci_test_block_used" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_Modefail_gen_en_ENUM">
            <enumItem name="disable" number="0x0"/>
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_Man_start_com_ENUM">
            <enumItem name="dont_care" number="0x0"/>
            <enumItem name="start_transmission_of_data" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_Man_start_en_ENUM">
            <enumItem name="auto_mode" number="0x0"/>
            <enumItem name="enables_maual_start" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_Manual_CS_ENUM">
            <enumItem name="auto_mode" number="0x0"/>
            <enumItem name="manual_CS_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_CS_ENUM">
            <enumItem name="slave_3_selected" number="0x7"/>
            <enumItem name="No_slave_selected" number="0xf"/>
        </enumeration>
        <enumeration name="Config_reg0_PERI_SEL_ENUM">
            <enumItem name="only_1_of_4_selects" number="0x0"/>
            <enumItem name="allow_external_4_to_16_decode" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_REF_CLK_ENUM">
            <enumItem name="use_SPI_REFERENCE_CLOCK" number="0x0"/>
            <enumItem name="use_ext_clk" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_FIFO_WIDTH_ENUM">
            <enumItem name="_8bits" number="0x0"/>
            <enumItem name="_16bits" number="0x1"/>
            <enumItem name="_24bits" number="0x2"/>
            <enumItem name="_32bits" number="0x3"/>
        </enumeration>
        <enumeration name="Config_reg0_BAUD_RATE_DIV_ENUM">
            <enumItem name="not_supported" number="0x0"/>
            <enumItem name="divide_by_4" number="0x1"/>
            <enumItem name="divide_by_8" number="0x2"/>
            <enumItem name="divide_by_16" number="0x3"/>
            <enumItem name="divide_by_32" number="0x4"/>
            <enumItem name="divide_by_64" number="0x5"/>
            <enumItem name="divide_by_128" number="0x6"/>
            <enumItem name="divide_by_256" number="0x7"/>
        </enumeration>
        <enumeration name="Config_reg0_CLK_PH_ENUM">
            <enumItem name="the_SPI_clock_is_active_outside_the_word" number="0x0"/>
            <enumItem name="the_SPI_clock_is_inactive_outside_the_word" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_CLK_POL_ENUM">
            <enumItem name="the_SPI_clock_is_quiescent_low" number="0x0"/>
            <enumItem name="the_SPI_clock_is_quiescent_high" number="0x1"/>
        </enumeration>
        <enumeration name="Config_reg0_MODE_SEL_ENUM">
            <enumItem name="the_SPI_is_in_slave_mode" number="0x0"/>
            <enumItem name="the_SPI_is_in_master_mode" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_TX_FIFO_underflow_ENUM">
            <enumItem name="no_underflow_has_been_detected" number="0x0"/>
            <enumItem name="underflow_is_detected" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_RX_FIFO_full_ENUM">
            <enumItem name="FIFO_is_not_full" number="0x0"/>
            <enumItem name="FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_RX_FIFO_not_empty_ENUM">
            <enumItem name="FIFO_has_less_than_RX_THRESHOLD_entries" number="0x0"/>
            <enumItem name="FIFO_has_more_than_or_equal_to_THRESHOLD_entries" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_TX_FIFO_full_ENUM">
            <enumItem name="FIFO_is_not_full" number="0x0"/>
            <enumItem name="FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_TX_FIFO_not_full_ENUM">
            <enumItem name="FIFO_has_more_than_or_equal_toTHRESHOLD_entries" number="0x0"/>
            <enumItem name="FIFO_has_less_than_THRESHOLD_entries" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_MODE_FAIL_ENUM">
            <enumItem name="no_mode_fault_has_been_detected" number="0x0"/>
            <enumItem name="a_mode_fault_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Intr_status_reg0_RX_OVERFLOW_ENUM">
            <enumItem name="no_overflow_occurred" number="0x0"/>
            <enumItem name="overflow_occured" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TX_FIFO_underflow_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_RX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_RX_FIFO_not_empty_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TX_FIFO_not_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_MODE_FAIL_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_RX_OVERFLOW_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="enable_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TX_FIFO_underflow_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_RX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_RX_FIFO_not_empty_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TX_FIFO_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TX_FIFO_not_full_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_MODE_FAIL_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_RX_OVERFLOW_ENUM">
            <enumItem name="no_effect" number="0x0"/>
            <enumItem name="disables_the_interrupt" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TX_FIFO_underflow_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RX_FIFO_full_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RX_FIFO_not_empty_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TX_FIFO_full_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TX_FIFO_not_full_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_MODE_FAIL_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RX_OVERFLOW_ENUM">
            <enumItem name="interrupt_is_enabled" number="0x0"/>
            <enumItem name="interrupt_is_disabled" number="0x1"/>
        </enumeration>
        <enumeration name="En_reg0_SPI_EN_ENUM">
            <enumItem name="disable_the_SPI" number="0x0"/>
            <enumItem name="enable_the_SPI" number="0x1"/>
        </enumeration>
        <enumeration name="MODE_EXTLN_ENUM">
            <enumItem name="_2" number="0x0"/>
            <enumItem name="_4" number="0x1"/>
            <enumItem name="_8" number="0x2"/>
            <enumItem name="_16" number="0x3"/>
            <enumItem name="_32" number="0x4"/>
            <enumItem name="_64" number="0x5"/>
            <enumItem name="_128" number="0x6"/>
            <enumItem name="_256" number="0x7"/>
        </enumeration>
        <enumeration name="MODE_IRQLN_ENUM">
            <enumItem name="_4" number="0x0"/>
            <enumItem name="_8" number="0x1"/>
            <enumItem name="_16" number="0x2"/>
            <enumItem name="_32" number="0x3"/>
        </enumeration>
        <enumeration name="MODE_RSTLN_ENUM">
            <enumItem name="_2" number="0x0"/>
            <enumItem name="_4" number="0x1"/>
            <enumItem name="_8" number="0x2"/>
            <enumItem name="_16" number="0x3"/>
            <enumItem name="_32" number="0x4"/>
            <enumItem name="_64" number="0x5"/>
            <enumItem name="_128_111" number="0x6"/>
        </enumeration>
        <enumeration name="CONTROL_CLKSEL_ENUM">
            <enumItem name="pclk_divided_by_8" number="0x0"/>
            <enumItem name="pclk_divided_by_64" number="0x1"/>
            <enumItem name="pclk_divided_by_256" number="0x2"/>
            <enumItem name="pclk_divided_by_4096" number="0x3"/>
        </enumeration>
        <enumeration name="SuppSize_a_ENUM">
            <enumItem name="bit_location_represents_a_single_port_size_that_is" number="0xeac"/>
        </enumeration>
        <enumeration name="Control_reg0_STPBRK_ENUM">
            <enumItem name="stop_transmission_of_the_break" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_STTBRK_ENUM">
            <enumItem name="start_to_transmit_a_break_Can_only_be_set_if" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_RSTTO_ENUM">
            <enumItem name="receiver_timeout_counter_is_restarted" number="0x1"/>
        </enumeration>
        <enumeration name="Control_reg0_RXDIS_ENUM">
            <enumItem name="receiver_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="mode_reg0_IRMODE_ENUM">
            <enumItem name="__Default_UART_mode" number="0x0"/>
            <enumItem name="__Enable_IrDA_mode" number="0x1"/>
        </enumeration>
        <enumeration name="mode_reg0_UCLKEN_ENUM">
            <enumItem name="__APB_clock_pclk" number="0x0"/>
            <enumItem name="__a_user_defined_clock" number="0x1"/>
        </enumeration>
        <enumeration name="mode_reg0_CHMODE_ENUM">
            <enumItem name="normal" number="0x0"/>
            <enumItem name="automatic_cho" number="0x1"/>
            <enumItem name="local_loopback" number="0x2"/>
            <enumItem name="remote_loopback" number="0x3"/>
        </enumeration>
        <enumeration name="mode_reg0_NBSTOP_ENUM">
            <enumItem name="_1_stop_bit" number="0x0"/>
            <enumItem name="_15_stop_bits" number="0x1"/>
            <enumItem name="_2_stop_bits" number="0x2"/>
            <enumItem name="reserved" number="0x3"/>
        </enumeration>
        <enumeration name="mode_reg0_PAR_ENUM">
            <enumItem name="even_parity" number="0x0"/>
            <enumItem name="odd_parity" number="0x1"/>
            <enumItem name="forced_to_0_parity_space" number="0x2"/>
            <enumItem name="forced_to_1_parity_mark" number="0x3"/>
        </enumeration>
        <enumeration name="mode_reg0_CHRL_ENUM">
            <enumItem name="__00___8_bits" number="0x1"/>
            <enumItem name="_7_bits" number="0x2"/>
            <enumItem name="_6_bits" number="0x3"/>
        </enumeration>
        <enumeration name="mode_reg0_CLKS_ENUM">
            <enumItem name="clock_source_is_uart_clk" number="0x0"/>
            <enumItem name="clock_source_is_uart_clk_8" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TOVR_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TNFUL_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TTRIG_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_DMSI_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TIMEOUT_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_PARE_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_FRAME_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_ROVR_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TFUL_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_TEMPTY_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_RFUL_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_REMPTY_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_en_reg0_RTRIG_ENUM">
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TOVR_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TNFUL_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TTRIG_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_DMSI_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TIMEOUT_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_PARE_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_FRAME_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_ROVR_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TFUL_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_TEMPTY_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_RFUL_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_REMPTY_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_dis_reg0_RTRIG_ENUM">
            <enumItem name="disable" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TOVR_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TNFUL_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TTRIG_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_DMSI_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TIMEOUT_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_PARE_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_FRAME_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_ROVR_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TFUL_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_TEMPTY_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RFUL_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_REMPTY_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Intrpt_mask_reg0_RTRIG_ENUM">
            <enumItem name="interrupt_is_disabled" number="0x0"/>
            <enumItem name="interrupt_is_enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_TOVR_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_TNFUL_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_TTRIG_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_DMSI_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_TIMEOUT_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_PARE_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_FRAME_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_ROVR_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_TFUL_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_TEMPTY_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_RFUL_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_REMPTY_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Chnl_int_sts_reg0_RTRIG_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Baud_rate_gen_reg0_CD_ENUM">
            <enumItem name="Disables_baud_sample" number="0x0"/>
            <enumItem name="Clock_divisor_bypass" number="0x1"/>
            <enumItem name="_65535___baud_sample_value" number="0x2"/>
        </enumeration>
        <enumeration name="Rcvr_timeout_reg0_RTO_ENUM">
            <enumItem name="Disables_receiver_timeout_counter" number="0x0"/>
            <enumItem name="_255___Receiver_timeout" number="0x1"/>
        </enumeration>
        <enumeration name="Rcvr_FIFO_trigger_level0_RTRIG_ENUM">
            <enumItem name="Disables_receiver_timeout_counter" number="0x0"/>
            <enumItem name="_63___Receiver_timeout" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_ctrl_reg0_FCM_ENUM">
            <enumItem name="disable" number="0x0"/>
            <enumItem name="enable" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_ctrl_reg0_RTS_ENUM">
            <enumItem name="forced_to_logic_1" number="0x0"/>
            <enumItem name="forced_to_logic_0" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_ctrl_reg0_DTR_ENUM">
            <enumItem name="forced_to_logic_1" number="0x0"/>
            <enumItem name="forced_to_logic_0" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_FCMS_ENUM">
            <enumItem name="disabled" number="0x0"/>
            <enumItem name="enabled" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_DCD_ENUM">
            <enumItem name="ua_ndcd_input_is_high" number="0x0"/>
            <enumItem name="ua_ndcd_input_is_low" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_RI_ENUM">
            <enumItem name="ua_nri_input_is_high" number="0x0"/>
            <enumItem name="ua_nri_input_is_low" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_DSR_ENUM">
            <enumItem name="ua_ndsr_input_is_high" number="0x0"/>
            <enumItem name="ua_ndsr_input_is_low" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_CTS_ENUM">
            <enumItem name="ua_ncts_input_is_high" number="0x0"/>
            <enumItem name="ua_ncts_input_is_low" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_DDCD_ENUM">
            <enumItem name="No_change_has_occurred" number="0x0"/>
            <enumItem name="Change_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_TERI_ENUM">
            <enumItem name="No_trailing_edge_has_occurred" number="0x0"/>
            <enumItem name="Trailing_edge_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_DDSR_ENUM">
            <enumItem name="No_change_has_occurred" number="0x0"/>
            <enumItem name="Change_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Modem_sts_reg0_DCTS_ENUM">
            <enumItem name="No_change_has_occurred" number="0x0"/>
            <enumItem name="Change_has_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_TNFUL_ENUM">
            <enumItem name="More_than_one_byte_is_unused_in_the_TX_FIFO" number="0x0"/>
            <enumItem name="Only_one_byte_is_free_in_the_TX_FIFO" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_TTRIG_ENUM">
            <enumItem name="TX_FIFO_fill_level_is_less_than_TTRIG" number="0x0"/>
            <enumItem name="TX_FIFO_fill_level_is_greater_than_or_equal_to_TTRIG" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_FDELT_ENUM">
            <enumItem name="RX_FIFO_fill_level_is_less_than_FDEL" number="0x0"/>
            <enumItem name="RX_FIFO_fill_level_is_greater_than_or_equal_to_FDEL" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_TACTIVE_ENUM">
            <enumItem name="inactive_state" number="0x0"/>
            <enumItem name="active_state" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_RACTIVE_ENUM">
            <enumItem name="inactive_state" number="0x0"/>
            <enumItem name="active_state" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_DMSI_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_TIMEOUT_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_PARE_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_FRAME_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_ROVR_ENUM">
            <enumItem name="no_interrupt_occurred" number="0x0"/>
            <enumItem name="interrupt_occurred" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_TFUL_ENUM">
            <enumItem name="TX_FIFO_is_not_full" number="0x0"/>
            <enumItem name="TX_FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_TEMPTY_ENUM">
            <enumItem name="TX_FIFO_is_not_empty" number="0x0"/>
            <enumItem name="TX_FIFO_is_empty" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_RFUL_ENUM">
            <enumItem name="RX_FIFO_is_not_full" number="0x0"/>
            <enumItem name="RX_FIFO_is_full" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_REMPTY_ENUM">
            <enumItem name="__RX_FIFO_is_not_empty" number="0x0"/>
            <enumItem name="__RX_FIFO_is_empty" number="0x1"/>
        </enumeration>
        <enumeration name="Channel_sts_reg0_RTRIG_ENUM">
            <enumItem name="__RX_FIFO_fill_level_is_less_than_RTRIG" number="0x0"/>
            <enumItem name="__RX_FIFO_fill_level_is_greater_than_or_equal_to_RTRIG" number="0x1"/>
        </enumeration>
        <enumeration name="Baud_rate_divider_reg0_BDIV_ENUM">
            <enumItem name="_3__ignored" number="0x0"/>
            <enumItem name="_255__Baud_rate" number="0x4"/>
        </enumeration>
        <enumeration name="Flow_delay_reg0_FDEL_ENUM">
            <enumItem name="_3___disabled" number="0x0"/>
            <enumItem name="to_65535___ua_nrts_is_driven_high_when_RX_FIFO_fill_level_equals_FDEL" number="0x4"/>
        </enumeration>
        <enumeration name="IR_min_rcv_pulse_wdth0_PMN_ENUM">
            <enumItem name="to_65535___minimum_width" number="0x0"/>
        </enumeration>
        <enumeration name="IR_transmitted_pulse_wdth0_PWID_ENUM">
            <enumItem name="_255___width" number="0x0"/>
        </enumeration>
        <enumeration name="Tx_FIFO_trigger_level0_TTRIG_ENUM">
            <enumItem name="Disables_transmitter_FIFO_trigger_level_function" number="0x0"/>
            <enumItem name="_63___Trigger_set_when_transmitter_FIFO_fills_to_TTRIG_bytes" number="0x1"/>
        </enumeration>
        <enumeration name="HWGENERAL_SM_ENUM">
            <enumItem name="No_Serial_Engine__Always_use_parallel_signalling" number="0x0"/>
        </enumeration>
        <enumeration name="HWGENERAL_PHYM_ENUM">
            <enumItem name="ULPI" number="0x2"/>
        </enumeration>
        <enumeration name="HWGENERAL_PHYW_ENUM">
            <enumItem name="_8_bit_wide_data_bus__60MHz_clock_from_the_transciever" number="0x0"/>
        </enumeration>
        <enumeration name="HWGENERAL_CLKC_ENUM">
            <enumItem name="xcvr_clk_0___pe_clk" number="0x1"/>
        </enumeration>
        <enumeration name="HWGENERAL_RT_ENUM">
            <enumItem name="Use_Asynchronous_Resets" number="0x1"/>
        </enumeration>
        <enumeration name="HWTXBUF_TXCHANADD_ENUM">
            <enumItem name="To_address_64_depth_TX_buffer_for_each_end_point" number="0x6"/>
        </enumeration>
        <enumeration name="SBUSCFG_AHBBRST_ENUM">
            <enumItem name="incremental_bursts_of_unspecified_length" number="0x0"/>
            <enumItem name="INCR4_non_multiple_transfers_of_4_are_decomposed_to_singles" number="0x1"/>
            <enumItem name="INCR8_non_multiple_transfers_of_8_are_decomposed_to_INCR4_or_singles" number="0x2"/>
            <enumItem name="INCR16_non_multiple_transfers_of_16_are_decomposed_to_INCR8_INCR4_or_singles" number="0x3"/>
            <enumItem name="Do_not_use_this_value" number="0x4"/>
            <enumItem name="INCR4_non_multiple_transfers_of_4_are_decomposed_to_INCR_of_unspecifed_length" number="0x5"/>
            <enumItem name="INCR8_non_multiple_transfers_of_8_are_decomposed_to_INCR4_or_INCR_of_unspecifed_length" number="0x6"/>
            <enumItem name="INCR16_non_multiple_transfers_of_16_are_decomposed_to_INCR8_INCR4_or_INCR_of_unspecifed_length" number="0x7"/>
        </enumeration>
        <enumeration name="HCSPARAMS_PPC_ENUM">
            <enumItem name="indicates_the_ports_do_not_have_port_power_switches" number="0x0"/>
            <enumItem name="_indicates_the_ports_have_port_power_switches" number="0x1"/>
        </enumeration>
        <enumeration name="DCCPARAMS_HC_ENUM">
            <enumItem name="The_controller_is_USB_20_host_controller_capable" number="0x1"/>
        </enumeration>
        <enumeration name="DCCPARAMS_DC_ENUM">
            <enumItem name="The_controller_is_USB_20_device_capable" number="0x1"/>
        </enumeration>
        <enumeration name="USBCMD_ITC_ENUM">
            <enumItem name="Immediate_no_threshold" number="0x0"/>
            <enumItem name="_1_micro_frame" number="0x1"/>
            <enumItem name="_2_micro_frames" number="0x2"/>
            <enumItem name="_4_micro_frames" number="0x4"/>
            <enumItem name="_8_micro_frames" number="0x8"/>
            <enumItem name="_16_micro_frames" number="0x10"/>
            <enumItem name="_32_micro_frames" number="0x20"/>
            <enumItem name="_64_micro_frames" number="0x40"/>
        </enumeration>
        <enumeration name="USBCMD_PSE_ENUM">
            <enumItem name="__Do_not_process_the_Periodic_Schedule" number="0x0"/>
            <enumItem name="__Use_the_PERIODICLISTBASE_register_to_access_the_Periodic_Schedule" number="0x1"/>
        </enumeration>
        <enumeration name="USBCMD_FS0_ENUM">
            <enumItem name="__1024_elements_4096_bytes" number="0x0"/>
            <enumItem name="__512_elements_2048_bytes" number="0x1"/>
            <enumItem name="__256_elements_1024_bytes" number="0x2"/>
            <enumItem name="__128_elements_512_bytes" number="0x3"/>
            <enumItem name="__64_elements_256_bytes" number="0x4"/>
            <enumItem name="__32_elements_128_bytes" number="0x5"/>
            <enumItem name="_16_elements_64_bytes" number="0x6"/>
            <enumItem name="__8_elements_32_bytes" number="0x7"/>
        </enumeration>
        <enumeration name="FRINDEX_FRINDEX_ENUM">
            <enumItem name="_1024" number="0x0"/>
            <enumItem name="_512" number="0x1"/>
            <enumItem name="_256__10" number="0x2"/>
            <enumItem name="_128" number="0x3"/>
            <enumItem name="_64" number="0x4"/>
            <enumItem name="_32" number="0x5"/>
            <enumItem name="_16" number="0x6"/>
            <enumItem name="_8" number="0x7"/>
        </enumeration>
        <enumeration name="IC_USB_IC_VDD1_ENUM">
            <enumItem name="No_voltage" number="0x0"/>
            <enumItem name="_10V" number="0x1"/>
            <enumItem name="_12V" number="0x2"/>
            <enumItem name="_15V" number="0x3"/>
            <enumItem name="_18V" number="0x4"/>
            <enumItem name="_30V" number="0x5"/>
            <enumItem name="Reserved" number="0x6"/>
            <enumItem name="Reserved_7" number="0x7"/>
        </enumeration>
        <enumeration name="ENDPTNAK_EPTN_ENUM">
            <enumItem name="TX_endpoint_has_1_bit_in_this_field_The_bit_is_set_when_the_Controller_sends_a_NAK_handshake_on_a_received_IN_token_for_the_corresponding_endpoint" number="0xeac"/>
        </enumeration>
        <enumeration name="ENDPTNAK_EPRN_ENUM">
            <enumItem name="RX_endpoint_has_1_bit_in_this_field_The_bit_is_set_when_the_Controller_sends_a_NAK_handshake_on_a_received_OUT_or_PING_token_for_the_corresponding_endpoint" number="0xeac"/>
        </enumeration>
        <enumeration name="ENDPTNAKEN_EPTNE_ENUM">
            <enumItem name="bit_is_an_enable_bit_for_the_corresponding_TX_Endpoint_NAK_bit_If_this_bit_is_set_and_the_corresponding_TX_Endpoint_NAK_bit_is_set_the_NAK_Interrupt_bit_is_set" number="0xeac"/>
        </enumeration>
        <enumeration name="ENDPTNAKEN_EPRNE_ENUM">
            <enumItem name="bit_is_an_enable_bit_for_the_corresponding_RX_Endpoint_NAK_bit_If_this_bit_is_set_and_the_corresponding_RX_Endpoint_NAK_bit_is_set_the_NAK_Interrupt_bit_is_set" number="0xeac"/>
        </enumeration>
        <enumeration name="PORTSC1_PTC_ENUM">
            <enumItem name="__TEST_MODE_DISABLE" number="0x0"/>
            <enumItem name="__J__STATE" number="0x1"/>
            <enumItem name="__K_STATE" number="0x2"/>
            <enumItem name="__SE0_host___NAK_device" number="0x3"/>
            <enumItem name="__Packet" number="0x4"/>
            <enumItem name="__FORCE_ENABLE_HS" number="0x5"/>
            <enumItem name="__FORCE_ENABLE_FS" number="0x6"/>
            <enumItem name="__FORCE_ENABLE_LS" number="0x7"/>
            <enumItem name="__Reserved" number="0x8"/>
        </enumeration>
        <enumeration name="PORTSC1_PIC_ENUM">
            <enumItem name="__Port_indicators_are_off" number="0x0"/>
            <enumItem name="__Amber" number="0x1"/>
            <enumItem name="__Green" number="0x2"/>
            <enumItem name="__Undefined" number="0x3"/>
        </enumeration>
        <enumeration name="PORTSC1_PP_ENUM">
            <enumItem name="__0b" number="0x0"/>
            <enumItem name="__1b_0b" number="0x1"/>
        </enumeration>
        <enumeration name="PORTSC1_LS_ENUM">
            <enumItem name="__SE0" number="0x0"/>
            <enumItem name="__K_state" number="0x1"/>
            <enumItem name="__J_state" number="0x2"/>
            <enumItem name="__Undefined" number="0x3"/>
        </enumeration>
        <enumeration name="PORTSC1_SUSP_ENUM">
            <enumItem name="Enable" number="0x2"/>
            <enumItem name="Suspend" number="0x3"/>
        </enumeration>
        <enumeration name="PORTSC1_FPR_ENUM">
            <enumItem name="Resume_detected_driven_on_port" number="0x1"/>
        </enumeration>
        <enumeration name="PORTSC1_PE_ENUM">
            <enumItem name="__Enable" number="0x1"/>
        </enumeration>
        <enumeration name="OTGSC_n1msE_ENUM">
            <enumItem name="millisecond_timer_Interrupt_Enable" number="0x1"/>
        </enumeration>
        <enumeration name="OTGSC_n1msS_ENUM">
            <enumItem name="millisecond_timer_Interrupt_Status" number="0x1"/>
        </enumeration>
        <enumeration name="OTGSC_n1msT_ENUM">
            <enumItem name="millisecond_timer_toggle" number="0x1"/>
        </enumeration>
        <enumeration name="ENDPTCOMPLETE_ETCE_ENUM">
            <enumItem name="bit_indicates_a_transmit_event_IN_INTERRUPT_occurred_and_software_should_read_the_corresponding_endpoint_queue_to_determine_the_endpoint_status_If_the" number="0xeac"/>
        </enumeration>
        <enumeration name="ENDPTCOMPLETE_ERCE_ENUM">
            <enumItem name="bit_indicates_a_received_event_OUT_occurred_and_software_should_read_the_corresponding_endpoint_queue_to_determine_the_transfer_status_If_the_corresponding_IOC_bit_is_set_in_the_Transfer_Descriptor_then_this_bit_will_be_set_simultaneously_with_the_USBINT_Writing_a_1_will_clear_the_corresponding_bit_in_this_register" number="0xeac"/>
        </enumeration>
        <enumeration name="ENDPTCTRL1_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL1_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL2_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL2_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL3_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL3_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL4_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL4_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL5_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL5_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL6_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL6_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL7_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL7_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL8_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL8_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL9_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL9_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL10_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL10_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL11_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL11_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL12_TXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
        <enumeration name="ENDPTCTRL12_RXD_ENUM">
            <enumItem name="Dual_Port_Memory_Buffer_DMA_Engine" number="0x0"/>
        </enumeration>
    </board>
</boards>
